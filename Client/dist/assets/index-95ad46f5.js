var ole=Object.defineProperty;var lle=(e,t,n)=>t in e?ole(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var k$=(e,t,n)=>(lle(e,typeof t!="symbol"?t+"":t,n),n);function f6(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in e)){const a=Object.getOwnPropertyDescriptor(r,s);a&&Object.defineProperty(e,s,a.get?a:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const i of a.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function n(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(s){if(s.ep)return;s.ep=!0;const a=n(s);fetch(s.href,a)}})();var mr=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function ey(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function ule(e){if(e.__esModule)return e;var t=e.default;if(typeof t=="function"){var n=function r(){return this instanceof r?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};n.prototype=t.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(e).forEach(function(r){var s=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(n,r,s.get?s:{enumerable:!0,get:function(){return e[r]}})}),n}var m6={exports:{}},II={},g6={exports:{}},Yt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var m0=Symbol.for("react.element"),cle=Symbol.for("react.portal"),dle=Symbol.for("react.fragment"),hle=Symbol.for("react.strict_mode"),ple=Symbol.for("react.profiler"),fle=Symbol.for("react.provider"),mle=Symbol.for("react.context"),gle=Symbol.for("react.forward_ref"),yle=Symbol.for("react.suspense"),ble=Symbol.for("react.memo"),vle=Symbol.for("react.lazy"),nB=Symbol.iterator;function xle(e){return e===null||typeof e!="object"?null:(e=nB&&e[nB]||e["@@iterator"],typeof e=="function"?e:null)}var y6={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},b6=Object.assign,v6={};function ty(e,t,n){this.props=e,this.context=t,this.refs=v6,this.updater=n||y6}ty.prototype.isReactComponent={};ty.prototype.setState=function(e,t){if(typeof e!="object"&&typeof e!="function"&&e!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")};ty.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")};function x6(){}x6.prototype=ty.prototype;function iD(e,t,n){this.props=e,this.context=t,this.refs=v6,this.updater=n||y6}var oD=iD.prototype=new x6;oD.constructor=iD;b6(oD,ty.prototype);oD.isPureReactComponent=!0;var rB=Array.isArray,w6=Object.prototype.hasOwnProperty,lD={current:null},k6={key:!0,ref:!0,__self:!0,__source:!0};function S6(e,t,n){var r,s={},a=null,i=null;if(t!=null)for(r in t.ref!==void 0&&(i=t.ref),t.key!==void 0&&(a=""+t.key),t)w6.call(t,r)&&!k6.hasOwnProperty(r)&&(s[r]=t[r]);var o=arguments.length-2;if(o===1)s.children=n;else if(1<o){for(var l=Array(o),u=0;u<o;u++)l[u]=arguments[u+2];s.children=l}if(e&&e.defaultProps)for(r in o=e.defaultProps,o)s[r]===void 0&&(s[r]=o[r]);return{$$typeof:m0,type:e,key:a,ref:i,props:s,_owner:lD.current}}function wle(e,t){return{$$typeof:m0,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}function uD(e){return typeof e=="object"&&e!==null&&e.$$typeof===m0}function kle(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,function(n){return t[n]})}var sB=/\/+/g;function S$(e,t){return typeof e=="object"&&e!==null&&e.key!=null?kle(""+e.key):t.toString(36)}function t2(e,t,n,r,s){var a=typeof e;(a==="undefined"||a==="boolean")&&(e=null);var i=!1;if(e===null)i=!0;else switch(a){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case m0:case cle:i=!0}}if(i)return i=e,s=s(i),e=r===""?"."+S$(i,0):r,rB(s)?(n="",e!=null&&(n=e.replace(sB,"$&/")+"/"),t2(s,t,n,"",function(u){return u})):s!=null&&(uD(s)&&(s=wle(s,n+(!s.key||i&&i.key===s.key?"":(""+s.key).replace(sB,"$&/")+"/")+e)),t.push(s)),1;if(i=0,r=r===""?".":r+":",rB(e))for(var o=0;o<e.length;o++){a=e[o];var l=r+S$(a,o);i+=t2(a,t,n,l,s)}else if(l=xle(e),typeof l=="function")for(e=l.call(e),o=0;!(a=e.next()).done;)a=a.value,l=r+S$(a,o++),i+=t2(a,t,n,l,s);else if(a==="object")throw t=String(e),Error("Objects are not valid as a React child (found: "+(t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return i}function nk(e,t,n){if(e==null)return e;var r=[],s=0;return t2(e,r,"","",function(a){return t.call(n,a,s++)}),r}function Sle(e){if(e._status===-1){var t=e._result;t=t(),t.then(function(n){(e._status===0||e._status===-1)&&(e._status=1,e._result=n)},function(n){(e._status===0||e._status===-1)&&(e._status=2,e._result=n)}),e._status===-1&&(e._status=0,e._result=t)}if(e._status===1)return e._result.default;throw e._result}var Ca={current:null},n2={transition:null},Ile={ReactCurrentDispatcher:Ca,ReactCurrentBatchConfig:n2,ReactCurrentOwner:lD};Yt.Children={map:nk,forEach:function(e,t,n){nk(e,function(){t.apply(this,arguments)},n)},count:function(e){var t=0;return nk(e,function(){t++}),t},toArray:function(e){return nk(e,function(t){return t})||[]},only:function(e){if(!uD(e))throw Error("React.Children.only expected to receive a single React element child.");return e}};Yt.Component=ty;Yt.Fragment=dle;Yt.Profiler=ple;Yt.PureComponent=iD;Yt.StrictMode=hle;Yt.Suspense=yle;Yt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Ile;Yt.cloneElement=function(e,t,n){if(e==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=b6({},e.props),s=e.key,a=e.ref,i=e._owner;if(t!=null){if(t.ref!==void 0&&(a=t.ref,i=lD.current),t.key!==void 0&&(s=""+t.key),e.type&&e.type.defaultProps)var o=e.type.defaultProps;for(l in t)w6.call(t,l)&&!k6.hasOwnProperty(l)&&(r[l]=t[l]===void 0&&o!==void 0?o[l]:t[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){o=Array(l);for(var u=0;u<l;u++)o[u]=arguments[u+2];r.children=o}return{$$typeof:m0,type:e.type,key:s,ref:a,props:r,_owner:i}};Yt.createContext=function(e){return e={$$typeof:mle,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},e.Provider={$$typeof:fle,_context:e},e.Consumer=e};Yt.createElement=S6;Yt.createFactory=function(e){var t=S6.bind(null,e);return t.type=e,t};Yt.createRef=function(){return{current:null}};Yt.forwardRef=function(e){return{$$typeof:gle,render:e}};Yt.isValidElement=uD;Yt.lazy=function(e){return{$$typeof:vle,_payload:{_status:-1,_result:e},_init:Sle}};Yt.memo=function(e,t){return{$$typeof:ble,type:e,compare:t===void 0?null:t}};Yt.startTransition=function(e){var t=n2.transition;n2.transition={};try{e()}finally{n2.transition=t}};Yt.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};Yt.useCallback=function(e,t){return Ca.current.useCallback(e,t)};Yt.useContext=function(e){return Ca.current.useContext(e)};Yt.useDebugValue=function(){};Yt.useDeferredValue=function(e){return Ca.current.useDeferredValue(e)};Yt.useEffect=function(e,t){return Ca.current.useEffect(e,t)};Yt.useId=function(){return Ca.current.useId()};Yt.useImperativeHandle=function(e,t,n){return Ca.current.useImperativeHandle(e,t,n)};Yt.useInsertionEffect=function(e,t){return Ca.current.useInsertionEffect(e,t)};Yt.useLayoutEffect=function(e,t){return Ca.current.useLayoutEffect(e,t)};Yt.useMemo=function(e,t){return Ca.current.useMemo(e,t)};Yt.useReducer=function(e,t,n){return Ca.current.useReducer(e,t,n)};Yt.useRef=function(e){return Ca.current.useRef(e)};Yt.useState=function(e){return Ca.current.useState(e)};Yt.useSyncExternalStore=function(e,t,n){return Ca.current.useSyncExternalStore(e,t,n)};Yt.useTransition=function(){return Ca.current.useTransition()};Yt.version="18.2.0";g6.exports=Yt;var Z=g6.exports;const wn=ey(Z),Cle=f6({__proto__:null,default:wn},[Z]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Nle=Z,Tle=Symbol.for("react.element"),$le=Symbol.for("react.fragment"),Ele=Object.prototype.hasOwnProperty,_le=Nle.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,Ale={key:!0,ref:!0,__self:!0,__source:!0};function I6(e,t,n){var r,s={},a=null,i=null;n!==void 0&&(a=""+n),t.key!==void 0&&(a=""+t.key),t.ref!==void 0&&(i=t.ref);for(r in t)Ele.call(t,r)&&!Ale.hasOwnProperty(r)&&(s[r]=t[r]);if(e&&e.defaultProps)for(r in t=e.defaultProps,t)s[r]===void 0&&(s[r]=t[r]);return{$$typeof:Tle,type:e,key:a,ref:i,props:s,_owner:_le.current}}II.Fragment=$le;II.jsx=I6;II.jsxs=I6;m6.exports=II;var A=m6.exports,YE={},C6={exports:{}},Ci={},N6={exports:{}},T6={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(e){function t(F,L){var O=F.length;F.push(L);e:for(;0<O;){var D=O-1>>>1,B=F[D];if(0<s(B,L))F[D]=L,F[O]=B,O=D;else break e}}function n(F){return F.length===0?null:F[0]}function r(F){if(F.length===0)return null;var L=F[0],O=F.pop();if(O!==L){F[0]=O;e:for(var D=0,B=F.length,V=B>>>1;D<V;){var K=2*(D+1)-1,G=F[K],U=K+1,q=F[U];if(0>s(G,O))U<B&&0>s(q,G)?(F[D]=q,F[U]=O,D=U):(F[D]=G,F[K]=O,D=K);else if(U<B&&0>s(q,O))F[D]=q,F[U]=O,D=U;else break e}}return L}function s(F,L){var O=F.sortIndex-L.sortIndex;return O!==0?O:F.id-L.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;e.unstable_now=function(){return a.now()}}else{var i=Date,o=i.now();e.unstable_now=function(){return i.now()-o}}var l=[],u=[],c=1,d=null,h=3,p=!1,f=!1,m=!1,g=typeof setTimeout=="function"?setTimeout:null,y=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function x(F){for(var L=n(u);L!==null;){if(L.callback===null)r(u);else if(L.startTime<=F)r(u),L.sortIndex=L.expirationTime,t(l,L);else break;L=n(u)}}function v(F){if(m=!1,x(F),!f)if(n(l)!==null)f=!0,z(w);else{var L=n(u);L!==null&&W(v,L.startTime-F)}}function w(F,L){f=!1,m&&(m=!1,y(I),I=-1),p=!0;var O=h;try{for(x(L),d=n(l);d!==null&&(!(d.expirationTime>L)||F&&!T());){var D=d.callback;if(typeof D=="function"){d.callback=null,h=d.priorityLevel;var B=D(d.expirationTime<=L);L=e.unstable_now(),typeof B=="function"?d.callback=B:d===n(l)&&r(l),x(L)}else r(l);d=n(l)}if(d!==null)var V=!0;else{var K=n(u);K!==null&&W(v,K.startTime-L),V=!1}return V}finally{d=null,h=O,p=!1}}var k=!1,S=null,I=-1,$=5,C=-1;function T(){return!(e.unstable_now()-C<$)}function N(){if(S!==null){var F=e.unstable_now();C=F;var L=!0;try{L=S(!0,F)}finally{L?E():(k=!1,S=null)}}else k=!1}var E;if(typeof b=="function")E=function(){b(N)};else if(typeof MessageChannel<"u"){var _=new MessageChannel,R=_.port2;_.port1.onmessage=N,E=function(){R.postMessage(null)}}else E=function(){g(N,0)};function z(F){S=F,k||(k=!0,E())}function W(F,L){I=g(function(){F(e.unstable_now())},L)}e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(F){F.callback=null},e.unstable_continueExecution=function(){f||p||(f=!0,z(w))},e.unstable_forceFrameRate=function(F){0>F||125<F?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):$=0<F?Math.floor(1e3/F):5},e.unstable_getCurrentPriorityLevel=function(){return h},e.unstable_getFirstCallbackNode=function(){return n(l)},e.unstable_next=function(F){switch(h){case 1:case 2:case 3:var L=3;break;default:L=h}var O=h;h=L;try{return F()}finally{h=O}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=function(){},e.unstable_runWithPriority=function(F,L){switch(F){case 1:case 2:case 3:case 4:case 5:break;default:F=3}var O=h;h=F;try{return L()}finally{h=O}},e.unstable_scheduleCallback=function(F,L,O){var D=e.unstable_now();switch(typeof O=="object"&&O!==null?(O=O.delay,O=typeof O=="number"&&0<O?D+O:D):O=D,F){case 1:var B=-1;break;case 2:B=250;break;case 5:B=1073741823;break;case 4:B=1e4;break;default:B=5e3}return B=O+B,F={id:c++,callback:L,priorityLevel:F,startTime:O,expirationTime:B,sortIndex:-1},O>D?(F.sortIndex=O,t(u,F),n(l)===null&&F===n(u)&&(m?(y(I),I=-1):m=!0,W(v,O-D))):(F.sortIndex=B,t(l,F),f||p||(f=!0,z(w))),F},e.unstable_shouldYield=T,e.unstable_wrapCallback=function(F){var L=h;return function(){var O=h;h=L;try{return F.apply(this,arguments)}finally{h=O}}}})(T6);N6.exports=T6;var Rle=N6.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $6=Z,xi=Rle;function He(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var E6=new Set,p1={};function cp(e,t){ig(e,t),ig(e+"Capture",t)}function ig(e,t){for(p1[e]=t,e=0;e<t.length;e++)E6.add(t[e])}var lu=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),JE=Object.prototype.hasOwnProperty,Dle=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,aB={},iB={};function Ole(e){return JE.call(iB,e)?!0:JE.call(aB,e)?!1:Dle.test(e)?iB[e]=!0:(aB[e]=!0,!1)}function Fle(e,t,n,r){if(n!==null&&n.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function Mle(e,t,n,r){if(t===null||typeof t>"u"||Fle(e,t,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function Na(e,t,n,r,s,a,i){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=r,this.attributeNamespace=s,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=a,this.removeEmptyString=i}var Rs={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){Rs[e]=new Na(e,0,!1,e,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];Rs[t]=new Na(t,1,!1,e[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(e){Rs[e]=new Na(e,2,!1,e.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){Rs[e]=new Na(e,2,!1,e,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){Rs[e]=new Na(e,3,!1,e.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(e){Rs[e]=new Na(e,3,!0,e,null,!1,!1)});["capture","download"].forEach(function(e){Rs[e]=new Na(e,4,!1,e,null,!1,!1)});["cols","rows","size","span"].forEach(function(e){Rs[e]=new Na(e,6,!1,e,null,!1,!1)});["rowSpan","start"].forEach(function(e){Rs[e]=new Na(e,5,!1,e.toLowerCase(),null,!1,!1)});var cD=/[\-:]([a-z])/g;function dD(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(cD,dD);Rs[t]=new Na(t,1,!1,e,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(cD,dD);Rs[t]=new Na(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(cD,dD);Rs[t]=new Na(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(e){Rs[e]=new Na(e,1,!1,e.toLowerCase(),null,!1,!1)});Rs.xlinkHref=new Na("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(e){Rs[e]=new Na(e,1,!1,e.toLowerCase(),null,!0,!0)});function hD(e,t,n,r){var s=Rs.hasOwnProperty(t)?Rs[t]:null;(s!==null?s.type!==0:r||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(Mle(t,n,s,r)&&(n=null),r||s===null?Ole(t)&&(n===null?e.removeAttribute(t):e.setAttribute(t,""+n)):s.mustUseProperty?e[s.propertyName]=n===null?s.type===3?!1:"":n:(t=s.attributeName,r=s.attributeNamespace,n===null?e.removeAttribute(t):(s=s.type,n=s===3||s===4&&n===!0?"":""+n,r?e.setAttributeNS(r,t,n):e.setAttribute(t,n))))}var xu=$6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,rk=Symbol.for("react.element"),Nm=Symbol.for("react.portal"),Tm=Symbol.for("react.fragment"),pD=Symbol.for("react.strict_mode"),ZE=Symbol.for("react.profiler"),_6=Symbol.for("react.provider"),A6=Symbol.for("react.context"),fD=Symbol.for("react.forward_ref"),QE=Symbol.for("react.suspense"),e_=Symbol.for("react.suspense_list"),mD=Symbol.for("react.memo"),Gu=Symbol.for("react.lazy"),R6=Symbol.for("react.offscreen"),oB=Symbol.iterator;function iv(e){return e===null||typeof e!="object"?null:(e=oB&&e[oB]||e["@@iterator"],typeof e=="function"?e:null)}var dr=Object.assign,I$;function Tv(e){if(I$===void 0)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);I$=t&&t[1]||""}return`
`+I$+e}var C$=!1;function N$(e,t){if(!e||C$)return"";C$=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var r=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){r=u}e.call(t.prototype)}else{try{throw Error()}catch(u){r=u}e()}}catch(u){if(u&&r&&typeof u.stack=="string"){for(var s=u.stack.split(`
`),a=r.stack.split(`
`),i=s.length-1,o=a.length-1;1<=i&&0<=o&&s[i]!==a[o];)o--;for(;1<=i&&0<=o;i--,o--)if(s[i]!==a[o]){if(i!==1||o!==1)do if(i--,o--,0>o||s[i]!==a[o]){var l=`
`+s[i].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}while(1<=i&&0<=o);break}}}finally{C$=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?Tv(e):""}function Ple(e){switch(e.tag){case 5:return Tv(e.type);case 16:return Tv("Lazy");case 13:return Tv("Suspense");case 19:return Tv("SuspenseList");case 0:case 2:case 15:return e=N$(e.type,!1),e;case 11:return e=N$(e.type.render,!1),e;case 1:return e=N$(e.type,!0),e;default:return""}}function t_(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case Tm:return"Fragment";case Nm:return"Portal";case ZE:return"Profiler";case pD:return"StrictMode";case QE:return"Suspense";case e_:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case A6:return(e.displayName||"Context")+".Consumer";case _6:return(e._context.displayName||"Context")+".Provider";case fD:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case mD:return t=e.displayName||null,t!==null?t:t_(e.type)||"Memo";case Gu:t=e._payload,e=e._init;try{return t_(e(t))}catch{}}return null}function Lle(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return t_(t);case 8:return t===pD?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function Tc(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function D6(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function zle(e){var t=D6(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),r=""+e[t];if(!e.hasOwnProperty(t)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var s=n.get,a=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return s.call(this)},set:function(i){r=""+i,a.call(this,i)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(i){r=""+i},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function sk(e){e._valueTracker||(e._valueTracker=zle(e))}function O6(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),r="";return e&&(r=D6(e)?e.checked?"true":"false":e.value),e=r,e!==n?(t.setValue(e),!0):!1}function _2(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function n_(e,t){var n=t.checked;return dr({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??e._wrapperState.initialChecked})}function lB(e,t){var n=t.defaultValue==null?"":t.defaultValue,r=t.checked!=null?t.checked:t.defaultChecked;n=Tc(t.value!=null?t.value:n),e._wrapperState={initialChecked:r,initialValue:n,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function F6(e,t){t=t.checked,t!=null&&hD(e,"checked",t,!1)}function r_(e,t){F6(e,t);var n=Tc(t.value),r=t.type;if(n!=null)r==="number"?(n===0&&e.value===""||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if(r==="submit"||r==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?s_(e,t.type,n):t.hasOwnProperty("defaultValue")&&s_(e,t.type,Tc(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function uB(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var r=t.type;if(!(r!=="submit"&&r!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}n=e.name,n!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,n!==""&&(e.name=n)}function s_(e,t,n){(t!=="number"||_2(e.ownerDocument)!==e)&&(n==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var $v=Array.isArray;function Wm(e,t,n,r){if(e=e.options,t){t={};for(var s=0;s<n.length;s++)t["$"+n[s]]=!0;for(n=0;n<e.length;n++)s=t.hasOwnProperty("$"+e[n].value),e[n].selected!==s&&(e[n].selected=s),s&&r&&(e[n].defaultSelected=!0)}else{for(n=""+Tc(n),t=null,s=0;s<e.length;s++){if(e[s].value===n){e[s].selected=!0,r&&(e[s].defaultSelected=!0);return}t!==null||e[s].disabled||(t=e[s])}t!==null&&(t.selected=!0)}}function a_(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(He(91));return dr({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function cB(e,t){var n=t.value;if(n==null){if(n=t.children,t=t.defaultValue,n!=null){if(t!=null)throw Error(He(92));if($v(n)){if(1<n.length)throw Error(He(93));n=n[0]}t=n}t==null&&(t=""),n=t}e._wrapperState={initialValue:Tc(n)}}function M6(e,t){var n=Tc(t.value),r=Tc(t.defaultValue);n!=null&&(n=""+n,n!==e.value&&(e.value=n),t.defaultValue==null&&e.defaultValue!==n&&(e.defaultValue=n)),r!=null&&(e.defaultValue=""+r)}function dB(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function P6(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function i_(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?P6(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var ak,L6=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,n,r,s){MSApp.execUnsafeLocalFunction(function(){return e(t,n,r,s)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(ak=ak||document.createElement("div"),ak.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ak.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function f1(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&n.nodeType===3){n.nodeValue=t;return}}e.textContent=t}var Xv={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Ble=["Webkit","ms","Moz","O"];Object.keys(Xv).forEach(function(e){Ble.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),Xv[t]=Xv[e]})});function z6(e,t,n){return t==null||typeof t=="boolean"||t===""?"":n||typeof t!="number"||t===0||Xv.hasOwnProperty(e)&&Xv[e]?(""+t).trim():t+"px"}function B6(e,t){e=e.style;for(var n in t)if(t.hasOwnProperty(n)){var r=n.indexOf("--")===0,s=z6(n,t[n],r);n==="float"&&(n="cssFloat"),r?e.setProperty(n,s):e[n]=s}}var Wle=dr({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function o_(e,t){if(t){if(Wle[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(He(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(He(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(He(61))}if(t.style!=null&&typeof t.style!="object")throw Error(He(62))}}function l_(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var u_=null;function gD(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var c_=null,Vm=null,Um=null;function hB(e){if(e=b0(e)){if(typeof c_!="function")throw Error(He(280));var t=e.stateNode;t&&(t=EI(t),c_(e.stateNode,e.type,t))}}function W6(e){Vm?Um?Um.push(e):Um=[e]:Vm=e}function V6(){if(Vm){var e=Vm,t=Um;if(Um=Vm=null,hB(e),t)for(e=0;e<t.length;e++)hB(t[e])}}function U6(e,t){return e(t)}function j6(){}var T$=!1;function G6(e,t,n){if(T$)return e(t,n);T$=!0;try{return U6(e,t,n)}finally{T$=!1,(Vm!==null||Um!==null)&&(j6(),V6())}}function m1(e,t){var n=e.stateNode;if(n===null)return null;var r=EI(n);if(r===null)return null;n=r[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(e=e.type,r=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!r;break e;default:e=!1}if(e)return null;if(n&&typeof n!="function")throw Error(He(231,t,typeof n));return n}var d_=!1;if(lu)try{var ov={};Object.defineProperty(ov,"passive",{get:function(){d_=!0}}),window.addEventListener("test",ov,ov),window.removeEventListener("test",ov,ov)}catch{d_=!1}function Vle(e,t,n,r,s,a,i,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(c){this.onError(c)}}var Yv=!1,A2=null,R2=!1,h_=null,Ule={onError:function(e){Yv=!0,A2=e}};function jle(e,t,n,r,s,a,i,o,l){Yv=!1,A2=null,Vle.apply(Ule,arguments)}function Gle(e,t,n,r,s,a,i,o,l){if(jle.apply(this,arguments),Yv){if(Yv){var u=A2;Yv=!1,A2=null}else throw Error(He(198));R2||(R2=!0,h_=u)}}function dp(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,t.flags&4098&&(n=t.return),e=t.return;while(e)}return t.tag===3?n:null}function H6(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function pB(e){if(dp(e)!==e)throw Error(He(188))}function Hle(e){var t=e.alternate;if(!t){if(t=dp(e),t===null)throw Error(He(188));return t!==e?null:e}for(var n=e,r=t;;){var s=n.return;if(s===null)break;var a=s.alternate;if(a===null){if(r=s.return,r!==null){n=r;continue}break}if(s.child===a.child){for(a=s.child;a;){if(a===n)return pB(s),e;if(a===r)return pB(s),t;a=a.sibling}throw Error(He(188))}if(n.return!==r.return)n=s,r=a;else{for(var i=!1,o=s.child;o;){if(o===n){i=!0,n=s,r=a;break}if(o===r){i=!0,r=s,n=a;break}o=o.sibling}if(!i){for(o=a.child;o;){if(o===n){i=!0,n=a,r=s;break}if(o===r){i=!0,r=a,n=s;break}o=o.sibling}if(!i)throw Error(He(189))}}if(n.alternate!==r)throw Error(He(190))}if(n.tag!==3)throw Error(He(188));return n.stateNode.current===n?e:t}function q6(e){return e=Hle(e),e!==null?K6(e):null}function K6(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=K6(e);if(t!==null)return t;e=e.sibling}return null}var X6=xi.unstable_scheduleCallback,fB=xi.unstable_cancelCallback,qle=xi.unstable_shouldYield,Kle=xi.unstable_requestPaint,Cr=xi.unstable_now,Xle=xi.unstable_getCurrentPriorityLevel,yD=xi.unstable_ImmediatePriority,Y6=xi.unstable_UserBlockingPriority,D2=xi.unstable_NormalPriority,Yle=xi.unstable_LowPriority,J6=xi.unstable_IdlePriority,CI=null,bl=null;function Jle(e){if(bl&&typeof bl.onCommitFiberRoot=="function")try{bl.onCommitFiberRoot(CI,e,void 0,(e.current.flags&128)===128)}catch{}}var To=Math.clz32?Math.clz32:eue,Zle=Math.log,Qle=Math.LN2;function eue(e){return e>>>=0,e===0?32:31-(Zle(e)/Qle|0)|0}var ik=64,ok=4194304;function Ev(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function O2(e,t){var n=e.pendingLanes;if(n===0)return 0;var r=0,s=e.suspendedLanes,a=e.pingedLanes,i=n&268435455;if(i!==0){var o=i&~s;o!==0?r=Ev(o):(a&=i,a!==0&&(r=Ev(a)))}else i=n&~s,i!==0?r=Ev(i):a!==0&&(r=Ev(a));if(r===0)return 0;if(t!==0&&t!==r&&!(t&s)&&(s=r&-r,a=t&-t,s>=a||s===16&&(a&4194240)!==0))return t;if(r&4&&(r|=n&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=r;0<t;)n=31-To(t),s=1<<n,r|=e[n],t&=~s;return r}function tue(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function nue(e,t){for(var n=e.suspendedLanes,r=e.pingedLanes,s=e.expirationTimes,a=e.pendingLanes;0<a;){var i=31-To(a),o=1<<i,l=s[i];l===-1?(!(o&n)||o&r)&&(s[i]=tue(o,t)):l<=t&&(e.expiredLanes|=o),a&=~o}}function p_(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function Z6(){var e=ik;return ik<<=1,!(ik&4194240)&&(ik=64),e}function $$(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function g0(e,t,n){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-To(t),e[t]=n}function rue(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var r=e.eventTimes;for(e=e.expirationTimes;0<n;){var s=31-To(n),a=1<<s;t[s]=0,r[s]=-1,e[s]=-1,n&=~a}}function bD(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var r=31-To(n),s=1<<r;s&t|e[r]&t&&(e[r]|=t),n&=~s}}var Sn=0;function Q6(e){return e&=-e,1<e?4<e?e&268435455?16:536870912:4:1}var eG,vD,tG,nG,rG,f_=!1,lk=[],cc=null,dc=null,hc=null,g1=new Map,y1=new Map,Yu=[],sue="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function mB(e,t){switch(e){case"focusin":case"focusout":cc=null;break;case"dragenter":case"dragleave":dc=null;break;case"mouseover":case"mouseout":hc=null;break;case"pointerover":case"pointerout":g1.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":y1.delete(t.pointerId)}}function lv(e,t,n,r,s,a){return e===null||e.nativeEvent!==a?(e={blockedOn:t,domEventName:n,eventSystemFlags:r,nativeEvent:a,targetContainers:[s]},t!==null&&(t=b0(t),t!==null&&vD(t)),e):(e.eventSystemFlags|=r,t=e.targetContainers,s!==null&&t.indexOf(s)===-1&&t.push(s),e)}function aue(e,t,n,r,s){switch(t){case"focusin":return cc=lv(cc,e,t,n,r,s),!0;case"dragenter":return dc=lv(dc,e,t,n,r,s),!0;case"mouseover":return hc=lv(hc,e,t,n,r,s),!0;case"pointerover":var a=s.pointerId;return g1.set(a,lv(g1.get(a)||null,e,t,n,r,s)),!0;case"gotpointercapture":return a=s.pointerId,y1.set(a,lv(y1.get(a)||null,e,t,n,r,s)),!0}return!1}function sG(e){var t=Zd(e.target);if(t!==null){var n=dp(t);if(n!==null){if(t=n.tag,t===13){if(t=H6(n),t!==null){e.blockedOn=t,rG(e.priority,function(){tG(n)});return}}else if(t===3&&n.stateNode.current.memoizedState.isDehydrated){e.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}e.blockedOn=null}function r2(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var n=m_(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(n===null){n=e.nativeEvent;var r=new n.constructor(n.type,n);u_=r,n.target.dispatchEvent(r),u_=null}else return t=b0(n),t!==null&&vD(t),e.blockedOn=n,!1;t.shift()}return!0}function gB(e,t,n){r2(e)&&n.delete(t)}function iue(){f_=!1,cc!==null&&r2(cc)&&(cc=null),dc!==null&&r2(dc)&&(dc=null),hc!==null&&r2(hc)&&(hc=null),g1.forEach(gB),y1.forEach(gB)}function uv(e,t){e.blockedOn===t&&(e.blockedOn=null,f_||(f_=!0,xi.unstable_scheduleCallback(xi.unstable_NormalPriority,iue)))}function b1(e){function t(s){return uv(s,e)}if(0<lk.length){uv(lk[0],e);for(var n=1;n<lk.length;n++){var r=lk[n];r.blockedOn===e&&(r.blockedOn=null)}}for(cc!==null&&uv(cc,e),dc!==null&&uv(dc,e),hc!==null&&uv(hc,e),g1.forEach(t),y1.forEach(t),n=0;n<Yu.length;n++)r=Yu[n],r.blockedOn===e&&(r.blockedOn=null);for(;0<Yu.length&&(n=Yu[0],n.blockedOn===null);)sG(n),n.blockedOn===null&&Yu.shift()}var jm=xu.ReactCurrentBatchConfig,F2=!0;function oue(e,t,n,r){var s=Sn,a=jm.transition;jm.transition=null;try{Sn=1,xD(e,t,n,r)}finally{Sn=s,jm.transition=a}}function lue(e,t,n,r){var s=Sn,a=jm.transition;jm.transition=null;try{Sn=4,xD(e,t,n,r)}finally{Sn=s,jm.transition=a}}function xD(e,t,n,r){if(F2){var s=m_(e,t,n,r);if(s===null)L$(e,t,r,M2,n),mB(e,r);else if(aue(s,e,t,n,r))r.stopPropagation();else if(mB(e,r),t&4&&-1<sue.indexOf(e)){for(;s!==null;){var a=b0(s);if(a!==null&&eG(a),a=m_(e,t,n,r),a===null&&L$(e,t,r,M2,n),a===s)break;s=a}s!==null&&r.stopPropagation()}else L$(e,t,r,null,n)}}var M2=null;function m_(e,t,n,r){if(M2=null,e=gD(r),e=Zd(e),e!==null)if(t=dp(e),t===null)e=null;else if(n=t.tag,n===13){if(e=H6(t),e!==null)return e;e=null}else if(n===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return M2=e,null}function aG(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Xle()){case yD:return 1;case Y6:return 4;case D2:case Yle:return 16;case J6:return 536870912;default:return 16}default:return 16}}var Qu=null,wD=null,s2=null;function iG(){if(s2)return s2;var e,t=wD,n=t.length,r,s="value"in Qu?Qu.value:Qu.textContent,a=s.length;for(e=0;e<n&&t[e]===s[e];e++);var i=n-e;for(r=1;r<=i&&t[n-r]===s[a-r];r++);return s2=s.slice(e,1<r?1-r:void 0)}function a2(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function uk(){return!0}function yB(){return!1}function Ni(e){function t(n,r,s,a,i){this._reactName=n,this._targetInst=s,this.type=r,this.nativeEvent=a,this.target=i,this.currentTarget=null;for(var o in e)e.hasOwnProperty(o)&&(n=e[o],this[o]=n?n(a):a[o]);return this.isDefaultPrevented=(a.defaultPrevented!=null?a.defaultPrevented:a.returnValue===!1)?uk:yB,this.isPropagationStopped=yB,this}return dr(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=uk)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=uk)},persist:function(){},isPersistent:uk}),t}var ny={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},kD=Ni(ny),y0=dr({},ny,{view:0,detail:0}),uue=Ni(y0),E$,_$,cv,NI=dr({},y0,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:SD,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==cv&&(cv&&e.type==="mousemove"?(E$=e.screenX-cv.screenX,_$=e.screenY-cv.screenY):_$=E$=0,cv=e),E$)},movementY:function(e){return"movementY"in e?e.movementY:_$}}),bB=Ni(NI),cue=dr({},NI,{dataTransfer:0}),due=Ni(cue),hue=dr({},y0,{relatedTarget:0}),A$=Ni(hue),pue=dr({},ny,{animationName:0,elapsedTime:0,pseudoElement:0}),fue=Ni(pue),mue=dr({},ny,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),gue=Ni(mue),yue=dr({},ny,{data:0}),vB=Ni(yue),bue={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},vue={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},xue={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function wue(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=xue[e])?!!t[e]:!1}function SD(){return wue}var kue=dr({},y0,{key:function(e){if(e.key){var t=bue[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=a2(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?vue[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:SD,charCode:function(e){return e.type==="keypress"?a2(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?a2(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),Sue=Ni(kue),Iue=dr({},NI,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),xB=Ni(Iue),Cue=dr({},y0,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:SD}),Nue=Ni(Cue),Tue=dr({},ny,{propertyName:0,elapsedTime:0,pseudoElement:0}),$ue=Ni(Tue),Eue=dr({},NI,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),_ue=Ni(Eue),Aue=[9,13,27,32],ID=lu&&"CompositionEvent"in window,Jv=null;lu&&"documentMode"in document&&(Jv=document.documentMode);var Rue=lu&&"TextEvent"in window&&!Jv,oG=lu&&(!ID||Jv&&8<Jv&&11>=Jv),wB=String.fromCharCode(32),kB=!1;function lG(e,t){switch(e){case"keyup":return Aue.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function uG(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var $m=!1;function Due(e,t){switch(e){case"compositionend":return uG(t);case"keypress":return t.which!==32?null:(kB=!0,wB);case"textInput":return e=t.data,e===wB&&kB?null:e;default:return null}}function Oue(e,t){if($m)return e==="compositionend"||!ID&&lG(e,t)?(e=iG(),s2=wD=Qu=null,$m=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return oG&&t.locale!=="ko"?null:t.data;default:return null}}var Fue={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function SB(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!Fue[e.type]:t==="textarea"}function cG(e,t,n,r){W6(r),t=P2(t,"onChange"),0<t.length&&(n=new kD("onChange","change",null,n,r),e.push({event:n,listeners:t}))}var Zv=null,v1=null;function Mue(e){wG(e,0)}function TI(e){var t=Am(e);if(O6(t))return e}function Pue(e,t){if(e==="change")return t}var dG=!1;if(lu){var R$;if(lu){var D$="oninput"in document;if(!D$){var IB=document.createElement("div");IB.setAttribute("oninput","return;"),D$=typeof IB.oninput=="function"}R$=D$}else R$=!1;dG=R$&&(!document.documentMode||9<document.documentMode)}function CB(){Zv&&(Zv.detachEvent("onpropertychange",hG),v1=Zv=null)}function hG(e){if(e.propertyName==="value"&&TI(v1)){var t=[];cG(t,v1,e,gD(e)),G6(Mue,t)}}function Lue(e,t,n){e==="focusin"?(CB(),Zv=t,v1=n,Zv.attachEvent("onpropertychange",hG)):e==="focusout"&&CB()}function zue(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return TI(v1)}function Bue(e,t){if(e==="click")return TI(t)}function Wue(e,t){if(e==="input"||e==="change")return TI(t)}function Vue(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var Mo=typeof Object.is=="function"?Object.is:Vue;function x1(e,t){if(Mo(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var n=Object.keys(e),r=Object.keys(t);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var s=n[r];if(!JE.call(t,s)||!Mo(e[s],t[s]))return!1}return!0}function NB(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function TB(e,t){var n=NB(e);e=0;for(var r;n;){if(n.nodeType===3){if(r=e+n.textContent.length,e<=t&&r>=t)return{node:n,offset:t-e};e=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=NB(n)}}function pG(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?pG(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function fG(){for(var e=window,t=_2();t instanceof e.HTMLIFrameElement;){try{var n=typeof t.contentWindow.location.href=="string"}catch{n=!1}if(n)e=t.contentWindow;else break;t=_2(e.document)}return t}function CD(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function Uue(e){var t=fG(),n=e.focusedElem,r=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&pG(n.ownerDocument.documentElement,n)){if(r!==null&&CD(n)){if(t=r.start,e=r.end,e===void 0&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if(e=(t=n.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var s=n.textContent.length,a=Math.min(r.start,s);r=r.end===void 0?a:Math.min(r.end,s),!e.extend&&a>r&&(s=r,r=a,a=s),s=TB(n,a);var i=TB(n,r);s&&i&&(e.rangeCount!==1||e.anchorNode!==s.node||e.anchorOffset!==s.offset||e.focusNode!==i.node||e.focusOffset!==i.offset)&&(t=t.createRange(),t.setStart(s.node,s.offset),e.removeAllRanges(),a>r?(e.addRange(t),e.extend(i.node,i.offset)):(t.setEnd(i.node,i.offset),e.addRange(t)))}}for(t=[],e=n;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<t.length;n++)e=t[n],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var jue=lu&&"documentMode"in document&&11>=document.documentMode,Em=null,g_=null,Qv=null,y_=!1;function $B(e,t,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;y_||Em==null||Em!==_2(r)||(r=Em,"selectionStart"in r&&CD(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Qv&&x1(Qv,r)||(Qv=r,r=P2(g_,"onSelect"),0<r.length&&(t=new kD("onSelect","select",null,t,n),e.push({event:t,listeners:r}),t.target=Em)))}function ck(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var _m={animationend:ck("Animation","AnimationEnd"),animationiteration:ck("Animation","AnimationIteration"),animationstart:ck("Animation","AnimationStart"),transitionend:ck("Transition","TransitionEnd")},O$={},mG={};lu&&(mG=document.createElement("div").style,"AnimationEvent"in window||(delete _m.animationend.animation,delete _m.animationiteration.animation,delete _m.animationstart.animation),"TransitionEvent"in window||delete _m.transitionend.transition);function $I(e){if(O$[e])return O$[e];if(!_m[e])return e;var t=_m[e],n;for(n in t)if(t.hasOwnProperty(n)&&n in mG)return O$[e]=t[n];return e}var gG=$I("animationend"),yG=$I("animationiteration"),bG=$I("animationstart"),vG=$I("transitionend"),xG=new Map,EB="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Jc(e,t){xG.set(e,t),cp(t,[e])}for(var F$=0;F$<EB.length;F$++){var M$=EB[F$],Gue=M$.toLowerCase(),Hue=M$[0].toUpperCase()+M$.slice(1);Jc(Gue,"on"+Hue)}Jc(gG,"onAnimationEnd");Jc(yG,"onAnimationIteration");Jc(bG,"onAnimationStart");Jc("dblclick","onDoubleClick");Jc("focusin","onFocus");Jc("focusout","onBlur");Jc(vG,"onTransitionEnd");ig("onMouseEnter",["mouseout","mouseover"]);ig("onMouseLeave",["mouseout","mouseover"]);ig("onPointerEnter",["pointerout","pointerover"]);ig("onPointerLeave",["pointerout","pointerover"]);cp("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));cp("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));cp("onBeforeInput",["compositionend","keypress","textInput","paste"]);cp("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));cp("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));cp("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var _v="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),que=new Set("cancel close invalid load scroll toggle".split(" ").concat(_v));function _B(e,t,n){var r=e.type||"unknown-event";e.currentTarget=n,Gle(r,t,void 0,e),e.currentTarget=null}function wG(e,t){t=(t&4)!==0;for(var n=0;n<e.length;n++){var r=e[n],s=r.event;r=r.listeners;e:{var a=void 0;if(t)for(var i=r.length-1;0<=i;i--){var o=r[i],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==a&&s.isPropagationStopped())break e;_B(s,o,u),a=l}else for(i=0;i<r.length;i++){if(o=r[i],l=o.instance,u=o.currentTarget,o=o.listener,l!==a&&s.isPropagationStopped())break e;_B(s,o,u),a=l}}}if(R2)throw e=h_,R2=!1,h_=null,e}function Gn(e,t){var n=t[k_];n===void 0&&(n=t[k_]=new Set);var r=e+"__bubble";n.has(r)||(kG(t,e,2,!1),n.add(r))}function P$(e,t,n){var r=0;t&&(r|=4),kG(n,e,r,t)}var dk="_reactListening"+Math.random().toString(36).slice(2);function w1(e){if(!e[dk]){e[dk]=!0,E6.forEach(function(n){n!=="selectionchange"&&(que.has(n)||P$(n,!1,e),P$(n,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[dk]||(t[dk]=!0,P$("selectionchange",!1,t))}}function kG(e,t,n,r){switch(aG(t)){case 1:var s=oue;break;case 4:s=lue;break;default:s=xD}n=s.bind(null,t,n,e),s=void 0,!d_||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(s=!0),r?s!==void 0?e.addEventListener(t,n,{capture:!0,passive:s}):e.addEventListener(t,n,!0):s!==void 0?e.addEventListener(t,n,{passive:s}):e.addEventListener(t,n,!1)}function L$(e,t,n,r,s){var a=r;if(!(t&1)&&!(t&2)&&r!==null)e:for(;;){if(r===null)return;var i=r.tag;if(i===3||i===4){var o=r.stateNode.containerInfo;if(o===s||o.nodeType===8&&o.parentNode===s)break;if(i===4)for(i=r.return;i!==null;){var l=i.tag;if((l===3||l===4)&&(l=i.stateNode.containerInfo,l===s||l.nodeType===8&&l.parentNode===s))return;i=i.return}for(;o!==null;){if(i=Zd(o),i===null)return;if(l=i.tag,l===5||l===6){r=a=i;continue e}o=o.parentNode}}r=r.return}G6(function(){var u=a,c=gD(n),d=[];e:{var h=xG.get(e);if(h!==void 0){var p=kD,f=e;switch(e){case"keypress":if(a2(n)===0)break e;case"keydown":case"keyup":p=Sue;break;case"focusin":f="focus",p=A$;break;case"focusout":f="blur",p=A$;break;case"beforeblur":case"afterblur":p=A$;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":p=bB;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":p=due;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":p=Nue;break;case gG:case yG:case bG:p=fue;break;case vG:p=$ue;break;case"scroll":p=uue;break;case"wheel":p=_ue;break;case"copy":case"cut":case"paste":p=gue;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":p=xB}var m=(t&4)!==0,g=!m&&e==="scroll",y=m?h!==null?h+"Capture":null:h;m=[];for(var b=u,x;b!==null;){x=b;var v=x.stateNode;if(x.tag===5&&v!==null&&(x=v,y!==null&&(v=m1(b,y),v!=null&&m.push(k1(b,v,x)))),g)break;b=b.return}0<m.length&&(h=new p(h,f,null,n,c),d.push({event:h,listeners:m}))}}if(!(t&7)){e:{if(h=e==="mouseover"||e==="pointerover",p=e==="mouseout"||e==="pointerout",h&&n!==u_&&(f=n.relatedTarget||n.fromElement)&&(Zd(f)||f[uu]))break e;if((p||h)&&(h=c.window===c?c:(h=c.ownerDocument)?h.defaultView||h.parentWindow:window,p?(f=n.relatedTarget||n.toElement,p=u,f=f?Zd(f):null,f!==null&&(g=dp(f),f!==g||f.tag!==5&&f.tag!==6)&&(f=null)):(p=null,f=u),p!==f)){if(m=bB,v="onMouseLeave",y="onMouseEnter",b="mouse",(e==="pointerout"||e==="pointerover")&&(m=xB,v="onPointerLeave",y="onPointerEnter",b="pointer"),g=p==null?h:Am(p),x=f==null?h:Am(f),h=new m(v,b+"leave",p,n,c),h.target=g,h.relatedTarget=x,v=null,Zd(c)===u&&(m=new m(y,b+"enter",f,n,c),m.target=x,m.relatedTarget=g,v=m),g=v,p&&f)t:{for(m=p,y=f,b=0,x=m;x;x=lm(x))b++;for(x=0,v=y;v;v=lm(v))x++;for(;0<b-x;)m=lm(m),b--;for(;0<x-b;)y=lm(y),x--;for(;b--;){if(m===y||y!==null&&m===y.alternate)break t;m=lm(m),y=lm(y)}m=null}else m=null;p!==null&&AB(d,h,p,m,!1),f!==null&&g!==null&&AB(d,g,f,m,!0)}}e:{if(h=u?Am(u):window,p=h.nodeName&&h.nodeName.toLowerCase(),p==="select"||p==="input"&&h.type==="file")var w=Pue;else if(SB(h))if(dG)w=Wue;else{w=zue;var k=Lue}else(p=h.nodeName)&&p.toLowerCase()==="input"&&(h.type==="checkbox"||h.type==="radio")&&(w=Bue);if(w&&(w=w(e,u))){cG(d,w,n,c);break e}k&&k(e,h,u),e==="focusout"&&(k=h._wrapperState)&&k.controlled&&h.type==="number"&&s_(h,"number",h.value)}switch(k=u?Am(u):window,e){case"focusin":(SB(k)||k.contentEditable==="true")&&(Em=k,g_=u,Qv=null);break;case"focusout":Qv=g_=Em=null;break;case"mousedown":y_=!0;break;case"contextmenu":case"mouseup":case"dragend":y_=!1,$B(d,n,c);break;case"selectionchange":if(jue)break;case"keydown":case"keyup":$B(d,n,c)}var S;if(ID)e:{switch(e){case"compositionstart":var I="onCompositionStart";break e;case"compositionend":I="onCompositionEnd";break e;case"compositionupdate":I="onCompositionUpdate";break e}I=void 0}else $m?lG(e,n)&&(I="onCompositionEnd"):e==="keydown"&&n.keyCode===229&&(I="onCompositionStart");I&&(oG&&n.locale!=="ko"&&($m||I!=="onCompositionStart"?I==="onCompositionEnd"&&$m&&(S=iG()):(Qu=c,wD="value"in Qu?Qu.value:Qu.textContent,$m=!0)),k=P2(u,I),0<k.length&&(I=new vB(I,e,null,n,c),d.push({event:I,listeners:k}),S?I.data=S:(S=uG(n),S!==null&&(I.data=S)))),(S=Rue?Due(e,n):Oue(e,n))&&(u=P2(u,"onBeforeInput"),0<u.length&&(c=new vB("onBeforeInput","beforeinput",null,n,c),d.push({event:c,listeners:u}),c.data=S))}wG(d,t)})}function k1(e,t,n){return{instance:e,listener:t,currentTarget:n}}function P2(e,t){for(var n=t+"Capture",r=[];e!==null;){var s=e,a=s.stateNode;s.tag===5&&a!==null&&(s=a,a=m1(e,n),a!=null&&r.unshift(k1(e,a,s)),a=m1(e,t),a!=null&&r.push(k1(e,a,s))),e=e.return}return r}function lm(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function AB(e,t,n,r,s){for(var a=t._reactName,i=[];n!==null&&n!==r;){var o=n,l=o.alternate,u=o.stateNode;if(l!==null&&l===r)break;o.tag===5&&u!==null&&(o=u,s?(l=m1(n,a),l!=null&&i.unshift(k1(n,l,o))):s||(l=m1(n,a),l!=null&&i.push(k1(n,l,o)))),n=n.return}i.length!==0&&e.push({event:t,listeners:i})}var Kue=/\r\n?/g,Xue=/\u0000|\uFFFD/g;function RB(e){return(typeof e=="string"?e:""+e).replace(Kue,`
`).replace(Xue,"")}function hk(e,t,n){if(t=RB(t),RB(e)!==t&&n)throw Error(He(425))}function L2(){}var b_=null,v_=null;function x_(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var w_=typeof setTimeout=="function"?setTimeout:void 0,Yue=typeof clearTimeout=="function"?clearTimeout:void 0,DB=typeof Promise=="function"?Promise:void 0,Jue=typeof queueMicrotask=="function"?queueMicrotask:typeof DB<"u"?function(e){return DB.resolve(null).then(e).catch(Zue)}:w_;function Zue(e){setTimeout(function(){throw e})}function z$(e,t){var n=t,r=0;do{var s=n.nextSibling;if(e.removeChild(n),s&&s.nodeType===8)if(n=s.data,n==="/$"){if(r===0){e.removeChild(s),b1(t);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=s}while(n);b1(t)}function pc(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function OB(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="$"||n==="$!"||n==="$?"){if(t===0)return e;t--}else n==="/$"&&t++}e=e.previousSibling}return null}var ry=Math.random().toString(36).slice(2),pl="__reactFiber$"+ry,S1="__reactProps$"+ry,uu="__reactContainer$"+ry,k_="__reactEvents$"+ry,Que="__reactListeners$"+ry,ece="__reactHandles$"+ry;function Zd(e){var t=e[pl];if(t)return t;for(var n=e.parentNode;n;){if(t=n[uu]||n[pl]){if(n=t.alternate,t.child!==null||n!==null&&n.child!==null)for(e=OB(e);e!==null;){if(n=e[pl])return n;e=OB(e)}return t}e=n,n=e.parentNode}return null}function b0(e){return e=e[pl]||e[uu],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function Am(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(He(33))}function EI(e){return e[S1]||null}var S_=[],Rm=-1;function Zc(e){return{current:e}}function Kn(e){0>Rm||(e.current=S_[Rm],S_[Rm]=null,Rm--)}function zn(e,t){Rm++,S_[Rm]=e.current,e.current=t}var $c={},Zs=Zc($c),Ga=Zc(!1),wh=$c;function og(e,t){var n=e.type.contextTypes;if(!n)return $c;var r=e.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===t)return r.__reactInternalMemoizedMaskedChildContext;var s={},a;for(a in n)s[a]=t[a];return r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function Ha(e){return e=e.childContextTypes,e!=null}function z2(){Kn(Ga),Kn(Zs)}function FB(e,t,n){if(Zs.current!==$c)throw Error(He(168));zn(Zs,t),zn(Ga,n)}function SG(e,t,n){var r=e.stateNode;if(t=t.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var s in r)if(!(s in t))throw Error(He(108,Lle(e)||"Unknown",s));return dr({},n,r)}function B2(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||$c,wh=Zs.current,zn(Zs,e),zn(Ga,Ga.current),!0}function MB(e,t,n){var r=e.stateNode;if(!r)throw Error(He(169));n?(e=SG(e,t,wh),r.__reactInternalMemoizedMergedChildContext=e,Kn(Ga),Kn(Zs),zn(Zs,e)):Kn(Ga),zn(Ga,n)}var Kl=null,_I=!1,B$=!1;function IG(e){Kl===null?Kl=[e]:Kl.push(e)}function tce(e){_I=!0,IG(e)}function Qc(){if(!B$&&Kl!==null){B$=!0;var e=0,t=Sn;try{var n=Kl;for(Sn=1;e<n.length;e++){var r=n[e];do r=r(!0);while(r!==null)}Kl=null,_I=!1}catch(s){throw Kl!==null&&(Kl=Kl.slice(e+1)),X6(yD,Qc),s}finally{Sn=t,B$=!1}}return null}var Dm=[],Om=0,W2=null,V2=0,Pi=[],Li=0,kh=null,tu=1,nu="";function Fd(e,t){Dm[Om++]=V2,Dm[Om++]=W2,W2=e,V2=t}function CG(e,t,n){Pi[Li++]=tu,Pi[Li++]=nu,Pi[Li++]=kh,kh=e;var r=tu;e=nu;var s=32-To(r)-1;r&=~(1<<s),n+=1;var a=32-To(t)+s;if(30<a){var i=s-s%5;a=(r&(1<<i)-1).toString(32),r>>=i,s-=i,tu=1<<32-To(t)+s|n<<s|r,nu=a+e}else tu=1<<a|n<<s|r,nu=e}function ND(e){e.return!==null&&(Fd(e,1),CG(e,1,0))}function TD(e){for(;e===W2;)W2=Dm[--Om],Dm[Om]=null,V2=Dm[--Om],Dm[Om]=null;for(;e===kh;)kh=Pi[--Li],Pi[Li]=null,nu=Pi[--Li],Pi[Li]=null,tu=Pi[--Li],Pi[Li]=null}var mi=null,ui=null,tr=!1,ko=null;function NG(e,t){var n=Bi(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,t=e.deletions,t===null?(e.deletions=[n],e.flags|=16):t.push(n)}function PB(e,t){switch(e.tag){case 5:var n=e.type;return t=t.nodeType!==1||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,mi=e,ui=pc(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,mi=e,ui=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(n=kh!==null?{id:tu,overflow:nu}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},n=Bi(18,null,null,0),n.stateNode=t,n.return=e,e.child=n,mi=e,ui=null,!0):!1;default:return!1}}function I_(e){return(e.mode&1)!==0&&(e.flags&128)===0}function C_(e){if(tr){var t=ui;if(t){var n=t;if(!PB(e,t)){if(I_(e))throw Error(He(418));t=pc(n.nextSibling);var r=mi;t&&PB(e,t)?NG(r,n):(e.flags=e.flags&-4097|2,tr=!1,mi=e)}}else{if(I_(e))throw Error(He(418));e.flags=e.flags&-4097|2,tr=!1,mi=e}}}function LB(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;mi=e}function pk(e){if(e!==mi)return!1;if(!tr)return LB(e),tr=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!x_(e.type,e.memoizedProps)),t&&(t=ui)){if(I_(e))throw TG(),Error(He(418));for(;t;)NG(e,t),t=pc(t.nextSibling)}if(LB(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(He(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var n=e.data;if(n==="/$"){if(t===0){ui=pc(e.nextSibling);break e}t--}else n!=="$"&&n!=="$!"&&n!=="$?"||t++}e=e.nextSibling}ui=null}}else ui=mi?pc(e.stateNode.nextSibling):null;return!0}function TG(){for(var e=ui;e;)e=pc(e.nextSibling)}function lg(){ui=mi=null,tr=!1}function $D(e){ko===null?ko=[e]:ko.push(e)}var nce=xu.ReactCurrentBatchConfig;function xo(e,t){if(e&&e.defaultProps){t=dr({},t),e=e.defaultProps;for(var n in e)t[n]===void 0&&(t[n]=e[n]);return t}return t}var U2=Zc(null),j2=null,Fm=null,ED=null;function _D(){ED=Fm=j2=null}function AD(e){var t=U2.current;Kn(U2),e._currentValue=t}function N_(e,t,n){for(;e!==null;){var r=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,r!==null&&(r.childLanes|=t)):r!==null&&(r.childLanes&t)!==t&&(r.childLanes|=t),e===n)break;e=e.return}}function Gm(e,t){j2=e,ED=Fm=null,e=e.dependencies,e!==null&&e.firstContext!==null&&(e.lanes&t&&(Ba=!0),e.firstContext=null)}function Ki(e){var t=e._currentValue;if(ED!==e)if(e={context:e,memoizedValue:t,next:null},Fm===null){if(j2===null)throw Error(He(308));Fm=e,j2.dependencies={lanes:0,firstContext:e}}else Fm=Fm.next=e;return t}var Qd=null;function RD(e){Qd===null?Qd=[e]:Qd.push(e)}function $G(e,t,n,r){var s=t.interleaved;return s===null?(n.next=n,RD(t)):(n.next=s.next,s.next=n),t.interleaved=n,cu(e,r)}function cu(e,t){e.lanes|=t;var n=e.alternate;for(n!==null&&(n.lanes|=t),n=e,e=e.return;e!==null;)e.childLanes|=t,n=e.alternate,n!==null&&(n.childLanes|=t),n=e,e=e.return;return n.tag===3?n.stateNode:null}var Hu=!1;function DD(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function EG(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function su(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function fc(e,t,n){var r=e.updateQueue;if(r===null)return null;if(r=r.shared,an&2){var s=r.pending;return s===null?t.next=t:(t.next=s.next,s.next=t),r.pending=t,cu(e,n)}return s=r.interleaved,s===null?(t.next=t,RD(r)):(t.next=s.next,s.next=t),r.interleaved=t,cu(e,n)}function i2(e,t,n){if(t=t.updateQueue,t!==null&&(t=t.shared,(n&4194240)!==0)){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,bD(e,n)}}function zB(e,t){var n=e.updateQueue,r=e.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var s=null,a=null;if(n=n.firstBaseUpdate,n!==null){do{var i={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};a===null?s=a=i:a=a.next=i,n=n.next}while(n!==null);a===null?s=a=t:a=a.next=t}else s=a=t;n={baseState:r.baseState,firstBaseUpdate:s,lastBaseUpdate:a,shared:r.shared,effects:r.effects},e.updateQueue=n;return}e=n.lastBaseUpdate,e===null?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function G2(e,t,n,r){var s=e.updateQueue;Hu=!1;var a=s.firstBaseUpdate,i=s.lastBaseUpdate,o=s.shared.pending;if(o!==null){s.shared.pending=null;var l=o,u=l.next;l.next=null,i===null?a=u:i.next=u,i=l;var c=e.alternate;c!==null&&(c=c.updateQueue,o=c.lastBaseUpdate,o!==i&&(o===null?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(a!==null){var d=s.baseState;i=0,c=u=l=null,o=a;do{var h=o.lane,p=o.eventTime;if((r&h)===h){c!==null&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,m=o;switch(h=t,p=n,m.tag){case 1:if(f=m.payload,typeof f=="function"){d=f.call(p,d,h);break e}d=f;break e;case 3:f.flags=f.flags&-65537|128;case 0:if(f=m.payload,h=typeof f=="function"?f.call(p,d,h):f,h==null)break e;d=dr({},d,h);break e;case 2:Hu=!0}}o.callback!==null&&o.lane!==0&&(e.flags|=64,h=s.effects,h===null?s.effects=[o]:h.push(o))}else p={eventTime:p,lane:h,tag:o.tag,payload:o.payload,callback:o.callback,next:null},c===null?(u=c=p,l=d):c=c.next=p,i|=h;if(o=o.next,o===null){if(o=s.shared.pending,o===null)break;h=o,o=h.next,h.next=null,s.lastBaseUpdate=h,s.shared.pending=null}}while(1);if(c===null&&(l=d),s.baseState=l,s.firstBaseUpdate=u,s.lastBaseUpdate=c,t=s.shared.interleaved,t!==null){s=t;do i|=s.lane,s=s.next;while(s!==t)}else a===null&&(s.shared.lanes=0);Ih|=i,e.lanes=i,e.memoizedState=d}}function BB(e,t,n){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var r=e[t],s=r.callback;if(s!==null){if(r.callback=null,r=n,typeof s!="function")throw Error(He(191,s));s.call(r)}}}var _G=new $6.Component().refs;function T_(e,t,n,r){t=e.memoizedState,n=n(r,t),n=n==null?t:dr({},t,n),e.memoizedState=n,e.lanes===0&&(e.updateQueue.baseState=n)}var AI={isMounted:function(e){return(e=e._reactInternals)?dp(e)===e:!1},enqueueSetState:function(e,t,n){e=e._reactInternals;var r=ma(),s=gc(e),a=su(r,s);a.payload=t,n!=null&&(a.callback=n),t=fc(e,a,s),t!==null&&($o(t,e,s,r),i2(t,e,s))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var r=ma(),s=gc(e),a=su(r,s);a.tag=1,a.payload=t,n!=null&&(a.callback=n),t=fc(e,a,s),t!==null&&($o(t,e,s,r),i2(t,e,s))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=ma(),r=gc(e),s=su(n,r);s.tag=2,t!=null&&(s.callback=t),t=fc(e,s,r),t!==null&&($o(t,e,r,n),i2(t,e,r))}};function WB(e,t,n,r,s,a,i){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(r,a,i):t.prototype&&t.prototype.isPureReactComponent?!x1(n,r)||!x1(s,a):!0}function AG(e,t,n){var r=!1,s=$c,a=t.contextType;return typeof a=="object"&&a!==null?a=Ki(a):(s=Ha(t)?wh:Zs.current,r=t.contextTypes,a=(r=r!=null)?og(e,s):$c),t=new t(n,a),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=AI,e.stateNode=t,t._reactInternals=e,r&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=s,e.__reactInternalMemoizedMaskedChildContext=a),t}function VB(e,t,n,r){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(n,r),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(n,r),t.state!==e&&AI.enqueueReplaceState(t,t.state,null)}function $_(e,t,n,r){var s=e.stateNode;s.props=n,s.state=e.memoizedState,s.refs=_G,DD(e);var a=t.contextType;typeof a=="object"&&a!==null?s.context=Ki(a):(a=Ha(t)?wh:Zs.current,s.context=og(e,a)),s.state=e.memoizedState,a=t.getDerivedStateFromProps,typeof a=="function"&&(T_(e,t,a,n),s.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof s.getSnapshotBeforeUpdate=="function"||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(t=s.state,typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount(),t!==s.state&&AI.enqueueReplaceState(s,s.state,null),G2(e,n,s,r),s.state=e.memoizedState),typeof s.componentDidMount=="function"&&(e.flags|=4194308)}function dv(e,t,n){if(e=n.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(He(309));var r=n.stateNode}if(!r)throw Error(He(147,e));var s=r,a=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===a?t.ref:(t=function(i){var o=s.refs;o===_G&&(o=s.refs={}),i===null?delete o[a]:o[a]=i},t._stringRef=a,t)}if(typeof e!="string")throw Error(He(284));if(!n._owner)throw Error(He(290,e))}return e}function fk(e,t){throw e=Object.prototype.toString.call(t),Error(He(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function UB(e){var t=e._init;return t(e._payload)}function RG(e){function t(y,b){if(e){var x=y.deletions;x===null?(y.deletions=[b],y.flags|=16):x.push(b)}}function n(y,b){if(!e)return null;for(;b!==null;)t(y,b),b=b.sibling;return null}function r(y,b){for(y=new Map;b!==null;)b.key!==null?y.set(b.key,b):y.set(b.index,b),b=b.sibling;return y}function s(y,b){return y=yc(y,b),y.index=0,y.sibling=null,y}function a(y,b,x){return y.index=x,e?(x=y.alternate,x!==null?(x=x.index,x<b?(y.flags|=2,b):x):(y.flags|=2,b)):(y.flags|=1048576,b)}function i(y){return e&&y.alternate===null&&(y.flags|=2),y}function o(y,b,x,v){return b===null||b.tag!==6?(b=q$(x,y.mode,v),b.return=y,b):(b=s(b,x),b.return=y,b)}function l(y,b,x,v){var w=x.type;return w===Tm?c(y,b,x.props.children,v,x.key):b!==null&&(b.elementType===w||typeof w=="object"&&w!==null&&w.$$typeof===Gu&&UB(w)===b.type)?(v=s(b,x.props),v.ref=dv(y,b,x),v.return=y,v):(v=h2(x.type,x.key,x.props,null,y.mode,v),v.ref=dv(y,b,x),v.return=y,v)}function u(y,b,x,v){return b===null||b.tag!==4||b.stateNode.containerInfo!==x.containerInfo||b.stateNode.implementation!==x.implementation?(b=K$(x,y.mode,v),b.return=y,b):(b=s(b,x.children||[]),b.return=y,b)}function c(y,b,x,v,w){return b===null||b.tag!==7?(b=lh(x,y.mode,v,w),b.return=y,b):(b=s(b,x),b.return=y,b)}function d(y,b,x){if(typeof b=="string"&&b!==""||typeof b=="number")return b=q$(""+b,y.mode,x),b.return=y,b;if(typeof b=="object"&&b!==null){switch(b.$$typeof){case rk:return x=h2(b.type,b.key,b.props,null,y.mode,x),x.ref=dv(y,null,b),x.return=y,x;case Nm:return b=K$(b,y.mode,x),b.return=y,b;case Gu:var v=b._init;return d(y,v(b._payload),x)}if($v(b)||iv(b))return b=lh(b,y.mode,x,null),b.return=y,b;fk(y,b)}return null}function h(y,b,x,v){var w=b!==null?b.key:null;if(typeof x=="string"&&x!==""||typeof x=="number")return w!==null?null:o(y,b,""+x,v);if(typeof x=="object"&&x!==null){switch(x.$$typeof){case rk:return x.key===w?l(y,b,x,v):null;case Nm:return x.key===w?u(y,b,x,v):null;case Gu:return w=x._init,h(y,b,w(x._payload),v)}if($v(x)||iv(x))return w!==null?null:c(y,b,x,v,null);fk(y,x)}return null}function p(y,b,x,v,w){if(typeof v=="string"&&v!==""||typeof v=="number")return y=y.get(x)||null,o(b,y,""+v,w);if(typeof v=="object"&&v!==null){switch(v.$$typeof){case rk:return y=y.get(v.key===null?x:v.key)||null,l(b,y,v,w);case Nm:return y=y.get(v.key===null?x:v.key)||null,u(b,y,v,w);case Gu:var k=v._init;return p(y,b,x,k(v._payload),w)}if($v(v)||iv(v))return y=y.get(x)||null,c(b,y,v,w,null);fk(b,v)}return null}function f(y,b,x,v){for(var w=null,k=null,S=b,I=b=0,$=null;S!==null&&I<x.length;I++){S.index>I?($=S,S=null):$=S.sibling;var C=h(y,S,x[I],v);if(C===null){S===null&&(S=$);break}e&&S&&C.alternate===null&&t(y,S),b=a(C,b,I),k===null?w=C:k.sibling=C,k=C,S=$}if(I===x.length)return n(y,S),tr&&Fd(y,I),w;if(S===null){for(;I<x.length;I++)S=d(y,x[I],v),S!==null&&(b=a(S,b,I),k===null?w=S:k.sibling=S,k=S);return tr&&Fd(y,I),w}for(S=r(y,S);I<x.length;I++)$=p(S,y,I,x[I],v),$!==null&&(e&&$.alternate!==null&&S.delete($.key===null?I:$.key),b=a($,b,I),k===null?w=$:k.sibling=$,k=$);return e&&S.forEach(function(T){return t(y,T)}),tr&&Fd(y,I),w}function m(y,b,x,v){var w=iv(x);if(typeof w!="function")throw Error(He(150));if(x=w.call(x),x==null)throw Error(He(151));for(var k=w=null,S=b,I=b=0,$=null,C=x.next();S!==null&&!C.done;I++,C=x.next()){S.index>I?($=S,S=null):$=S.sibling;var T=h(y,S,C.value,v);if(T===null){S===null&&(S=$);break}e&&S&&T.alternate===null&&t(y,S),b=a(T,b,I),k===null?w=T:k.sibling=T,k=T,S=$}if(C.done)return n(y,S),tr&&Fd(y,I),w;if(S===null){for(;!C.done;I++,C=x.next())C=d(y,C.value,v),C!==null&&(b=a(C,b,I),k===null?w=C:k.sibling=C,k=C);return tr&&Fd(y,I),w}for(S=r(y,S);!C.done;I++,C=x.next())C=p(S,y,I,C.value,v),C!==null&&(e&&C.alternate!==null&&S.delete(C.key===null?I:C.key),b=a(C,b,I),k===null?w=C:k.sibling=C,k=C);return e&&S.forEach(function(N){return t(y,N)}),tr&&Fd(y,I),w}function g(y,b,x,v){if(typeof x=="object"&&x!==null&&x.type===Tm&&x.key===null&&(x=x.props.children),typeof x=="object"&&x!==null){switch(x.$$typeof){case rk:e:{for(var w=x.key,k=b;k!==null;){if(k.key===w){if(w=x.type,w===Tm){if(k.tag===7){n(y,k.sibling),b=s(k,x.props.children),b.return=y,y=b;break e}}else if(k.elementType===w||typeof w=="object"&&w!==null&&w.$$typeof===Gu&&UB(w)===k.type){n(y,k.sibling),b=s(k,x.props),b.ref=dv(y,k,x),b.return=y,y=b;break e}n(y,k);break}else t(y,k);k=k.sibling}x.type===Tm?(b=lh(x.props.children,y.mode,v,x.key),b.return=y,y=b):(v=h2(x.type,x.key,x.props,null,y.mode,v),v.ref=dv(y,b,x),v.return=y,y=v)}return i(y);case Nm:e:{for(k=x.key;b!==null;){if(b.key===k)if(b.tag===4&&b.stateNode.containerInfo===x.containerInfo&&b.stateNode.implementation===x.implementation){n(y,b.sibling),b=s(b,x.children||[]),b.return=y,y=b;break e}else{n(y,b);break}else t(y,b);b=b.sibling}b=K$(x,y.mode,v),b.return=y,y=b}return i(y);case Gu:return k=x._init,g(y,b,k(x._payload),v)}if($v(x))return f(y,b,x,v);if(iv(x))return m(y,b,x,v);fk(y,x)}return typeof x=="string"&&x!==""||typeof x=="number"?(x=""+x,b!==null&&b.tag===6?(n(y,b.sibling),b=s(b,x),b.return=y,y=b):(n(y,b),b=q$(x,y.mode,v),b.return=y,y=b),i(y)):n(y,b)}return g}var ug=RG(!0),DG=RG(!1),v0={},vl=Zc(v0),I1=Zc(v0),C1=Zc(v0);function eh(e){if(e===v0)throw Error(He(174));return e}function OD(e,t){switch(zn(C1,t),zn(I1,e),zn(vl,v0),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:i_(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=i_(t,e)}Kn(vl),zn(vl,t)}function cg(){Kn(vl),Kn(I1),Kn(C1)}function OG(e){eh(C1.current);var t=eh(vl.current),n=i_(t,e.type);t!==n&&(zn(I1,e),zn(vl,n))}function FD(e){I1.current===e&&(Kn(vl),Kn(I1))}var ur=Zc(0);function H2(e){for(var t=e;t!==null;){if(t.tag===13){var n=t.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if(t.flags&128)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var W$=[];function MD(){for(var e=0;e<W$.length;e++)W$[e]._workInProgressVersionPrimary=null;W$.length=0}var o2=xu.ReactCurrentDispatcher,V$=xu.ReactCurrentBatchConfig,Sh=0,cr=null,ns=null,gs=null,q2=!1,e1=!1,N1=0,rce=0;function Ws(){throw Error(He(321))}function PD(e,t){if(t===null)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!Mo(e[n],t[n]))return!1;return!0}function LD(e,t,n,r,s,a){if(Sh=a,cr=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,o2.current=e===null||e.memoizedState===null?oce:lce,e=n(r,s),e1){a=0;do{if(e1=!1,N1=0,25<=a)throw Error(He(301));a+=1,gs=ns=null,t.updateQueue=null,o2.current=uce,e=n(r,s)}while(e1)}if(o2.current=K2,t=ns!==null&&ns.next!==null,Sh=0,gs=ns=cr=null,q2=!1,t)throw Error(He(300));return e}function zD(){var e=N1!==0;return N1=0,e}function nl(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return gs===null?cr.memoizedState=gs=e:gs=gs.next=e,gs}function Xi(){if(ns===null){var e=cr.alternate;e=e!==null?e.memoizedState:null}else e=ns.next;var t=gs===null?cr.memoizedState:gs.next;if(t!==null)gs=t,ns=e;else{if(e===null)throw Error(He(310));ns=e,e={memoizedState:ns.memoizedState,baseState:ns.baseState,baseQueue:ns.baseQueue,queue:ns.queue,next:null},gs===null?cr.memoizedState=gs=e:gs=gs.next=e}return gs}function T1(e,t){return typeof t=="function"?t(e):t}function U$(e){var t=Xi(),n=t.queue;if(n===null)throw Error(He(311));n.lastRenderedReducer=e;var r=ns,s=r.baseQueue,a=n.pending;if(a!==null){if(s!==null){var i=s.next;s.next=a.next,a.next=i}r.baseQueue=s=a,n.pending=null}if(s!==null){a=s.next,r=r.baseState;var o=i=null,l=null,u=a;do{var c=u.lane;if((Sh&c)===c)l!==null&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),r=u.hasEagerState?u.eagerState:e(r,u.action);else{var d={lane:c,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};l===null?(o=l=d,i=r):l=l.next=d,cr.lanes|=c,Ih|=c}u=u.next}while(u!==null&&u!==a);l===null?i=r:l.next=o,Mo(r,t.memoizedState)||(Ba=!0),t.memoizedState=r,t.baseState=i,t.baseQueue=l,n.lastRenderedState=r}if(e=n.interleaved,e!==null){s=e;do a=s.lane,cr.lanes|=a,Ih|=a,s=s.next;while(s!==e)}else s===null&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function j$(e){var t=Xi(),n=t.queue;if(n===null)throw Error(He(311));n.lastRenderedReducer=e;var r=n.dispatch,s=n.pending,a=t.memoizedState;if(s!==null){n.pending=null;var i=s=s.next;do a=e(a,i.action),i=i.next;while(i!==s);Mo(a,t.memoizedState)||(Ba=!0),t.memoizedState=a,t.baseQueue===null&&(t.baseState=a),n.lastRenderedState=a}return[a,r]}function FG(){}function MG(e,t){var n=cr,r=Xi(),s=t(),a=!Mo(r.memoizedState,s);if(a&&(r.memoizedState=s,Ba=!0),r=r.queue,BD(zG.bind(null,n,r,e),[e]),r.getSnapshot!==t||a||gs!==null&&gs.memoizedState.tag&1){if(n.flags|=2048,$1(9,LG.bind(null,n,r,s,t),void 0,null),ks===null)throw Error(He(349));Sh&30||PG(n,t,s)}return s}function PG(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},t=cr.updateQueue,t===null?(t={lastEffect:null,stores:null},cr.updateQueue=t,t.stores=[e]):(n=t.stores,n===null?t.stores=[e]:n.push(e))}function LG(e,t,n,r){t.value=n,t.getSnapshot=r,BG(t)&&WG(e)}function zG(e,t,n){return n(function(){BG(t)&&WG(e)})}function BG(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!Mo(e,n)}catch{return!0}}function WG(e){var t=cu(e,1);t!==null&&$o(t,e,1,-1)}function jB(e){var t=nl();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:T1,lastRenderedState:e},t.queue=e,e=e.dispatch=ice.bind(null,cr,e),[t.memoizedState,e]}function $1(e,t,n,r){return e={tag:e,create:t,destroy:n,deps:r,next:null},t=cr.updateQueue,t===null?(t={lastEffect:null,stores:null},cr.updateQueue=t,t.lastEffect=e.next=e):(n=t.lastEffect,n===null?t.lastEffect=e.next=e:(r=n.next,n.next=e,e.next=r,t.lastEffect=e)),e}function VG(){return Xi().memoizedState}function l2(e,t,n,r){var s=nl();cr.flags|=e,s.memoizedState=$1(1|t,n,void 0,r===void 0?null:r)}function RI(e,t,n,r){var s=Xi();r=r===void 0?null:r;var a=void 0;if(ns!==null){var i=ns.memoizedState;if(a=i.destroy,r!==null&&PD(r,i.deps)){s.memoizedState=$1(t,n,a,r);return}}cr.flags|=e,s.memoizedState=$1(1|t,n,a,r)}function GB(e,t){return l2(8390656,8,e,t)}function BD(e,t){return RI(2048,8,e,t)}function UG(e,t){return RI(4,2,e,t)}function jG(e,t){return RI(4,4,e,t)}function GG(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function HG(e,t,n){return n=n!=null?n.concat([e]):null,RI(4,4,GG.bind(null,t,e),n)}function WD(){}function qG(e,t){var n=Xi();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&PD(t,r[1])?r[0]:(n.memoizedState=[e,t],e)}function KG(e,t){var n=Xi();t=t===void 0?null:t;var r=n.memoizedState;return r!==null&&t!==null&&PD(t,r[1])?r[0]:(e=e(),n.memoizedState=[e,t],e)}function XG(e,t,n){return Sh&21?(Mo(n,t)||(n=Z6(),cr.lanes|=n,Ih|=n,e.baseState=!0),t):(e.baseState&&(e.baseState=!1,Ba=!0),e.memoizedState=n)}function sce(e,t){var n=Sn;Sn=n!==0&&4>n?n:4,e(!0);var r=V$.transition;V$.transition={};try{e(!1),t()}finally{Sn=n,V$.transition=r}}function YG(){return Xi().memoizedState}function ace(e,t,n){var r=gc(e);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},JG(e))ZG(t,n);else if(n=$G(e,t,n,r),n!==null){var s=ma();$o(n,e,r,s),QG(n,t,r)}}function ice(e,t,n){var r=gc(e),s={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(JG(e))ZG(t,s);else{var a=e.alternate;if(e.lanes===0&&(a===null||a.lanes===0)&&(a=t.lastRenderedReducer,a!==null))try{var i=t.lastRenderedState,o=a(i,n);if(s.hasEagerState=!0,s.eagerState=o,Mo(o,i)){var l=t.interleaved;l===null?(s.next=s,RD(t)):(s.next=l.next,l.next=s),t.interleaved=s;return}}catch{}finally{}n=$G(e,t,s,r),n!==null&&(s=ma(),$o(n,e,r,s),QG(n,t,r))}}function JG(e){var t=e.alternate;return e===cr||t!==null&&t===cr}function ZG(e,t){e1=q2=!0;var n=e.pending;n===null?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function QG(e,t,n){if(n&4194240){var r=t.lanes;r&=e.pendingLanes,n|=r,t.lanes=n,bD(e,n)}}var K2={readContext:Ki,useCallback:Ws,useContext:Ws,useEffect:Ws,useImperativeHandle:Ws,useInsertionEffect:Ws,useLayoutEffect:Ws,useMemo:Ws,useReducer:Ws,useRef:Ws,useState:Ws,useDebugValue:Ws,useDeferredValue:Ws,useTransition:Ws,useMutableSource:Ws,useSyncExternalStore:Ws,useId:Ws,unstable_isNewReconciler:!1},oce={readContext:Ki,useCallback:function(e,t){return nl().memoizedState=[e,t===void 0?null:t],e},useContext:Ki,useEffect:GB,useImperativeHandle:function(e,t,n){return n=n!=null?n.concat([e]):null,l2(4194308,4,GG.bind(null,t,e),n)},useLayoutEffect:function(e,t){return l2(4194308,4,e,t)},useInsertionEffect:function(e,t){return l2(4,2,e,t)},useMemo:function(e,t){var n=nl();return t=t===void 0?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var r=nl();return t=n!==void 0?n(t):t,r.memoizedState=r.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},r.queue=e,e=e.dispatch=ace.bind(null,cr,e),[r.memoizedState,e]},useRef:function(e){var t=nl();return e={current:e},t.memoizedState=e},useState:jB,useDebugValue:WD,useDeferredValue:function(e){return nl().memoizedState=e},useTransition:function(){var e=jB(!1),t=e[0];return e=sce.bind(null,e[1]),nl().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var r=cr,s=nl();if(tr){if(n===void 0)throw Error(He(407));n=n()}else{if(n=t(),ks===null)throw Error(He(349));Sh&30||PG(r,t,n)}s.memoizedState=n;var a={value:n,getSnapshot:t};return s.queue=a,GB(zG.bind(null,r,a,e),[e]),r.flags|=2048,$1(9,LG.bind(null,r,a,n,t),void 0,null),n},useId:function(){var e=nl(),t=ks.identifierPrefix;if(tr){var n=nu,r=tu;n=(r&~(1<<32-To(r)-1)).toString(32)+n,t=":"+t+"R"+n,n=N1++,0<n&&(t+="H"+n.toString(32)),t+=":"}else n=rce++,t=":"+t+"r"+n.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},lce={readContext:Ki,useCallback:qG,useContext:Ki,useEffect:BD,useImperativeHandle:HG,useInsertionEffect:UG,useLayoutEffect:jG,useMemo:KG,useReducer:U$,useRef:VG,useState:function(){return U$(T1)},useDebugValue:WD,useDeferredValue:function(e){var t=Xi();return XG(t,ns.memoizedState,e)},useTransition:function(){var e=U$(T1)[0],t=Xi().memoizedState;return[e,t]},useMutableSource:FG,useSyncExternalStore:MG,useId:YG,unstable_isNewReconciler:!1},uce={readContext:Ki,useCallback:qG,useContext:Ki,useEffect:BD,useImperativeHandle:HG,useInsertionEffect:UG,useLayoutEffect:jG,useMemo:KG,useReducer:j$,useRef:VG,useState:function(){return j$(T1)},useDebugValue:WD,useDeferredValue:function(e){var t=Xi();return ns===null?t.memoizedState=e:XG(t,ns.memoizedState,e)},useTransition:function(){var e=j$(T1)[0],t=Xi().memoizedState;return[e,t]},useMutableSource:FG,useSyncExternalStore:MG,useId:YG,unstable_isNewReconciler:!1};function dg(e,t){try{var n="",r=t;do n+=Ple(r),r=r.return;while(r);var s=n}catch(a){s=`
Error generating stack: `+a.message+`
`+a.stack}return{value:e,source:t,stack:s,digest:null}}function G$(e,t,n){return{value:e,source:null,stack:n??null,digest:t??null}}function E_(e,t){try{console.error(t.value)}catch(n){setTimeout(function(){throw n})}}var cce=typeof WeakMap=="function"?WeakMap:Map;function eH(e,t,n){n=su(-1,n),n.tag=3,n.payload={element:null};var r=t.value;return n.callback=function(){Y2||(Y2=!0,z_=r),E_(e,t)},n}function tH(e,t,n){n=su(-1,n),n.tag=3;var r=e.type.getDerivedStateFromError;if(typeof r=="function"){var s=t.value;n.payload=function(){return r(s)},n.callback=function(){E_(e,t)}}var a=e.stateNode;return a!==null&&typeof a.componentDidCatch=="function"&&(n.callback=function(){E_(e,t),typeof r!="function"&&(mc===null?mc=new Set([this]):mc.add(this));var i=t.stack;this.componentDidCatch(t.value,{componentStack:i!==null?i:""})}),n}function HB(e,t,n){var r=e.pingCache;if(r===null){r=e.pingCache=new cce;var s=new Set;r.set(t,s)}else s=r.get(t),s===void 0&&(s=new Set,r.set(t,s));s.has(n)||(s.add(n),e=Ice.bind(null,e,t,n),t.then(e,e))}function qB(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function KB(e,t,n,r,s){return e.mode&1?(e.flags|=65536,e.lanes=s,e):(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(t=su(-1,1),t.tag=2,fc(n,t,1))),n.lanes|=1),e)}var dce=xu.ReactCurrentOwner,Ba=!1;function ua(e,t,n,r){t.child=e===null?DG(t,null,n,r):ug(t,e.child,n,r)}function XB(e,t,n,r,s){n=n.render;var a=t.ref;return Gm(t,s),r=LD(e,t,n,r,a,s),n=zD(),e!==null&&!Ba?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,du(e,t,s)):(tr&&n&&ND(t),t.flags|=1,ua(e,t,r,s),t.child)}function YB(e,t,n,r,s){if(e===null){var a=n.type;return typeof a=="function"&&!XD(a)&&a.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(t.tag=15,t.type=a,nH(e,t,a,r,s)):(e=h2(n.type,null,r,t,t.mode,s),e.ref=t.ref,e.return=t,t.child=e)}if(a=e.child,!(e.lanes&s)){var i=a.memoizedProps;if(n=n.compare,n=n!==null?n:x1,n(i,r)&&e.ref===t.ref)return du(e,t,s)}return t.flags|=1,e=yc(a,r),e.ref=t.ref,e.return=t,t.child=e}function nH(e,t,n,r,s){if(e!==null){var a=e.memoizedProps;if(x1(a,r)&&e.ref===t.ref)if(Ba=!1,t.pendingProps=r=a,(e.lanes&s)!==0)e.flags&131072&&(Ba=!0);else return t.lanes=e.lanes,du(e,t,s)}return __(e,t,n,r,s)}function rH(e,t,n){var r=t.pendingProps,s=r.children,a=e!==null?e.memoizedState:null;if(r.mode==="hidden")if(!(t.mode&1))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},zn(Pm,oi),oi|=n;else{if(!(n&1073741824))return e=a!==null?a.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,zn(Pm,oi),oi|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=a!==null?a.baseLanes:n,zn(Pm,oi),oi|=r}else a!==null?(r=a.baseLanes|n,t.memoizedState=null):r=n,zn(Pm,oi),oi|=r;return ua(e,t,s,n),t.child}function sH(e,t){var n=t.ref;(e===null&&n!==null||e!==null&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function __(e,t,n,r,s){var a=Ha(n)?wh:Zs.current;return a=og(t,a),Gm(t,s),n=LD(e,t,n,r,a,s),r=zD(),e!==null&&!Ba?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~s,du(e,t,s)):(tr&&r&&ND(t),t.flags|=1,ua(e,t,n,s),t.child)}function JB(e,t,n,r,s){if(Ha(n)){var a=!0;B2(t)}else a=!1;if(Gm(t,s),t.stateNode===null)u2(e,t),AG(t,n,r),$_(t,n,r,s),r=!0;else if(e===null){var i=t.stateNode,o=t.memoizedProps;i.props=o;var l=i.context,u=n.contextType;typeof u=="object"&&u!==null?u=Ki(u):(u=Ha(n)?wh:Zs.current,u=og(t,u));var c=n.getDerivedStateFromProps,d=typeof c=="function"||typeof i.getSnapshotBeforeUpdate=="function";d||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==r||l!==u)&&VB(t,i,r,u),Hu=!1;var h=t.memoizedState;i.state=h,G2(t,r,i,s),l=t.memoizedState,o!==r||h!==l||Ga.current||Hu?(typeof c=="function"&&(T_(t,n,c,r),l=t.memoizedState),(o=Hu||WB(t,n,o,r,h,l,u))?(d||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount()),typeof i.componentDidMount=="function"&&(t.flags|=4194308)):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=r,t.memoizedState=l),i.props=r,i.state=l,i.context=u,r=o):(typeof i.componentDidMount=="function"&&(t.flags|=4194308),r=!1)}else{i=t.stateNode,EG(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:xo(t.type,o),i.props=u,d=t.pendingProps,h=i.context,l=n.contextType,typeof l=="object"&&l!==null?l=Ki(l):(l=Ha(n)?wh:Zs.current,l=og(t,l));var p=n.getDerivedStateFromProps;(c=typeof p=="function"||typeof i.getSnapshotBeforeUpdate=="function")||typeof i.UNSAFE_componentWillReceiveProps!="function"&&typeof i.componentWillReceiveProps!="function"||(o!==d||h!==l)&&VB(t,i,r,l),Hu=!1,h=t.memoizedState,i.state=h,G2(t,r,i,s);var f=t.memoizedState;o!==d||h!==f||Ga.current||Hu?(typeof p=="function"&&(T_(t,n,p,r),f=t.memoizedState),(u=Hu||WB(t,n,u,r,h,f,l)||!1)?(c||typeof i.UNSAFE_componentWillUpdate!="function"&&typeof i.componentWillUpdate!="function"||(typeof i.componentWillUpdate=="function"&&i.componentWillUpdate(r,f,l),typeof i.UNSAFE_componentWillUpdate=="function"&&i.UNSAFE_componentWillUpdate(r,f,l)),typeof i.componentDidUpdate=="function"&&(t.flags|=4),typeof i.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),t.memoizedProps=r,t.memoizedState=f),i.props=r,i.state=f,i.context=l,r=u):(typeof i.componentDidUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=4),typeof i.getSnapshotBeforeUpdate!="function"||o===e.memoizedProps&&h===e.memoizedState||(t.flags|=1024),r=!1)}return A_(e,t,n,r,a,s)}function A_(e,t,n,r,s,a){sH(e,t);var i=(t.flags&128)!==0;if(!r&&!i)return s&&MB(t,n,!1),du(e,t,a);r=t.stateNode,dce.current=t;var o=i&&typeof n.getDerivedStateFromError!="function"?null:r.render();return t.flags|=1,e!==null&&i?(t.child=ug(t,e.child,null,a),t.child=ug(t,null,o,a)):ua(e,t,o,a),t.memoizedState=r.state,s&&MB(t,n,!0),t.child}function aH(e){var t=e.stateNode;t.pendingContext?FB(e,t.pendingContext,t.pendingContext!==t.context):t.context&&FB(e,t.context,!1),OD(e,t.containerInfo)}function ZB(e,t,n,r,s){return lg(),$D(s),t.flags|=256,ua(e,t,n,r),t.child}var R_={dehydrated:null,treeContext:null,retryLane:0};function D_(e){return{baseLanes:e,cachePool:null,transitions:null}}function iH(e,t,n){var r=t.pendingProps,s=ur.current,a=!1,i=(t.flags&128)!==0,o;if((o=i)||(o=e!==null&&e.memoizedState===null?!1:(s&2)!==0),o?(a=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(s|=1),zn(ur,s&1),e===null)return C_(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?(t.mode&1?e.data==="$!"?t.lanes=8:t.lanes=1073741824:t.lanes=1,null):(i=r.children,e=r.fallback,a?(r=t.mode,a=t.child,i={mode:"hidden",children:i},!(r&1)&&a!==null?(a.childLanes=0,a.pendingProps=i):a=FI(i,r,0,null),e=lh(e,r,n,null),a.return=t,e.return=t,a.sibling=e,t.child=a,t.child.memoizedState=D_(n),t.memoizedState=R_,e):VD(t,i));if(s=e.memoizedState,s!==null&&(o=s.dehydrated,o!==null))return hce(e,t,i,r,o,s,n);if(a){a=r.fallback,i=t.mode,s=e.child,o=s.sibling;var l={mode:"hidden",children:r.children};return!(i&1)&&t.child!==s?(r=t.child,r.childLanes=0,r.pendingProps=l,t.deletions=null):(r=yc(s,l),r.subtreeFlags=s.subtreeFlags&14680064),o!==null?a=yc(o,a):(a=lh(a,i,n,null),a.flags|=2),a.return=t,r.return=t,r.sibling=a,t.child=r,r=a,a=t.child,i=e.child.memoizedState,i=i===null?D_(n):{baseLanes:i.baseLanes|n,cachePool:null,transitions:i.transitions},a.memoizedState=i,a.childLanes=e.childLanes&~n,t.memoizedState=R_,r}return a=e.child,e=a.sibling,r=yc(a,{mode:"visible",children:r.children}),!(t.mode&1)&&(r.lanes=n),r.return=t,r.sibling=null,e!==null&&(n=t.deletions,n===null?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function VD(e,t){return t=FI({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function mk(e,t,n,r){return r!==null&&$D(r),ug(t,e.child,null,n),e=VD(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function hce(e,t,n,r,s,a,i){if(n)return t.flags&256?(t.flags&=-257,r=G$(Error(He(422))),mk(e,t,i,r)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(a=r.fallback,s=t.mode,r=FI({mode:"visible",children:r.children},s,0,null),a=lh(a,s,i,null),a.flags|=2,r.return=t,a.return=t,r.sibling=a,t.child=r,t.mode&1&&ug(t,e.child,null,i),t.child.memoizedState=D_(i),t.memoizedState=R_,a);if(!(t.mode&1))return mk(e,t,i,null);if(s.data==="$!"){if(r=s.nextSibling&&s.nextSibling.dataset,r)var o=r.dgst;return r=o,a=Error(He(419)),r=G$(a,r,void 0),mk(e,t,i,r)}if(o=(i&e.childLanes)!==0,Ba||o){if(r=ks,r!==null){switch(i&-i){case 4:s=2;break;case 16:s=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:s=32;break;case 536870912:s=268435456;break;default:s=0}s=s&(r.suspendedLanes|i)?0:s,s!==0&&s!==a.retryLane&&(a.retryLane=s,cu(e,s),$o(r,e,s,-1))}return KD(),r=G$(Error(He(421))),mk(e,t,i,r)}return s.data==="$?"?(t.flags|=128,t.child=e.child,t=Cce.bind(null,e),s._reactRetry=t,null):(e=a.treeContext,ui=pc(s.nextSibling),mi=t,tr=!0,ko=null,e!==null&&(Pi[Li++]=tu,Pi[Li++]=nu,Pi[Li++]=kh,tu=e.id,nu=e.overflow,kh=t),t=VD(t,r.children),t.flags|=4096,t)}function QB(e,t,n){e.lanes|=t;var r=e.alternate;r!==null&&(r.lanes|=t),N_(e.return,t,n)}function H$(e,t,n,r,s){var a=e.memoizedState;a===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:s}:(a.isBackwards=t,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=n,a.tailMode=s)}function oH(e,t,n){var r=t.pendingProps,s=r.revealOrder,a=r.tail;if(ua(e,t,r.children,n),r=ur.current,r&2)r=r&1|2,t.flags|=128;else{if(e!==null&&e.flags&128)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&QB(e,n,t);else if(e.tag===19)QB(e,n,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}r&=1}if(zn(ur,r),!(t.mode&1))t.memoizedState=null;else switch(s){case"forwards":for(n=t.child,s=null;n!==null;)e=n.alternate,e!==null&&H2(e)===null&&(s=n),n=n.sibling;n=s,n===null?(s=t.child,t.child=null):(s=n.sibling,n.sibling=null),H$(t,!1,s,n,a);break;case"backwards":for(n=null,s=t.child,t.child=null;s!==null;){if(e=s.alternate,e!==null&&H2(e)===null){t.child=s;break}e=s.sibling,s.sibling=n,n=s,s=e}H$(t,!0,n,null,a);break;case"together":H$(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function u2(e,t){!(t.mode&1)&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function du(e,t,n){if(e!==null&&(t.dependencies=e.dependencies),Ih|=t.lanes,!(n&t.childLanes))return null;if(e!==null&&t.child!==e.child)throw Error(He(153));if(t.child!==null){for(e=t.child,n=yc(e,e.pendingProps),t.child=n,n.return=t;e.sibling!==null;)e=e.sibling,n=n.sibling=yc(e,e.pendingProps),n.return=t;n.sibling=null}return t.child}function pce(e,t,n){switch(t.tag){case 3:aH(t),lg();break;case 5:OG(t);break;case 1:Ha(t.type)&&B2(t);break;case 4:OD(t,t.stateNode.containerInfo);break;case 10:var r=t.type._context,s=t.memoizedProps.value;zn(U2,r._currentValue),r._currentValue=s;break;case 13:if(r=t.memoizedState,r!==null)return r.dehydrated!==null?(zn(ur,ur.current&1),t.flags|=128,null):n&t.child.childLanes?iH(e,t,n):(zn(ur,ur.current&1),e=du(e,t,n),e!==null?e.sibling:null);zn(ur,ur.current&1);break;case 19:if(r=(n&t.childLanes)!==0,e.flags&128){if(r)return oH(e,t,n);t.flags|=128}if(s=t.memoizedState,s!==null&&(s.rendering=null,s.tail=null,s.lastEffect=null),zn(ur,ur.current),r)break;return null;case 22:case 23:return t.lanes=0,rH(e,t,n)}return du(e,t,n)}var lH,O_,uH,cH;lH=function(e,t){for(var n=t.child;n!==null;){if(n.tag===5||n.tag===6)e.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===t)break;for(;n.sibling===null;){if(n.return===null||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};O_=function(){};uH=function(e,t,n,r){var s=e.memoizedProps;if(s!==r){e=t.stateNode,eh(vl.current);var a=null;switch(n){case"input":s=n_(e,s),r=n_(e,r),a=[];break;case"select":s=dr({},s,{value:void 0}),r=dr({},r,{value:void 0}),a=[];break;case"textarea":s=a_(e,s),r=a_(e,r),a=[];break;default:typeof s.onClick!="function"&&typeof r.onClick=="function"&&(e.onclick=L2)}o_(n,r);var i;n=null;for(u in s)if(!r.hasOwnProperty(u)&&s.hasOwnProperty(u)&&s[u]!=null)if(u==="style"){var o=s[u];for(i in o)o.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else u!=="dangerouslySetInnerHTML"&&u!=="children"&&u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&u!=="autoFocus"&&(p1.hasOwnProperty(u)?a||(a=[]):(a=a||[]).push(u,null));for(u in r){var l=r[u];if(o=s!=null?s[u]:void 0,r.hasOwnProperty(u)&&l!==o&&(l!=null||o!=null))if(u==="style")if(o){for(i in o)!o.hasOwnProperty(i)||l&&l.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in l)l.hasOwnProperty(i)&&o[i]!==l[i]&&(n||(n={}),n[i]=l[i])}else n||(a||(a=[]),a.push(u,n)),n=l;else u==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,o=o?o.__html:void 0,l!=null&&o!==l&&(a=a||[]).push(u,l)):u==="children"?typeof l!="string"&&typeof l!="number"||(a=a||[]).push(u,""+l):u!=="suppressContentEditableWarning"&&u!=="suppressHydrationWarning"&&(p1.hasOwnProperty(u)?(l!=null&&u==="onScroll"&&Gn("scroll",e),a||o===l||(a=[])):(a=a||[]).push(u,l))}n&&(a=a||[]).push("style",n);var u=a;(t.updateQueue=u)&&(t.flags|=4)}};cH=function(e,t,n,r){n!==r&&(t.flags|=4)};function hv(e,t){if(!tr)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;t!==null;)t.alternate!==null&&(n=t),t=t.sibling;n===null?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:r.sibling=null}}function Vs(e){var t=e.alternate!==null&&e.alternate.child===e.child,n=0,r=0;if(t)for(var s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags&14680064,r|=s.flags&14680064,s.return=e,s=s.sibling;else for(s=e.child;s!==null;)n|=s.lanes|s.childLanes,r|=s.subtreeFlags,r|=s.flags,s.return=e,s=s.sibling;return e.subtreeFlags|=r,e.childLanes=n,t}function fce(e,t,n){var r=t.pendingProps;switch(TD(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Vs(t),null;case 1:return Ha(t.type)&&z2(),Vs(t),null;case 3:return r=t.stateNode,cg(),Kn(Ga),Kn(Zs),MD(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(e===null||e.child===null)&&(pk(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&!(t.flags&256)||(t.flags|=1024,ko!==null&&(V_(ko),ko=null))),O_(e,t),Vs(t),null;case 5:FD(t);var s=eh(C1.current);if(n=t.type,e!==null&&t.stateNode!=null)uH(e,t,n,r,s),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!r){if(t.stateNode===null)throw Error(He(166));return Vs(t),null}if(e=eh(vl.current),pk(t)){r=t.stateNode,n=t.type;var a=t.memoizedProps;switch(r[pl]=t,r[S1]=a,e=(t.mode&1)!==0,n){case"dialog":Gn("cancel",r),Gn("close",r);break;case"iframe":case"object":case"embed":Gn("load",r);break;case"video":case"audio":for(s=0;s<_v.length;s++)Gn(_v[s],r);break;case"source":Gn("error",r);break;case"img":case"image":case"link":Gn("error",r),Gn("load",r);break;case"details":Gn("toggle",r);break;case"input":lB(r,a),Gn("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!a.multiple},Gn("invalid",r);break;case"textarea":cB(r,a),Gn("invalid",r)}o_(n,a),s=null;for(var i in a)if(a.hasOwnProperty(i)){var o=a[i];i==="children"?typeof o=="string"?r.textContent!==o&&(a.suppressHydrationWarning!==!0&&hk(r.textContent,o,e),s=["children",o]):typeof o=="number"&&r.textContent!==""+o&&(a.suppressHydrationWarning!==!0&&hk(r.textContent,o,e),s=["children",""+o]):p1.hasOwnProperty(i)&&o!=null&&i==="onScroll"&&Gn("scroll",r)}switch(n){case"input":sk(r),uB(r,a,!0);break;case"textarea":sk(r),dB(r);break;case"select":case"option":break;default:typeof a.onClick=="function"&&(r.onclick=L2)}r=s,t.updateQueue=r,r!==null&&(t.flags|=4)}else{i=s.nodeType===9?s:s.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=P6(n)),e==="http://www.w3.org/1999/xhtml"?n==="script"?(e=i.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof r.is=="string"?e=i.createElement(n,{is:r.is}):(e=i.createElement(n),n==="select"&&(i=e,r.multiple?i.multiple=!0:r.size&&(i.size=r.size))):e=i.createElementNS(e,n),e[pl]=t,e[S1]=r,lH(e,t,!1,!1),t.stateNode=e;e:{switch(i=l_(n,r),n){case"dialog":Gn("cancel",e),Gn("close",e),s=r;break;case"iframe":case"object":case"embed":Gn("load",e),s=r;break;case"video":case"audio":for(s=0;s<_v.length;s++)Gn(_v[s],e);s=r;break;case"source":Gn("error",e),s=r;break;case"img":case"image":case"link":Gn("error",e),Gn("load",e),s=r;break;case"details":Gn("toggle",e),s=r;break;case"input":lB(e,r),s=n_(e,r),Gn("invalid",e);break;case"option":s=r;break;case"select":e._wrapperState={wasMultiple:!!r.multiple},s=dr({},r,{value:void 0}),Gn("invalid",e);break;case"textarea":cB(e,r),s=a_(e,r),Gn("invalid",e);break;default:s=r}o_(n,s),o=s;for(a in o)if(o.hasOwnProperty(a)){var l=o[a];a==="style"?B6(e,l):a==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&L6(e,l)):a==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&f1(e,l):typeof l=="number"&&f1(e,""+l):a!=="suppressContentEditableWarning"&&a!=="suppressHydrationWarning"&&a!=="autoFocus"&&(p1.hasOwnProperty(a)?l!=null&&a==="onScroll"&&Gn("scroll",e):l!=null&&hD(e,a,l,i))}switch(n){case"input":sk(e),uB(e,r,!1);break;case"textarea":sk(e),dB(e);break;case"option":r.value!=null&&e.setAttribute("value",""+Tc(r.value));break;case"select":e.multiple=!!r.multiple,a=r.value,a!=null?Wm(e,!!r.multiple,a,!1):r.defaultValue!=null&&Wm(e,!!r.multiple,r.defaultValue,!0);break;default:typeof s.onClick=="function"&&(e.onclick=L2)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return Vs(t),null;case 6:if(e&&t.stateNode!=null)cH(e,t,e.memoizedProps,r);else{if(typeof r!="string"&&t.stateNode===null)throw Error(He(166));if(n=eh(C1.current),eh(vl.current),pk(t)){if(r=t.stateNode,n=t.memoizedProps,r[pl]=t,(a=r.nodeValue!==n)&&(e=mi,e!==null))switch(e.tag){case 3:hk(r.nodeValue,n,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&hk(r.nodeValue,n,(e.mode&1)!==0)}a&&(t.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[pl]=t,t.stateNode=r}return Vs(t),null;case 13:if(Kn(ur),r=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(tr&&ui!==null&&t.mode&1&&!(t.flags&128))TG(),lg(),t.flags|=98560,a=!1;else if(a=pk(t),r!==null&&r.dehydrated!==null){if(e===null){if(!a)throw Error(He(318));if(a=t.memoizedState,a=a!==null?a.dehydrated:null,!a)throw Error(He(317));a[pl]=t}else lg(),!(t.flags&128)&&(t.memoizedState=null),t.flags|=4;Vs(t),a=!1}else ko!==null&&(V_(ko),ko=null),a=!0;if(!a)return t.flags&65536?t:null}return t.flags&128?(t.lanes=n,t):(r=r!==null,r!==(e!==null&&e.memoizedState!==null)&&r&&(t.child.flags|=8192,t.mode&1&&(e===null||ur.current&1?ls===0&&(ls=3):KD())),t.updateQueue!==null&&(t.flags|=4),Vs(t),null);case 4:return cg(),O_(e,t),e===null&&w1(t.stateNode.containerInfo),Vs(t),null;case 10:return AD(t.type._context),Vs(t),null;case 17:return Ha(t.type)&&z2(),Vs(t),null;case 19:if(Kn(ur),a=t.memoizedState,a===null)return Vs(t),null;if(r=(t.flags&128)!==0,i=a.rendering,i===null)if(r)hv(a,!1);else{if(ls!==0||e!==null&&e.flags&128)for(e=t.child;e!==null;){if(i=H2(e),i!==null){for(t.flags|=128,hv(a,!1),r=i.updateQueue,r!==null&&(t.updateQueue=r,t.flags|=4),t.subtreeFlags=0,r=n,n=t.child;n!==null;)a=n,e=r,a.flags&=14680066,i=a.alternate,i===null?(a.childLanes=0,a.lanes=e,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=i.childLanes,a.lanes=i.lanes,a.child=i.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=i.memoizedProps,a.memoizedState=i.memoizedState,a.updateQueue=i.updateQueue,a.type=i.type,e=i.dependencies,a.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return zn(ur,ur.current&1|2),t.child}e=e.sibling}a.tail!==null&&Cr()>hg&&(t.flags|=128,r=!0,hv(a,!1),t.lanes=4194304)}else{if(!r)if(e=H2(i),e!==null){if(t.flags|=128,r=!0,n=e.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),hv(a,!0),a.tail===null&&a.tailMode==="hidden"&&!i.alternate&&!tr)return Vs(t),null}else 2*Cr()-a.renderingStartTime>hg&&n!==1073741824&&(t.flags|=128,r=!0,hv(a,!1),t.lanes=4194304);a.isBackwards?(i.sibling=t.child,t.child=i):(n=a.last,n!==null?n.sibling=i:t.child=i,a.last=i)}return a.tail!==null?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=Cr(),t.sibling=null,n=ur.current,zn(ur,r?n&1|2:n&1),t):(Vs(t),null);case 22:case 23:return qD(),r=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==r&&(t.flags|=8192),r&&t.mode&1?oi&1073741824&&(Vs(t),t.subtreeFlags&6&&(t.flags|=8192)):Vs(t),null;case 24:return null;case 25:return null}throw Error(He(156,t.tag))}function mce(e,t){switch(TD(t),t.tag){case 1:return Ha(t.type)&&z2(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return cg(),Kn(Ga),Kn(Zs),MD(),e=t.flags,e&65536&&!(e&128)?(t.flags=e&-65537|128,t):null;case 5:return FD(t),null;case 13:if(Kn(ur),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(He(340));lg()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return Kn(ur),null;case 4:return cg(),null;case 10:return AD(t.type._context),null;case 22:case 23:return qD(),null;case 24:return null;default:return null}}var gk=!1,js=!1,gce=typeof WeakSet=="function"?WeakSet:Set,dt=null;function Mm(e,t){var n=e.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){fr(e,t,r)}else n.current=null}function F_(e,t,n){try{n()}catch(r){fr(e,t,r)}}var eW=!1;function yce(e,t){if(b_=F2,e=fG(),CD(e)){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{n=(n=e.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var s=r.anchorOffset,a=r.focusNode;r=r.focusOffset;try{n.nodeType,a.nodeType}catch{n=null;break e}var i=0,o=-1,l=-1,u=0,c=0,d=e,h=null;t:for(;;){for(var p;d!==n||s!==0&&d.nodeType!==3||(o=i+s),d!==a||r!==0&&d.nodeType!==3||(l=i+r),d.nodeType===3&&(i+=d.nodeValue.length),(p=d.firstChild)!==null;)h=d,d=p;for(;;){if(d===e)break t;if(h===n&&++u===s&&(o=i),h===a&&++c===r&&(l=i),(p=d.nextSibling)!==null)break;d=h,h=d.parentNode}d=p}n=o===-1||l===-1?null:{start:o,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(v_={focusedElem:e,selectionRange:n},F2=!1,dt=t;dt!==null;)if(t=dt,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,dt=e;else for(;dt!==null;){t=dt;try{var f=t.alternate;if(t.flags&1024)switch(t.tag){case 0:case 11:case 15:break;case 1:if(f!==null){var m=f.memoizedProps,g=f.memoizedState,y=t.stateNode,b=y.getSnapshotBeforeUpdate(t.elementType===t.type?m:xo(t.type,m),g);y.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var x=t.stateNode.containerInfo;x.nodeType===1?x.textContent="":x.nodeType===9&&x.documentElement&&x.removeChild(x.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(He(163))}}catch(v){fr(t,t.return,v)}if(e=t.sibling,e!==null){e.return=t.return,dt=e;break}dt=t.return}return f=eW,eW=!1,f}function t1(e,t,n){var r=t.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var s=r=r.next;do{if((s.tag&e)===e){var a=s.destroy;s.destroy=void 0,a!==void 0&&F_(t,n,a)}s=s.next}while(s!==r)}}function DI(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var n=t=t.next;do{if((n.tag&e)===e){var r=n.create;n.destroy=r()}n=n.next}while(n!==t)}}function M_(e){var t=e.ref;if(t!==null){var n=e.stateNode;switch(e.tag){case 5:e=n;break;default:e=n}typeof t=="function"?t(e):t.current=e}}function dH(e){var t=e.alternate;t!==null&&(e.alternate=null,dH(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[pl],delete t[S1],delete t[k_],delete t[Que],delete t[ece])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function hH(e){return e.tag===5||e.tag===3||e.tag===4}function tW(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||hH(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function P_(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.nodeType===8?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(n.nodeType===8?(t=n.parentNode,t.insertBefore(e,n)):(t=n,t.appendChild(e)),n=n._reactRootContainer,n!=null||t.onclick!==null||(t.onclick=L2));else if(r!==4&&(e=e.child,e!==null))for(P_(e,t,n),e=e.sibling;e!==null;)P_(e,t,n),e=e.sibling}function L_(e,t,n){var r=e.tag;if(r===5||r===6)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(r!==4&&(e=e.child,e!==null))for(L_(e,t,n),e=e.sibling;e!==null;)L_(e,t,n),e=e.sibling}var _s=null,wo=!1;function Mu(e,t,n){for(n=n.child;n!==null;)pH(e,t,n),n=n.sibling}function pH(e,t,n){if(bl&&typeof bl.onCommitFiberUnmount=="function")try{bl.onCommitFiberUnmount(CI,n)}catch{}switch(n.tag){case 5:js||Mm(n,t);case 6:var r=_s,s=wo;_s=null,Mu(e,t,n),_s=r,wo=s,_s!==null&&(wo?(e=_s,n=n.stateNode,e.nodeType===8?e.parentNode.removeChild(n):e.removeChild(n)):_s.removeChild(n.stateNode));break;case 18:_s!==null&&(wo?(e=_s,n=n.stateNode,e.nodeType===8?z$(e.parentNode,n):e.nodeType===1&&z$(e,n),b1(e)):z$(_s,n.stateNode));break;case 4:r=_s,s=wo,_s=n.stateNode.containerInfo,wo=!0,Mu(e,t,n),_s=r,wo=s;break;case 0:case 11:case 14:case 15:if(!js&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){s=r=r.next;do{var a=s,i=a.destroy;a=a.tag,i!==void 0&&(a&2||a&4)&&F_(n,t,i),s=s.next}while(s!==r)}Mu(e,t,n);break;case 1:if(!js&&(Mm(n,t),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(o){fr(n,t,o)}Mu(e,t,n);break;case 21:Mu(e,t,n);break;case 22:n.mode&1?(js=(r=js)||n.memoizedState!==null,Mu(e,t,n),js=r):Mu(e,t,n);break;default:Mu(e,t,n)}}function nW(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var n=e.stateNode;n===null&&(n=e.stateNode=new gce),t.forEach(function(r){var s=Nce.bind(null,e,r);n.has(r)||(n.add(r),r.then(s,s))})}}function ho(e,t){var n=t.deletions;if(n!==null)for(var r=0;r<n.length;r++){var s=n[r];try{var a=e,i=t,o=i;e:for(;o!==null;){switch(o.tag){case 5:_s=o.stateNode,wo=!1;break e;case 3:_s=o.stateNode.containerInfo,wo=!0;break e;case 4:_s=o.stateNode.containerInfo,wo=!0;break e}o=o.return}if(_s===null)throw Error(He(160));pH(a,i,s),_s=null,wo=!1;var l=s.alternate;l!==null&&(l.return=null),s.return=null}catch(u){fr(s,t,u)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)fH(t,e),t=t.sibling}function fH(e,t){var n=e.alternate,r=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(ho(t,e),Xo(e),r&4){try{t1(3,e,e.return),DI(3,e)}catch(m){fr(e,e.return,m)}try{t1(5,e,e.return)}catch(m){fr(e,e.return,m)}}break;case 1:ho(t,e),Xo(e),r&512&&n!==null&&Mm(n,n.return);break;case 5:if(ho(t,e),Xo(e),r&512&&n!==null&&Mm(n,n.return),e.flags&32){var s=e.stateNode;try{f1(s,"")}catch(m){fr(e,e.return,m)}}if(r&4&&(s=e.stateNode,s!=null)){var a=e.memoizedProps,i=n!==null?n.memoizedProps:a,o=e.type,l=e.updateQueue;if(e.updateQueue=null,l!==null)try{o==="input"&&a.type==="radio"&&a.name!=null&&F6(s,a),l_(o,i);var u=l_(o,a);for(i=0;i<l.length;i+=2){var c=l[i],d=l[i+1];c==="style"?B6(s,d):c==="dangerouslySetInnerHTML"?L6(s,d):c==="children"?f1(s,d):hD(s,c,d,u)}switch(o){case"input":r_(s,a);break;case"textarea":M6(s,a);break;case"select":var h=s._wrapperState.wasMultiple;s._wrapperState.wasMultiple=!!a.multiple;var p=a.value;p!=null?Wm(s,!!a.multiple,p,!1):h!==!!a.multiple&&(a.defaultValue!=null?Wm(s,!!a.multiple,a.defaultValue,!0):Wm(s,!!a.multiple,a.multiple?[]:"",!1))}s[S1]=a}catch(m){fr(e,e.return,m)}}break;case 6:if(ho(t,e),Xo(e),r&4){if(e.stateNode===null)throw Error(He(162));s=e.stateNode,a=e.memoizedProps;try{s.nodeValue=a}catch(m){fr(e,e.return,m)}}break;case 3:if(ho(t,e),Xo(e),r&4&&n!==null&&n.memoizedState.isDehydrated)try{b1(t.containerInfo)}catch(m){fr(e,e.return,m)}break;case 4:ho(t,e),Xo(e);break;case 13:ho(t,e),Xo(e),s=e.child,s.flags&8192&&(a=s.memoizedState!==null,s.stateNode.isHidden=a,!a||s.alternate!==null&&s.alternate.memoizedState!==null||(GD=Cr())),r&4&&nW(e);break;case 22:if(c=n!==null&&n.memoizedState!==null,e.mode&1?(js=(u=js)||c,ho(t,e),js=u):ho(t,e),Xo(e),r&8192){if(u=e.memoizedState!==null,(e.stateNode.isHidden=u)&&!c&&e.mode&1)for(dt=e,c=e.child;c!==null;){for(d=dt=c;dt!==null;){switch(h=dt,p=h.child,h.tag){case 0:case 11:case 14:case 15:t1(4,h,h.return);break;case 1:Mm(h,h.return);var f=h.stateNode;if(typeof f.componentWillUnmount=="function"){r=h,n=h.return;try{t=r,f.props=t.memoizedProps,f.state=t.memoizedState,f.componentWillUnmount()}catch(m){fr(r,n,m)}}break;case 5:Mm(h,h.return);break;case 22:if(h.memoizedState!==null){sW(d);continue}}p!==null?(p.return=h,dt=p):sW(d)}c=c.sibling}e:for(c=null,d=e;;){if(d.tag===5){if(c===null){c=d;try{s=d.stateNode,u?(a=s.style,typeof a.setProperty=="function"?a.setProperty("display","none","important"):a.display="none"):(o=d.stateNode,l=d.memoizedProps.style,i=l!=null&&l.hasOwnProperty("display")?l.display:null,o.style.display=z6("display",i))}catch(m){fr(e,e.return,m)}}}else if(d.tag===6){if(c===null)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(m){fr(e,e.return,m)}}else if((d.tag!==22&&d.tag!==23||d.memoizedState===null||d===e)&&d.child!==null){d.child.return=d,d=d.child;continue}if(d===e)break e;for(;d.sibling===null;){if(d.return===null||d.return===e)break e;c===d&&(c=null),d=d.return}c===d&&(c=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:ho(t,e),Xo(e),r&4&&nW(e);break;case 21:break;default:ho(t,e),Xo(e)}}function Xo(e){var t=e.flags;if(t&2){try{e:{for(var n=e.return;n!==null;){if(hH(n)){var r=n;break e}n=n.return}throw Error(He(160))}switch(r.tag){case 5:var s=r.stateNode;r.flags&32&&(f1(s,""),r.flags&=-33);var a=tW(e);L_(e,a,s);break;case 3:case 4:var i=r.stateNode.containerInfo,o=tW(e);P_(e,o,i);break;default:throw Error(He(161))}}catch(l){fr(e,e.return,l)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function bce(e,t,n){dt=e,mH(e)}function mH(e,t,n){for(var r=(e.mode&1)!==0;dt!==null;){var s=dt,a=s.child;if(s.tag===22&&r){var i=s.memoizedState!==null||gk;if(!i){var o=s.alternate,l=o!==null&&o.memoizedState!==null||js;o=gk;var u=js;if(gk=i,(js=l)&&!u)for(dt=s;dt!==null;)i=dt,l=i.child,i.tag===22&&i.memoizedState!==null?aW(s):l!==null?(l.return=i,dt=l):aW(s);for(;a!==null;)dt=a,mH(a),a=a.sibling;dt=s,gk=o,js=u}rW(e)}else s.subtreeFlags&8772&&a!==null?(a.return=s,dt=a):rW(e)}}function rW(e){for(;dt!==null;){var t=dt;if(t.flags&8772){var n=t.alternate;try{if(t.flags&8772)switch(t.tag){case 0:case 11:case 15:js||DI(5,t);break;case 1:var r=t.stateNode;if(t.flags&4&&!js)if(n===null)r.componentDidMount();else{var s=t.elementType===t.type?n.memoizedProps:xo(t.type,n.memoizedProps);r.componentDidUpdate(s,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var a=t.updateQueue;a!==null&&BB(t,a,r);break;case 3:var i=t.updateQueue;if(i!==null){if(n=null,t.child!==null)switch(t.child.tag){case 5:n=t.child.stateNode;break;case 1:n=t.child.stateNode}BB(t,i,n)}break;case 5:var o=t.stateNode;if(n===null&&t.flags&4){n=o;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var u=t.alternate;if(u!==null){var c=u.memoizedState;if(c!==null){var d=c.dehydrated;d!==null&&b1(d)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(He(163))}js||t.flags&512&&M_(t)}catch(h){fr(t,t.return,h)}}if(t===e){dt=null;break}if(n=t.sibling,n!==null){n.return=t.return,dt=n;break}dt=t.return}}function sW(e){for(;dt!==null;){var t=dt;if(t===e){dt=null;break}var n=t.sibling;if(n!==null){n.return=t.return,dt=n;break}dt=t.return}}function aW(e){for(;dt!==null;){var t=dt;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{DI(4,t)}catch(l){fr(t,n,l)}break;case 1:var r=t.stateNode;if(typeof r.componentDidMount=="function"){var s=t.return;try{r.componentDidMount()}catch(l){fr(t,s,l)}}var a=t.return;try{M_(t)}catch(l){fr(t,a,l)}break;case 5:var i=t.return;try{M_(t)}catch(l){fr(t,i,l)}}}catch(l){fr(t,t.return,l)}if(t===e){dt=null;break}var o=t.sibling;if(o!==null){o.return=t.return,dt=o;break}dt=t.return}}var vce=Math.ceil,X2=xu.ReactCurrentDispatcher,UD=xu.ReactCurrentOwner,Hi=xu.ReactCurrentBatchConfig,an=0,ks=null,zr=null,As=0,oi=0,Pm=Zc(0),ls=0,E1=null,Ih=0,OI=0,jD=0,n1=null,Pa=null,GD=0,hg=1/0,Hl=null,Y2=!1,z_=null,mc=null,yk=!1,ec=null,J2=0,r1=0,B_=null,c2=-1,d2=0;function ma(){return an&6?Cr():c2!==-1?c2:c2=Cr()}function gc(e){return e.mode&1?an&2&&As!==0?As&-As:nce.transition!==null?(d2===0&&(d2=Z6()),d2):(e=Sn,e!==0||(e=window.event,e=e===void 0?16:aG(e.type)),e):1}function $o(e,t,n,r){if(50<r1)throw r1=0,B_=null,Error(He(185));g0(e,n,r),(!(an&2)||e!==ks)&&(e===ks&&(!(an&2)&&(OI|=n),ls===4&&Ju(e,As)),qa(e,r),n===1&&an===0&&!(t.mode&1)&&(hg=Cr()+500,_I&&Qc()))}function qa(e,t){var n=e.callbackNode;nue(e,t);var r=O2(e,e===ks?As:0);if(r===0)n!==null&&fB(n),e.callbackNode=null,e.callbackPriority=0;else if(t=r&-r,e.callbackPriority!==t){if(n!=null&&fB(n),t===1)e.tag===0?tce(iW.bind(null,e)):IG(iW.bind(null,e)),Jue(function(){!(an&6)&&Qc()}),n=null;else{switch(Q6(r)){case 1:n=yD;break;case 4:n=Y6;break;case 16:n=D2;break;case 536870912:n=J6;break;default:n=D2}n=SH(n,gH.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function gH(e,t){if(c2=-1,d2=0,an&6)throw Error(He(327));var n=e.callbackNode;if(Hm()&&e.callbackNode!==n)return null;var r=O2(e,e===ks?As:0);if(r===0)return null;if(r&30||r&e.expiredLanes||t)t=Z2(e,r);else{t=r;var s=an;an|=2;var a=bH();(ks!==e||As!==t)&&(Hl=null,hg=Cr()+500,oh(e,t));do try{kce();break}catch(o){yH(e,o)}while(1);_D(),X2.current=a,an=s,zr!==null?t=0:(ks=null,As=0,t=ls)}if(t!==0){if(t===2&&(s=p_(e),s!==0&&(r=s,t=W_(e,s))),t===1)throw n=E1,oh(e,0),Ju(e,r),qa(e,Cr()),n;if(t===6)Ju(e,r);else{if(s=e.current.alternate,!(r&30)&&!xce(s)&&(t=Z2(e,r),t===2&&(a=p_(e),a!==0&&(r=a,t=W_(e,a))),t===1))throw n=E1,oh(e,0),Ju(e,r),qa(e,Cr()),n;switch(e.finishedWork=s,e.finishedLanes=r,t){case 0:case 1:throw Error(He(345));case 2:Md(e,Pa,Hl);break;case 3:if(Ju(e,r),(r&130023424)===r&&(t=GD+500-Cr(),10<t)){if(O2(e,0)!==0)break;if(s=e.suspendedLanes,(s&r)!==r){ma(),e.pingedLanes|=e.suspendedLanes&s;break}e.timeoutHandle=w_(Md.bind(null,e,Pa,Hl),t);break}Md(e,Pa,Hl);break;case 4:if(Ju(e,r),(r&4194240)===r)break;for(t=e.eventTimes,s=-1;0<r;){var i=31-To(r);a=1<<i,i=t[i],i>s&&(s=i),r&=~a}if(r=s,r=Cr()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*vce(r/1960))-r,10<r){e.timeoutHandle=w_(Md.bind(null,e,Pa,Hl),r);break}Md(e,Pa,Hl);break;case 5:Md(e,Pa,Hl);break;default:throw Error(He(329))}}}return qa(e,Cr()),e.callbackNode===n?gH.bind(null,e):null}function W_(e,t){var n=n1;return e.current.memoizedState.isDehydrated&&(oh(e,t).flags|=256),e=Z2(e,t),e!==2&&(t=Pa,Pa=n,t!==null&&V_(t)),e}function V_(e){Pa===null?Pa=e:Pa.push.apply(Pa,e)}function xce(e){for(var t=e;;){if(t.flags&16384){var n=t.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var s=n[r],a=s.getSnapshot;s=s.value;try{if(!Mo(a(),s))return!1}catch{return!1}}}if(n=t.child,t.subtreeFlags&16384&&n!==null)n.return=t,t=n;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Ju(e,t){for(t&=~jD,t&=~OI,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-To(t),r=1<<n;e[n]=-1,t&=~r}}function iW(e){if(an&6)throw Error(He(327));Hm();var t=O2(e,0);if(!(t&1))return qa(e,Cr()),null;var n=Z2(e,t);if(e.tag!==0&&n===2){var r=p_(e);r!==0&&(t=r,n=W_(e,r))}if(n===1)throw n=E1,oh(e,0),Ju(e,t),qa(e,Cr()),n;if(n===6)throw Error(He(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,Md(e,Pa,Hl),qa(e,Cr()),null}function HD(e,t){var n=an;an|=1;try{return e(t)}finally{an=n,an===0&&(hg=Cr()+500,_I&&Qc())}}function Ch(e){ec!==null&&ec.tag===0&&!(an&6)&&Hm();var t=an;an|=1;var n=Hi.transition,r=Sn;try{if(Hi.transition=null,Sn=1,e)return e()}finally{Sn=r,Hi.transition=n,an=t,!(an&6)&&Qc()}}function qD(){oi=Pm.current,Kn(Pm)}function oh(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(n!==-1&&(e.timeoutHandle=-1,Yue(n)),zr!==null)for(n=zr.return;n!==null;){var r=n;switch(TD(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&z2();break;case 3:cg(),Kn(Ga),Kn(Zs),MD();break;case 5:FD(r);break;case 4:cg();break;case 13:Kn(ur);break;case 19:Kn(ur);break;case 10:AD(r.type._context);break;case 22:case 23:qD()}n=n.return}if(ks=e,zr=e=yc(e.current,null),As=oi=t,ls=0,E1=null,jD=OI=Ih=0,Pa=n1=null,Qd!==null){for(t=0;t<Qd.length;t++)if(n=Qd[t],r=n.interleaved,r!==null){n.interleaved=null;var s=r.next,a=n.pending;if(a!==null){var i=a.next;a.next=s,r.next=i}n.pending=r}Qd=null}return e}function yH(e,t){do{var n=zr;try{if(_D(),o2.current=K2,q2){for(var r=cr.memoizedState;r!==null;){var s=r.queue;s!==null&&(s.pending=null),r=r.next}q2=!1}if(Sh=0,gs=ns=cr=null,e1=!1,N1=0,UD.current=null,n===null||n.return===null){ls=1,E1=t,zr=null;break}e:{var a=e,i=n.return,o=n,l=t;if(t=As,o.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var u=l,c=o,d=c.tag;if(!(c.mode&1)&&(d===0||d===11||d===15)){var h=c.alternate;h?(c.updateQueue=h.updateQueue,c.memoizedState=h.memoizedState,c.lanes=h.lanes):(c.updateQueue=null,c.memoizedState=null)}var p=qB(i);if(p!==null){p.flags&=-257,KB(p,i,o,a,t),p.mode&1&&HB(a,u,t),t=p,l=u;var f=t.updateQueue;if(f===null){var m=new Set;m.add(l),t.updateQueue=m}else f.add(l);break e}else{if(!(t&1)){HB(a,u,t),KD();break e}l=Error(He(426))}}else if(tr&&o.mode&1){var g=qB(i);if(g!==null){!(g.flags&65536)&&(g.flags|=256),KB(g,i,o,a,t),$D(dg(l,o));break e}}a=l=dg(l,o),ls!==4&&(ls=2),n1===null?n1=[a]:n1.push(a),a=i;do{switch(a.tag){case 3:a.flags|=65536,t&=-t,a.lanes|=t;var y=eH(a,l,t);zB(a,y);break e;case 1:o=l;var b=a.type,x=a.stateNode;if(!(a.flags&128)&&(typeof b.getDerivedStateFromError=="function"||x!==null&&typeof x.componentDidCatch=="function"&&(mc===null||!mc.has(x)))){a.flags|=65536,t&=-t,a.lanes|=t;var v=tH(a,o,t);zB(a,v);break e}}a=a.return}while(a!==null)}xH(n)}catch(w){t=w,zr===n&&n!==null&&(zr=n=n.return);continue}break}while(1)}function bH(){var e=X2.current;return X2.current=K2,e===null?K2:e}function KD(){(ls===0||ls===3||ls===2)&&(ls=4),ks===null||!(Ih&268435455)&&!(OI&268435455)||Ju(ks,As)}function Z2(e,t){var n=an;an|=2;var r=bH();(ks!==e||As!==t)&&(Hl=null,oh(e,t));do try{wce();break}catch(s){yH(e,s)}while(1);if(_D(),an=n,X2.current=r,zr!==null)throw Error(He(261));return ks=null,As=0,ls}function wce(){for(;zr!==null;)vH(zr)}function kce(){for(;zr!==null&&!qle();)vH(zr)}function vH(e){var t=kH(e.alternate,e,oi);e.memoizedProps=e.pendingProps,t===null?xH(e):zr=t,UD.current=null}function xH(e){var t=e;do{var n=t.alternate;if(e=t.return,t.flags&32768){if(n=mce(n,t),n!==null){n.flags&=32767,zr=n;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{ls=6,zr=null;return}}else if(n=fce(n,t,oi),n!==null){zr=n;return}if(t=t.sibling,t!==null){zr=t;return}zr=t=e}while(t!==null);ls===0&&(ls=5)}function Md(e,t,n){var r=Sn,s=Hi.transition;try{Hi.transition=null,Sn=1,Sce(e,t,n,r)}finally{Hi.transition=s,Sn=r}return null}function Sce(e,t,n,r){do Hm();while(ec!==null);if(an&6)throw Error(He(327));n=e.finishedWork;var s=e.finishedLanes;if(n===null)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(He(177));e.callbackNode=null,e.callbackPriority=0;var a=n.lanes|n.childLanes;if(rue(e,a),e===ks&&(zr=ks=null,As=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||yk||(yk=!0,SH(D2,function(){return Hm(),null})),a=(n.flags&15990)!==0,n.subtreeFlags&15990||a){a=Hi.transition,Hi.transition=null;var i=Sn;Sn=1;var o=an;an|=4,UD.current=null,yce(e,n),fH(n,e),Uue(v_),F2=!!b_,v_=b_=null,e.current=n,bce(n),Kle(),an=o,Sn=i,Hi.transition=a}else e.current=n;if(yk&&(yk=!1,ec=e,J2=s),a=e.pendingLanes,a===0&&(mc=null),Jle(n.stateNode),qa(e,Cr()),t!==null)for(r=e.onRecoverableError,n=0;n<t.length;n++)s=t[n],r(s.value,{componentStack:s.stack,digest:s.digest});if(Y2)throw Y2=!1,e=z_,z_=null,e;return J2&1&&e.tag!==0&&Hm(),a=e.pendingLanes,a&1?e===B_?r1++:(r1=0,B_=e):r1=0,Qc(),null}function Hm(){if(ec!==null){var e=Q6(J2),t=Hi.transition,n=Sn;try{if(Hi.transition=null,Sn=16>e?16:e,ec===null)var r=!1;else{if(e=ec,ec=null,J2=0,an&6)throw Error(He(331));var s=an;for(an|=4,dt=e.current;dt!==null;){var a=dt,i=a.child;if(dt.flags&16){var o=a.deletions;if(o!==null){for(var l=0;l<o.length;l++){var u=o[l];for(dt=u;dt!==null;){var c=dt;switch(c.tag){case 0:case 11:case 15:t1(8,c,a)}var d=c.child;if(d!==null)d.return=c,dt=d;else for(;dt!==null;){c=dt;var h=c.sibling,p=c.return;if(dH(c),c===u){dt=null;break}if(h!==null){h.return=p,dt=h;break}dt=p}}}var f=a.alternate;if(f!==null){var m=f.child;if(m!==null){f.child=null;do{var g=m.sibling;m.sibling=null,m=g}while(m!==null)}}dt=a}}if(a.subtreeFlags&2064&&i!==null)i.return=a,dt=i;else e:for(;dt!==null;){if(a=dt,a.flags&2048)switch(a.tag){case 0:case 11:case 15:t1(9,a,a.return)}var y=a.sibling;if(y!==null){y.return=a.return,dt=y;break e}dt=a.return}}var b=e.current;for(dt=b;dt!==null;){i=dt;var x=i.child;if(i.subtreeFlags&2064&&x!==null)x.return=i,dt=x;else e:for(i=b;dt!==null;){if(o=dt,o.flags&2048)try{switch(o.tag){case 0:case 11:case 15:DI(9,o)}}catch(w){fr(o,o.return,w)}if(o===i){dt=null;break e}var v=o.sibling;if(v!==null){v.return=o.return,dt=v;break e}dt=o.return}}if(an=s,Qc(),bl&&typeof bl.onPostCommitFiberRoot=="function")try{bl.onPostCommitFiberRoot(CI,e)}catch{}r=!0}return r}finally{Sn=n,Hi.transition=t}}return!1}function oW(e,t,n){t=dg(n,t),t=eH(e,t,1),e=fc(e,t,1),t=ma(),e!==null&&(g0(e,1,t),qa(e,t))}function fr(e,t,n){if(e.tag===3)oW(e,e,n);else for(;t!==null;){if(t.tag===3){oW(t,e,n);break}else if(t.tag===1){var r=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(mc===null||!mc.has(r))){e=dg(n,e),e=tH(t,e,1),t=fc(t,e,1),e=ma(),t!==null&&(g0(t,1,e),qa(t,e));break}}t=t.return}}function Ice(e,t,n){var r=e.pingCache;r!==null&&r.delete(t),t=ma(),e.pingedLanes|=e.suspendedLanes&n,ks===e&&(As&n)===n&&(ls===4||ls===3&&(As&130023424)===As&&500>Cr()-GD?oh(e,0):jD|=n),qa(e,t)}function wH(e,t){t===0&&(e.mode&1?(t=ok,ok<<=1,!(ok&130023424)&&(ok=4194304)):t=1);var n=ma();e=cu(e,t),e!==null&&(g0(e,t,n),qa(e,n))}function Cce(e){var t=e.memoizedState,n=0;t!==null&&(n=t.retryLane),wH(e,n)}function Nce(e,t){var n=0;switch(e.tag){case 13:var r=e.stateNode,s=e.memoizedState;s!==null&&(n=s.retryLane);break;case 19:r=e.stateNode;break;default:throw Error(He(314))}r!==null&&r.delete(t),wH(e,n)}var kH;kH=function(e,t,n){if(e!==null)if(e.memoizedProps!==t.pendingProps||Ga.current)Ba=!0;else{if(!(e.lanes&n)&&!(t.flags&128))return Ba=!1,pce(e,t,n);Ba=!!(e.flags&131072)}else Ba=!1,tr&&t.flags&1048576&&CG(t,V2,t.index);switch(t.lanes=0,t.tag){case 2:var r=t.type;u2(e,t),e=t.pendingProps;var s=og(t,Zs.current);Gm(t,n),s=LD(null,t,r,e,s,n);var a=zD();return t.flags|=1,typeof s=="object"&&s!==null&&typeof s.render=="function"&&s.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ha(r)?(a=!0,B2(t)):a=!1,t.memoizedState=s.state!==null&&s.state!==void 0?s.state:null,DD(t),s.updater=AI,t.stateNode=s,s._reactInternals=t,$_(t,r,e,n),t=A_(null,t,r,!0,a,n)):(t.tag=0,tr&&a&&ND(t),ua(null,t,s,n),t=t.child),t;case 16:r=t.elementType;e:{switch(u2(e,t),e=t.pendingProps,s=r._init,r=s(r._payload),t.type=r,s=t.tag=$ce(r),e=xo(r,e),s){case 0:t=__(null,t,r,e,n);break e;case 1:t=JB(null,t,r,e,n);break e;case 11:t=XB(null,t,r,e,n);break e;case 14:t=YB(null,t,r,xo(r.type,e),n);break e}throw Error(He(306,r,""))}return t;case 0:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:xo(r,s),__(e,t,r,s,n);case 1:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:xo(r,s),JB(e,t,r,s,n);case 3:e:{if(aH(t),e===null)throw Error(He(387));r=t.pendingProps,a=t.memoizedState,s=a.element,EG(e,t),G2(t,r,null,n);var i=t.memoizedState;if(r=i.element,a.isDehydrated)if(a={element:r,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=a,t.memoizedState=a,t.flags&256){s=dg(Error(He(423)),t),t=ZB(e,t,r,n,s);break e}else if(r!==s){s=dg(Error(He(424)),t),t=ZB(e,t,r,n,s);break e}else for(ui=pc(t.stateNode.containerInfo.firstChild),mi=t,tr=!0,ko=null,n=DG(t,null,r,n),t.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(lg(),r===s){t=du(e,t,n);break e}ua(e,t,r,n)}t=t.child}return t;case 5:return OG(t),e===null&&C_(t),r=t.type,s=t.pendingProps,a=e!==null?e.memoizedProps:null,i=s.children,x_(r,s)?i=null:a!==null&&x_(r,a)&&(t.flags|=32),sH(e,t),ua(e,t,i,n),t.child;case 6:return e===null&&C_(t),null;case 13:return iH(e,t,n);case 4:return OD(t,t.stateNode.containerInfo),r=t.pendingProps,e===null?t.child=ug(t,null,r,n):ua(e,t,r,n),t.child;case 11:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:xo(r,s),XB(e,t,r,s,n);case 7:return ua(e,t,t.pendingProps,n),t.child;case 8:return ua(e,t,t.pendingProps.children,n),t.child;case 12:return ua(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(r=t.type._context,s=t.pendingProps,a=t.memoizedProps,i=s.value,zn(U2,r._currentValue),r._currentValue=i,a!==null)if(Mo(a.value,i)){if(a.children===s.children&&!Ga.current){t=du(e,t,n);break e}}else for(a=t.child,a!==null&&(a.return=t);a!==null;){var o=a.dependencies;if(o!==null){i=a.child;for(var l=o.firstContext;l!==null;){if(l.context===r){if(a.tag===1){l=su(-1,n&-n),l.tag=2;var u=a.updateQueue;if(u!==null){u=u.shared;var c=u.pending;c===null?l.next=l:(l.next=c.next,c.next=l),u.pending=l}}a.lanes|=n,l=a.alternate,l!==null&&(l.lanes|=n),N_(a.return,n,t),o.lanes|=n;break}l=l.next}}else if(a.tag===10)i=a.type===t.type?null:a.child;else if(a.tag===18){if(i=a.return,i===null)throw Error(He(341));i.lanes|=n,o=i.alternate,o!==null&&(o.lanes|=n),N_(i,n,t),i=a.sibling}else i=a.child;if(i!==null)i.return=a;else for(i=a;i!==null;){if(i===t){i=null;break}if(a=i.sibling,a!==null){a.return=i.return,i=a;break}i=i.return}a=i}ua(e,t,s.children,n),t=t.child}return t;case 9:return s=t.type,r=t.pendingProps.children,Gm(t,n),s=Ki(s),r=r(s),t.flags|=1,ua(e,t,r,n),t.child;case 14:return r=t.type,s=xo(r,t.pendingProps),s=xo(r.type,s),YB(e,t,r,s,n);case 15:return nH(e,t,t.type,t.pendingProps,n);case 17:return r=t.type,s=t.pendingProps,s=t.elementType===r?s:xo(r,s),u2(e,t),t.tag=1,Ha(r)?(e=!0,B2(t)):e=!1,Gm(t,n),AG(t,r,s),$_(t,r,s,n),A_(null,t,r,!0,e,n);case 19:return oH(e,t,n);case 22:return rH(e,t,n)}throw Error(He(156,t.tag))};function SH(e,t){return X6(e,t)}function Tce(e,t,n,r){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Bi(e,t,n,r){return new Tce(e,t,n,r)}function XD(e){return e=e.prototype,!(!e||!e.isReactComponent)}function $ce(e){if(typeof e=="function")return XD(e)?1:0;if(e!=null){if(e=e.$$typeof,e===fD)return 11;if(e===mD)return 14}return 2}function yc(e,t){var n=e.alternate;return n===null?(n=Bi(e.tag,t,e.key,e.mode),n.elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=e.flags&14680064,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function h2(e,t,n,r,s,a){var i=2;if(r=e,typeof e=="function")XD(e)&&(i=1);else if(typeof e=="string")i=5;else e:switch(e){case Tm:return lh(n.children,s,a,t);case pD:i=8,s|=8;break;case ZE:return e=Bi(12,n,t,s|2),e.elementType=ZE,e.lanes=a,e;case QE:return e=Bi(13,n,t,s),e.elementType=QE,e.lanes=a,e;case e_:return e=Bi(19,n,t,s),e.elementType=e_,e.lanes=a,e;case R6:return FI(n,s,a,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case _6:i=10;break e;case A6:i=9;break e;case fD:i=11;break e;case mD:i=14;break e;case Gu:i=16,r=null;break e}throw Error(He(130,e==null?e:typeof e,""))}return t=Bi(i,n,t,s),t.elementType=e,t.type=r,t.lanes=a,t}function lh(e,t,n,r){return e=Bi(7,e,r,t),e.lanes=n,e}function FI(e,t,n,r){return e=Bi(22,e,r,t),e.elementType=R6,e.lanes=n,e.stateNode={isHidden:!1},e}function q$(e,t,n){return e=Bi(6,e,null,t),e.lanes=n,e}function K$(e,t,n){return t=Bi(4,e.children!==null?e.children:[],e.key,t),t.lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Ece(e,t,n,r,s){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=$$(0),this.expirationTimes=$$(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=$$(0),this.identifierPrefix=r,this.onRecoverableError=s,this.mutableSourceEagerHydrationData=null}function YD(e,t,n,r,s,a,i,o,l){return e=new Ece(e,t,n,o,l),t===1?(t=1,a===!0&&(t|=8)):t=0,a=Bi(3,null,null,t),e.current=a,a.stateNode=e,a.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},DD(a),e}function _ce(e,t,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:Nm,key:r==null?null:""+r,children:e,containerInfo:t,implementation:n}}function IH(e){if(!e)return $c;e=e._reactInternals;e:{if(dp(e)!==e||e.tag!==1)throw Error(He(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ha(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(He(171))}if(e.tag===1){var n=e.type;if(Ha(n))return SG(e,n,t)}return t}function CH(e,t,n,r,s,a,i,o,l){return e=YD(n,r,!0,e,s,a,i,o,l),e.context=IH(null),n=e.current,r=ma(),s=gc(n),a=su(r,s),a.callback=t??null,fc(n,a,s),e.current.lanes=s,g0(e,s,r),qa(e,r),e}function MI(e,t,n,r){var s=t.current,a=ma(),i=gc(s);return n=IH(n),t.context===null?t.context=n:t.pendingContext=n,t=su(a,i),t.payload={element:e},r=r===void 0?null:r,r!==null&&(t.callback=r),e=fc(s,t,i),e!==null&&($o(e,s,i,a),i2(e,s,i)),i}function Q2(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function lW(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var n=e.retryLane;e.retryLane=n!==0&&n<t?n:t}}function JD(e,t){lW(e,t),(e=e.alternate)&&lW(e,t)}function Ace(){return null}var NH=typeof reportError=="function"?reportError:function(e){console.error(e)};function ZD(e){this._internalRoot=e}PI.prototype.render=ZD.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(He(409));MI(e,t,null,null)};PI.prototype.unmount=ZD.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;Ch(function(){MI(null,e,null,null)}),t[uu]=null}};function PI(e){this._internalRoot=e}PI.prototype.unstable_scheduleHydration=function(e){if(e){var t=nG();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Yu.length&&t!==0&&t<Yu[n].priority;n++);Yu.splice(n,0,e),n===0&&sG(e)}};function QD(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function LI(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function uW(){}function Rce(e,t,n,r,s){if(s){if(typeof r=="function"){var a=r;r=function(){var u=Q2(i);a.call(u)}}var i=CH(t,r,e,0,null,!1,!1,"",uW);return e._reactRootContainer=i,e[uu]=i.current,w1(e.nodeType===8?e.parentNode:e),Ch(),i}for(;s=e.lastChild;)e.removeChild(s);if(typeof r=="function"){var o=r;r=function(){var u=Q2(l);o.call(u)}}var l=YD(e,0,!1,null,null,!1,!1,"",uW);return e._reactRootContainer=l,e[uu]=l.current,w1(e.nodeType===8?e.parentNode:e),Ch(function(){MI(t,l,n,r)}),l}function zI(e,t,n,r,s){var a=n._reactRootContainer;if(a){var i=a;if(typeof s=="function"){var o=s;s=function(){var l=Q2(i);o.call(l)}}MI(t,i,e,s)}else i=Rce(n,t,e,s,r);return Q2(i)}eG=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=Ev(t.pendingLanes);n!==0&&(bD(t,n|1),qa(t,Cr()),!(an&6)&&(hg=Cr()+500,Qc()))}break;case 13:Ch(function(){var r=cu(e,1);if(r!==null){var s=ma();$o(r,e,1,s)}}),JD(e,1)}};vD=function(e){if(e.tag===13){var t=cu(e,134217728);if(t!==null){var n=ma();$o(t,e,134217728,n)}JD(e,134217728)}};tG=function(e){if(e.tag===13){var t=gc(e),n=cu(e,t);if(n!==null){var r=ma();$o(n,e,t,r)}JD(e,t)}};nG=function(){return Sn};rG=function(e,t){var n=Sn;try{return Sn=e,t()}finally{Sn=n}};c_=function(e,t,n){switch(t){case"input":if(r_(e,n),t=n.name,n.type==="radio"&&t!=null){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var r=n[t];if(r!==e&&r.form===e.form){var s=EI(r);if(!s)throw Error(He(90));O6(r),r_(r,s)}}}break;case"textarea":M6(e,n);break;case"select":t=n.value,t!=null&&Wm(e,!!n.multiple,t,!1)}};U6=HD;j6=Ch;var Dce={usingClientEntryPoint:!1,Events:[b0,Am,EI,W6,V6,HD]},pv={findFiberByHostInstance:Zd,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},Oce={bundleType:pv.bundleType,version:pv.version,rendererPackageName:pv.rendererPackageName,rendererConfig:pv.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:xu.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=q6(e),e===null?null:e.stateNode},findFiberByHostInstance:pv.findFiberByHostInstance||Ace,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var bk=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!bk.isDisabled&&bk.supportsFiber)try{CI=bk.inject(Oce),bl=bk}catch{}}Ci.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Dce;Ci.createPortal=function(e,t){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!QD(t))throw Error(He(200));return _ce(e,t,null,n)};Ci.createRoot=function(e,t){if(!QD(e))throw Error(He(299));var n=!1,r="",s=NH;return t!=null&&(t.unstable_strictMode===!0&&(n=!0),t.identifierPrefix!==void 0&&(r=t.identifierPrefix),t.onRecoverableError!==void 0&&(s=t.onRecoverableError)),t=YD(e,1,!1,null,null,n,!1,r,s),e[uu]=t.current,w1(e.nodeType===8?e.parentNode:e),new ZD(t)};Ci.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(He(188)):(e=Object.keys(e).join(","),Error(He(268,e)));return e=q6(t),e=e===null?null:e.stateNode,e};Ci.flushSync=function(e){return Ch(e)};Ci.hydrate=function(e,t,n){if(!LI(t))throw Error(He(200));return zI(null,e,t,!0,n)};Ci.hydrateRoot=function(e,t,n){if(!QD(e))throw Error(He(405));var r=n!=null&&n.hydratedSources||null,s=!1,a="",i=NH;if(n!=null&&(n.unstable_strictMode===!0&&(s=!0),n.identifierPrefix!==void 0&&(a=n.identifierPrefix),n.onRecoverableError!==void 0&&(i=n.onRecoverableError)),t=CH(t,null,e,1,n??null,s,!1,a,i),e[uu]=t.current,w1(e),r)for(e=0;e<r.length;e++)n=r[e],s=n._getVersion,s=s(n._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[n,s]:t.mutableSourceEagerHydrationData.push(n,s);return new PI(t)};Ci.render=function(e,t,n){if(!LI(t))throw Error(He(200));return zI(null,e,t,!1,n)};Ci.unmountComponentAtNode=function(e){if(!LI(e))throw Error(He(40));return e._reactRootContainer?(Ch(function(){zI(null,null,e,!1,function(){e._reactRootContainer=null,e[uu]=null})}),!0):!1};Ci.unstable_batchedUpdates=HD;Ci.unstable_renderSubtreeIntoContainer=function(e,t,n,r){if(!LI(n))throw Error(He(200));if(e==null||e._reactInternals===void 0)throw Error(He(38));return zI(e,t,n,!1,r)};Ci.version="18.2.0-next-9e3b772b8-20220608";function TH(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(TH)}catch(e){console.error(e)}}TH(),C6.exports=Ci;var eO=C6.exports;const vk=ey(eO);var cW=eO;YE.createRoot=cW.createRoot,YE.hydrateRoot=cW.hydrateRoot;/**
 * @remix-run/router v1.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function _1(){return _1=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},_1.apply(this,arguments)}var tc;(function(e){e.Pop="POP",e.Push="PUSH",e.Replace="REPLACE"})(tc||(tc={}));const dW="popstate";function Fce(e){e===void 0&&(e={});function t(r,s){let{pathname:a,search:i,hash:o}=r.location;return U_("",{pathname:a,search:i,hash:o},s.state&&s.state.usr||null,s.state&&s.state.key||"default")}function n(r,s){return typeof s=="string"?s:eS(s)}return Pce(t,n,null,e)}function $r(e,t){if(e===!1||e===null||typeof e>"u")throw new Error(t)}function tO(e,t){if(!e){typeof console<"u"&&console.warn(t);try{throw new Error(t)}catch{}}}function Mce(){return Math.random().toString(36).substr(2,8)}function hW(e,t){return{usr:e.state,key:e.key,idx:t}}function U_(e,t,n,r){return n===void 0&&(n=null),_1({pathname:typeof e=="string"?e:e.pathname,search:"",hash:""},typeof t=="string"?sy(t):t,{state:n,key:t&&t.key||r||Mce()})}function eS(e){let{pathname:t="/",search:n="",hash:r=""}=e;return n&&n!=="?"&&(t+=n.charAt(0)==="?"?n:"?"+n),r&&r!=="#"&&(t+=r.charAt(0)==="#"?r:"#"+r),t}function sy(e){let t={};if(e){let n=e.indexOf("#");n>=0&&(t.hash=e.substr(n),e=e.substr(0,n));let r=e.indexOf("?");r>=0&&(t.search=e.substr(r),e=e.substr(0,r)),e&&(t.pathname=e)}return t}function Pce(e,t,n,r){r===void 0&&(r={});let{window:s=document.defaultView,v5Compat:a=!1}=r,i=s.history,o=tc.Pop,l=null,u=c();u==null&&(u=0,i.replaceState(_1({},i.state,{idx:u}),""));function c(){return(i.state||{idx:null}).idx}function d(){o=tc.Pop;let g=c(),y=g==null?null:g-u;u=g,l&&l({action:o,location:m.location,delta:y})}function h(g,y){o=tc.Push;let b=U_(m.location,g,y);n&&n(b,g),u=c()+1;let x=hW(b,u),v=m.createHref(b);try{i.pushState(x,"",v)}catch(w){if(w instanceof DOMException&&w.name==="DataCloneError")throw w;s.location.assign(v)}a&&l&&l({action:o,location:m.location,delta:1})}function p(g,y){o=tc.Replace;let b=U_(m.location,g,y);n&&n(b,g),u=c();let x=hW(b,u),v=m.createHref(b);i.replaceState(x,"",v),a&&l&&l({action:o,location:m.location,delta:0})}function f(g){let y=s.location.origin!=="null"?s.location.origin:s.location.href,b=typeof g=="string"?g:eS(g);return $r(y,"No window.location.(origin|href) available to create URL for href: "+b),new URL(b,y)}let m={get action(){return o},get location(){return e(s,i)},listen(g){if(l)throw new Error("A history only accepts one active listener");return s.addEventListener(dW,d),l=g,()=>{s.removeEventListener(dW,d),l=null}},createHref(g){return t(s,g)},createURL:f,encodeLocation(g){let y=f(g);return{pathname:y.pathname,search:y.search,hash:y.hash}},push:h,replace:p,go(g){return i.go(g)}};return m}var pW;(function(e){e.data="data",e.deferred="deferred",e.redirect="redirect",e.error="error"})(pW||(pW={}));function Lce(e,t,n){n===void 0&&(n="/");let r=typeof t=="string"?sy(t):t,s=nO(r.pathname||"/",n);if(s==null)return null;let a=$H(e);zce(a);let i=null;for(let o=0;i==null&&o<a.length;++o)i=Kce(a[o],Jce(s));return i}function $H(e,t,n,r){t===void 0&&(t=[]),n===void 0&&(n=[]),r===void 0&&(r="");let s=(a,i,o)=>{let l={relativePath:o===void 0?a.path||"":o,caseSensitive:a.caseSensitive===!0,childrenIndex:i,route:a};l.relativePath.startsWith("/")&&($r(l.relativePath.startsWith(r),'Absolute route path "'+l.relativePath+'" nested under path '+('"'+r+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),l.relativePath=l.relativePath.slice(r.length));let u=bc([r,l.relativePath]),c=n.concat(l);a.children&&a.children.length>0&&($r(a.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+u+'".')),$H(a.children,t,c,u)),!(a.path==null&&!a.index)&&t.push({path:u,score:Hce(u,a.index),routesMeta:c})};return e.forEach((a,i)=>{var o;if(a.path===""||!((o=a.path)!=null&&o.includes("?")))s(a,i);else for(let l of EH(a.path))s(a,i,l)}),t}function EH(e){let t=e.split("/");if(t.length===0)return[];let[n,...r]=t,s=n.endsWith("?"),a=n.replace(/\?$/,"");if(r.length===0)return s?[a,""]:[a];let i=EH(r.join("/")),o=[];return o.push(...i.map(l=>l===""?a:[a,l].join("/"))),s&&o.push(...i),o.map(l=>e.startsWith("/")&&l===""?"/":l)}function zce(e){e.sort((t,n)=>t.score!==n.score?n.score-t.score:qce(t.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const Bce=/^:[\w-]+$/,Wce=3,Vce=2,Uce=1,jce=10,Gce=-2,fW=e=>e==="*";function Hce(e,t){let n=e.split("/"),r=n.length;return n.some(fW)&&(r+=Gce),t&&(r+=Vce),n.filter(s=>!fW(s)).reduce((s,a)=>s+(Bce.test(a)?Wce:a===""?Uce:jce),r)}function qce(e,t){return e.length===t.length&&e.slice(0,-1).every((r,s)=>r===t[s])?e[e.length-1]-t[t.length-1]:0}function Kce(e,t){let{routesMeta:n}=e,r={},s="/",a=[];for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1,u=s==="/"?t:t.slice(s.length)||"/",c=Xce({path:o.relativePath,caseSensitive:o.caseSensitive,end:l},u);if(!c)return null;Object.assign(r,c.params);let d=o.route;a.push({params:r,pathname:bc([s,c.pathname]),pathnameBase:nde(bc([s,c.pathnameBase])),route:d}),c.pathnameBase!=="/"&&(s=bc([s,c.pathnameBase]))}return a}function Xce(e,t){typeof e=="string"&&(e={path:e,caseSensitive:!1,end:!0});let[n,r]=Yce(e.path,e.caseSensitive,e.end),s=t.match(n);if(!s)return null;let a=s[0],i=a.replace(/(.)\/+$/,"$1"),o=s.slice(1);return{params:r.reduce((u,c,d)=>{let{paramName:h,isOptional:p}=c;if(h==="*"){let m=o[d]||"";i=a.slice(0,a.length-m.length).replace(/(.)\/+$/,"$1")}const f=o[d];return p&&!f?u[h]=void 0:u[h]=Zce(f||"",h),u},{}),pathname:a,pathnameBase:i,pattern:e}}function Yce(e,t,n){t===void 0&&(t=!1),n===void 0&&(n=!0),tO(e==="*"||!e.endsWith("*")||e.endsWith("/*"),'Route path "'+e+'" will be treated as if it were '+('"'+e.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+e.replace(/\*$/,"/*")+'".'));let r=[],s="^"+e.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(i,o,l)=>(r.push({paramName:o,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return e.endsWith("*")?(r.push({paramName:"*"}),s+=e==="*"||e==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?s+="\\/*$":e!==""&&e!=="/"&&(s+="(?:(?=\\/|$))"),[new RegExp(s,t?void 0:"i"),r]}function Jce(e){try{return decodeURI(e)}catch(t){return tO(!1,'The URL path "'+e+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+t+").")),e}}function Zce(e,t){try{return decodeURIComponent(e)}catch(n){return tO(!1,'The value for the URL param "'+t+'" will not be decoded because'+(' the string "'+e+'" is a malformed URL segment. This is probably')+(" due to a bad percent encoding ("+n+").")),e}}function nO(e,t){if(t==="/")return e;if(!e.toLowerCase().startsWith(t.toLowerCase()))return null;let n=t.endsWith("/")?t.length-1:t.length,r=e.charAt(n);return r&&r!=="/"?null:e.slice(n)||"/"}function Qce(e,t){t===void 0&&(t="/");let{pathname:n,search:r="",hash:s=""}=typeof e=="string"?sy(e):e;return{pathname:n?n.startsWith("/")?n:ede(n,t):t,search:rde(r),hash:sde(s)}}function ede(e,t){let n=t.replace(/\/+$/,"").split("/");return e.split("/").forEach(s=>{s===".."?n.length>1&&n.pop():s!=="."&&n.push(s)}),n.length>1?n.join("/"):"/"}function X$(e,t,n,r){return"Cannot include a '"+e+"' character in a manually specified "+("`to."+t+"` field ["+JSON.stringify(r)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function tde(e){return e.filter((t,n)=>n===0||t.route.path&&t.route.path.length>0)}function rO(e,t){let n=tde(e);return t?n.map((r,s)=>s===e.length-1?r.pathname:r.pathnameBase):n.map(r=>r.pathnameBase)}function sO(e,t,n,r){r===void 0&&(r=!1);let s;typeof e=="string"?s=sy(e):(s=_1({},e),$r(!s.pathname||!s.pathname.includes("?"),X$("?","pathname","search",s)),$r(!s.pathname||!s.pathname.includes("#"),X$("#","pathname","hash",s)),$r(!s.search||!s.search.includes("#"),X$("#","search","hash",s)));let a=e===""||s.pathname==="",i=a?"/":s.pathname,o;if(i==null)o=n;else{let d=t.length-1;if(!r&&i.startsWith("..")){let h=i.split("/");for(;h[0]==="..";)h.shift(),d-=1;s.pathname=h.join("/")}o=d>=0?t[d]:"/"}let l=Qce(s,o),u=i&&i!=="/"&&i.endsWith("/"),c=(a||i===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(u||c)&&(l.pathname+="/"),l}const bc=e=>e.join("/").replace(/\/\/+/g,"/"),nde=e=>e.replace(/\/+$/,"").replace(/^\/*/,"/"),rde=e=>!e||e==="?"?"":e.startsWith("?")?e:"?"+e,sde=e=>!e||e==="#"?"":e.startsWith("#")?e:"#"+e;function ade(e){return e!=null&&typeof e.status=="number"&&typeof e.statusText=="string"&&typeof e.internal=="boolean"&&"data"in e}const _H=["post","put","patch","delete"];new Set(_H);const ide=["get",..._H];new Set(ide);/**
 * React Router v6.22.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function A1(){return A1=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},A1.apply(this,arguments)}const aO=Z.createContext(null),ode=Z.createContext(null),ed=Z.createContext(null),BI=Z.createContext(null),td=Z.createContext({outlet:null,matches:[],isDataRoute:!1}),AH=Z.createContext(null);function lde(e,t){let{relative:n}=t===void 0?{}:t;ay()||$r(!1);let{basename:r,navigator:s}=Z.useContext(ed),{hash:a,pathname:i,search:o}=DH(e,{relative:n}),l=i;return r!=="/"&&(l=i==="/"?r:bc([r,i])),s.createHref({pathname:l,search:o,hash:a})}function ay(){return Z.useContext(BI)!=null}function hp(){return ay()||$r(!1),Z.useContext(BI).location}function RH(e){Z.useContext(ed).static||Z.useLayoutEffect(e)}function WI(){let{isDataRoute:e}=Z.useContext(td);return e?wde():ude()}function ude(){ay()||$r(!1);let e=Z.useContext(aO),{basename:t,future:n,navigator:r}=Z.useContext(ed),{matches:s}=Z.useContext(td),{pathname:a}=hp(),i=JSON.stringify(rO(s,n.v7_relativeSplatPath)),o=Z.useRef(!1);return RH(()=>{o.current=!0}),Z.useCallback(function(u,c){if(c===void 0&&(c={}),!o.current)return;if(typeof u=="number"){r.go(u);return}let d=sO(u,JSON.parse(i),a,c.relative==="path");e==null&&t!=="/"&&(d.pathname=d.pathname==="/"?t:bc([t,d.pathname])),(c.replace?r.replace:r.push)(d,c.state,c)},[t,r,i,a,e])}function DH(e,t){let{relative:n}=t===void 0?{}:t,{future:r}=Z.useContext(ed),{matches:s}=Z.useContext(td),{pathname:a}=hp(),i=JSON.stringify(rO(s,r.v7_relativeSplatPath));return Z.useMemo(()=>sO(e,JSON.parse(i),a,n==="path"),[e,i,a,n])}function cde(e,t){return dde(e,t)}function dde(e,t,n,r){ay()||$r(!1);let{navigator:s}=Z.useContext(ed),{matches:a}=Z.useContext(td),i=a[a.length-1],o=i?i.params:{};i&&i.pathname;let l=i?i.pathnameBase:"/";i&&i.route;let u=hp(),c;if(t){var d;let g=typeof t=="string"?sy(t):t;l==="/"||(d=g.pathname)!=null&&d.startsWith(l)||$r(!1),c=g}else c=u;let h=c.pathname||"/",p=l==="/"?h:h.slice(l.length)||"/",f=Lce(e,{pathname:p}),m=gde(f&&f.map(g=>Object.assign({},g,{params:Object.assign({},o,g.params),pathname:bc([l,s.encodeLocation?s.encodeLocation(g.pathname).pathname:g.pathname]),pathnameBase:g.pathnameBase==="/"?l:bc([l,s.encodeLocation?s.encodeLocation(g.pathnameBase).pathname:g.pathnameBase])})),a,n,r);return t&&m?Z.createElement(BI.Provider,{value:{location:A1({pathname:"/",search:"",hash:"",state:null,key:"default"},c),navigationType:tc.Pop}},m):m}function hde(){let e=xde(),t=ade(e)?e.status+" "+e.statusText:e instanceof Error?e.message:JSON.stringify(e),n=e instanceof Error?e.stack:null,s={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"},a=null;return Z.createElement(Z.Fragment,null,Z.createElement("h2",null,"Unexpected Application Error!"),Z.createElement("h3",{style:{fontStyle:"italic"}},t),n?Z.createElement("pre",{style:s},n):null,a)}const pde=Z.createElement(hde,null);class fde extends Z.Component{constructor(t){super(t),this.state={location:t.location,revalidation:t.revalidation,error:t.error}}static getDerivedStateFromError(t){return{error:t}}static getDerivedStateFromProps(t,n){return n.location!==t.location||n.revalidation!=="idle"&&t.revalidation==="idle"?{error:t.error,location:t.location,revalidation:t.revalidation}:{error:t.error!==void 0?t.error:n.error,location:n.location,revalidation:t.revalidation||n.revalidation}}componentDidCatch(t,n){console.error("React Router caught the following error during render",t,n)}render(){return this.state.error!==void 0?Z.createElement(td.Provider,{value:this.props.routeContext},Z.createElement(AH.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function mde(e){let{routeContext:t,match:n,children:r}=e,s=Z.useContext(aO);return s&&s.static&&s.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(s.staticContext._deepestRenderedBoundaryId=n.route.id),Z.createElement(td.Provider,{value:t},r)}function gde(e,t,n,r){var s;if(t===void 0&&(t=[]),n===void 0&&(n=null),r===void 0&&(r=null),e==null){var a;if((a=n)!=null&&a.errors)e=n.matches;else return null}let i=e,o=(s=n)==null?void 0:s.errors;if(o!=null){let c=i.findIndex(d=>d.route.id&&(o==null?void 0:o[d.route.id]));c>=0||$r(!1),i=i.slice(0,Math.min(i.length,c+1))}let l=!1,u=-1;if(n&&r&&r.v7_partialHydration)for(let c=0;c<i.length;c++){let d=i[c];if((d.route.HydrateFallback||d.route.hydrateFallbackElement)&&(u=c),d.route.id){let{loaderData:h,errors:p}=n,f=d.route.loader&&h[d.route.id]===void 0&&(!p||p[d.route.id]===void 0);if(d.route.lazy||f){l=!0,u>=0?i=i.slice(0,u+1):i=[i[0]];break}}}return i.reduceRight((c,d,h)=>{let p,f=!1,m=null,g=null;n&&(p=o&&d.route.id?o[d.route.id]:void 0,m=d.route.errorElement||pde,l&&(u<0&&h===0?(kde("route-fallback",!1),f=!0,g=null):u===h&&(f=!0,g=d.route.hydrateFallbackElement||null)));let y=t.concat(i.slice(0,h+1)),b=()=>{let x;return p?x=m:f?x=g:d.route.Component?x=Z.createElement(d.route.Component,null):d.route.element?x=d.route.element:x=c,Z.createElement(mde,{match:d,routeContext:{outlet:c,matches:y,isDataRoute:n!=null},children:x})};return n&&(d.route.ErrorBoundary||d.route.errorElement||h===0)?Z.createElement(fde,{location:n.location,revalidation:n.revalidation,component:m,error:p,children:b(),routeContext:{outlet:null,matches:y,isDataRoute:!0}}):b()},null)}var OH=function(e){return e.UseBlocker="useBlocker",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e}(OH||{}),tS=function(e){return e.UseBlocker="useBlocker",e.UseLoaderData="useLoaderData",e.UseActionData="useActionData",e.UseRouteError="useRouteError",e.UseNavigation="useNavigation",e.UseRouteLoaderData="useRouteLoaderData",e.UseMatches="useMatches",e.UseRevalidator="useRevalidator",e.UseNavigateStable="useNavigate",e.UseRouteId="useRouteId",e}(tS||{});function yde(e){let t=Z.useContext(aO);return t||$r(!1),t}function bde(e){let t=Z.useContext(ode);return t||$r(!1),t}function vde(e){let t=Z.useContext(td);return t||$r(!1),t}function FH(e){let t=vde(),n=t.matches[t.matches.length-1];return n.route.id||$r(!1),n.route.id}function xde(){var e;let t=Z.useContext(AH),n=bde(tS.UseRouteError),r=FH(tS.UseRouteError);return t!==void 0?t:(e=n.errors)==null?void 0:e[r]}function wde(){let{router:e}=yde(OH.UseNavigateStable),t=FH(tS.UseNavigateStable),n=Z.useRef(!1);return RH(()=>{n.current=!0}),Z.useCallback(function(s,a){a===void 0&&(a={}),n.current&&(typeof s=="number"?e.navigate(s):e.navigate(s,A1({fromRouteId:t},a)))},[e,t])}const mW={};function kde(e,t,n){!t&&!mW[e]&&(mW[e]=!0)}function Sde(e){let{to:t,replace:n,state:r,relative:s}=e;ay()||$r(!1);let{future:a,static:i}=Z.useContext(ed),{matches:o}=Z.useContext(td),{pathname:l}=hp(),u=WI(),c=sO(t,rO(o,a.v7_relativeSplatPath),l,s==="path"),d=JSON.stringify(c);return Z.useEffect(()=>u(JSON.parse(d),{replace:n,state:r,relative:s}),[u,d,s,n,r]),null}function mo(e){$r(!1)}function Ide(e){let{basename:t="/",children:n=null,location:r,navigationType:s=tc.Pop,navigator:a,static:i=!1,future:o}=e;ay()&&$r(!1);let l=t.replace(/^\/*/,"/"),u=Z.useMemo(()=>({basename:l,navigator:a,static:i,future:A1({v7_relativeSplatPath:!1},o)}),[l,o,a,i]);typeof r=="string"&&(r=sy(r));let{pathname:c="/",search:d="",hash:h="",state:p=null,key:f="default"}=r,m=Z.useMemo(()=>{let g=nO(c,l);return g==null?null:{location:{pathname:g,search:d,hash:h,state:p,key:f},navigationType:s}},[l,c,d,h,p,f,s]);return m==null?null:Z.createElement(ed.Provider,{value:u},Z.createElement(BI.Provider,{children:n,value:m}))}function gW(e){let{children:t,location:n}=e;return cde(j_(t),n)}new Promise(()=>{});function j_(e,t){t===void 0&&(t=[]);let n=[];return Z.Children.forEach(e,(r,s)=>{if(!Z.isValidElement(r))return;let a=[...t,s];if(r.type===Z.Fragment){n.push.apply(n,j_(r.props.children,a));return}r.type!==mo&&$r(!1),!r.props.index||!r.props.children||$r(!1);let i={id:r.props.id||a.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(i.children=j_(r.props.children,a)),n.push(i)}),n}/**
 * React Router DOM v6.22.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function G_(){return G_=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},G_.apply(this,arguments)}function Cde(e,t){if(e==null)return{};var n={},r=Object.keys(e),s,a;for(a=0;a<r.length;a++)s=r[a],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}function Nde(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}function Tde(e,t){return e.button===0&&(!t||t==="_self")&&!Nde(e)}const $de=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"],Ede="6";try{window.__reactRouterVersion=Ede}catch{}const _de="startTransition",yW=Cle[_de];function Ade(e){let{basename:t,children:n,future:r,window:s}=e,a=Z.useRef();a.current==null&&(a.current=Fce({window:s,v5Compat:!0}));let i=a.current,[o,l]=Z.useState({action:i.action,location:i.location}),{v7_startTransition:u}=r||{},c=Z.useCallback(d=>{u&&yW?yW(()=>l(d)):l(d)},[l,u]);return Z.useLayoutEffect(()=>i.listen(c),[i,c]),Z.createElement(Ide,{basename:t,children:n,location:o.location,navigationType:o.action,navigator:i,future:r})}const Rde=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",Dde=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Qo=Z.forwardRef(function(t,n){let{onClick:r,relative:s,reloadDocument:a,replace:i,state:o,target:l,to:u,preventScrollReset:c,unstable_viewTransition:d}=t,h=Cde(t,$de),{basename:p}=Z.useContext(ed),f,m=!1;if(typeof u=="string"&&Dde.test(u)&&(f=u,Rde))try{let x=new URL(window.location.href),v=u.startsWith("//")?new URL(x.protocol+u):new URL(u),w=nO(v.pathname,p);v.origin===x.origin&&w!=null?u=w+v.search+v.hash:m=!0}catch{}let g=lde(u,{relative:s}),y=Ode(u,{replace:i,state:o,target:l,preventScrollReset:c,relative:s,unstable_viewTransition:d});function b(x){r&&r(x),x.defaultPrevented||y(x)}return Z.createElement("a",G_({},h,{href:f||g,onClick:m||a?r:b,ref:n,target:l}))});var bW;(function(e){e.UseScrollRestoration="useScrollRestoration",e.UseSubmit="useSubmit",e.UseSubmitFetcher="useSubmitFetcher",e.UseFetcher="useFetcher",e.useViewTransitionState="useViewTransitionState"})(bW||(bW={}));var vW;(function(e){e.UseFetcher="useFetcher",e.UseFetchers="useFetchers",e.UseScrollRestoration="useScrollRestoration"})(vW||(vW={}));function Ode(e,t){let{target:n,replace:r,state:s,preventScrollReset:a,relative:i,unstable_viewTransition:o}=t===void 0?{}:t,l=WI(),u=hp(),c=DH(e,{relative:i});return Z.useCallback(d=>{if(Tde(d,n)){d.preventDefault();let h=r!==void 0?r:eS(u)===eS(c);l(e,{replace:h,state:s,preventScrollReset:a,relative:i,unstable_viewTransition:o})}},[u,l,c,r,s,n,e,a,i,o])}const Fde="/assets/LogoDesign3-c159a0a1.png",MH=()=>A.jsx(A.Fragment,{children:A.jsxs("div",{className:"blogLogoContainer",children:[A.jsx("img",{src:Fde,alt:"Dawid's Blog Logo",className:"blogLogo",loading:"eager"}),A.jsx("h1",{id:"logoHeader",children:"You Are Not Your Thoughts!"})]})}),Mde=()=>A.jsx(A.Fragment,{children:A.jsxs("div",{className:"footerContainer",children:[A.jsx("h3",{children:"Contact Details"}),A.jsxs("div",{id:"contactDetailsContainer",children:[A.jsx("p",{children:"Email: tpd20seu@uea.ac.uk"}),A.jsx("p",{children:"Github: bhunter3k"})]})]})}),Pde=()=>A.jsx(A.Fragment,{children:A.jsxs("div",{className:"footerContainer2",children:[A.jsx("h3",{children:"Contact Details"}),A.jsx("br",{}),A.jsx("p",{children:"Email: tpd20seu@uea.ac.uk"}),A.jsx("br",{}),A.jsx("p",{children:"Github: bhunter3k"})]})});function H_(){return H_=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},H_.apply(this,arguments)}function PH(e,t){if(e==null)return{};var n={},r=Object.keys(e),s,a;for(a=0;a<r.length;a++)s=r[a],!(t.indexOf(s)>=0)&&(n[s]=e[s]);return n}function q_(e,t){return q_=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(r,s){return r.__proto__=s,r},q_(e,t)}function LH(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,q_(e,t)}function Lde(e,t){return e.classList?!!t&&e.classList.contains(t):(" "+(e.className.baseVal||e.className)+" ").indexOf(" "+t+" ")!==-1}function zde(e,t){e.classList?e.classList.add(t):Lde(e,t)||(typeof e.className=="string"?e.className=e.className+" "+t:e.setAttribute("class",(e.className&&e.className.baseVal||"")+" "+t))}function xW(e,t){return e.replace(new RegExp("(^|\\s)"+t+"(?:\\s|$)","g"),"$1").replace(/\s+/g," ").replace(/^\s*|\s*$/g,"")}function Bde(e,t){e.classList?e.classList.remove(t):typeof e.className=="string"?e.className=xW(e.className,t):e.setAttribute("class",xW(e.className&&e.className.baseVal||"",t))}const wW={disabled:!1},zH=wn.createContext(null);var BH=function(t){return t.scrollTop},Av="unmounted",Pd="exited",Ld="entering",bm="entered",K_="exiting",wu=function(e){LH(t,e);function t(r,s){var a;a=e.call(this,r,s)||this;var i=s,o=i&&!i.isMounting?r.enter:r.appear,l;return a.appearStatus=null,r.in?o?(l=Pd,a.appearStatus=Ld):l=bm:r.unmountOnExit||r.mountOnEnter?l=Av:l=Pd,a.state={status:l},a.nextCallback=null,a}t.getDerivedStateFromProps=function(s,a){var i=s.in;return i&&a.status===Av?{status:Pd}:null};var n=t.prototype;return n.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},n.componentDidUpdate=function(s){var a=null;if(s!==this.props){var i=this.state.status;this.props.in?i!==Ld&&i!==bm&&(a=Ld):(i===Ld||i===bm)&&(a=K_)}this.updateStatus(!1,a)},n.componentWillUnmount=function(){this.cancelNextCallback()},n.getTimeouts=function(){var s=this.props.timeout,a,i,o;return a=i=o=s,s!=null&&typeof s!="number"&&(a=s.exit,i=s.enter,o=s.appear!==void 0?s.appear:i),{exit:a,enter:i,appear:o}},n.updateStatus=function(s,a){if(s===void 0&&(s=!1),a!==null)if(this.cancelNextCallback(),a===Ld){if(this.props.unmountOnExit||this.props.mountOnEnter){var i=this.props.nodeRef?this.props.nodeRef.current:vk.findDOMNode(this);i&&BH(i)}this.performEnter(s)}else this.performExit();else this.props.unmountOnExit&&this.state.status===Pd&&this.setState({status:Av})},n.performEnter=function(s){var a=this,i=this.props.enter,o=this.context?this.context.isMounting:s,l=this.props.nodeRef?[o]:[vk.findDOMNode(this),o],u=l[0],c=l[1],d=this.getTimeouts(),h=o?d.appear:d.enter;if(!s&&!i||wW.disabled){this.safeSetState({status:bm},function(){a.props.onEntered(u)});return}this.props.onEnter(u,c),this.safeSetState({status:Ld},function(){a.props.onEntering(u,c),a.onTransitionEnd(h,function(){a.safeSetState({status:bm},function(){a.props.onEntered(u,c)})})})},n.performExit=function(){var s=this,a=this.props.exit,i=this.getTimeouts(),o=this.props.nodeRef?void 0:vk.findDOMNode(this);if(!a||wW.disabled){this.safeSetState({status:Pd},function(){s.props.onExited(o)});return}this.props.onExit(o),this.safeSetState({status:K_},function(){s.props.onExiting(o),s.onTransitionEnd(i.exit,function(){s.safeSetState({status:Pd},function(){s.props.onExited(o)})})})},n.cancelNextCallback=function(){this.nextCallback!==null&&(this.nextCallback.cancel(),this.nextCallback=null)},n.safeSetState=function(s,a){a=this.setNextCallback(a),this.setState(s,a)},n.setNextCallback=function(s){var a=this,i=!0;return this.nextCallback=function(o){i&&(i=!1,a.nextCallback=null,s(o))},this.nextCallback.cancel=function(){i=!1},this.nextCallback},n.onTransitionEnd=function(s,a){this.setNextCallback(a);var i=this.props.nodeRef?this.props.nodeRef.current:vk.findDOMNode(this),o=s==null&&!this.props.addEndListener;if(!i||o){setTimeout(this.nextCallback,0);return}if(this.props.addEndListener){var l=this.props.nodeRef?[this.nextCallback]:[i,this.nextCallback],u=l[0],c=l[1];this.props.addEndListener(u,c)}s!=null&&setTimeout(this.nextCallback,s)},n.render=function(){var s=this.state.status;if(s===Av)return null;var a=this.props,i=a.children;a.in,a.mountOnEnter,a.unmountOnExit,a.appear,a.enter,a.exit,a.timeout,a.addEndListener,a.onEnter,a.onEntering,a.onEntered,a.onExit,a.onExiting,a.onExited,a.nodeRef;var o=PH(a,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]);return wn.createElement(zH.Provider,{value:null},typeof i=="function"?i(s,o):wn.cloneElement(wn.Children.only(i),o))},t}(wn.Component);wu.contextType=zH;wu.propTypes={};function um(){}wu.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:um,onEntering:um,onEntered:um,onExit:um,onExiting:um,onExited:um};wu.UNMOUNTED=Av;wu.EXITED=Pd;wu.ENTERING=Ld;wu.ENTERED=bm;wu.EXITING=K_;const Wde=wu;var Vde=function(t,n){return t&&n&&n.split(" ").forEach(function(r){return zde(t,r)})},Y$=function(t,n){return t&&n&&n.split(" ").forEach(function(r){return Bde(t,r)})},iO=function(e){LH(t,e);function t(){for(var r,s=arguments.length,a=new Array(s),i=0;i<s;i++)a[i]=arguments[i];return r=e.call.apply(e,[this].concat(a))||this,r.appliedClasses={appear:{},enter:{},exit:{}},r.onEnter=function(o,l){var u=r.resolveArguments(o,l),c=u[0],d=u[1];r.removeClasses(c,"exit"),r.addClass(c,d?"appear":"enter","base"),r.props.onEnter&&r.props.onEnter(o,l)},r.onEntering=function(o,l){var u=r.resolveArguments(o,l),c=u[0],d=u[1],h=d?"appear":"enter";r.addClass(c,h,"active"),r.props.onEntering&&r.props.onEntering(o,l)},r.onEntered=function(o,l){var u=r.resolveArguments(o,l),c=u[0],d=u[1],h=d?"appear":"enter";r.removeClasses(c,h),r.addClass(c,h,"done"),r.props.onEntered&&r.props.onEntered(o,l)},r.onExit=function(o){var l=r.resolveArguments(o),u=l[0];r.removeClasses(u,"appear"),r.removeClasses(u,"enter"),r.addClass(u,"exit","base"),r.props.onExit&&r.props.onExit(o)},r.onExiting=function(o){var l=r.resolveArguments(o),u=l[0];r.addClass(u,"exit","active"),r.props.onExiting&&r.props.onExiting(o)},r.onExited=function(o){var l=r.resolveArguments(o),u=l[0];r.removeClasses(u,"exit"),r.addClass(u,"exit","done"),r.props.onExited&&r.props.onExited(o)},r.resolveArguments=function(o,l){return r.props.nodeRef?[r.props.nodeRef.current,o]:[o,l]},r.getClassNames=function(o){var l=r.props.classNames,u=typeof l=="string",c=u&&l?l+"-":"",d=u?""+c+o:l[o],h=u?d+"-active":l[o+"Active"],p=u?d+"-done":l[o+"Done"];return{baseClassName:d,activeClassName:h,doneClassName:p}},r}var n=t.prototype;return n.addClass=function(s,a,i){var o=this.getClassNames(a)[i+"ClassName"],l=this.getClassNames("enter"),u=l.doneClassName;a==="appear"&&i==="done"&&u&&(o+=" "+u),i==="active"&&s&&BH(s),o&&(this.appliedClasses[a][i]=o,Vde(s,o))},n.removeClasses=function(s,a){var i=this.appliedClasses[a],o=i.base,l=i.active,u=i.done;this.appliedClasses[a]={},o&&Y$(s,o),l&&Y$(s,l),u&&Y$(s,u)},n.render=function(){var s=this.props;s.classNames;var a=PH(s,["classNames"]);return wn.createElement(Wde,H_({},a,{onEnter:this.onEnter,onEntered:this.onEntered,onEntering:this.onEntering,onExit:this.onExit,onExiting:this.onExiting,onExited:this.onExited}))},t}(wn.Component);iO.defaultProps={classNames:""};iO.propTypes={};const Ude=iO;var WH={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},kW=wn.createContext&&wn.createContext(WH),vc=globalThis&&globalThis.__assign||function(){return vc=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++){t=arguments[n];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e},vc.apply(this,arguments)},jde=globalThis&&globalThis.__rest||function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n};function VH(e){return e&&e.map(function(t,n){return wn.createElement(t.tag,vc({key:n},t.attr),VH(t.child))})}function Dr(e){return function(t){return wn.createElement(Gde,vc({attr:vc({},e.attr)},t),VH(e.child))}}function Gde(e){var t=function(n){var r=e.attr,s=e.size,a=e.title,i=jde(e,["attr","size","title"]),o=s||n.size||"1em",l;return n.className&&(l=n.className),e.className&&(l=(l?l+" ":"")+e.className),wn.createElement("svg",vc({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},n.attr,r,i,{className:l,style:vc(vc({color:e.color||n.color},n.style),e.style),height:o,width:o,xmlns:"http://www.w3.org/2000/svg"}),a&&wn.createElement("title",null,a),e.children)};return kW!==void 0?wn.createElement(kW.Consumer,null,function(n){return t(n)}):t(WH)}function Hde(e){return Dr({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M280.37 148.26L96 300.11V464a16 16 0 0 0 16 16l112.06-.29a16 16 0 0 0 15.92-16V368a16 16 0 0 1 16-16h64a16 16 0 0 1 16 16v95.64a16 16 0 0 0 16 16.05L464 480a16 16 0 0 0 16-16V300L295.67 148.26a12.19 12.19 0 0 0-15.3 0zM571.6 251.47L488 182.56V44.05a12 12 0 0 0-12-12h-56a12 12 0 0 0-12 12v72.61L318.47 43a48 48 0 0 0-61 0L4.34 251.47a12 12 0 0 0-1.6 16.9l25.5 31A12 12 0 0 0 45.15 301l235.22-193.74a12.19 12.19 0 0 1 15.3 0L530.9 301a12 12 0 0 0 16.9-1.6l25.5-31a12 12 0 0 0-1.7-16.93z"}}]})(e)}function qde(e){return Dr({tag:"svg",attr:{viewBox:"0 0 448 512"},child:[{tag:"path",attr:{d:"M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h352a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48zm-16.39 307.37l-15 65A15 15 0 0 1 354 416C194 416 64 286.29 64 126a15.7 15.7 0 0 1 11.63-14.61l65-15A18.23 18.23 0 0 1 144 96a16.27 16.27 0 0 1 13.79 9.09l30 70A17.9 17.9 0 0 1 189 181a17 17 0 0 1-5.5 11.61l-37.89 31a231.91 231.91 0 0 0 110.78 110.78l31-37.89A17 17 0 0 1 299 291a17.85 17.85 0 0 1 5.91 1.21l70 30A16.25 16.25 0 0 1 384 336a17.41 17.41 0 0 1-.39 3.37z"}}]})(e)}function Kde(e){return Dr({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"}}]})(e)}function Xde(e){return Dr({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 288c79.5 0 144-64.5 144-144S335.5 0 256 0 112 64.5 112 144s64.5 144 144 144zm128 32h-55.1c-22.2 10.2-46.9 16-72.9 16s-50.6-5.8-72.9-16H128C57.3 320 0 377.3 0 448v16c0 26.5 21.5 48 48 48h416c26.5 0 48-21.5 48-48v-16c0-70.7-57.3-128-128-128z"}}]})(e)}function nS(e){return Dr({tag:"svg",attr:{viewBox:"0 0 576 512"},child:[{tag:"path",attr:{d:"M480 416v16c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V176c0-26.51 21.49-48 48-48h16v48H54a6 6 0 0 0-6 6v244a6 6 0 0 0 6 6h372a6 6 0 0 0 6-6v-10h48zm42-336H150a6 6 0 0 0-6 6v244a6 6 0 0 0 6 6h372a6 6 0 0 0 6-6V86a6 6 0 0 0-6-6zm6-48c26.51 0 48 21.49 48 48v256c0 26.51-21.49 48-48 48H144c-26.51 0-48-21.49-48-48V80c0-26.51 21.49-48 48-48h384zM264 144c0 22.091-17.909 40-40 40s-40-17.909-40-40 17.909-40 40-40 40 17.909 40 40zm-72 96l39.515-39.515c4.686-4.686 12.284-4.686 16.971 0L288 240l103.515-103.515c4.686-4.686 12.284-4.686 16.971 0L480 208v80H192v-48z"}}]})(e)}function SW(e){return Dr({tag:"svg",attr:{viewBox:"0 0 496 512"},child:[{tag:"path",attr:{d:"M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm144 386.4V280c0-13.2-10.8-24-24-24s-24 10.8-24 24v151.4C315.5 447 282.8 456 248 456s-67.5-9-96-24.6V280c0-13.2-10.8-24-24-24s-24 10.8-24 24v114.4c-34.6-36-56-84.7-56-138.4 0-110.3 89.7-200 200-200s200 89.7 200 200c0 53.7-21.4 102.5-56 138.4zM205.8 234.5c4.4-2.4 6.9-7.4 6.1-12.4-4-25.2-34.2-42.1-59.8-42.1s-55.9 16.9-59.8 42.1c-.8 5 1.7 10 6.1 12.4 4.4 2.4 9.9 1.8 13.7-1.6l9.5-8.5c14.8-13.2 46.2-13.2 61 0l9.5 8.5c2.5 2.3 7.9 4.8 13.7 1.6zM344 180c-25.7 0-55.9 16.9-59.8 42.1-.8 5 1.7 10 6.1 12.4 4.5 2.4 9.9 1.8 13.7-1.6l9.5-8.5c14.8-13.2 46.2-13.2 61 0l9.5 8.5c2.5 2.2 8 4.7 13.7 1.6 4.4-2.4 6.9-7.4 6.1-12.4-3.9-25.2-34.1-42.1-59.8-42.1zm-96 92c-30.9 0-56 28.7-56 64s25.1 64 56 64 56-28.7 56-64-25.1-64-56-64z"}}]})(e)}function Yde(e){return Dr({tag:"svg",attr:{viewBox:"0 0 15 15",fill:"none"},child:[{tag:"path",attr:{fillRule:"evenodd",clipRule:"evenodd",d:"M2.8 1L2.74967 0.99997C2.52122 0.999752 2.32429 0.999564 2.14983 1.04145C1.60136 1.17312 1.17312 1.60136 1.04145 2.14983C0.999564 2.32429 0.999752 2.52122 0.99997 2.74967L1 2.8V5.2L0.99997 5.25033C0.999752 5.47878 0.999564 5.67572 1.04145 5.85017C1.17312 6.39864 1.60136 6.82688 2.14983 6.95856C2.32429 7.00044 2.52122 7.00025 2.74967 7.00003L2.8 7H5.2L5.25033 7.00003C5.47878 7.00025 5.67572 7.00044 5.85017 6.95856C6.39864 6.82688 6.82688 6.39864 6.95856 5.85017C7.00044 5.67572 7.00025 5.47878 7.00003 5.25033L7 5.2V2.8L7.00003 2.74967C7.00025 2.52122 7.00044 2.32429 6.95856 2.14983C6.82688 1.60136 6.39864 1.17312 5.85017 1.04145C5.67572 0.999564 5.47878 0.999752 5.25033 0.99997L5.2 1H2.8ZM2.38328 2.01382C2.42632 2.00348 2.49222 2 2.8 2H5.2C5.50779 2 5.57369 2.00348 5.61672 2.01382C5.79955 2.05771 5.94229 2.20045 5.98619 2.38328C5.99652 2.42632 6 2.49222 6 2.8V5.2C6 5.50779 5.99652 5.57369 5.98619 5.61672C5.94229 5.79955 5.79955 5.94229 5.61672 5.98619C5.57369 5.99652 5.50779 6 5.2 6H2.8C2.49222 6 2.42632 5.99652 2.38328 5.98619C2.20045 5.94229 2.05771 5.79955 2.01382 5.61672C2.00348 5.57369 2 5.50779 2 5.2V2.8C2 2.49222 2.00348 2.42632 2.01382 2.38328C2.05771 2.20045 2.20045 2.05771 2.38328 2.01382ZM9.8 1L9.74967 0.99997C9.52122 0.999752 9.32429 0.999564 9.14983 1.04145C8.60136 1.17312 8.17312 1.60136 8.04145 2.14983C7.99956 2.32429 7.99975 2.52122 7.99997 2.74967L8 2.8V5.2L7.99997 5.25033C7.99975 5.47878 7.99956 5.67572 8.04145 5.85017C8.17312 6.39864 8.60136 6.82688 9.14983 6.95856C9.32429 7.00044 9.52122 7.00025 9.74967 7.00003L9.8 7H12.2L12.2503 7.00003C12.4788 7.00025 12.6757 7.00044 12.8502 6.95856C13.3986 6.82688 13.8269 6.39864 13.9586 5.85017C14.0004 5.67572 14.0003 5.47878 14 5.25033L14 5.2V2.8L14 2.74967C14.0003 2.52122 14.0004 2.32429 13.9586 2.14983C13.8269 1.60136 13.3986 1.17312 12.8502 1.04145C12.6757 0.999564 12.4788 0.999752 12.2503 0.99997L12.2 1H9.8ZM9.38328 2.01382C9.42632 2.00348 9.49222 2 9.8 2H12.2C12.5078 2 12.5737 2.00348 12.6167 2.01382C12.7995 2.05771 12.9423 2.20045 12.9862 2.38328C12.9965 2.42632 13 2.49222 13 2.8V5.2C13 5.50779 12.9965 5.57369 12.9862 5.61672C12.9423 5.79955 12.7995 5.94229 12.6167 5.98619C12.5737 5.99652 12.5078 6 12.2 6H9.8C9.49222 6 9.42632 5.99652 9.38328 5.98619C9.20045 5.94229 9.05771 5.79955 9.01382 5.61672C9.00348 5.57369 9 5.50779 9 5.2V2.8C9 2.49222 9.00348 2.42632 9.01382 2.38328C9.05771 2.20045 9.20045 2.05771 9.38328 2.01382ZM2.74967 7.99997L2.8 8H5.2L5.25033 7.99997C5.47878 7.99975 5.67572 7.99956 5.85017 8.04145C6.39864 8.17312 6.82688 8.60136 6.95856 9.14983C7.00044 9.32429 7.00025 9.52122 7.00003 9.74967L7 9.8V12.2L7.00003 12.2503C7.00025 12.4788 7.00044 12.6757 6.95856 12.8502C6.82688 13.3986 6.39864 13.8269 5.85017 13.9586C5.67572 14.0004 5.47878 14.0003 5.25033 14L5.2 14H2.8L2.74967 14C2.52122 14.0003 2.32429 14.0004 2.14983 13.9586C1.60136 13.8269 1.17312 13.3986 1.04145 12.8502C0.999564 12.6757 0.999752 12.4788 0.99997 12.2503L1 12.2V9.8L0.99997 9.74967C0.999752 9.52122 0.999564 9.32429 1.04145 9.14983C1.17312 8.60136 1.60136 8.17312 2.14983 8.04145C2.32429 7.99956 2.52122 7.99975 2.74967 7.99997ZM2.8 9C2.49222 9 2.42632 9.00348 2.38328 9.01382C2.20045 9.05771 2.05771 9.20045 2.01382 9.38328C2.00348 9.42632 2 9.49222 2 9.8V12.2C2 12.5078 2.00348 12.5737 2.01382 12.6167C2.05771 12.7995 2.20045 12.9423 2.38328 12.9862C2.42632 12.9965 2.49222 13 2.8 13H5.2C5.50779 13 5.57369 12.9965 5.61672 12.9862C5.79955 12.9423 5.94229 12.7995 5.98619 12.6167C5.99652 12.5737 6 12.5078 6 12.2V9.8C6 9.49222 5.99652 9.42632 5.98619 9.38328C5.94229 9.20045 5.79955 9.05771 5.61672 9.01382C5.57369 9.00348 5.50779 9 5.2 9H2.8ZM9.8 8L9.74967 7.99997C9.52122 7.99975 9.32429 7.99956 9.14983 8.04145C8.60136 8.17312 8.17312 8.60136 8.04145 9.14983C7.99956 9.32429 7.99975 9.52122 7.99997 9.74967L8 9.8V12.2L7.99997 12.2503C7.99975 12.4788 7.99956 12.6757 8.04145 12.8502C8.17312 13.3986 8.60136 13.8269 9.14983 13.9586C9.32429 14.0004 9.52122 14.0003 9.74967 14L9.8 14H12.2L12.2503 14C12.4788 14.0003 12.6757 14.0004 12.8502 13.9586C13.3986 13.8269 13.8269 13.3986 13.9586 12.8502C14.0004 12.6757 14.0003 12.4788 14 12.2503L14 12.2V9.8L14 9.74967C14.0003 9.52122 14.0004 9.32429 13.9586 9.14983C13.8269 8.60136 13.3986 8.17312 12.8502 8.04145C12.6757 7.99956 12.4788 7.99975 12.2503 7.99997L12.2 8H9.8ZM9.38328 9.01382C9.42632 9.00348 9.49222 9 9.8 9H12.2C12.5078 9 12.5737 9.00348 12.6167 9.01382C12.7995 9.05771 12.9423 9.20045 12.9862 9.38328C12.9965 9.42632 13 9.49222 13 9.8V12.2C13 12.5078 12.9965 12.5737 12.9862 12.6167C12.9423 12.7995 12.7995 12.9423 12.6167 12.9862C12.5737 12.9965 12.5078 13 12.2 13H9.8C9.49222 13 9.42632 12.9965 9.38328 12.9862C9.20045 12.9423 9.05771 12.7995 9.01382 12.6167C9.00348 12.5737 9 12.5078 9 12.2V9.8C9 9.49222 9.00348 9.42632 9.01382 9.38328C9.05771 9.20045 9.20045 9.05771 9.38328 9.01382Z",fill:"currentColor"}}]})(e)}const UH=()=>{const e=hp();function t(n){return e.pathname===n}return A.jsxs("ul",{children:[A.jsx("li",{children:A.jsxs(Qo,{to:"/homePage",className:"navbarLink",id:t("/homePage")?"currentPage":"",children:[A.jsx(Hde,{className:"navIcon"}),"Home"]})}),A.jsx("li",{children:A.jsxs(Qo,{to:"/dashboardPage",className:"navbarLink",id:t("/dashboardPage")?"currentPage":"",children:[A.jsx(Yde,{className:"navIcon"}),"Feature Dashboard"]})}),A.jsx("li",{children:A.jsx(Qo,{to:"/ratingPage",className:"navbarLink dashBoardLink",id:t("/ratingPage")?"currentPage":"",children:"1) Rate Today's Mood"})}),A.jsx("li",{children:A.jsx(Qo,{to:"/journalPage",className:"navbarLink dashBoardLink",id:t("/journalPage")?"currentPage":"",children:"2) Journal"})}),A.jsx("li",{children:A.jsx(Qo,{to:"/selfiePage",className:"navbarLink dashBoardLink",id:t("/selfiePage")?"currentPage":"",children:"3) Selfie"})}),A.jsx("li",{children:A.jsx(Qo,{to:"/recommendationsPage",className:"navbarLink dashBoardLink",id:t("/recommendationsPage")?"currentPage":"",children:"4) Advice/Activities"})}),A.jsx("li",{children:A.jsx(Qo,{to:"/statsPage",className:"navbarLink dashBoardLink",id:t("/statsPage")?"currentPage":"",children:"5) History/Statistics"})}),A.jsx("li",{children:A.jsxs(Qo,{to:"/contactPage",className:"navbarLink",id:t("/contactPage")?"currentPage":"",children:[A.jsx(qde,{className:"navIcon"}),"Contact"]})}),A.jsx("li",{children:A.jsxs(Qo,{to:"/aboutMePage",className:"navbarLink",id:t("/aboutMePage")?"currentPage":"",children:[A.jsx(Xde,{className:"navIcon"}),"About Me"]})})]})},Jde=()=>A.jsx(A.Fragment,{children:A.jsxs("div",{className:"navbarDesktopContainer",children:[A.jsx(MH,{}),A.jsx(UH,{})]})}),Zde=()=>{const[e,t]=Z.useState(!1),[n,r]=Z.useState("navbarMobileContainerInitial"),s=()=>{t(!e),r("navbarMobileContainerAfter")},a=wn.useRef(null);return A.jsxs(A.Fragment,{children:[A.jsxs("div",{className:"logoHamburgerContainer",children:[A.jsx(MH,{}),A.jsx("div",{className:"hamburgerMenuContainer",children:A.jsx(ehe,{onClick:s,isExpanded:e})})]}),A.jsx(Ude,{nodeRef:a,in:e,timeout:500,classNames:"navbarMobile",children:A.jsx("div",{className:n,ref:a,children:A.jsx(UH,{})})})]})},Qde=()=>{const[e,t]=Z.useState(window.matchMedia("(max-width: 740px)").matches);return Z.useEffect(()=>{const n=window.matchMedia("(max-width: 740px)");function r(s){t(s.matches)}return n.addEventListener("change",r),()=>{n.removeEventListener("change",r)}},[]),A.jsxs(A.Fragment,{children:[" ",e?A.jsx(Zde,{}):A.jsx(Jde,{})]})},ehe=e=>A.jsx("button",{type:"button",className:"hamburgerMenuBtn","aria-expanded":e.isExpanded,onClick:e.onClick,children:A.jsxs("svg",{className:"hamburgerMenuIcon",viewBox:"0 0 100 100",width:"30",height:"40",fill:"currentColor",children:[A.jsx("rect",{className:"line top",width:"95",height:"12",x:"2.5",y:"20",rx:"5"}),A.jsx("rect",{className:"line middle",width:"95",height:"12",x:"2.5",y:"45",rx:"5"}),A.jsx("rect",{className:"line bottom",width:"95",height:"12",x:"2.5",y:"70",rx:"5"})]})}),the=[{Heading:"Mood Rating",Image:"../assets/MoodTrackerIdea.jpg",Summary:"Rate your mood through out the day using the mood tracker scale.",Link:"/rating"},{Heading:"Journal",Image:"../assets/MoodJournal.jpg",Summary:"Write in journal entries about your thoughts and feelings throughout the day!",Link:"/journal"},{Heading:"Selfie",Image:"../assets/MoodSelfie.jpg",Summary:"Take a selfie of how you are currently feeling :)",Link:"/selfie"},{Heading:"Advice/Activities",Image:"../assets/Recommendations.png",Summary:"View our tailored advice about your current stress level and how to manage it. Practice mindfulness and participate in our breathing exercise activity during a rainy day!",Link:"/recommendations"},{Heading:"History/Statistics",Image:"../assets/StatisticsIdea.png",Summary:"View your past stress statistics, phrases and scenarios that cause you stress, and most common emotions displayed in your selfies.",Link:"/stats"},{Heading:"Contact Me",Image:"../assets/Contact.png",Summary:"Feel free to contact the research if you have any questions or run into any problems :)",Link:"/contactPage"}];const nhe=[{Heading:"",Image:"",Summary:"",Link:""}],rhe=()=>{const[e,t]=Z.useState(nhe),[n,r]=Z.useState("");Z.useEffect(()=>{s()},[]),Z.useEffect(()=>{n!=""?a(n):s()},[n]);function s(){let i=[];the.forEach(o=>{i.push(o)}),t(i)}function a(i){let o=[];e.forEach(l=>{l.Heading.toLowerCase().includes(i.toLowerCase())&&o.push(l)}),t(o)}return A.jsxs(A.Fragment,{children:[A.jsx("h1",{children:"Dashboard:"}),A.jsx("p",{children:"A page displaying all the different features of the website. Find out more about each feature by clicking the link on its card or using the navigation bar."}),A.jsx("hr",{}),A.jsx(iy,{placeholder:"Search dashboard by feature title...",onChange:i=>{r(i.target.value)}}),A.jsx("div",{className:"test",children:A.jsx("div",{className:"cardContainer",children:e.length===0?A.jsx("p",{children:"Search term not found... Maybe try search by heading of each card..."}):e.map((i,o)=>A.jsx(A.Fragment,{children:A.jsx(she,{feature:i},o)}))})})]})},she=({feature:e})=>A.jsx(A.Fragment,{children:A.jsxs("div",{className:"dashCard",children:[A.jsx("h3",{children:e.Heading}),A.jsx("img",{src:e.Image,alt:"Picture",loading:"lazy"}),A.jsxs("p",{children:[A.jsx("b",{children:"Summary:"})," ",e.Summary]}),A.jsx(Qo,{to:e.Link,children:"Click to view"})]})}),iy=e=>A.jsxs("div",{id:"searchBarContainer",children:[A.jsx("input",{type:"text",id:"searchBar",placeholder:e.placeholder,onChange:e.onChange,maxLength:37}),A.jsx(Kde,{id:"searchIcon"})]}),x0=e=>{var n,r;const t=Z.useRef(null);return e.dialogShow?(n=t.current)==null||n.showModal():(r=t.current)==null||r.close(),A.jsx(A.Fragment,{children:A.jsx("dialog",{id:"confirmationDialog",ref:t,children:A.jsxs("div",{id:"dialogDiv",children:[A.jsx("h3",{children:e.header}),A.jsx("br",{}),A.jsxs("div",{id:"logoutButtons",children:[e.dialogConfirmation!="understand"&&A.jsxs(A.Fragment,{children:[A.jsx("button",{type:"submit",id:"dialogConfirmBtn",className:"dialogBtn",onClick:()=>{e.dialogConfirmation==="manualPrediction"?e.onManualPrediction():e.onConfirm()},children:"Confirm"}),A.jsx("button",{type:"button",id:"dialogCancelBtn",className:"dialogBtn",onClick:()=>{e.onCancel()},children:"Cancel"})]}),e.dialogConfirmation==="understand"&&A.jsx("button",{type:"button",id:"dialogUnderstoodBtn",className:"dialogBtn",onClick:()=>{e.onUnderstand()},children:"I understand"})]})]})})})};function ahe(e){return Dr({tag:"svg",attr:{fill:"currentColor",viewBox:"0 0 16 16"},child:[{tag:"path",attr:{fillRule:"evenodd",d:"M10.961 12.365a1.99 1.99 0 0 0 .522-1.103l3.11 1.382A1 1 0 0 0 16 11.731V4.269a1 1 0 0 0-1.406-.913l-3.111 1.382A2 2 0 0 0 9.5 3H4.272l.714 1H9.5a1 1 0 0 1 1 1v6a1 1 0 0 1-.144.518l.605.847zM1.428 4.18A.999.999 0 0 0 1 5v6a1 1 0 0 0 1 1h5.014l.714 1H2a2 2 0 0 1-2-2V5c0-.675.334-1.272.847-1.634l.58.814zM15 11.73l-3.5-1.555v-4.35L15 4.269v7.462zm-4.407 3.56-10-14 .814-.58 10 14-.814.58z"}}]})(e)}const pg=Math.min,uh=Math.max,rS=Math.round,xk=Math.floor,Ec=e=>({x:e,y:e}),ihe={left:"right",right:"left",bottom:"top",top:"bottom"},ohe={start:"end",end:"start"};function X_(e,t,n){return uh(e,pg(t,n))}function w0(e,t){return typeof e=="function"?e(t):e}function Nh(e){return e.split("-")[0]}function k0(e){return e.split("-")[1]}function jH(e){return e==="x"?"y":"x"}function oO(e){return e==="y"?"height":"width"}function VI(e){return["top","bottom"].includes(Nh(e))?"y":"x"}function lO(e){return jH(VI(e))}function lhe(e,t,n){n===void 0&&(n=!1);const r=k0(e),s=lO(e),a=oO(s);let i=s==="x"?r===(n?"end":"start")?"right":"left":r==="start"?"bottom":"top";return t.reference[a]>t.floating[a]&&(i=sS(i)),[i,sS(i)]}function uhe(e){const t=sS(e);return[Y_(e),t,Y_(t)]}function Y_(e){return e.replace(/start|end/g,t=>ohe[t])}function che(e,t,n){const r=["left","right"],s=["right","left"],a=["top","bottom"],i=["bottom","top"];switch(e){case"top":case"bottom":return n?t?s:r:t?r:s;case"left":case"right":return t?a:i;default:return[]}}function dhe(e,t,n,r){const s=k0(e);let a=che(Nh(e),n==="start",r);return s&&(a=a.map(i=>i+"-"+s),t&&(a=a.concat(a.map(Y_)))),a}function sS(e){return e.replace(/left|right|bottom|top/g,t=>ihe[t])}function hhe(e){return{top:0,right:0,bottom:0,left:0,...e}}function GH(e){return typeof e!="number"?hhe(e):{top:e,right:e,bottom:e,left:e}}function aS(e){return{...e,top:e.y,left:e.x,right:e.x+e.width,bottom:e.y+e.height}}function IW(e,t,n){let{reference:r,floating:s}=e;const a=VI(t),i=lO(t),o=oO(i),l=Nh(t),u=a==="y",c=r.x+r.width/2-s.width/2,d=r.y+r.height/2-s.height/2,h=r[o]/2-s[o]/2;let p;switch(l){case"top":p={x:c,y:r.y-s.height};break;case"bottom":p={x:c,y:r.y+r.height};break;case"right":p={x:r.x+r.width,y:d};break;case"left":p={x:r.x-s.width,y:d};break;default:p={x:r.x,y:r.y}}switch(k0(t)){case"start":p[i]-=h*(n&&u?-1:1);break;case"end":p[i]+=h*(n&&u?-1:1);break}return p}const phe=async(e,t,n)=>{const{placement:r="bottom",strategy:s="absolute",middleware:a=[],platform:i}=n,o=a.filter(Boolean),l=await(i.isRTL==null?void 0:i.isRTL(t));let u=await i.getElementRects({reference:e,floating:t,strategy:s}),{x:c,y:d}=IW(u,r,l),h=r,p={},f=0;for(let m=0;m<o.length;m++){const{name:g,fn:y}=o[m],{x:b,y:x,data:v,reset:w}=await y({x:c,y:d,initialPlacement:r,placement:h,strategy:s,middlewareData:p,rects:u,platform:i,elements:{reference:e,floating:t}});c=b??c,d=x??d,p={...p,[g]:{...p[g],...v}},w&&f<=50&&(f++,typeof w=="object"&&(w.placement&&(h=w.placement),w.rects&&(u=w.rects===!0?await i.getElementRects({reference:e,floating:t,strategy:s}):w.rects),{x:c,y:d}=IW(u,h,l)),m=-1)}return{x:c,y:d,placement:h,strategy:s,middlewareData:p}};async function HH(e,t){var n;t===void 0&&(t={});const{x:r,y:s,platform:a,rects:i,elements:o,strategy:l}=e,{boundary:u="clippingAncestors",rootBoundary:c="viewport",elementContext:d="floating",altBoundary:h=!1,padding:p=0}=w0(t,e),f=GH(p),g=o[h?d==="floating"?"reference":"floating":d],y=aS(await a.getClippingRect({element:(n=await(a.isElement==null?void 0:a.isElement(g)))==null||n?g:g.contextElement||await(a.getDocumentElement==null?void 0:a.getDocumentElement(o.floating)),boundary:u,rootBoundary:c,strategy:l})),b=d==="floating"?{...i.floating,x:r,y:s}:i.reference,x=await(a.getOffsetParent==null?void 0:a.getOffsetParent(o.floating)),v=await(a.isElement==null?void 0:a.isElement(x))?await(a.getScale==null?void 0:a.getScale(x))||{x:1,y:1}:{x:1,y:1},w=aS(a.convertOffsetParentRelativeRectToViewportRelativeRect?await a.convertOffsetParentRelativeRectToViewportRelativeRect({elements:o,rect:b,offsetParent:x,strategy:l}):b);return{top:(y.top-w.top+f.top)/v.y,bottom:(w.bottom-y.bottom+f.bottom)/v.y,left:(y.left-w.left+f.left)/v.x,right:(w.right-y.right+f.right)/v.x}}const fhe=e=>({name:"arrow",options:e,async fn(t){const{x:n,y:r,placement:s,rects:a,platform:i,elements:o,middlewareData:l}=t,{element:u,padding:c=0}=w0(e,t)||{};if(u==null)return{};const d=GH(c),h={x:n,y:r},p=lO(s),f=oO(p),m=await i.getDimensions(u),g=p==="y",y=g?"top":"left",b=g?"bottom":"right",x=g?"clientHeight":"clientWidth",v=a.reference[f]+a.reference[p]-h[p]-a.floating[f],w=h[p]-a.reference[p],k=await(i.getOffsetParent==null?void 0:i.getOffsetParent(u));let S=k?k[x]:0;(!S||!await(i.isElement==null?void 0:i.isElement(k)))&&(S=o.floating[x]||a.floating[f]);const I=v/2-w/2,$=S/2-m[f]/2-1,C=pg(d[y],$),T=pg(d[b],$),N=C,E=S-m[f]-T,_=S/2-m[f]/2+I,R=X_(N,_,E),z=!l.arrow&&k0(s)!=null&&_!==R&&a.reference[f]/2-(_<N?C:T)-m[f]/2<0,W=z?_<N?_-N:_-E:0;return{[p]:h[p]+W,data:{[p]:R,centerOffset:_-R-W,...z&&{alignmentOffset:W}},reset:z}}}),mhe=function(e){return e===void 0&&(e={}),{name:"flip",options:e,async fn(t){var n,r;const{placement:s,middlewareData:a,rects:i,initialPlacement:o,platform:l,elements:u}=t,{mainAxis:c=!0,crossAxis:d=!0,fallbackPlacements:h,fallbackStrategy:p="bestFit",fallbackAxisSideDirection:f="none",flipAlignment:m=!0,...g}=w0(e,t);if((n=a.arrow)!=null&&n.alignmentOffset)return{};const y=Nh(s),b=Nh(o)===o,x=await(l.isRTL==null?void 0:l.isRTL(u.floating)),v=h||(b||!m?[sS(o)]:uhe(o));!h&&f!=="none"&&v.push(...dhe(o,m,f,x));const w=[o,...v],k=await HH(t,g),S=[];let I=((r=a.flip)==null?void 0:r.overflows)||[];if(c&&S.push(k[y]),d){const N=lhe(s,i,x);S.push(k[N[0]],k[N[1]])}if(I=[...I,{placement:s,overflows:S}],!S.every(N=>N<=0)){var $,C;const N=((($=a.flip)==null?void 0:$.index)||0)+1,E=w[N];if(E)return{data:{index:N,overflows:I},reset:{placement:E}};let _=(C=I.filter(R=>R.overflows[0]<=0).sort((R,z)=>R.overflows[1]-z.overflows[1])[0])==null?void 0:C.placement;if(!_)switch(p){case"bestFit":{var T;const R=(T=I.map(z=>[z.placement,z.overflows.filter(W=>W>0).reduce((W,F)=>W+F,0)]).sort((z,W)=>z[1]-W[1])[0])==null?void 0:T[0];R&&(_=R);break}case"initialPlacement":_=o;break}if(s!==_)return{reset:{placement:_}}}return{}}}};async function ghe(e,t){const{placement:n,platform:r,elements:s}=e,a=await(r.isRTL==null?void 0:r.isRTL(s.floating)),i=Nh(n),o=k0(n),l=VI(n)==="y",u=["left","top"].includes(i)?-1:1,c=a&&l?-1:1,d=w0(t,e);let{mainAxis:h,crossAxis:p,alignmentAxis:f}=typeof d=="number"?{mainAxis:d,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...d};return o&&typeof f=="number"&&(p=o==="end"?f*-1:f),l?{x:p*c,y:h*u}:{x:h*u,y:p*c}}const yhe=function(e){return e===void 0&&(e=0),{name:"offset",options:e,async fn(t){var n,r;const{x:s,y:a,placement:i,middlewareData:o}=t,l=await ghe(t,e);return i===((n=o.offset)==null?void 0:n.placement)&&(r=o.arrow)!=null&&r.alignmentOffset?{}:{x:s+l.x,y:a+l.y,data:{...l,placement:i}}}}},bhe=function(e){return e===void 0&&(e={}),{name:"shift",options:e,async fn(t){const{x:n,y:r,placement:s}=t,{mainAxis:a=!0,crossAxis:i=!1,limiter:o={fn:g=>{let{x:y,y:b}=g;return{x:y,y:b}}},...l}=w0(e,t),u={x:n,y:r},c=await HH(t,l),d=VI(Nh(s)),h=jH(d);let p=u[h],f=u[d];if(a){const g=h==="y"?"top":"left",y=h==="y"?"bottom":"right",b=p+c[g],x=p-c[y];p=X_(b,p,x)}if(i){const g=d==="y"?"top":"left",y=d==="y"?"bottom":"right",b=f+c[g],x=f-c[y];f=X_(b,f,x)}const m=o.fn({...t,[h]:p,[d]:f});return{...m,data:{x:m.x-n,y:m.y-r}}}}};function _c(e){return qH(e)?(e.nodeName||"").toLowerCase():"#document"}function gi(e){var t;return(e==null||(t=e.ownerDocument)==null?void 0:t.defaultView)||window}function ku(e){var t;return(t=(qH(e)?e.ownerDocument:e.document)||window.document)==null?void 0:t.documentElement}function qH(e){return e instanceof Node||e instanceof gi(e).Node}function hu(e){return e instanceof Element||e instanceof gi(e).Element}function _l(e){return e instanceof HTMLElement||e instanceof gi(e).HTMLElement}function CW(e){return typeof ShadowRoot>"u"?!1:e instanceof ShadowRoot||e instanceof gi(e).ShadowRoot}function S0(e){const{overflow:t,overflowX:n,overflowY:r,display:s}=Yi(e);return/auto|scroll|overlay|hidden|clip/.test(t+r+n)&&!["inline","contents"].includes(s)}function vhe(e){return["table","td","th"].includes(_c(e))}function uO(e){const t=cO(),n=Yi(e);return n.transform!=="none"||n.perspective!=="none"||(n.containerType?n.containerType!=="normal":!1)||!t&&(n.backdropFilter?n.backdropFilter!=="none":!1)||!t&&(n.filter?n.filter!=="none":!1)||["transform","perspective","filter"].some(r=>(n.willChange||"").includes(r))||["paint","layout","strict","content"].some(r=>(n.contain||"").includes(r))}function xhe(e){let t=fg(e);for(;_l(t)&&!UI(t);){if(uO(t))return t;t=fg(t)}return null}function cO(){return typeof CSS>"u"||!CSS.supports?!1:CSS.supports("-webkit-backdrop-filter","none")}function UI(e){return["html","body","#document"].includes(_c(e))}function Yi(e){return gi(e).getComputedStyle(e)}function jI(e){return hu(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.pageXOffset,scrollTop:e.pageYOffset}}function fg(e){if(_c(e)==="html")return e;const t=e.assignedSlot||e.parentNode||CW(e)&&e.host||ku(e);return CW(t)?t.host:t}function KH(e){const t=fg(e);return UI(t)?e.ownerDocument?e.ownerDocument.body:e.body:_l(t)&&S0(t)?t:KH(t)}function R1(e,t,n){var r;t===void 0&&(t=[]),n===void 0&&(n=!0);const s=KH(e),a=s===((r=e.ownerDocument)==null?void 0:r.body),i=gi(s);return a?t.concat(i,i.visualViewport||[],S0(s)?s:[],i.frameElement&&n?R1(i.frameElement):[]):t.concat(s,R1(s,[],n))}function XH(e){const t=Yi(e);let n=parseFloat(t.width)||0,r=parseFloat(t.height)||0;const s=_l(e),a=s?e.offsetWidth:n,i=s?e.offsetHeight:r,o=rS(n)!==a||rS(r)!==i;return o&&(n=a,r=i),{width:n,height:r,$:o}}function dO(e){return hu(e)?e:e.contextElement}function qm(e){const t=dO(e);if(!_l(t))return Ec(1);const n=t.getBoundingClientRect(),{width:r,height:s,$:a}=XH(t);let i=(a?rS(n.width):n.width)/r,o=(a?rS(n.height):n.height)/s;return(!i||!Number.isFinite(i))&&(i=1),(!o||!Number.isFinite(o))&&(o=1),{x:i,y:o}}const whe=Ec(0);function YH(e){const t=gi(e);return!cO()||!t.visualViewport?whe:{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}}function khe(e,t,n){return t===void 0&&(t=!1),!n||t&&n!==gi(e)?!1:t}function Th(e,t,n,r){t===void 0&&(t=!1),n===void 0&&(n=!1);const s=e.getBoundingClientRect(),a=dO(e);let i=Ec(1);t&&(r?hu(r)&&(i=qm(r)):i=qm(e));const o=khe(a,n,r)?YH(a):Ec(0);let l=(s.left+o.x)/i.x,u=(s.top+o.y)/i.y,c=s.width/i.x,d=s.height/i.y;if(a){const h=gi(a),p=r&&hu(r)?gi(r):r;let f=h,m=f.frameElement;for(;m&&r&&p!==f;){const g=qm(m),y=m.getBoundingClientRect(),b=Yi(m),x=y.left+(m.clientLeft+parseFloat(b.paddingLeft))*g.x,v=y.top+(m.clientTop+parseFloat(b.paddingTop))*g.y;l*=g.x,u*=g.y,c*=g.x,d*=g.y,l+=x,u+=v,f=gi(m),m=f.frameElement}}return aS({width:c,height:d,x:l,y:u})}const She=[":popover-open",":modal"];function JH(e){return She.some(t=>{try{return e.matches(t)}catch{return!1}})}function Ihe(e){let{elements:t,rect:n,offsetParent:r,strategy:s}=e;const a=s==="fixed",i=ku(r),o=t?JH(t.floating):!1;if(r===i||o&&a)return n;let l={scrollLeft:0,scrollTop:0},u=Ec(1);const c=Ec(0),d=_l(r);if((d||!d&&!a)&&((_c(r)!=="body"||S0(i))&&(l=jI(r)),_l(r))){const h=Th(r);u=qm(r),c.x=h.x+r.clientLeft,c.y=h.y+r.clientTop}return{width:n.width*u.x,height:n.height*u.y,x:n.x*u.x-l.scrollLeft*u.x+c.x,y:n.y*u.y-l.scrollTop*u.y+c.y}}function Che(e){return Array.from(e.getClientRects())}function ZH(e){return Th(ku(e)).left+jI(e).scrollLeft}function Nhe(e){const t=ku(e),n=jI(e),r=e.ownerDocument.body,s=uh(t.scrollWidth,t.clientWidth,r.scrollWidth,r.clientWidth),a=uh(t.scrollHeight,t.clientHeight,r.scrollHeight,r.clientHeight);let i=-n.scrollLeft+ZH(e);const o=-n.scrollTop;return Yi(r).direction==="rtl"&&(i+=uh(t.clientWidth,r.clientWidth)-s),{width:s,height:a,x:i,y:o}}function The(e,t){const n=gi(e),r=ku(e),s=n.visualViewport;let a=r.clientWidth,i=r.clientHeight,o=0,l=0;if(s){a=s.width,i=s.height;const u=cO();(!u||u&&t==="fixed")&&(o=s.offsetLeft,l=s.offsetTop)}return{width:a,height:i,x:o,y:l}}function $he(e,t){const n=Th(e,!0,t==="fixed"),r=n.top+e.clientTop,s=n.left+e.clientLeft,a=_l(e)?qm(e):Ec(1),i=e.clientWidth*a.x,o=e.clientHeight*a.y,l=s*a.x,u=r*a.y;return{width:i,height:o,x:l,y:u}}function NW(e,t,n){let r;if(t==="viewport")r=The(e,n);else if(t==="document")r=Nhe(ku(e));else if(hu(t))r=$he(t,n);else{const s=YH(e);r={...t,x:t.x-s.x,y:t.y-s.y}}return aS(r)}function QH(e,t){const n=fg(e);return n===t||!hu(n)||UI(n)?!1:Yi(n).position==="fixed"||QH(n,t)}function Ehe(e,t){const n=t.get(e);if(n)return n;let r=R1(e,[],!1).filter(o=>hu(o)&&_c(o)!=="body"),s=null;const a=Yi(e).position==="fixed";let i=a?fg(e):e;for(;hu(i)&&!UI(i);){const o=Yi(i),l=uO(i);!l&&o.position==="fixed"&&(s=null),(a?!l&&!s:!l&&o.position==="static"&&!!s&&["absolute","fixed"].includes(s.position)||S0(i)&&!l&&QH(e,i))?r=r.filter(c=>c!==i):s=o,i=fg(i)}return t.set(e,r),r}function _he(e){let{element:t,boundary:n,rootBoundary:r,strategy:s}=e;const i=[...n==="clippingAncestors"?Ehe(t,this._c):[].concat(n),r],o=i[0],l=i.reduce((u,c)=>{const d=NW(t,c,s);return u.top=uh(d.top,u.top),u.right=pg(d.right,u.right),u.bottom=pg(d.bottom,u.bottom),u.left=uh(d.left,u.left),u},NW(t,o,s));return{width:l.right-l.left,height:l.bottom-l.top,x:l.left,y:l.top}}function Ahe(e){const{width:t,height:n}=XH(e);return{width:t,height:n}}function Rhe(e,t,n){const r=_l(t),s=ku(t),a=n==="fixed",i=Th(e,!0,a,t);let o={scrollLeft:0,scrollTop:0};const l=Ec(0);if(r||!r&&!a)if((_c(t)!=="body"||S0(s))&&(o=jI(t)),r){const d=Th(t,!0,a,t);l.x=d.x+t.clientLeft,l.y=d.y+t.clientTop}else s&&(l.x=ZH(s));const u=i.left+o.scrollLeft-l.x,c=i.top+o.scrollTop-l.y;return{x:u,y:c,width:i.width,height:i.height}}function TW(e,t){return!_l(e)||Yi(e).position==="fixed"?null:t?t(e):e.offsetParent}function e8(e,t){const n=gi(e);if(!_l(e)||JH(e))return n;let r=TW(e,t);for(;r&&vhe(r)&&Yi(r).position==="static";)r=TW(r,t);return r&&(_c(r)==="html"||_c(r)==="body"&&Yi(r).position==="static"&&!uO(r))?n:r||xhe(e)||n}const Dhe=async function(e){const t=this.getOffsetParent||e8,n=this.getDimensions;return{reference:Rhe(e.reference,await t(e.floating),e.strategy),floating:{x:0,y:0,...await n(e.floating)}}};function Ohe(e){return Yi(e).direction==="rtl"}const Fhe={convertOffsetParentRelativeRectToViewportRelativeRect:Ihe,getDocumentElement:ku,getClippingRect:_he,getOffsetParent:e8,getElementRects:Dhe,getClientRects:Che,getDimensions:Ahe,getScale:qm,isElement:hu,isRTL:Ohe};function Mhe(e,t){let n=null,r;const s=ku(e);function a(){var o;clearTimeout(r),(o=n)==null||o.disconnect(),n=null}function i(o,l){o===void 0&&(o=!1),l===void 0&&(l=1),a();const{left:u,top:c,width:d,height:h}=e.getBoundingClientRect();if(o||t(),!d||!h)return;const p=xk(c),f=xk(s.clientWidth-(u+d)),m=xk(s.clientHeight-(c+h)),g=xk(u),b={rootMargin:-p+"px "+-f+"px "+-m+"px "+-g+"px",threshold:uh(0,pg(1,l))||1};let x=!0;function v(w){const k=w[0].intersectionRatio;if(k!==l){if(!x)return i();k?i(!1,k):r=setTimeout(()=>{i(!1,1e-7)},100)}x=!1}try{n=new IntersectionObserver(v,{...b,root:s.ownerDocument})}catch{n=new IntersectionObserver(v,b)}n.observe(e)}return i(!0),a}function Phe(e,t,n,r){r===void 0&&(r={});const{ancestorScroll:s=!0,ancestorResize:a=!0,elementResize:i=typeof ResizeObserver=="function",layoutShift:o=typeof IntersectionObserver=="function",animationFrame:l=!1}=r,u=dO(e),c=s||a?[...u?R1(u):[],...R1(t)]:[];c.forEach(y=>{s&&y.addEventListener("scroll",n,{passive:!0}),a&&y.addEventListener("resize",n)});const d=u&&o?Mhe(u,n):null;let h=-1,p=null;i&&(p=new ResizeObserver(y=>{let[b]=y;b&&b.target===u&&p&&(p.unobserve(t),cancelAnimationFrame(h),h=requestAnimationFrame(()=>{var x;(x=p)==null||x.observe(t)})),n()}),u&&!l&&p.observe(u),p.observe(t));let f,m=l?Th(e):null;l&&g();function g(){const y=Th(e);m&&(y.x!==m.x||y.y!==m.y||y.width!==m.width||y.height!==m.height)&&n(),m=y,f=requestAnimationFrame(g)}return n(),()=>{var y;c.forEach(b=>{s&&b.removeEventListener("scroll",n),a&&b.removeEventListener("resize",n)}),d==null||d(),(y=p)==null||y.disconnect(),p=null,l&&cancelAnimationFrame(f)}}const Lhe=bhe,zhe=mhe,Bhe=fhe,$W=(e,t,n)=>{const r=new Map,s={platform:Fhe,...n},a={...s.platform,_c:r};return phe(e,t,{...s,platform:a})};var t8={exports:{}};/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/(function(e){(function(){var t={}.hasOwnProperty;function n(){for(var a="",i=0;i<arguments.length;i++){var o=arguments[i];o&&(a=s(a,r(o)))}return a}function r(a){if(typeof a=="string"||typeof a=="number")return a;if(typeof a!="object")return"";if(Array.isArray(a))return n.apply(null,a);if(a.toString!==Object.prototype.toString&&!a.toString.toString().includes("[native code]"))return a.toString();var i="";for(var o in a)t.call(a,o)&&a[o]&&(i=s(i,o));return i}function s(a,i){return i?a?a+" "+i:a+i:a}e.exports?(n.default=n,e.exports=n):window.classNames=n})()})(t8);var Whe=t8.exports;const J_=ey(Whe);/*
* React Tooltip
* {@link https://github.com/ReactTooltip/react-tooltip}
* @copyright ReactTooltip Team
* @license MIT
*/const Vhe="react-tooltip-core-styles",Uhe="react-tooltip-base-styles",EW={core:!1,base:!1};function _W({css:e,id:t=Uhe,type:n="base",ref:r}){var s,a;if(!e||typeof document>"u"||EW[n]||n==="core"&&typeof process<"u"&&(!((s=process==null?void 0:process.env)===null||s===void 0)&&s.REACT_TOOLTIP_DISABLE_CORE_STYLES)||n!=="base"&&typeof process<"u"&&(!((a=process==null?void 0:process.env)===null||a===void 0)&&a.REACT_TOOLTIP_DISABLE_BASE_STYLES))return;n==="core"&&(t=Vhe),r||(r={});const{insertAt:i}=r;if(document.getElementById(t))return void console.warn(`[react-tooltip] Element with id '${t}' already exists. Call \`removeStyle()\` first`);const o=document.head||document.getElementsByTagName("head")[0],l=document.createElement("style");l.id=t,l.type="text/css",i==="top"&&o.firstChild?o.insertBefore(l,o.firstChild):o.appendChild(l),l.styleSheet?l.styleSheet.cssText=e:l.appendChild(document.createTextNode(e)),EW[n]=!0}const AW=async({elementReference:e=null,tooltipReference:t=null,tooltipArrowReference:n=null,place:r="top",offset:s=10,strategy:a="absolute",middlewares:i=[yhe(Number(s)),zhe({fallbackAxisSideDirection:"start"}),Lhe({padding:5})],border:o})=>{if(!e)return{tooltipStyles:{},tooltipArrowStyles:{},place:r};if(t===null)return{tooltipStyles:{},tooltipArrowStyles:{},place:r};const l=i;return n?(l.push(Bhe({element:n,padding:5})),$W(e,t,{placement:r,strategy:a,middleware:l}).then(({x:u,y:c,placement:d,middlewareData:h})=>{var p,f;const m={left:`${u}px`,top:`${c}px`,border:o},{x:g,y}=(p=h.arrow)!==null&&p!==void 0?p:{x:0,y:0},b=(f={top:"bottom",right:"left",bottom:"top",left:"right"}[d.split("-")[0]])!==null&&f!==void 0?f:"bottom",x=o&&{borderBottom:o,borderRight:o};let v=0;if(o){const w=`${o}`.match(/(\d+)px/);v=w!=null&&w[1]?Number(w[1]):1}return{tooltipStyles:m,tooltipArrowStyles:{left:g!=null?`${g}px`:"",top:y!=null?`${y}px`:"",right:"",bottom:"",...x,[b]:`-${4+v}px`},place:d}})):$W(e,t,{placement:"bottom",strategy:a,middleware:l}).then(({x:u,y:c,placement:d})=>({tooltipStyles:{left:`${u}px`,top:`${c}px`},tooltipArrowStyles:{},place:d}))},RW=(e,t)=>!("CSS"in window&&"supports"in window.CSS)||window.CSS.supports(e,t),DW=(e,t,n)=>{let r=null;const s=function(...a){const i=()=>{r=null,n||e.apply(this,a)};n&&!r&&(e.apply(this,a),r=setTimeout(i,t)),n||(r&&clearTimeout(r),r=setTimeout(i,t))};return s.cancel=()=>{r&&(clearTimeout(r),r=null)},s},OW=e=>e!==null&&!Array.isArray(e)&&typeof e=="object",Z_=(e,t)=>{if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t))return e.length===t.length&&e.every((s,a)=>Z_(s,t[a]));if(Array.isArray(e)!==Array.isArray(t))return!1;if(!OW(e)||!OW(t))return e===t;const n=Object.keys(e),r=Object.keys(t);return n.length===r.length&&n.every(s=>Z_(e[s],t[s]))},jhe=e=>{if(!(e instanceof HTMLElement||e instanceof SVGElement))return!1;const t=getComputedStyle(e);return["overflow","overflow-x","overflow-y"].some(n=>{const r=t.getPropertyValue(n);return r==="auto"||r==="scroll"})},FW=e=>{if(!e)return null;let t=e.parentElement;for(;t;){if(jhe(t))return t;t=t.parentElement}return document.scrollingElement||document.documentElement},Ghe=typeof window<"u"?Z.useLayoutEffect:Z.useEffect,Hhe="DEFAULT_TOOLTIP_ID",qhe={anchorRefs:new Set,activeAnchor:{current:null},attach:()=>{},detach:()=>{},setActiveAnchor:()=>{}},Khe=Z.createContext({getTooltipData:()=>qhe});function n8(e=Hhe){return Z.useContext(Khe).getTooltipData(e)}var cm={tooltip:"core-styles-module_tooltip__3vRRp",fixed:"core-styles-module_fixed__pcSol",arrow:"core-styles-module_arrow__cvMwQ",noArrow:"core-styles-module_noArrow__xock6",clickable:"core-styles-module_clickable__ZuTTB",show:"core-styles-module_show__Nt9eE",closing:"core-styles-module_closing__sGnxF"},J$={tooltip:"styles-module_tooltip__mnnfp",arrow:"styles-module_arrow__K0L3T",dark:"styles-module_dark__xNqje",light:"styles-module_light__Z6W-X",success:"styles-module_success__A2AKt",warning:"styles-module_warning__SCK0X",error:"styles-module_error__JvumD",info:"styles-module_info__BWdHW"};const Xhe=({forwardRef:e,id:t,className:n,classNameArrow:r,variant:s="dark",anchorId:a,anchorSelect:i,place:o="top",offset:l=10,events:u=["hover"],openOnClick:c=!1,positionStrategy:d="absolute",middlewares:h,wrapper:p,delayShow:f=0,delayHide:m=0,float:g=!1,hidden:y=!1,noArrow:b=!1,clickable:x=!1,closeOnEsc:v=!1,closeOnScroll:w=!1,closeOnResize:k=!1,openEvents:S,closeEvents:I,globalCloseEvents:$,imperativeModeOnly:C,style:T,position:N,afterShow:E,afterHide:_,content:R,contentWrapperRef:z,isOpen:W,defaultIsOpen:F=!1,setIsOpen:L,activeAnchor:O,setActiveAnchor:D,border:B,opacity:V,arrowColor:K,role:G="tooltip"})=>{var U;const q=Z.useRef(null),Q=Z.useRef(null),ee=Z.useRef(null),ae=Z.useRef(null),ye=Z.useRef(null),[j,ce]=Z.useState({tooltipStyles:{},tooltipArrowStyles:{},place:o}),[be,ke]=Z.useState(!1),[Ae,Pe]=Z.useState(!1),[ie,Te]=Z.useState(null),Le=Z.useRef(!1),$e=Z.useRef(null),{anchorRefs:ge,setActiveAnchor:ve}=n8(t),pe=Z.useRef(!1),[Ie,ze]=Z.useState([]),Ye=Z.useRef(!1),Je=c||u.includes("click"),Ke=Je||(S==null?void 0:S.click)||(S==null?void 0:S.dblclick)||(S==null?void 0:S.mousedown),Ue=S?{...S}:{mouseenter:!0,focus:!0,click:!1,dblclick:!1,mousedown:!1};!S&&Je&&Object.assign(Ue,{mouseenter:!1,focus:!1,click:!0});const Xe=I?{...I}:{mouseleave:!0,blur:!0,click:!1,dblclick:!1,mouseup:!1};!I&&Je&&Object.assign(Xe,{mouseleave:!1,blur:!1});const ut=$?{...$}:{escape:v||!1,scroll:w||!1,resize:k||!1,clickOutsideAnchor:Ke||!1};C&&(Object.assign(Ue,{mouseenter:!1,focus:!1,click:!1,dblclick:!1,mousedown:!1}),Object.assign(Xe,{mouseleave:!1,blur:!1,click:!1,dblclick:!1,mouseup:!1}),Object.assign(ut,{escape:!1,scroll:!1,resize:!1,clickOutsideAnchor:!1})),Ghe(()=>(Ye.current=!0,()=>{Ye.current=!1}),[]);const vt=Re=>{Ye.current&&(Re&&Pe(!0),setTimeout(()=>{Ye.current&&(L==null||L(Re),W===void 0&&ke(Re))},10))};Z.useEffect(()=>{if(W===void 0)return()=>null;W&&Pe(!0);const Re=setTimeout(()=>{ke(W)},10);return()=>{clearTimeout(Re)}},[W]),Z.useEffect(()=>{if(be!==Le.current)if(ye.current&&clearTimeout(ye.current),Le.current=be,be)E==null||E();else{const Re=(rt=>{const lt=rt.match(/^([\d.]+)(ms|s)$/);if(!lt)return 0;const[,xt,yt]=lt;return Number(xt)*(yt==="ms"?1:1e3)})(getComputedStyle(document.body).getPropertyValue("--rt-transition-show-delay"));ye.current=setTimeout(()=>{Pe(!1),Te(null),_==null||_()},Re+25)}},[be]);const An=Re=>{ce(rt=>Z_(rt,Re)?rt:Re)},Rt=(Re=f)=>{ee.current&&clearTimeout(ee.current),Ae?vt(!0):ee.current=setTimeout(()=>{vt(!0)},Re)},Bs=(Re=m)=>{ae.current&&clearTimeout(ae.current),ae.current=setTimeout(()=>{pe.current||vt(!1)},Re)},Un=Re=>{var rt;if(!Re)return;const lt=(rt=Re.currentTarget)!==null&&rt!==void 0?rt:Re.target;if(!(lt!=null&&lt.isConnected))return D(null),void ve({current:null});f?Rt():vt(!0),D(lt),ve({current:lt}),ae.current&&clearTimeout(ae.current)},si=()=>{x?Bs(m||100):m?Bs():vt(!1),ee.current&&clearTimeout(ee.current)},_a=({x:Re,y:rt})=>{var lt;const xt={getBoundingClientRect:()=>({x:Re,y:rt,width:0,height:0,top:rt,left:Re,right:Re,bottom:rt})};AW({place:(lt=ie==null?void 0:ie.place)!==null&&lt!==void 0?lt:o,offset:l,elementReference:xt,tooltipReference:q.current,tooltipArrowReference:Q.current,strategy:d,middlewares:h,border:B}).then(yt=>{An(yt)})},pr=Re=>{if(!Re)return;const rt=Re,lt={x:rt.clientX,y:rt.clientY};_a(lt),$e.current=lt},Aa=Re=>{var rt;if(!be)return;const lt=Re.target;lt.isConnected&&(!((rt=q.current)===null||rt===void 0)&&rt.contains(lt)||[document.querySelector(`[id='${a}']`),...Ie].some(xt=>xt==null?void 0:xt.contains(lt))||(vt(!1),ee.current&&clearTimeout(ee.current)))},jl=DW(Un,50,!0),Ln=DW(si,50,!0),Mr=Re=>{Ln.cancel(),jl(Re)},It=()=>{jl.cancel(),Ln()},Ce=Z.useCallback(()=>{var Re,rt;const lt=(Re=ie==null?void 0:ie.position)!==null&&Re!==void 0?Re:N;lt?_a(lt):g?$e.current&&_a($e.current):O!=null&&O.isConnected&&AW({place:(rt=ie==null?void 0:ie.place)!==null&&rt!==void 0?rt:o,offset:l,elementReference:O,tooltipReference:q.current,tooltipArrowReference:Q.current,strategy:d,middlewares:h,border:B}).then(xt=>{Ye.current&&An(xt)})},[be,O,R,T,o,ie==null?void 0:ie.place,l,d,N,ie==null?void 0:ie.position,g]);Z.useEffect(()=>{var Re,rt;const lt=new Set(ge);Ie.forEach($n=>{lt.add({current:$n})});const xt=document.querySelector(`[id='${a}']`);xt&&lt.add({current:xt});const yt=()=>{vt(!1)},on=FW(O),Qn=FW(q.current);ut.scroll&&(window.addEventListener("scroll",yt),on==null||on.addEventListener("scroll",yt),Qn==null||Qn.addEventListener("scroll",yt));let jn=null;ut.resize?window.addEventListener("resize",yt):O&&q.current&&(jn=Phe(O,q.current,Ce,{ancestorResize:!0,elementResize:!0,layoutShift:!0}));const Es=$n=>{$n.key==="Escape"&&vt(!1)};ut.escape&&window.addEventListener("keydown",Es),ut.clickOutsideAnchor&&window.addEventListener("click",Aa);const hn=[],Ko=$n=>{be&&($n==null?void 0:$n.target)===O||Un($n)},ms=$n=>{be&&($n==null?void 0:$n.target)===O&&si()},lo=["mouseenter","mouseleave","focus","blur"],_d=["click","dblclick","mousedown","mouseup"];Object.entries(Ue).forEach(([$n,uo])=>{uo&&(lo.includes($n)?hn.push({event:$n,listener:Mr}):_d.includes($n)&&hn.push({event:$n,listener:Ko}))}),Object.entries(Xe).forEach(([$n,uo])=>{uo&&(lo.includes($n)?hn.push({event:$n,listener:It}):_d.includes($n)&&hn.push({event:$n,listener:ms}))}),g&&hn.push({event:"pointermove",listener:pr});const Xw=()=>{pe.current=!0},am=()=>{pe.current=!1,si()};return x&&!Ke&&((Re=q.current)===null||Re===void 0||Re.addEventListener("mouseenter",Xw),(rt=q.current)===null||rt===void 0||rt.addEventListener("mouseleave",am)),hn.forEach(({event:$n,listener:uo})=>{lt.forEach(sv=>{var co;(co=sv.current)===null||co===void 0||co.addEventListener($n,uo)})}),()=>{var $n,uo;ut.scroll&&(window.removeEventListener("scroll",yt),on==null||on.removeEventListener("scroll",yt),Qn==null||Qn.removeEventListener("scroll",yt)),ut.resize?window.removeEventListener("resize",yt):jn==null||jn(),ut.clickOutsideAnchor&&window.removeEventListener("click",Aa),ut.escape&&window.removeEventListener("keydown",Es),x&&!Ke&&(($n=q.current)===null||$n===void 0||$n.removeEventListener("mouseenter",Xw),(uo=q.current)===null||uo===void 0||uo.removeEventListener("mouseleave",am)),hn.forEach(({event:sv,listener:co})=>{lt.forEach(g$=>{var av;(av=g$.current)===null||av===void 0||av.removeEventListener(sv,co)})})}},[O,Ce,Ae,ge,Ie,S,I,$,Je,f,m]),Z.useEffect(()=>{var Re,rt;let lt=(rt=(Re=ie==null?void 0:ie.anchorSelect)!==null&&Re!==void 0?Re:i)!==null&&rt!==void 0?rt:"";!lt&&t&&(lt=`[data-tooltip-id='${t}']`);const xt=new MutationObserver(yt=>{const on=[],Qn=[];yt.forEach(jn=>{if(jn.type==="attributes"&&jn.attributeName==="data-tooltip-id"&&(jn.target.getAttribute("data-tooltip-id")===t?on.push(jn.target):jn.oldValue===t&&Qn.push(jn.target)),jn.type==="childList"){if(O){const Es=[...jn.removedNodes].filter(hn=>hn.nodeType===1);if(lt)try{Qn.push(...Es.filter(hn=>hn.matches(lt))),Qn.push(...Es.flatMap(hn=>[...hn.querySelectorAll(lt)]))}catch{}Es.some(hn=>{var Ko;return!!(!((Ko=hn==null?void 0:hn.contains)===null||Ko===void 0)&&Ko.call(hn,O))&&(Pe(!1),vt(!1),D(null),ee.current&&clearTimeout(ee.current),ae.current&&clearTimeout(ae.current),!0)})}if(lt)try{const Es=[...jn.addedNodes].filter(hn=>hn.nodeType===1);on.push(...Es.filter(hn=>hn.matches(lt))),on.push(...Es.flatMap(hn=>[...hn.querySelectorAll(lt)]))}catch{}}}),(on.length||Qn.length)&&ze(jn=>[...jn.filter(Es=>!Qn.includes(Es)),...on])});return xt.observe(document.body,{childList:!0,subtree:!0,attributes:!0,attributeFilter:["data-tooltip-id"],attributeOldValue:!0}),()=>{xt.disconnect()}},[t,i,ie==null?void 0:ie.anchorSelect,O]),Z.useEffect(()=>{Ce()},[Ce]),Z.useEffect(()=>{if(!(z!=null&&z.current))return()=>null;const Re=new ResizeObserver(()=>{setTimeout(()=>Ce())});return Re.observe(z.current),()=>{Re.disconnect()}},[R,z==null?void 0:z.current]),Z.useEffect(()=>{var Re;const rt=document.querySelector(`[id='${a}']`),lt=[...Ie,rt];O&&lt.includes(O)||D((Re=Ie[0])!==null&&Re!==void 0?Re:rt)},[a,Ie,O]),Z.useEffect(()=>(F&&vt(!0),()=>{ee.current&&clearTimeout(ee.current),ae.current&&clearTimeout(ae.current)}),[]),Z.useEffect(()=>{var Re;let rt=(Re=ie==null?void 0:ie.anchorSelect)!==null&&Re!==void 0?Re:i;if(!rt&&t&&(rt=`[data-tooltip-id='${t}']`),rt)try{const lt=Array.from(document.querySelectorAll(rt));ze(lt)}catch{ze([])}},[t,i,ie==null?void 0:ie.anchorSelect]),Z.useEffect(()=>{ee.current&&(clearTimeout(ee.current),Rt(f))},[f]);const We=(U=ie==null?void 0:ie.content)!==null&&U!==void 0?U:R,gt=be&&Object.keys(j.tooltipStyles).length>0;return Z.useImperativeHandle(e,()=>({open:Re=>{if(Re!=null&&Re.anchorSelect)try{document.querySelector(Re.anchorSelect)}catch{return void console.warn(`[react-tooltip] "${Re.anchorSelect}" is not a valid CSS selector`)}Te(Re??null),Re!=null&&Re.delay?Rt(Re.delay):vt(!0)},close:Re=>{Re!=null&&Re.delay?Bs(Re.delay):vt(!1)},activeAnchor:O,place:j.place,isOpen:!!(Ae&&!y&&We&&gt)})),Ae&&!y&&We?wn.createElement(p,{id:t,role:G,className:J_("react-tooltip",cm.tooltip,J$.tooltip,J$[s],n,`react-tooltip__place-${j.place}`,cm[gt?"show":"closing"],gt?"react-tooltip__show":"react-tooltip__closing",d==="fixed"&&cm.fixed,x&&cm.clickable),onTransitionEnd:Re=>{ye.current&&clearTimeout(ye.current),be||Re.propertyName!=="opacity"||(Pe(!1),Te(null),_==null||_())},style:{...T,...j.tooltipStyles,opacity:V!==void 0&&gt?V:void 0},ref:q},We,wn.createElement(p,{className:J_("react-tooltip-arrow",cm.arrow,J$.arrow,r,b&&cm.noArrow),style:{...j.tooltipArrowStyles,background:K?`linear-gradient(to right bottom, transparent 50%, ${K} 50%)`:void 0},ref:Q})):null},Yhe=({content:e})=>wn.createElement("span",{dangerouslySetInnerHTML:{__html:e}}),nr=wn.forwardRef(({id:e,anchorId:t,anchorSelect:n,content:r,html:s,render:a,className:i,classNameArrow:o,variant:l="dark",place:u="top",offset:c=10,wrapper:d="div",children:h=null,events:p=["hover"],openOnClick:f=!1,positionStrategy:m="absolute",middlewares:g,delayShow:y=0,delayHide:b=0,float:x=!1,hidden:v=!1,noArrow:w=!1,clickable:k=!1,closeOnEsc:S=!1,closeOnScroll:I=!1,closeOnResize:$=!1,openEvents:C,closeEvents:T,globalCloseEvents:N,imperativeModeOnly:E=!1,style:_,position:R,isOpen:z,defaultIsOpen:W=!1,disableStyleInjection:F=!1,border:L,opacity:O,arrowColor:D,setIsOpen:B,afterShow:V,afterHide:K,role:G="tooltip"},U)=>{const[q,Q]=Z.useState(r),[ee,ae]=Z.useState(s),[ye,j]=Z.useState(u),[ce,be]=Z.useState(l),[ke,Ae]=Z.useState(c),[Pe,ie]=Z.useState(y),[Te,Le]=Z.useState(b),[$e,ge]=Z.useState(x),[ve,pe]=Z.useState(v),[Ie,ze]=Z.useState(d),[Ye,Je]=Z.useState(p),[Ke,Ue]=Z.useState(m),[Xe,ut]=Z.useState(null),[vt,An]=Z.useState(null),Rt=Z.useRef(F),{anchorRefs:Bs,activeAnchor:Un}=n8(e),si=Ln=>Ln==null?void 0:Ln.getAttributeNames().reduce((Mr,It)=>{var Ce;return It.startsWith("data-tooltip-")&&(Mr[It.replace(/^data-tooltip-/,"")]=(Ce=Ln==null?void 0:Ln.getAttribute(It))!==null&&Ce!==void 0?Ce:null),Mr},{}),_a=Ln=>{const Mr={place:It=>{var Ce;j((Ce=It)!==null&&Ce!==void 0?Ce:u)},content:It=>{Q(It??r)},html:It=>{ae(It??s)},variant:It=>{var Ce;be((Ce=It)!==null&&Ce!==void 0?Ce:l)},offset:It=>{Ae(It===null?c:Number(It))},wrapper:It=>{var Ce;ze((Ce=It)!==null&&Ce!==void 0?Ce:d)},events:It=>{const Ce=It==null?void 0:It.split(" ");Je(Ce??p)},"position-strategy":It=>{var Ce;Ue((Ce=It)!==null&&Ce!==void 0?Ce:m)},"delay-show":It=>{ie(It===null?y:Number(It))},"delay-hide":It=>{Le(It===null?b:Number(It))},float:It=>{ge(It===null?x:It==="true")},hidden:It=>{pe(It===null?v:It==="true")},"class-name":It=>{ut(It)}};Object.values(Mr).forEach(It=>It(null)),Object.entries(Ln).forEach(([It,Ce])=>{var We;(We=Mr[It])===null||We===void 0||We.call(Mr,Ce)})};Z.useEffect(()=>{Q(r)},[r]),Z.useEffect(()=>{ae(s)},[s]),Z.useEffect(()=>{j(u)},[u]),Z.useEffect(()=>{be(l)},[l]),Z.useEffect(()=>{Ae(c)},[c]),Z.useEffect(()=>{ie(y)},[y]),Z.useEffect(()=>{Le(b)},[b]),Z.useEffect(()=>{ge(x)},[x]),Z.useEffect(()=>{pe(v)},[v]),Z.useEffect(()=>{Ue(m)},[m]),Z.useEffect(()=>{Rt.current!==F&&console.warn("[react-tooltip] Do not change `disableStyleInjection` dynamically.")},[F]),Z.useEffect(()=>{typeof window<"u"&&window.dispatchEvent(new CustomEvent("react-tooltip-inject-styles",{detail:{disableCore:F==="core",disableBase:F}}))},[]),Z.useEffect(()=>{var Ln;const Mr=new Set(Bs);let It=n;if(!It&&e&&(It=`[data-tooltip-id='${e}']`),It)try{document.querySelectorAll(It).forEach(rt=>{Mr.add({current:rt})})}catch{console.warn(`[react-tooltip] "${It}" is not a valid CSS selector`)}const Ce=document.querySelector(`[id='${t}']`);if(Ce&&Mr.add({current:Ce}),!Mr.size)return()=>null;const We=(Ln=vt??Ce)!==null&&Ln!==void 0?Ln:Un.current,gt=new MutationObserver(rt=>{rt.forEach(lt=>{var xt;if(!We||lt.type!=="attributes"||!(!((xt=lt.attributeName)===null||xt===void 0)&&xt.startsWith("data-tooltip-")))return;const yt=si(We);_a(yt)})}),Re={attributes:!0,childList:!1,subtree:!1};if(We){const rt=si(We);_a(rt),gt.observe(We,Re)}return()=>{gt.disconnect()}},[Bs,Un,vt,t,n]),Z.useEffect(()=>{_!=null&&_.border&&console.warn("[react-tooltip] Do not set `style.border`. Use `border` prop instead."),L&&!RW("border",`${L}`)&&console.warn(`[react-tooltip] "${L}" is not a valid \`border\`.`),_!=null&&_.opacity&&console.warn("[react-tooltip] Do not set `style.opacity`. Use `opacity` prop instead."),O&&!RW("opacity",`${O}`)&&console.warn(`[react-tooltip] "${O}" is not a valid \`opacity\`.`)},[]);let pr=h;const Aa=Z.useRef(null);if(a){const Ln=a({content:(vt==null?void 0:vt.getAttribute("data-tooltip-content"))||q||null,activeAnchor:vt});pr=Ln?wn.createElement("div",{ref:Aa,className:"react-tooltip-content-wrapper"},Ln):null}else q&&(pr=q);ee&&(pr=wn.createElement(Yhe,{content:ee}));const jl={forwardRef:U,id:e,anchorId:t,anchorSelect:n,className:J_(i,Xe),classNameArrow:o,content:pr,contentWrapperRef:Aa,place:ye,variant:ce,offset:ke,wrapper:Ie,events:Ye,openOnClick:f,positionStrategy:Ke,middlewares:g,delayShow:Pe,delayHide:Te,float:$e,hidden:ve,noArrow:w,clickable:k,closeOnEsc:S,closeOnScroll:I,closeOnResize:$,openEvents:C,closeEvents:T,globalCloseEvents:N,imperativeModeOnly:E,style:_,position:R,isOpen:z,defaultIsOpen:W,border:L,opacity:O,arrowColor:D,setIsOpen:B,afterShow:V,afterHide:K,activeAnchor:vt,setActiveAnchor:Ln=>An(Ln),role:G};return wn.createElement(Xhe,{...jl})});typeof window<"u"&&window.addEventListener("react-tooltip-inject-styles",e=>{e.detail.disableCore||_W({css:":root{--rt-color-white:#fff;--rt-color-dark:#222;--rt-color-success:#8dc572;--rt-color-error:#be6464;--rt-color-warning:#f0ad4e;--rt-color-info:#337ab7;--rt-opacity:0.9;--rt-transition-show-delay:0.15s;--rt-transition-closing-delay:0.15s}.core-styles-module_tooltip__3vRRp{position:absolute;top:0;left:0;pointer-events:none;opacity:0;will-change:opacity}.core-styles-module_fixed__pcSol{position:fixed}.core-styles-module_arrow__cvMwQ{position:absolute;background:inherit}.core-styles-module_noArrow__xock6{display:none}.core-styles-module_clickable__ZuTTB{pointer-events:auto}.core-styles-module_show__Nt9eE{opacity:var(--rt-opacity);transition:opacity var(--rt-transition-show-delay)ease-out}.core-styles-module_closing__sGnxF{opacity:0;transition:opacity var(--rt-transition-closing-delay)ease-in}",type:"core"}),e.detail.disableBase||_W({css:`
.styles-module_tooltip__mnnfp{padding:8px 16px;border-radius:3px;font-size:90%;width:max-content}.styles-module_arrow__K0L3T{width:8px;height:8px}[class*='react-tooltip__place-top']>.styles-module_arrow__K0L3T{transform:rotate(45deg)}[class*='react-tooltip__place-right']>.styles-module_arrow__K0L3T{transform:rotate(135deg)}[class*='react-tooltip__place-bottom']>.styles-module_arrow__K0L3T{transform:rotate(225deg)}[class*='react-tooltip__place-left']>.styles-module_arrow__K0L3T{transform:rotate(315deg)}.styles-module_dark__xNqje{background:var(--rt-color-dark);color:var(--rt-color-white)}.styles-module_light__Z6W-X{background-color:var(--rt-color-white);color:var(--rt-color-dark)}.styles-module_success__A2AKt{background-color:var(--rt-color-success);color:var(--rt-color-white)}.styles-module_warning__SCK0X{background-color:var(--rt-color-warning);color:var(--rt-color-white)}.styles-module_error__JvumD{background-color:var(--rt-color-error);color:var(--rt-color-white)}.styles-module_info__BWdHW{background-color:var(--rt-color-info);color:var(--rt-color-white)}`,type:"base"})});const r8=({id:e,videoRef:t,videoHeight:n,videoWidth:r,videoConnected:s,videoChange:a})=>{Z.useEffect(()=>{async function l(){await navigator.mediaDevices.getUserMedia({video:{width:r,height:n}})&&i()}l()},[]);async function i(){try{a();const l=await navigator.mediaDevices.getUserMedia({video:{width:r,height:n}});let u=t.current;u&&(u.srcObject=l,u.play())}catch(l){console.error("Error while connecting to the camera: ",l)}}function o(){var l;try{let u=t.current;if(u){u.pause();const c=(l=u.srcObject)==null?void 0:l.getTracks();c&&c.length>0&&c[0].stop()}a()}catch(u){console.error("Error while disconnecting the camera: ",u)}}return A.jsxs(A.Fragment,{children:[A.jsxs("div",{id:"videoButtonContainer",children:[A.jsx(nr,{id:"cameraAlreadyConnectedTooltip",place:"top",content:"Your device's camera is already connected"}),A.jsx(nr,{id:"cameraAlreadyDisconnectedTooltip",place:"top",content:"Your device's camera is already disconnected"}),A.jsx("button",{type:"button",className:"videoControlBtn",onClick:()=>{i()},disabled:s===!0,"data-tooltip-id":s===!0?"cameraAlreadyConnectedTooltip":"",children:"Connect Camera"}),A.jsx("button",{type:"button",className:"videoControlBtn",onClick:()=>{o()},disabled:s===!1,"data-tooltip-id":s===!1?"cameraAlreadyDisconnectedTooltip":"",children:"Disconnect Camera"})]}),s&&A.jsx("video",{id:e,ref:t,height:n,width:r}),!s&&A.jsx("div",{id:"videoConnectionStatusContainer",children:A.jsxs("h2",{className:"connectionStatusH2",children:["Camera is Disconnected ",A.jsx(ahe,{})]})})]})},s8=({id:e,canvasRef:t,canvasWidth:n,canvasHeight:r})=>(Z.useEffect(()=>{const s=t.current;if(s){const a=s.getContext("2d");a&&(a.fillStyle="transparent",a.fillRect(0,0,n,r))}},[t,n,r]),A.jsx("canvas",{id:e,ref:t,width:n,height:r}));var Wa=function(){return Wa=Object.assign||function(t){for(var n,r=1,s=arguments.length;r<s;r++){n=arguments[r];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(t[a]=n[a])}return t},Wa.apply(this,arguments)};function D1(e,t,n){if(n||arguments.length===2)for(var r=0,s=t.length,a;r<s;r++)(a||!(r in t))&&(a||(a=Array.prototype.slice.call(t,0,r)),a[r]=t[r]);return e.concat(a||Array.prototype.slice.call(t))}var Hn="-ms-",s1="-moz-",pn="-webkit-",a8="comm",GI="rule",hO="decl",Jhe="@import",i8="@keyframes",Zhe="@layer",o8=Math.abs,pO=String.fromCharCode,Q_=Object.assign;function Qhe(e,t){return ys(e,0)^45?(((t<<2^ys(e,0))<<2^ys(e,1))<<2^ys(e,2))<<2^ys(e,3):0}function l8(e){return e.trim()}function ql(e,t){return(e=t.exec(e))?e[0]:e}function jt(e,t,n){return e.replace(t,n)}function p2(e,t,n){return e.indexOf(t,n)}function ys(e,t){return e.charCodeAt(t)|0}function mg(e,t,n){return e.slice(t,n)}function il(e){return e.length}function u8(e){return e.length}function Rv(e,t){return t.push(e),e}function epe(e,t){return e.map(t).join("")}function MW(e,t){return e.filter(function(n){return!ql(n,t)})}var HI=1,gg=1,c8=0,Ji=0,Pr=0,oy="";function qI(e,t,n,r,s,a,i,o){return{value:e,root:t,parent:n,type:r,props:s,children:a,line:HI,column:gg,length:i,return:"",siblings:o}}function Wu(e,t){return Q_(qI("",null,null,"",null,null,0,e.siblings),e,{length:-e.length},t)}function dm(e){for(;e.root;)e=Wu(e.root,{children:[e]});Rv(e,e.siblings)}function tpe(){return Pr}function npe(){return Pr=Ji>0?ys(oy,--Ji):0,gg--,Pr===10&&(gg=1,HI--),Pr}function Eo(){return Pr=Ji<c8?ys(oy,Ji++):0,gg++,Pr===10&&(gg=1,HI++),Pr}function ch(){return ys(oy,Ji)}function f2(){return Ji}function KI(e,t){return mg(oy,e,t)}function eA(e){switch(e){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function rpe(e){return HI=gg=1,c8=il(oy=e),Ji=0,[]}function spe(e){return oy="",e}function Z$(e){return l8(KI(Ji-1,tA(e===91?e+2:e===40?e+1:e)))}function ape(e){for(;(Pr=ch())&&Pr<33;)Eo();return eA(e)>2||eA(Pr)>3?"":" "}function ipe(e,t){for(;--t&&Eo()&&!(Pr<48||Pr>102||Pr>57&&Pr<65||Pr>70&&Pr<97););return KI(e,f2()+(t<6&&ch()==32&&Eo()==32))}function tA(e){for(;Eo();)switch(Pr){case e:return Ji;case 34:case 39:e!==34&&e!==39&&tA(Pr);break;case 40:e===41&&tA(e);break;case 92:Eo();break}return Ji}function ope(e,t){for(;Eo()&&e+Pr!==47+10;)if(e+Pr===42+42&&ch()===47)break;return"/*"+KI(t,Ji-1)+"*"+pO(e===47?e:Eo())}function lpe(e){for(;!eA(ch());)Eo();return KI(e,Ji)}function upe(e){return spe(m2("",null,null,null,[""],e=rpe(e),0,[0],e))}function m2(e,t,n,r,s,a,i,o,l){for(var u=0,c=0,d=i,h=0,p=0,f=0,m=1,g=1,y=1,b=0,x="",v=s,w=a,k=r,S=x;g;)switch(f=b,b=Eo()){case 40:if(f!=108&&ys(S,d-1)==58){p2(S+=jt(Z$(b),"&","&\f"),"&\f",o8(u?o[u-1]:0))!=-1&&(y=-1);break}case 34:case 39:case 91:S+=Z$(b);break;case 9:case 10:case 13:case 32:S+=ape(f);break;case 92:S+=ipe(f2()-1,7);continue;case 47:switch(ch()){case 42:case 47:Rv(cpe(ope(Eo(),f2()),t,n,l),l);break;default:S+="/"}break;case 123*m:o[u++]=il(S)*y;case 125*m:case 59:case 0:switch(b){case 0:case 125:g=0;case 59+c:y==-1&&(S=jt(S,/\f/g,"")),p>0&&il(S)-d&&Rv(p>32?LW(S+";",r,n,d-1,l):LW(jt(S," ","")+";",r,n,d-2,l),l);break;case 59:S+=";";default:if(Rv(k=PW(S,t,n,u,c,s,o,x,v=[],w=[],d,a),a),b===123)if(c===0)m2(S,t,k,k,v,a,d,o,w);else switch(h===99&&ys(S,3)===110?100:h){case 100:case 108:case 109:case 115:m2(e,k,k,r&&Rv(PW(e,k,k,0,0,s,o,x,s,v=[],d,w),w),s,w,d,o,r?v:w);break;default:m2(S,k,k,k,[""],w,0,o,w)}}u=c=p=0,m=y=1,x=S="",d=i;break;case 58:d=1+il(S),p=f;default:if(m<1){if(b==123)--m;else if(b==125&&m++==0&&npe()==125)continue}switch(S+=pO(b),b*m){case 38:y=c>0?1:(S+="\f",-1);break;case 44:o[u++]=(il(S)-1)*y,y=1;break;case 64:ch()===45&&(S+=Z$(Eo())),h=ch(),c=d=il(x=S+=lpe(f2())),b++;break;case 45:f===45&&il(S)==2&&(m=0)}}return a}function PW(e,t,n,r,s,a,i,o,l,u,c,d){for(var h=s-1,p=s===0?a:[""],f=u8(p),m=0,g=0,y=0;m<r;++m)for(var b=0,x=mg(e,h+1,h=o8(g=i[m])),v=e;b<f;++b)(v=l8(g>0?p[b]+" "+x:jt(x,/&\f/g,p[b])))&&(l[y++]=v);return qI(e,t,n,s===0?GI:o,l,u,c,d)}function cpe(e,t,n,r){return qI(e,t,n,a8,pO(tpe()),mg(e,2,-2),0,r)}function LW(e,t,n,r,s){return qI(e,t,n,hO,mg(e,0,r),mg(e,r+1,-1),r,s)}function d8(e,t,n){switch(Qhe(e,t)){case 5103:return pn+"print-"+e+e;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return pn+e+e;case 4789:return s1+e+e;case 5349:case 4246:case 4810:case 6968:case 2756:return pn+e+s1+e+Hn+e+e;case 5936:switch(ys(e,t+11)){case 114:return pn+e+Hn+jt(e,/[svh]\w+-[tblr]{2}/,"tb")+e;case 108:return pn+e+Hn+jt(e,/[svh]\w+-[tblr]{2}/,"tb-rl")+e;case 45:return pn+e+Hn+jt(e,/[svh]\w+-[tblr]{2}/,"lr")+e}case 6828:case 4268:case 2903:return pn+e+Hn+e+e;case 6165:return pn+e+Hn+"flex-"+e+e;case 5187:return pn+e+jt(e,/(\w+).+(:[^]+)/,pn+"box-$1$2"+Hn+"flex-$1$2")+e;case 5443:return pn+e+Hn+"flex-item-"+jt(e,/flex-|-self/g,"")+(ql(e,/flex-|baseline/)?"":Hn+"grid-row-"+jt(e,/flex-|-self/g,""))+e;case 4675:return pn+e+Hn+"flex-line-pack"+jt(e,/align-content|flex-|-self/g,"")+e;case 5548:return pn+e+Hn+jt(e,"shrink","negative")+e;case 5292:return pn+e+Hn+jt(e,"basis","preferred-size")+e;case 6060:return pn+"box-"+jt(e,"-grow","")+pn+e+Hn+jt(e,"grow","positive")+e;case 4554:return pn+jt(e,/([^-])(transform)/g,"$1"+pn+"$2")+e;case 6187:return jt(jt(jt(e,/(zoom-|grab)/,pn+"$1"),/(image-set)/,pn+"$1"),e,"")+e;case 5495:case 3959:return jt(e,/(image-set\([^]*)/,pn+"$1$`$1");case 4968:return jt(jt(e,/(.+:)(flex-)?(.*)/,pn+"box-pack:$3"+Hn+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+pn+e+e;case 4200:if(!ql(e,/flex-|baseline/))return Hn+"grid-column-align"+mg(e,t)+e;break;case 2592:case 3360:return Hn+jt(e,"template-","")+e;case 4384:case 3616:return n&&n.some(function(r,s){return t=s,ql(r.props,/grid-\w+-end/)})?~p2(e+(n=n[t].value),"span",0)?e:Hn+jt(e,"-start","")+e+Hn+"grid-row-span:"+(~p2(n,"span",0)?ql(n,/\d+/):+ql(n,/\d+/)-+ql(e,/\d+/))+";":Hn+jt(e,"-start","")+e;case 4896:case 4128:return n&&n.some(function(r){return ql(r.props,/grid-\w+-start/)})?e:Hn+jt(jt(e,"-end","-span"),"span ","")+e;case 4095:case 3583:case 4068:case 2532:return jt(e,/(.+)-inline(.+)/,pn+"$1$2")+e;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(il(e)-1-t>6)switch(ys(e,t+1)){case 109:if(ys(e,t+4)!==45)break;case 102:return jt(e,/(.+:)(.+)-([^]+)/,"$1"+pn+"$2-$3$1"+s1+(ys(e,t+3)==108?"$3":"$2-$3"))+e;case 115:return~p2(e,"stretch",0)?d8(jt(e,"stretch","fill-available"),t,n)+e:e}break;case 5152:case 5920:return jt(e,/(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/,function(r,s,a,i,o,l,u){return Hn+s+":"+a+u+(i?Hn+s+"-span:"+(o?l:+l-+a)+u:"")+e});case 4949:if(ys(e,t+6)===121)return jt(e,":",":"+pn)+e;break;case 6444:switch(ys(e,ys(e,14)===45?18:11)){case 120:return jt(e,/(.+:)([^;\s!]+)(;|(\s+)?!.+)?/,"$1"+pn+(ys(e,14)===45?"inline-":"")+"box$3$1"+pn+"$2$3$1"+Hn+"$2box$3")+e;case 100:return jt(e,":",":"+Hn)+e}break;case 5719:case 2647:case 2135:case 3927:case 2391:return jt(e,"scroll-","scroll-snap-")+e}return e}function iS(e,t){for(var n="",r=0;r<e.length;r++)n+=t(e[r],r,e,t)||"";return n}function dpe(e,t,n,r){switch(e.type){case Zhe:if(e.children.length)break;case Jhe:case hO:return e.return=e.return||e.value;case a8:return"";case i8:return e.return=e.value+"{"+iS(e.children,r)+"}";case GI:if(!il(e.value=e.props.join(",")))return""}return il(n=iS(e.children,r))?e.return=e.value+"{"+n+"}":""}function hpe(e){var t=u8(e);return function(n,r,s,a){for(var i="",o=0;o<t;o++)i+=e[o](n,r,s,a)||"";return i}}function ppe(e){return function(t){t.root||(t=t.return)&&e(t)}}function fpe(e,t,n,r){if(e.length>-1&&!e.return)switch(e.type){case hO:e.return=d8(e.value,e.length,n);return;case i8:return iS([Wu(e,{value:jt(e.value,"@","@"+pn)})],r);case GI:if(e.length)return epe(n=e.props,function(s){switch(ql(s,r=/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":dm(Wu(e,{props:[jt(s,/:(read-\w+)/,":"+s1+"$1")]})),dm(Wu(e,{props:[s]})),Q_(e,{props:MW(n,r)});break;case"::placeholder":dm(Wu(e,{props:[jt(s,/:(plac\w+)/,":"+pn+"input-$1")]})),dm(Wu(e,{props:[jt(s,/:(plac\w+)/,":"+s1+"$1")]})),dm(Wu(e,{props:[jt(s,/:(plac\w+)/,Hn+"input-$1")]})),dm(Wu(e,{props:[s]})),Q_(e,{props:MW(n,r)});break}return""})}}var mpe={animationIterationCount:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},yg=typeof process<"u"&&process.env!==void 0&&({}.REACT_APP_SC_ATTR||{}.SC_ATTR)||"data-styled",h8="active",p8="data-styled-version",XI="6.1.8",fO=`/*!sc*/
`,mO=typeof window<"u"&&"HTMLElement"in window,gpe=!!(typeof SC_DISABLE_SPEEDY=="boolean"?SC_DISABLE_SPEEDY:typeof process<"u"&&process.env!==void 0&&{}.REACT_APP_SC_DISABLE_SPEEDY!==void 0&&{}.REACT_APP_SC_DISABLE_SPEEDY!==""?{}.REACT_APP_SC_DISABLE_SPEEDY!=="false"&&{}.REACT_APP_SC_DISABLE_SPEEDY:typeof process<"u"&&process.env!==void 0&&{}.SC_DISABLE_SPEEDY!==void 0&&{}.SC_DISABLE_SPEEDY!==""&&{}.SC_DISABLE_SPEEDY!=="false"&&{}.SC_DISABLE_SPEEDY),YI=Object.freeze([]),bg=Object.freeze({});function ype(e,t,n){return n===void 0&&(n=bg),e.theme!==n.theme&&e.theme||t||n.theme}var f8=new Set(["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","tr","track","u","ul","use","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","marker","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"]),bpe=/[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g,vpe=/(^-|-$)/g;function zW(e){return e.replace(bpe,"-").replace(vpe,"")}var xpe=/(a)(d)/gi,wk=52,BW=function(e){return String.fromCharCode(e+(e>25?39:97))};function nA(e){var t,n="";for(t=Math.abs(e);t>wk;t=t/wk|0)n=BW(t%wk)+n;return(BW(t%wk)+n).replace(xpe,"$1-$2")}var Q$,m8=5381,Lm=function(e,t){for(var n=t.length;n;)e=33*e^t.charCodeAt(--n);return e},g8=function(e){return Lm(m8,e)};function y8(e){return nA(g8(e)>>>0)}function wpe(e){return e.displayName||e.name||"Component"}function eE(e){return typeof e=="string"&&!0}var b8=typeof Symbol=="function"&&Symbol.for,v8=b8?Symbol.for("react.memo"):60115,kpe=b8?Symbol.for("react.forward_ref"):60112,Spe={childContextTypes:!0,contextType:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromError:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},Ipe={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},x8={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},Cpe=((Q$={})[kpe]={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},Q$[v8]=x8,Q$);function WW(e){return("type"in(t=e)&&t.type.$$typeof)===v8?x8:"$$typeof"in e?Cpe[e.$$typeof]:Spe;var t}var Npe=Object.defineProperty,Tpe=Object.getOwnPropertyNames,VW=Object.getOwnPropertySymbols,$pe=Object.getOwnPropertyDescriptor,Epe=Object.getPrototypeOf,UW=Object.prototype;function w8(e,t,n){if(typeof t!="string"){if(UW){var r=Epe(t);r&&r!==UW&&w8(e,r,n)}var s=Tpe(t);VW&&(s=s.concat(VW(t)));for(var a=WW(e),i=WW(t),o=0;o<s.length;++o){var l=s[o];if(!(l in Ipe||n&&n[l]||i&&l in i||a&&l in a)){var u=$pe(t,l);try{Npe(e,l,u)}catch{}}}}return e}function vg(e){return typeof e=="function"}function gO(e){return typeof e=="object"&&"styledComponentId"in e}function th(e,t){return e&&t?"".concat(e," ").concat(t):e||t||""}function rA(e,t){if(e.length===0)return"";for(var n=e[0],r=1;r<e.length;r++)n+=t?t+e[r]:e[r];return n}function O1(e){return e!==null&&typeof e=="object"&&e.constructor.name===Object.name&&!("props"in e&&e.$$typeof)}function sA(e,t,n){if(n===void 0&&(n=!1),!n&&!O1(e)&&!Array.isArray(e))return t;if(Array.isArray(t))for(var r=0;r<t.length;r++)e[r]=sA(e[r],t[r]);else if(O1(t))for(var r in t)e[r]=sA(e[r],t[r]);return e}function yO(e,t){Object.defineProperty(e,"toString",{value:t})}function I0(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(e," for more information.").concat(t.length>0?" Args: ".concat(t.join(", ")):""))}var _pe=function(){function e(t){this.groupSizes=new Uint32Array(512),this.length=512,this.tag=t}return e.prototype.indexOfGroup=function(t){for(var n=0,r=0;r<t;r++)n+=this.groupSizes[r];return n},e.prototype.insertRules=function(t,n){if(t>=this.groupSizes.length){for(var r=this.groupSizes,s=r.length,a=s;t>=a;)if((a<<=1)<0)throw I0(16,"".concat(t));this.groupSizes=new Uint32Array(a),this.groupSizes.set(r),this.length=a;for(var i=s;i<a;i++)this.groupSizes[i]=0}for(var o=this.indexOfGroup(t+1),l=(i=0,n.length);i<l;i++)this.tag.insertRule(o,n[i])&&(this.groupSizes[t]++,o++)},e.prototype.clearGroup=function(t){if(t<this.length){var n=this.groupSizes[t],r=this.indexOfGroup(t),s=r+n;this.groupSizes[t]=0;for(var a=r;a<s;a++)this.tag.deleteRule(r)}},e.prototype.getGroup=function(t){var n="";if(t>=this.length||this.groupSizes[t]===0)return n;for(var r=this.groupSizes[t],s=this.indexOfGroup(t),a=s+r,i=s;i<a;i++)n+="".concat(this.tag.getRule(i)).concat(fO);return n},e}(),g2=new Map,oS=new Map,y2=1,kk=function(e){if(g2.has(e))return g2.get(e);for(;oS.has(y2);)y2++;var t=y2++;return g2.set(e,t),oS.set(t,e),t},Ape=function(e,t){y2=t+1,g2.set(e,t),oS.set(t,e)},Rpe="style[".concat(yg,"][").concat(p8,'="').concat(XI,'"]'),Dpe=new RegExp("^".concat(yg,'\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')),Ope=function(e,t,n){for(var r,s=n.split(","),a=0,i=s.length;a<i;a++)(r=s[a])&&e.registerName(t,r)},Fpe=function(e,t){for(var n,r=((n=t.textContent)!==null&&n!==void 0?n:"").split(fO),s=[],a=0,i=r.length;a<i;a++){var o=r[a].trim();if(o){var l=o.match(Dpe);if(l){var u=0|parseInt(l[1],10),c=l[2];u!==0&&(Ape(c,u),Ope(e,c,l[3]),e.getTag().insertRules(u,s)),s.length=0}else s.push(o)}}};function Mpe(){return typeof __webpack_nonce__<"u"?__webpack_nonce__:null}var k8=function(e){var t=document.head,n=e||t,r=document.createElement("style"),s=function(o){var l=Array.from(o.querySelectorAll("style[".concat(yg,"]")));return l[l.length-1]}(n),a=s!==void 0?s.nextSibling:null;r.setAttribute(yg,h8),r.setAttribute(p8,XI);var i=Mpe();return i&&r.setAttribute("nonce",i),n.insertBefore(r,a),r},Ppe=function(){function e(t){this.element=k8(t),this.element.appendChild(document.createTextNode("")),this.sheet=function(n){if(n.sheet)return n.sheet;for(var r=document.styleSheets,s=0,a=r.length;s<a;s++){var i=r[s];if(i.ownerNode===n)return i}throw I0(17)}(this.element),this.length=0}return e.prototype.insertRule=function(t,n){try{return this.sheet.insertRule(n,t),this.length++,!0}catch{return!1}},e.prototype.deleteRule=function(t){this.sheet.deleteRule(t),this.length--},e.prototype.getRule=function(t){var n=this.sheet.cssRules[t];return n&&n.cssText?n.cssText:""},e}(),Lpe=function(){function e(t){this.element=k8(t),this.nodes=this.element.childNodes,this.length=0}return e.prototype.insertRule=function(t,n){if(t<=this.length&&t>=0){var r=document.createTextNode(n);return this.element.insertBefore(r,this.nodes[t]||null),this.length++,!0}return!1},e.prototype.deleteRule=function(t){this.element.removeChild(this.nodes[t]),this.length--},e.prototype.getRule=function(t){return t<this.length?this.nodes[t].textContent:""},e}(),zpe=function(){function e(t){this.rules=[],this.length=0}return e.prototype.insertRule=function(t,n){return t<=this.length&&(this.rules.splice(t,0,n),this.length++,!0)},e.prototype.deleteRule=function(t){this.rules.splice(t,1),this.length--},e.prototype.getRule=function(t){return t<this.length?this.rules[t]:""},e}(),jW=mO,Bpe={isServer:!mO,useCSSOMInjection:!gpe},S8=function(){function e(t,n,r){t===void 0&&(t=bg),n===void 0&&(n={});var s=this;this.options=Wa(Wa({},Bpe),t),this.gs=n,this.names=new Map(r),this.server=!!t.isServer,!this.server&&mO&&jW&&(jW=!1,function(a){for(var i=document.querySelectorAll(Rpe),o=0,l=i.length;o<l;o++){var u=i[o];u&&u.getAttribute(yg)!==h8&&(Fpe(a,u),u.parentNode&&u.parentNode.removeChild(u))}}(this)),yO(this,function(){return function(a){for(var i=a.getTag(),o=i.length,l="",u=function(d){var h=function(y){return oS.get(y)}(d);if(h===void 0)return"continue";var p=a.names.get(h),f=i.getGroup(d);if(p===void 0||f.length===0)return"continue";var m="".concat(yg,".g").concat(d,'[id="').concat(h,'"]'),g="";p!==void 0&&p.forEach(function(y){y.length>0&&(g+="".concat(y,","))}),l+="".concat(f).concat(m,'{content:"').concat(g,'"}').concat(fO)},c=0;c<o;c++)u(c);return l}(s)})}return e.registerId=function(t){return kk(t)},e.prototype.reconstructWithOptions=function(t,n){return n===void 0&&(n=!0),new e(Wa(Wa({},this.options),t),this.gs,n&&this.names||void 0)},e.prototype.allocateGSInstance=function(t){return this.gs[t]=(this.gs[t]||0)+1},e.prototype.getTag=function(){return this.tag||(this.tag=(t=function(n){var r=n.useCSSOMInjection,s=n.target;return n.isServer?new zpe(s):r?new Ppe(s):new Lpe(s)}(this.options),new _pe(t)));var t},e.prototype.hasNameForId=function(t,n){return this.names.has(t)&&this.names.get(t).has(n)},e.prototype.registerName=function(t,n){if(kk(t),this.names.has(t))this.names.get(t).add(n);else{var r=new Set;r.add(n),this.names.set(t,r)}},e.prototype.insertRules=function(t,n,r){this.registerName(t,n),this.getTag().insertRules(kk(t),r)},e.prototype.clearNames=function(t){this.names.has(t)&&this.names.get(t).clear()},e.prototype.clearRules=function(t){this.getTag().clearGroup(kk(t)),this.clearNames(t)},e.prototype.clearTag=function(){this.tag=void 0},e}(),Wpe=/&/g,Vpe=/^\s*\/\/.*$/gm;function I8(e,t){return e.map(function(n){return n.type==="rule"&&(n.value="".concat(t," ").concat(n.value),n.value=n.value.replaceAll(",",",".concat(t," ")),n.props=n.props.map(function(r){return"".concat(t," ").concat(r)})),Array.isArray(n.children)&&n.type!=="@keyframes"&&(n.children=I8(n.children,t)),n})}function Upe(e){var t,n,r,s=e===void 0?bg:e,a=s.options,i=a===void 0?bg:a,o=s.plugins,l=o===void 0?YI:o,u=function(h,p,f){return f.startsWith(n)&&f.endsWith(n)&&f.replaceAll(n,"").length>0?".".concat(t):h},c=l.slice();c.push(function(h){h.type===GI&&h.value.includes("&")&&(h.props[0]=h.props[0].replace(Wpe,n).replace(r,u))}),i.prefix&&c.push(fpe),c.push(dpe);var d=function(h,p,f,m){p===void 0&&(p=""),f===void 0&&(f=""),m===void 0&&(m="&"),t=m,n=p,r=new RegExp("\\".concat(n,"\\b"),"g");var g=h.replace(Vpe,""),y=upe(f||p?"".concat(f," ").concat(p," { ").concat(g," }"):g);i.namespace&&(y=I8(y,i.namespace));var b=[];return iS(y,hpe(c.concat(ppe(function(x){return b.push(x)})))),b};return d.hash=l.length?l.reduce(function(h,p){return p.name||I0(15),Lm(h,p.name)},m8).toString():"",d}var jpe=new S8,aA=Upe(),C8=wn.createContext({shouldForwardProp:void 0,styleSheet:jpe,stylis:aA});C8.Consumer;wn.createContext(void 0);function GW(){return Z.useContext(C8)}var N8=function(){function e(t,n){var r=this;this.inject=function(s,a){a===void 0&&(a=aA);var i=r.name+a.hash;s.hasNameForId(r.id,i)||s.insertRules(r.id,i,a(r.rules,i,"@keyframes"))},this.name=t,this.id="sc-keyframes-".concat(t),this.rules=n,yO(this,function(){throw I0(12,String(r.name))})}return e.prototype.getName=function(t){return t===void 0&&(t=aA),this.name+t.hash},e}(),Gpe=function(e){return e>="A"&&e<="Z"};function HW(e){for(var t="",n=0;n<e.length;n++){var r=e[n];if(n===1&&r==="-"&&e[0]==="-")return e;Gpe(r)?t+="-"+r.toLowerCase():t+=r}return t.startsWith("ms-")?"-"+t:t}var T8=function(e){return e==null||e===!1||e===""},$8=function(e){var t,n,r=[];for(var s in e){var a=e[s];e.hasOwnProperty(s)&&!T8(a)&&(Array.isArray(a)&&a.isCss||vg(a)?r.push("".concat(HW(s),":"),a,";"):O1(a)?r.push.apply(r,D1(D1(["".concat(s," {")],$8(a),!1),["}"],!1)):r.push("".concat(HW(s),": ").concat((t=s,(n=a)==null||typeof n=="boolean"||n===""?"":typeof n!="number"||n===0||t in mpe||t.startsWith("--")?String(n).trim():"".concat(n,"px")),";")))}return r};function dh(e,t,n,r){if(T8(e))return[];if(gO(e))return[".".concat(e.styledComponentId)];if(vg(e)){if(!vg(a=e)||a.prototype&&a.prototype.isReactComponent||!t)return[e];var s=e(t);return dh(s,t,n,r)}var a;return e instanceof N8?n?(e.inject(n,r),[e.getName(r)]):[e]:O1(e)?$8(e):Array.isArray(e)?Array.prototype.concat.apply(YI,e.map(function(i){return dh(i,t,n,r)})):[e.toString()]}function Hpe(e){for(var t=0;t<e.length;t+=1){var n=e[t];if(vg(n)&&!gO(n))return!1}return!0}var qpe=g8(XI),Kpe=function(){function e(t,n,r){this.rules=t,this.staticRulesId="",this.isStatic=(r===void 0||r.isStatic)&&Hpe(t),this.componentId=n,this.baseHash=Lm(qpe,n),this.baseStyle=r,S8.registerId(n)}return e.prototype.generateAndInjectStyles=function(t,n,r){var s=this.baseStyle?this.baseStyle.generateAndInjectStyles(t,n,r):"";if(this.isStatic&&!r.hash)if(this.staticRulesId&&n.hasNameForId(this.componentId,this.staticRulesId))s=th(s,this.staticRulesId);else{var a=rA(dh(this.rules,t,n,r)),i=nA(Lm(this.baseHash,a)>>>0);if(!n.hasNameForId(this.componentId,i)){var o=r(a,".".concat(i),void 0,this.componentId);n.insertRules(this.componentId,i,o)}s=th(s,i),this.staticRulesId=i}else{for(var l=Lm(this.baseHash,r.hash),u="",c=0;c<this.rules.length;c++){var d=this.rules[c];if(typeof d=="string")u+=d;else if(d){var h=rA(dh(d,t,n,r));l=Lm(l,h+c),u+=h}}if(u){var p=nA(l>>>0);n.hasNameForId(this.componentId,p)||n.insertRules(this.componentId,p,r(u,".".concat(p),void 0,this.componentId)),s=th(s,p)}}return s},e}(),E8=wn.createContext(void 0);E8.Consumer;var tE={};function Xpe(e,t,n){var r=gO(e),s=e,a=!eE(e),i=t.attrs,o=i===void 0?YI:i,l=t.componentId,u=l===void 0?function(v,w){var k=typeof v!="string"?"sc":zW(v);tE[k]=(tE[k]||0)+1;var S="".concat(k,"-").concat(y8(XI+k+tE[k]));return w?"".concat(w,"-").concat(S):S}(t.displayName,t.parentComponentId):l,c=t.displayName,d=c===void 0?function(v){return eE(v)?"styled.".concat(v):"Styled(".concat(wpe(v),")")}(e):c,h=t.displayName&&t.componentId?"".concat(zW(t.displayName),"-").concat(t.componentId):t.componentId||u,p=r&&s.attrs?s.attrs.concat(o).filter(Boolean):o,f=t.shouldForwardProp;if(r&&s.shouldForwardProp){var m=s.shouldForwardProp;if(t.shouldForwardProp){var g=t.shouldForwardProp;f=function(v,w){return m(v,w)&&g(v,w)}}else f=m}var y=new Kpe(n,h,r?s.componentStyle:void 0);function b(v,w){return function(k,S,I){var $=k.attrs,C=k.componentStyle,T=k.defaultProps,N=k.foldedComponentIds,E=k.styledComponentId,_=k.target,R=wn.useContext(E8),z=GW(),W=k.shouldForwardProp||z.shouldForwardProp,F=ype(S,R,T)||bg,L=function(G,U,q){for(var Q,ee=Wa(Wa({},U),{className:void 0,theme:q}),ae=0;ae<G.length;ae+=1){var ye=vg(Q=G[ae])?Q(ee):Q;for(var j in ye)ee[j]=j==="className"?th(ee[j],ye[j]):j==="style"?Wa(Wa({},ee[j]),ye[j]):ye[j]}return U.className&&(ee.className=th(ee.className,U.className)),ee}($,S,F),O=L.as||_,D={};for(var B in L)L[B]===void 0||B[0]==="$"||B==="as"||B==="theme"&&L.theme===F||(B==="forwardedAs"?D.as=L.forwardedAs:W&&!W(B,O)||(D[B]=L[B]));var V=function(G,U){var q=GW(),Q=G.generateAndInjectStyles(U,q.styleSheet,q.stylis);return Q}(C,L),K=th(N,E);return V&&(K+=" "+V),L.className&&(K+=" "+L.className),D[eE(O)&&!f8.has(O)?"class":"className"]=K,D.ref=I,Z.createElement(O,D)}(x,v,w)}b.displayName=d;var x=wn.forwardRef(b);return x.attrs=p,x.componentStyle=y,x.displayName=d,x.shouldForwardProp=f,x.foldedComponentIds=r?th(s.foldedComponentIds,s.styledComponentId):"",x.styledComponentId=h,x.target=r?s.target:e,Object.defineProperty(x,"defaultProps",{get:function(){return this._foldedDefaultProps},set:function(v){this._foldedDefaultProps=r?function(w){for(var k=[],S=1;S<arguments.length;S++)k[S-1]=arguments[S];for(var I=0,$=k;I<$.length;I++)sA(w,$[I],!0);return w}({},s.defaultProps,v):v}}),yO(x,function(){return".".concat(x.styledComponentId)}),a&&w8(x,e,{attrs:!0,componentStyle:!0,displayName:!0,foldedComponentIds:!0,shouldForwardProp:!0,styledComponentId:!0,target:!0}),x}function qW(e,t){for(var n=[e[0]],r=0,s=t.length;r<s;r+=1)n.push(t[r],e[r+1]);return n}var KW=function(e){return Object.assign(e,{isCss:!0})};function _8(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];if(vg(e)||O1(e))return KW(dh(qW(YI,D1([e],t,!0))));var r=e;return t.length===0&&r.length===1&&typeof r[0]=="string"?dh(r):KW(dh(qW(r,t)))}function iA(e,t,n){if(n===void 0&&(n=bg),!t)throw I0(1,t);var r=function(s){for(var a=[],i=1;i<arguments.length;i++)a[i-1]=arguments[i];return e(t,n,_8.apply(void 0,D1([s],a,!1)))};return r.attrs=function(s){return iA(e,t,Wa(Wa({},n),{attrs:Array.prototype.concat(n.attrs,s).filter(Boolean)}))},r.withConfig=function(s){return iA(e,t,Wa(Wa({},n),s))},r}var A8=function(e){return iA(Xpe,e)},pp=A8;f8.forEach(function(e){pp[e]=A8(e)});function bO(e){for(var t=[],n=1;n<arguments.length;n++)t[n-1]=arguments[n];var r=rA(_8.apply(void 0,D1([e],t,!1))),s=y8(r);return new N8(s,r)}const Ype="#4fa94d",Jpe={"aria-busy":!0,role:"progressbar"},Zpe=pp.div`
  display: ${e=>e.$visible?"flex":"none"};
`,Qpe="http://www.w3.org/2000/svg",bo=242.776657104492,efe=1.6,tfe=bO`
12.5% {
  stroke-dasharray: ${bo*.14}px, ${bo}px;
  stroke-dashoffset: -${bo*.11}px;
}
43.75% {
  stroke-dasharray: ${bo*.35}px, ${bo}px;
  stroke-dashoffset: -${bo*.35}px;
}
100% {
  stroke-dasharray: ${bo*.01}px, ${bo}px;
  stroke-dashoffset: -${bo*.99}px;
}
`;pp.path`
  stroke-dasharray: ${bo*.01}px, ${bo};
  stroke-dashoffset: 0;
  animation: ${tfe} ${efe}s linear infinite;
`;const nfe=bO`
to {
   transform: rotate(360deg);
 }
`;pp.svg`
  animation: ${nfe} 0.75s steps(12, end) infinite;
  animation-duration: 0.75s;
`;pp.polyline`
  stroke-width: ${e=>e.width}px;
  stroke-linecap: round;

  &:nth-child(12n + 0) {
    stroke-opacity: 0.08;
  }

  &:nth-child(12n + 1) {
    stroke-opacity: 0.17;
  }

  &:nth-child(12n + 2) {
    stroke-opacity: 0.25;
  }

  &:nth-child(12n + 3) {
    stroke-opacity: 0.33;
  }

  &:nth-child(12n + 4) {
    stroke-opacity: 0.42;
  }

  &:nth-child(12n + 5) {
    stroke-opacity: 0.5;
  }

  &:nth-child(12n + 6) {
    stroke-opacity: 0.58;
  }

  &:nth-child(12n + 7) {
    stroke-opacity: 0.66;
  }

  &:nth-child(12n + 8) {
    stroke-opacity: 0.75;
  }

  &:nth-child(12n + 9) {
    stroke-opacity: 0.83;
  }

  &:nth-child(12n + 11) {
    stroke-opacity: 0.92;
  }
`;const ly=({height:e=80,width:t=80,strokeWidth:n=2,radius:r=1,color:s=Ype,ariaLabel:a="tail-spin-loading",wrapperStyle:i,wrapperClass:o,visible:l=!0})=>{const u=parseInt(String(n)),c=u+36,d=u/2,h=d+parseInt(String(r))-1;return A.jsx(Zpe,{style:i,$visible:l,className:o,"data-testid":"tail-spin-loading","aria-label":a,...Jpe,children:A.jsxs("svg",{width:t,height:e,viewBox:`0 0 ${c} ${c}`,xmlns:Qpe,"data-testid":"tail-spin-svg",children:[A.jsx("defs",{children:A.jsxs("linearGradient",{x1:"8.042%",y1:"0%",x2:"65.682%",y2:"23.865%",id:"a",children:[A.jsx("stop",{stopColor:s,stopOpacity:"0",offset:"0%"}),A.jsx("stop",{stopColor:s,stopOpacity:".631",offset:"63.146%"}),A.jsx("stop",{stopColor:s,offset:"100%"})]})}),A.jsx("g",{fill:"none",fillRule:"evenodd",children:A.jsxs("g",{transform:`translate(${d} ${d})`,children:[A.jsx("path",{d:"M36 18c0-9.94-8.06-18-18-18",id:"Oval-2",stroke:s,strokeWidth:n,children:A.jsx("animateTransform",{attributeName:"transform",type:"rotate",from:"0 18 18",to:"360 18 18",dur:"0.9s",repeatCount:"indefinite"})}),A.jsx("circle",{fill:"#fff",cx:"36",cy:"18",r:h,children:A.jsx("animateTransform",{attributeName:"transform",type:"rotate",from:"0 18 18",to:"360 18 18",dur:"0.9s",repeatCount:"indefinite"})})]})})]})})},rfe=bO`
to {
   stroke-dashoffset: 136;
 }
`;pp.polygon`
  stroke-dasharray: 17;
  animation: ${rfe} 2.5s cubic-bezier(0.35, 0.04, 0.63, 0.95) infinite;
`;pp.svg`
  transform-origin: 50% 65%;
`;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sfe=1e-7,afe=1e-4;class R8{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class vO{refCount(t){return Ra("refCount")}incRef(t){return Ra("incRef")}timerAvailable(){return!0}time(t){return Ra("time")}read(t){return Ra("read")}readSync(t){return Ra("readSync")}readToGPU(t,n){return Ra("readToGPU")}numDataIds(){return Ra("numDataIds")}disposeData(t,n){return Ra("disposeData")}write(t,n,r){return Ra("write")}move(t,n,r,s,a){return Ra("move")}createTensorFromGPUData(t,n,r){return Ra("createTensorFromGPUData")}memory(){return Ra("memory")}floatPrecision(){return Ra("floatPrecision")}epsilon(){return this.floatPrecision()===32?sfe:afe}dispose(){return Ra("dispose")}}function Ra(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ife(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,vm(e,t,n)}function $h(e,t,n){return Math.max(e,Math.min(t,n))}function xO(e){return e%2===0?e:e+1}function vm(e,t,n){const r=e[t];e[t]=e[n],e[n]=r}function ofe(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Y(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function wO(e,t,n=""){Y(cn(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function D8(e){Y(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Me(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function cn(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function xg(e){return e%1===0}function oA(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Km(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function XW(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0;const o=()=>{if(e()){s();return}i++;const l=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function O8(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const s=e.slice();return s[r]=t/n,s}function Ht(e,t){const n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),Y(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),Y(e.every(r=>xg(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function nd(e,t){const n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:Ht(t,e).sort();let i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function Ds(e,t){return gr(e,t)}function gr(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function lfe(e,t){for(let n=0;n<e.length;n++){const r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function ufe(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function F8(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function lS(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function cfe(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function C0(e){return typeof e=="string"||e instanceof String}function dfe(e){return typeof e=="boolean"}function lA(e){return typeof e=="number"}function uy(e){return Array.isArray(e)?uy(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":lA(e)?"float32":C0(e)?"string":dfe(e)?"bool":"float32"}function uA(e){return!!(e&&e.constructor&&e.call&&e.apply)}function cA(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function kt(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function M8(e,t,n,r=!1){const s=new Array;if(t.length===1){const a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{const a=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<a;l++)s[l]=M8(e+l*o,i,n,r)}return s}function _o(e,t,n=!1){if(e.length===0)return t[0];const r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return M8(0,e,t,n)}function hfe(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function kO(e,t){const n=Os(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function Os(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function P8(e,t){const n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return _o(e,new Float32Array(n));if(t==="int32")return _o(e,new Int32Array(n));if(t==="bool")return _o(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Su(e){e.forEach(t=>{Y(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function xl(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function cy(e,t,n){if(t===0)return[];if(t===1)return[e];const r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function SO(e){return e&&e.then&&typeof e.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YW="tfjsflags";class pfe{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=ffe,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,r){if(this.flagRegistry[t]={evaluationFn:n,setHook:r},this.urlFlags[t]!=null){const s=this.urlFlags[t];_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(SO(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);YW in t&&t[YW].split(",").forEach(r=>{const[s,a]=r.split(":");this.urlFlags[s]=gfe(s,a)})}}function ffe(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(mfe(t,r[0],r[1]),r.join("="))),t}function mfe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function gfe(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function _e(){return L8}let L8=null;function yfe(e){L8=e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let nE;function z8(){if(nE==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");nE=e}return nE}function bfe(){const e=z8();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function IO(e,t){const n=bfe();if(n.has(e))return n.get(e);{const r=t();return n.set(e,r),n.get(e)}}const JI="Abs",N0="Acos",T0="Acosh",dy="Add",CO="AddN",NO="All",TO="Any",ZI="ArgMax",QI="ArgMin",$0="Asin",E0="Asinh",_0="Atan",A0="Atanh",R0="Atan2",eC="AvgPool",$O="AvgPoolGrad",tC="AvgPool3D",EO="AvgPool3DGrad",nC="BatchMatMul",rC="BatchToSpaceND",_O="Bincount",AO="BitwiseAnd",vfe="BroadcastTo",B8="BroadcastArgs",D0="Cast",O0="Ceil",F0="ClipByValue",RO="Complex",sC="ComplexAbs",aC="Concat",iC="Conv2D",DO="Conv2DBackpropFilter",oC="Conv2DBackpropInput",lC="Conv3D",OO="Conv3DBackpropFilterV2",FO="Conv3DBackpropInputV2",M0="Cos",P0="Cosh",MO="Cumprod",uC="Cumsum",PO="CropAndResize",LO="DenseBincount",zO="DepthToSpace",cC="DepthwiseConv2dNative",BO="DepthwiseConv2dNativeBackpropFilter",WO="DepthwiseConv2dNativeBackpropInput",W8="Diag",dC="Dilation2D",dA="Dilation2DBackpropInput",hA="Dilation2DBackpropFilter",xfe="Draw",L0="RealDiv",VO="Einsum",z0="Elu",UO="EluGrad",B0="Erf",hC="Equal",W0="Exp",pC="ExpandDims",V0="Expm1",jO="FFT",GO="Fill",HO="FlipLeftRight",U0="Floor",j0="FloorDiv",fC="FusedBatchNorm",mC="GatherV2",V8="GatherNd",gC="Greater",G0="GreaterEqual",H0="Identity",qO="IFFT",KO="Imag",q0="IsFinite",K0="IsInf",X0="IsNan",yC="LeakyRelu",bC="Less",vC="LessEqual",U8="LinSpace",Y0="Log",J0="Log1p",xC="LogicalAnd",wC="LogicalNot",kC="LogicalOr",wfe="LogSoftmax",SC="LRN",XO="LRNGrad",IC="Max",Z0="Maximum",CC="MaxPool",YO="MaxPoolGrad",NC="MaxPool3D",JO="MaxPool3DGrad",j8="MaxPoolWithArgmax",TC="Mean",$C="Min",Q0="Minimum",EC="MirrorPad",ex="Mod",G8="Multinomial",tx="Multiply",_C="Neg",AC="NotEqual",ZO="NonMaxSuppressionV3",QO="NonMaxSuppressionV4",eF="NonMaxSuppressionV5",RC="OnesLike",DC="OneHot",OC="Pack",FC="PadV2",nx="Pow",MC="Prelu",PC="Prod",H8="RaggedGather",q8="RaggedRange",K8="RaggedTensorToTensor",tF="Range",nF="Real",rx="Reciprocal",sx="Relu",LC="Reshape",zC="ResizeNearestNeighbor",rF="ResizeNearestNeighborGrad",BC="ResizeBilinear",sF="ResizeBilinearGrad",ax="Relu6",WC="Reverse",ix="Round",ox="Rsqrt",X8="ScatterNd",Y8="TensorScatterUpdate",J8="SearchSorted",VC="Select",lx="Selu",UC="Slice",ux="Sin",cx="Sinh",dx="Sign",hx="Sigmoid",px="Softplus",fx="Sqrt",jC="Sum",GC="SpaceToBatchND",HC="SplitV",qC="Softmax",Z8="SparseFillEmptyRows",Q8="SparseReshape",eq="SparseSegmentMean",tq="SparseSegmentSum",nq="SparseToDense",mx="SquaredDifference",aF="Square",iF="StaticRegexReplace",oF="StridedSlice",rq="StringNGrams",sq="StringSplit",aq="StringToHashBucketFast",gx="Sub",yx="Tan",bx="Tanh",vx="Tile",lF="TopK",uF="Transform",Xm="Transpose",cF="Unique",KC="Unpack",XC="UnsortedSegmentSum",YC="ZerosLike",xx="Step",kfe="FromPixels",dF="RotateWithOffset",uS="_FusedMatMul",cS="FusedConv2D",iq="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function li(...e){_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn(...e)}function Sfe(...e){_e().getBool("IS_TEST")||_e().getBool("PROD")||console.log(...e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dS=IO("kernelRegistry",()=>new Map),pA=IO("gradRegistry",()=>new Map);function JW(e,t){const n=lq(e,t);return dS.get(n)}function ZW(e){return pA.get(e)}function QW(e){const t=dS.entries(),n=[];for(;;){const{done:r,value:s}=t.next();if(r)break;const[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function oq(e){const{kernelName:t,backendName:n}=e,r=lq(t,n);dS.has(r)&&li(`The kernel '${t}' for backend '${n}' is already registered`),dS.set(r,e)}function Ife(e){const{kernelName:t}=e;pA.has(t)&&_e().getBool("DEBUG")&&li(`Overriding the gradient for '${t}'`),pA.set(t,e)}function lq(e,t){return`${t}_${e}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uq(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var cq=Wn,Wi=null;try{Wi=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Wn(e,t,n){this.low=e|0,this.high=t|0,this.unsigned=!!n}Wn.prototype.__isLong__;Object.defineProperty(Wn.prototype,"__isLong__",{value:!0});function ni(e){return(e&&e.__isLong__)===!0}Wn.isLong=ni;var eV={},tV={};function fp(e,t){var n,r,s;return t?(e>>>=0,(s=0<=e&&e<256)&&(r=tV[e],r)?r:(n=Vn(e,(e|0)<0?-1:0,!0),s&&(tV[e]=n),n)):(e|=0,(s=-128<=e&&e<128)&&(r=eV[e],r)?r:(n=Vn(e,e<0?-1:0,!1),s&&(eV[e]=n),n))}Wn.fromInt=fp;function Vi(e,t){if(isNaN(e))return t?nh:Ui;if(t){if(e<0)return nh;if(e>=dq)return fq}else{if(e<=-rV)return Va;if(e+1>=rV)return pq}return e<0?Vi(-e,t).neg():Vn(e%wg|0,e/wg|0,t)}Wn.fromNumber=Vi;function Vn(e,t,n){return new Wn(e,t,n)}Wn.fromBits=Vn;var hS=Math.pow;function hF(e,t,n){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return Ui;if(typeof t=="number"?(n=t,t=!1):t=!!t,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=e.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return hF(e.substring(1),t,n).neg();for(var s=Vi(hS(n,8)),a=Ui,i=0;i<e.length;i+=8){var o=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+o),n);if(o<8){var u=Vi(hS(n,o));a=a.mul(u).add(Vi(l))}else a=a.mul(s),a=a.add(Vi(l))}return a.unsigned=t,a}Wn.fromString=hF;function jo(e,t){return typeof e=="number"?Vi(e,t):typeof e=="string"?hF(e,t):Vn(e.low,e.high,typeof t=="boolean"?t:e.unsigned)}Wn.fromValue=jo;var nV=65536,Cfe=1<<24,wg=nV*nV,dq=wg*wg,rV=dq/2,sV=fp(Cfe),Ui=fp(0);Wn.ZERO=Ui;var nh=fp(0,!0);Wn.UZERO=nh;var zm=fp(1);Wn.ONE=zm;var hq=fp(1,!0);Wn.UONE=hq;var fA=fp(-1);Wn.NEG_ONE=fA;var pq=Vn(-1,2147483647,!1);Wn.MAX_VALUE=pq;var fq=Vn(-1,-1,!0);Wn.MAX_UNSIGNED_VALUE=fq;var Va=Vn(0,-2147483648,!1);Wn.MIN_VALUE=Va;var tt=Wn.prototype;tt.toInt=function(){return this.unsigned?this.low>>>0:this.low};tt.toNumber=function(){return this.unsigned?(this.high>>>0)*wg+(this.low>>>0):this.high*wg+(this.low>>>0)};tt.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Va)){var n=Vi(t),r=this.div(n),s=r.mul(n).sub(this);return r.toString(t)+s.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var a=Vi(hS(t,6),this.unsigned),i=this,o="";;){var l=i.div(a),u=i.sub(l.mul(a)).toInt()>>>0,c=u.toString(t);if(i=l,i.isZero())return c+o;for(;c.length<6;)c="0"+c;o=""+c+o}};tt.getHighBits=function(){return this.high};tt.getHighBitsUnsigned=function(){return this.high>>>0};tt.getLowBits=function(){return this.low};tt.getLowBitsUnsigned=function(){return this.low>>>0};tt.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Va)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,n=31;n>0&&!(t&1<<n);n--);return this.high!=0?n+33:n+1};tt.isZero=function(){return this.high===0&&this.low===0};tt.eqz=tt.isZero;tt.isNegative=function(){return!this.unsigned&&this.high<0};tt.isPositive=function(){return this.unsigned||this.high>=0};tt.isOdd=function(){return(this.low&1)===1};tt.isEven=function(){return(this.low&1)===0};tt.equals=function(t){return ni(t)||(t=jo(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};tt.eq=tt.equals;tt.notEquals=function(t){return!this.eq(t)};tt.neq=tt.notEquals;tt.ne=tt.notEquals;tt.lessThan=function(t){return this.comp(t)<0};tt.lt=tt.lessThan;tt.lessThanOrEqual=function(t){return this.comp(t)<=0};tt.lte=tt.lessThanOrEqual;tt.le=tt.lessThanOrEqual;tt.greaterThan=function(t){return this.comp(t)>0};tt.gt=tt.greaterThan;tt.greaterThanOrEqual=function(t){return this.comp(t)>=0};tt.gte=tt.greaterThanOrEqual;tt.ge=tt.greaterThanOrEqual;tt.compare=function(t){if(ni(t)||(t=jo(t)),this.eq(t))return 0;var n=this.isNegative(),r=t.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};tt.comp=tt.compare;tt.negate=function(){return!this.unsigned&&this.eq(Va)?Va:this.not().add(zm)};tt.neg=tt.negate;tt.add=function(t){ni(t)||(t=jo(t));var n=this.high>>>16,r=this.high&65535,s=this.low>>>16,a=this.low&65535,i=t.high>>>16,o=t.high&65535,l=t.low>>>16,u=t.low&65535,c=0,d=0,h=0,p=0;return p+=a+u,h+=p>>>16,p&=65535,h+=s+l,d+=h>>>16,h&=65535,d+=r+o,c+=d>>>16,d&=65535,c+=n+i,c&=65535,Vn(h<<16|p,c<<16|d,this.unsigned)};tt.subtract=function(t){return ni(t)||(t=jo(t)),this.add(t.neg())};tt.sub=tt.subtract;tt.multiply=function(t){if(this.isZero())return Ui;if(ni(t)||(t=jo(t)),Wi){var n=Wi.mul(this.low,this.high,t.low,t.high);return Vn(n,Wi.get_high(),this.unsigned)}if(t.isZero())return Ui;if(this.eq(Va))return t.isOdd()?Va:Ui;if(t.eq(Va))return this.isOdd()?Va:Ui;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(sV)&&t.lt(sV))return Vi(this.toNumber()*t.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,a=this.low>>>16,i=this.low&65535,o=t.high>>>16,l=t.high&65535,u=t.low>>>16,c=t.low&65535,d=0,h=0,p=0,f=0;return f+=i*c,p+=f>>>16,f&=65535,p+=a*c,h+=p>>>16,p&=65535,p+=i*u,h+=p>>>16,p&=65535,h+=s*c,d+=h>>>16,h&=65535,h+=a*u,d+=h>>>16,h&=65535,h+=i*l,d+=h>>>16,h&=65535,d+=r*c+s*u+a*l+i*o,d&=65535,Vn(p<<16|f,d<<16|h,this.unsigned)};tt.mul=tt.multiply;tt.divide=function(t){if(ni(t)||(t=jo(t)),t.isZero())throw Error("division by zero");if(Wi){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var n=(this.unsigned?Wi.div_u:Wi.div_s)(this.low,this.high,t.low,t.high);return Vn(n,Wi.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?nh:Ui;var r,s,a;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return nh;if(t.gt(this.shru(1)))return hq;a=nh}else{if(this.eq(Va)){if(t.eq(zm)||t.eq(fA))return Va;if(t.eq(Va))return zm;var i=this.shr(1);return r=i.div(t).shl(1),r.eq(Ui)?t.isNegative()?zm:fA:(s=this.sub(t.mul(r)),a=r.add(s.div(t)),a)}else if(t.eq(Va))return this.unsigned?nh:Ui;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();a=Ui}for(s=this;s.gte(t);){r=Math.max(1,Math.floor(s.toNumber()/t.toNumber()));for(var o=Math.ceil(Math.log(r)/Math.LN2),l=o<=48?1:hS(2,o-48),u=Vi(r),c=u.mul(t);c.isNegative()||c.gt(s);)r-=l,u=Vi(r,this.unsigned),c=u.mul(t);u.isZero()&&(u=zm),a=a.add(u),s=s.sub(c)}return a};tt.div=tt.divide;tt.modulo=function(t){if(ni(t)||(t=jo(t)),Wi){var n=(this.unsigned?Wi.rem_u:Wi.rem_s)(this.low,this.high,t.low,t.high);return Vn(n,Wi.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};tt.mod=tt.modulo;tt.rem=tt.modulo;tt.not=function(){return Vn(~this.low,~this.high,this.unsigned)};tt.and=function(t){return ni(t)||(t=jo(t)),Vn(this.low&t.low,this.high&t.high,this.unsigned)};tt.or=function(t){return ni(t)||(t=jo(t)),Vn(this.low|t.low,this.high|t.high,this.unsigned)};tt.xor=function(t){return ni(t)||(t=jo(t)),Vn(this.low^t.low,this.high^t.high,this.unsigned)};tt.shiftLeft=function(t){return ni(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Vn(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):Vn(0,this.low<<t-32,this.unsigned)};tt.shl=tt.shiftLeft;tt.shiftRight=function(t){return ni(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?Vn(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):Vn(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};tt.shr=tt.shiftRight;tt.shiftRightUnsigned=function(t){if(ni(t)&&(t=t.toInt()),t&=63,t===0)return this;var n=this.high;if(t<32){var r=this.low;return Vn(r>>>t|n<<32-t,n>>>t,this.unsigned)}else return t===32?Vn(n,0,this.unsigned):Vn(n>>>t-32,0,this.unsigned)};tt.shru=tt.shiftRightUnsigned;tt.shr_u=tt.shiftRightUnsigned;tt.toSigned=function(){return this.unsigned?Vn(this.low,this.high,!1):this};tt.toUnsigned=function(){return this.unsigned?this:Vn(this.low,this.high,!0)};tt.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};tt.toBytesLE=function(){var t=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};tt.toBytesBE=function(){var t=this.high,n=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Wn.fromBytes=function(t,n,r){return r?Wn.fromBytesLE(t,n):Wn.fromBytesBE(t,n)};Wn.fromBytesLE=function(t,n){return new Wn(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,n)};Wn.fromBytesBE=function(t,n){return new Wn(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],n)};const mq=ey(cq),Nfe=f6({__proto__:null,default:mq},[cq]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jd=mq||Nfe;function JC(e){return jd.fromString(e,!0,16)}const gq=JC("c3a5c85c97cb3127"),zd=JC("b492b66fbe98f273"),Gs=JC("9ae16a3b2f90404f");function mA(e){return e.xor(e.shru(47))}function yq(e,t,n){const r=e.slice(t,t+n);return jd.fromBytes(Array.from(r),!0,!0)}function Rn(e,t){return yq(e,t,8)}function aV(e,t){return yq(e,t,4)}function rs(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function xc(e,t,n=JC("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function Tfe(e,t,n,r,s,a){s=s.add(e),a=rs(a.add(s).add(r),21);const i=s;return s=s.add(t),s=s.add(n),a=a.add(rs(s,44)),[s.add(r),a.add(i)]}function Sk(e,t,n,r){return Tfe(Rn(e,t),Rn(e,t+8),Rn(e,t+16),Rn(e,t+24),n,r)}function $fe(e,t=e.length){if(t>=8){const n=Gs.add(t*2),r=Rn(e,0).add(Gs),s=Rn(e,t-8),a=rs(s,37).mul(n).add(r),i=rs(r,25).add(s).mul(n);return xc(a,i,n)}if(t>=4){const n=Gs.add(t*2),r=aV(e,0);return xc(r.shl(3).add(t),aV(e,t-4),n)}if(t>0){const n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return mA(Gs.mul(a).xor(gq.mul(i))).mul(Gs)}return Gs}function Efe(e,t=e.length){const n=Gs.add(t*2),r=Rn(e,0).mul(zd),s=Rn(e,8),a=Rn(e,t-8).mul(n),i=Rn(e,t-16).mul(Gs);return xc(rs(r.add(s),43).add(rs(a,30)).add(i),r.add(rs(s.add(Gs),18)).add(a),n)}function _fe(e,t=e.length){const n=Gs.add(t*2),r=Rn(e,0).mul(Gs),s=Rn(e,8),a=Rn(e,t-8).mul(n),i=Rn(e,t-16).mul(Gs),o=rs(r.add(s),43).add(rs(a,30)).add(i),l=xc(o,r.add(rs(s.add(Gs),18)).add(a),n),u=Rn(e,16).mul(n),c=Rn(e,24),d=o.add(Rn(e,t-32)).mul(n),h=l.add(Rn(e,t-24)).mul(n);return xc(rs(u.add(c),43).add(rs(d,30)).add(h),u.add(rs(c.add(r),18)).add(d),n)}function Afe(e,t=e.length){const n=jd.fromNumber(81,!0);if(t<=32)return t<=16?$fe(e,t):Efe(e,t);if(t<=64)return _fe(e,t);let r=n,s=n.mul(zd).add(113),a=mA(s.mul(Gs).add(113)).mul(Gs),i=[jd.UZERO,jd.UZERO],o=[jd.UZERO,jd.UZERO];r=r.mul(Gs).add(Rn(e,0));let l=0;const u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=rs(r.add(s).add(i[0]).add(Rn(e,l+8)),37).mul(zd),s=rs(s.add(i[1]).add(Rn(e,l+48)),42).mul(zd),r=r.xor(o[1]),s=s.add(i[0]).add(Rn(e,l+40)),a=rs(a.add(o[0]),33).mul(zd),i=Sk(e,l,i[1].mul(zd),r.add(o[0])),o=Sk(e,l+32,a.add(o[1]),s.add(Rn(e,l+16))),[a,r]=[r,a],l+=64;while(l!==u);const d=zd.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=rs(r.add(s).add(i[0]).add(Rn(e,l+8)),37).mul(d),s=rs(s.add(i[1]).add(Rn(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(Rn(e,l+40))),a=rs(a.add(o[0]),33).mul(d),i=Sk(e,l,i[1].mul(d),r.add(o[0])),o=Sk(e,l+32,a.add(o[1]),s.add(Rn(e,l+16))),[a,r]=[r,a],xc(xc(i[0],o[0],d).add(mA(s).mul(gq)).add(a),xc(i[1],o[1],d).add(r),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rd(e,t){return t==="string"?wc(e):mp([e],t)}function Rfe(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function mp(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Eh(e)),_e().getBool("DEBUG")&&lfe(e,t),Rfe(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function ca(){return _e().platform.now()}function wc(e,t="utf-8"){return t=t||"utf-8",_e().platform.encode(e,t)}function Ac(e,t="utf-8"){return t=t||"utf-8",_e().platform.decode(e,t)}function Zi(e){return _e().platform.isTypedArray!=null?_e().platform.isTypedArray(e):uq(e)}function Eh(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||SO(e)||e==null||Zi(e)&&n)t.push(e);else if(Array.isArray(e)||Zi(e))for(let r=0;r<e.length;++r)Eh(e[r],t,n);else{let r=-1;for(const s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Eh(e[s],t,n)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dfe{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new Ffe)}profileKernel(t,n,r){let s;const a=()=>{s=r()};let i;const o=ca();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(a);else{a();for(const u of s)u.dataSync();i=Promise.resolve({kernelMs:ca()-o})}if(_e().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){const c=s[u];c.data().then(d=>{Ofe(d,c.dtype,t)})}return{kernelName:t,outputs:s,inputs:n,timeMs:i.then(u=>u.kernelMs),extraInfo:i.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:r,timeMs:s,inputs:a,extraInfo:i}=t;r.forEach(o=>{Promise.all([o.data(),s,i]).then(l=>{this.logger.logKernelProfile(n,o,l[0],l[1],a,l[2])})})}}function Ofe(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){const s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}class Ffe{logKernelProfile(t,n,r,s,a,i){const o=typeof s=="number"?Km(`${s}ms`,9):s.error,l=Km(t,25),u=n.rank,c=n.size,d=Km(n.shape.toString(),14);let h="";for(const p in a){const f=a[p];if(f!=null){const m=f.shape||n.shape,g=m.length;h+=`${p}: ${g}D ${g>0?m:""} `}}console.log(`%c${l}	%c${o}	%c${u}D ${d}	%c${c}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mfe(e,t,n){const r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){const u=e[l],c=u.inputs;for(const d in c){const h=c[d];let p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}const a={};a[n.id]=!0;const i={};for(let l=e.length-1;l>=0;l--){const u=e[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(a[u.outputs[d].id]){for(const h in c)a[c[h].id]=!0,i[u.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const u=e[l];if(s[u.id]&&i[u.id]){const c={};for(const h in u.inputs){const p=u.inputs[h];r[p.id]&&(c[h]=p)}const d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,o.push(d)}}return o}function Pfe(e,t,n,r){for(let s=t.length-1;s>=0;s--){const a=t[s],i=[];if(a.outputs.forEach(l=>{const u=e[l.id];u!=null?i.push(u):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const o=a.gradient(i);for(const l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);const c=a.inputs[l];if(!cn(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{const d=e[c.id];e[c.id]=r(d,u),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iV=20,fv=3,rE=7;function Lfe(e,t,n,r){const s=kt(t),a=zfe(e,t,n,s),i=t.length,o=b2(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function zfe(e,t,n,r){const s=Me(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l=n==="complex64"?Ov(e):e;if(o>1)for(let u=0;u<s/a;u++){const c=u*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],Dv(l[c+d],0,n).length)}return i}function Dv(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(rE))} + ${parseFloat(e[1].toFixed(rE))}j`:C0(e)?r=`'${e}'`:n==="bool"?r=bq(e):r=parseFloat(e.toFixed(rE)).toString(),Km(r,t)}function bq(e){return e===0?"false":"true"}function b2(e,t,n,r,s,a=!0){const i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){const m=Ov(e);return[Dv(m[0],0,n)]}return n==="bool"?[bq(e[0])]:[e[0].toString()]}if(l===1){if(o>iV){const g=fv*i;let y=Array.from(e.slice(0,g)),b=Array.from(e.slice((o-fv)*i,o*i));return n==="complex64"&&(y=Ov(y),b=Ov(b)),["["+y.map((x,v)=>Dv(x,s[v],n)).join(", ")+", ..., "+b.map((x,v)=>Dv(x,s[o-fv+v],n)).join(", ")+"]"]}return["["+(n==="complex64"?Ov(e):Array.from(e)).map((g,y)=>Dv(g,s[y],n)).join(", ")+"]"]}const u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>iV){for(let m=0;m<fv;m++){const g=m*d,y=g+d;h.push(...b2(e.slice(g,y),u,n,c,s,!1))}h.push("...");for(let m=o-fv;m<o;m++){const g=m*d,y=g+d;h.push(...b2(e.slice(g,y),u,n,c,s,m===o-1))}}else for(let m=0;m<o;m++){const g=m*d,y=g+d;h.push(...b2(e.slice(g,y),u,n,c,s,m===o-1))}const p=l===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Ov(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ss{constructor(t,n,r){if(this.dtype=n,this.shape=t.slice(),this.size=Me(t),r!=null){const s=r.length;Y(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||gr(n,this.size),this.strides=kt(t)}set(t,...n){n.length===0&&(n=[0]),Y(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const s of t){if(s<0||s>=this.shape[n]){const a=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(a)}n++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let r=0;r<t.length-1;++r)n+=this.strides[r]*t[r];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(t/this.strides[r]),t-=n[r]*this.strides[r];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return So().makeTensor(this.values,this.shape,this.dtype)}}let So=null,xm=null;function Bfe(e){So=e}function Wfe(e){xm=e}class Lr{constructor(t,n,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=Me(t),this.strides=kt(t),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return xm.buffer(this.shape,this.dtype,t)}bufferSync(){return xm.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return _o(this.shape,t,this.dtype==="complex64")}arraySync(){return _o(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=So().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(r=>Ac(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),So().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=So().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>Ac(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await So().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),So().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return xm.print(this,t)}clone(){return this.throwIfDisposed(),xm.clone(this)}toString(t=!1){const n=this.dataSync();return Lfe(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),xm.cast(this,t)}variable(t=!0,n,r){return this.throwIfDisposed(),So().makeVariable(this,t,n,r)}}Object.defineProperty(Lr,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Oe(){return IO("Tensor",()=>Lr)}Oe();class pS extends Lr{constructor(t,n,r,s){super(t.shape,t.dtype,t.dataId,s),this.trainable=n,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!cn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);So().disposeTensor(this),this.dataId=t.dataId,So().incRef(this,null)}dispose(){So().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(pS,Symbol.hasInstance,{value:e=>e instanceof Lr&&e.assign!=null&&e.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oV;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(oV||(oV={}));var gA;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(gA||(gA={}));var yA;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(yA||(yA={}));var bA;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(bA||(bA={}));var vA;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(vA||(vA={}));const Vfe={float32:bA,int32:gA,bool:yA,complex64:vA};function Xa(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return Vfe[e][t]}function pF(e){return Xa(e,"int32")}function vq(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function xq(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function br(e,t){if(e.dtype===t.dtype)return[e,t];const n=Xa(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function wq(e){const t=[];return kq(e,t,new Set),t}function kq(e,t,n){if(e==null)return;if(e instanceof Lr){t.push(e);return}if(!Ufe(e))return;const r=e;for(const s in r){const a=r[s];n.has(a)||(n.add(a),kq(a,t,n))}}function Ufe(e){return Array.isArray(e)||typeof e=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sE(e){return e.kernelName!=null}class lV{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class kg{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new lV}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(li(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Dfe(this.backendInstance),!0}setupRegisteredKernels(){QW(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){QW(t).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof vO)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,li(`Initialization of backend ${t} failed`),li(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return li(`Initialization of backend ${t} failed`),li(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const r=t[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{const s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return kg.nextTensorId++}nextVariableId(){return kg.nextVariableId++}clone(t){const n=fe.runKernel(H0,{x:t}),r={x:t},s=i=>({x:()=>{const o="float32",l={x:i},u={dtype:o};return fe.runKernel(D0,l,u)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,!(JW(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){const s=this.backend.numDataIds();let a=0;r.forEach(l=>{a+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[];const s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const u=sE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(sE(t)){const{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;const y=JW(f,this.backendName);Y(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,x);const v=x.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(s){const w=this.getTensorsForGradient(f,m,v);r=this.saveTensorsForBackwardMode(w)}return v}}else{const{forwardFunc:f}=t,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};o=()=>{const g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}const{inputs:c,attrs:d}=t,h=sE(t)?null:t.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),s&&this.addTapeNode(u,c,n,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(t,n,r){const s=ZW(t);if(s!=null){const a=s.inputsToSave||[],i=s.outputsToSave||[];let o;s.saveAllInputs?(Y(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=a.map(u=>n[u]);const l=r.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=t;r==="string"&&C0(t[0])&&(a=t.map(l=>wc(l)));const i=s.write(a,n,r),o=new Lr(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){const l=this.state.tensorInfo.get(i),u=cfe(a);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,r,s){r=r||"float32";const a={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(t,n){const{dataId:r,shape:s,dtype:a}=t,i=new Lr(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));const a=new pS(t,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*lS(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof pS||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const r=t.size*lS(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,a,i){const o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:a},l=ZW(t);l!=null&&(s=l.gradFunc),s!=null&&(o.gradient=u=>(u=u.map((c,d)=>{if(c==null){const h=r[d],p=Os(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return c}),s(u.length>1?u:u[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=wq(t),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(t,n,r,s=!1){if(Y(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));Y(a instanceof Lr,()=>"The result y returned by f() must be a tensor.");const i=Mfe(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[a.id]=r??jfe(a.shape),Pfe(o,i,u=>this.tidy(u),Gfe);const l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(const c of u.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(t){return Y(uA(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{Y(n.every(o=>o instanceof Lr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};n.forEach((o,l)=>{s[l]=o});const a=(o,l)=>(r=t(...n,l),Y(r.value instanceof Lr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Y(uA(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{const u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];Y(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Y(c.every(h=>h instanceof Lr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return c.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=ca(),r=await this.backend.time(t);return r.wallMs=ca()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new lV;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}kg.nextTensorId=0;kg.nextVariableId=0;function jfe(e){const t=kO(Me(e),"float32");return fe.makeTensor(t,e,"float32")}function Sq(){const e=z8();if(e._tfengine==null){const t=new pfe(e);e._tfengine=new kg(t)}return yfe(e._tfengine.ENV),Bfe(()=>e._tfengine),e._tfengine}const fe=Sq();function Gfe(e,t){const n={a:e,b:t};return fe.runKernel(dy,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hfe(){return typeof navigator<"u"&&navigator!=null}function Iq(e){if(e||Hfe()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Cq(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const va=_e();va.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});va.registerFlag("IS_BROWSER",()=>Cq());va.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");va.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));va.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));va.registerFlag("PROD",()=>!1);va.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>va.getBool("DEBUG"));va.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);va.registerFlag("IS_TEST",()=>!1);va.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>va.getBool("DEBUG"));va.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);va.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);va.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(e,t){let n=e;if(Zi(e))return t==="string"?[]:[e.length];if(vq(e)){const s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(xq(e))return[e.buffer.size/(t==null?4:lS(t))];if(!Array.isArray(e))return[];const r=[];for(;Array.isArray(n)||Zi(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&_e().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Nq(e,r,[]),r}function Nq(e,t,n){if(n=n||[],!Array.isArray(e)&&!Zi(e)){Y(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}Y(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),Y(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const r=t.slice(1);for(let s=0;s<e.length;++s)Nq(e[s],r,n.concat(s))}function uV(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function re(e,t,n,r="numeric"){if(e instanceof Oe())return uV(r,e.dtype,t,n),e;let s=uy(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),uV(r,s,t,n),e==null||!Zi(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const a=ZC(e,s);!Zi(e)&&!Array.isArray(e)&&(e=[e]);const o=s!=="string"?mp(e,s):Eh(e,[],!0);return fe.makeTensor(o,a,s)}function Tq(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((a,i)=>re(a,`${t}[${i}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qfe="__op";function Se(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+qfe;const s=(...a)=>{fe.startScope(n);try{const i=r(...a);return SO(i)&&console.error("Cannot return a Promise inside of tidy."),fe.endScope(i),i}catch(i){throw fe.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kfe(e,t){const n=re(e,"real","complex"),r=re(t,"imag","complex");wO(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:n,imag:r};return fe.runKernel(RO,s)}const _h=Se({complex_:Kfe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QC(e,t,n,r){if(r==null)r=uy(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(xq(e)||vq(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return fe.backend.createTensorFromGPUData(e,t||n,r)}if(!Zi(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Su(t);const s=Me(t),a=Me(n);Y(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){const o=n[i],l=i===n.length-1?o!==Me(t.slice(i)):!0;Y(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!Zi(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?mp(e,r):Eh(e,[],!0),fe.makeTensor(e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hh(e,t,n){const r=ZC(e,n);return QC(e,t,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fS={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class sd{static join(t){return new sd(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>Zi(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){const s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const a=n+s.byteLength;this.shards.push({buffer:s,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);const s=n-t,a=new ArrayBuffer(s),i=new Uint8Array(a);let o=0;for(let l=r;l<this.shards.length;l++){const u=this.shards[l],d=t+o-u.start,h=o,f=Math.min(n,u.end)-u.start,m=new Uint8Array(u.buffer,d,f-d);if(i.set(m,h),o+=m.length,n<u.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(s){return t<s.start?-1:t>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=Xfe(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Xfe(e,t){let n=0,r=e.length;for(;n<=r;){const s=Math.floor((r-n)/2)+n,a=t(e[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rl(){return fe}function xA(){return fe.memory()}function Ee(e,t){return fe.tidy(e,t)}function Vt(e){wq(e).forEach(n=>n.dispose())}function wl(e){return fe.keep(e)}function Ym(e){return fe.setBackend(e)}function Jm(){return fe.ready()}function fF(){return fe.backendName}function $q(e,t,n=1){return fe.registerBackend(e,t,n)}function Yfe(){return fe.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sg=4;async function cV(e,t){const n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){const o=s[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const c=new Promise(async d=>{const h=await l.bytes(),p=h.reduce((g,y)=>g+y.length,0)+Sg*h.length,f=new Uint8Array(p);let m=0;for(let g=0;g<h.length;g++){const y=h[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=Sg,f.set(y,m),m+=y.length}d(f)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}const a=await Promise.all(r);return{data:eme(a),specs:n}}function Jfe(e,t){const n=new sd(e),r={};let s=0;for(const a of t){const i=Zfe(a,(o,l)=>n.slice(s+o,s+l));r[a.name]=Qfe(a,n.slice(s,s+i)),s+=i}return r}function Zfe(e,t){const n=Me(e.shape);let r;if("quantization"in e){const s=e.quantization;r=fS[s.dtype]}else if(e.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=Sg+new Uint32Array(t(s,s+Sg))[0];return s}else r=fS[e.dtype];return n*r}function Qfe(e,t){const n=e.name,r=e.dtype,s=e.shape,a=Me(s);let i,o=0;if("quantization"in e){const l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const u=fS[l.dtype],c=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let d=0;d<c.length;d++){const h=c[d];i[d]=h*l.scale+l.min}}else if(l.dtype==="float16")i=cme()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let d=0;d<c.length;d++){const h=c[d];i[d]=Math.round(h*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*u}else if(r==="string"){const l=Me(e.shape);i=[];for(let u=0;u<l;u++){const c=new Uint32Array(t.slice(o,o+Sg))[0];o+=Sg;const d=new Uint8Array(t.slice(o,o+c));i.push(d),o+=c}}else{const l=fS[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);const u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let f=0;f<u.length;f++)u[f]=i[f*2],c[f]=i[f*2+1];const d=hh(u,s,"float32"),h=hh(c,s,"float32"),p=_h(d,h);return d.dispose(),h.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*l}return hh(i,s,r)}function eme(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(t);let s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}const mF=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function dV(e){return mF?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function tme(e){if(mF)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function nme(e){if(mF){const r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function rme(e){return sd.join(e)}function sme(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function ame(e,t,n){const r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function ime(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),ame(e,n,r)}function gF(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:dV(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:dV(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new sd(e.weightData).byteLength}}function hV(e){const t=[];for(const n of e)t.push(...n.weights);return t}function ome(){const e=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function lme(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function ume(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function cme(){const e=ome(),t=lme(),n=ume();return r=>{const s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){const o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];a[i]=l}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class es{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return es.instance==null&&(es.instance=new es),es.instance}static registerSaveRouter(t){es.getInstance().saveRouters.push(t)}static registerLoadRouter(t){es.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return es.getHandlers(t,"save")}static getLoadHandlers(t,n){return es.getHandlers(t,"load",n)}static getHandlers(t,n,r){const s=[];return(n==="load"?es.getInstance().loadRouters:es.getInstance().saveRouters).forEach(i=>{const o=i(t,r);o!==null&&s.push(o)}),s}}const dme=e=>es.getSaveHandlers(e),hme=(e,t)=>es.getLoadHandlers(e,t);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wA="tensorflowjs",kA=1,rh="models_store",nc="model_info_store";function Eq(){if(!_e().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function SA(e){const t=e.result;t.createObjectStore(rh,{keyPath:"modelPath"}),t.createObjectStore(nc,{keyPath:"modelPath"})}class Ah{constructor(t){if(this.indexedDB=Eq(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((r,s)=>{const a=this.indexedDB.open(wA,kA);a.onupgradeneeded=()=>SA(a),a.onsuccess=()=>{const i=a.result;if(n==null){const o=i.transaction(rh,"readonly"),u=o.objectStore(rh).get(this.modelPath);u.onsuccess=()=>{if(u.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(u.result.modelArtifacts)},u.onerror=c=>(i.close(),s(u.error)),o.oncomplete=()=>i.close()}else{n.weightData=sd.join(n.weightData);const o=gF(n),l=i.transaction(nc,"readwrite");let u=l.objectStore(nc),c;try{c=u.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(h){return s(h)}let d;c.onsuccess=()=>{d=i.transaction(rh,"readwrite");const h=d.objectStore(rh);let p;try{p=h.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:o})}catch(f){return s(f)}p.onsuccess=()=>r({modelArtifactsInfo:o}),p.onerror=f=>{u=l.objectStore(nc);const m=u.delete(this.modelPath);m.onsuccess=()=>(i.close(),s(p.error)),m.onerror=g=>(i.close(),s(p.error))}},c.onerror=h=>(i.close(),s(c.error)),l.oncomplete=()=>{d==null?i.close():d.oncomplete=()=>i.close()}}},a.onerror=i=>s(a.error)})}}Ah.URL_SCHEME="indexeddb://";const _q=e=>_e().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Ah.URL_SCHEME)?pme(e.slice(Ah.URL_SCHEME.length)):null;es.registerSaveRouter(_q);es.registerLoadRouter(_q);function pme(e){return new Ah(e)}function fme(e){return e.startsWith(Ah.URL_SCHEME)?e.slice(Ah.URL_SCHEME.length):e}class mme{constructor(){this.indexedDB=Eq()}async listModels(){return new Promise((t,n)=>{const r=this.indexedDB.open(wA,kA);r.onupgradeneeded=()=>SA(r),r.onsuccess=()=>{const s=r.result,a=s.transaction(nc,"readonly"),o=a.objectStore(nc).getAll();o.onsuccess=()=>{const l={};for(const u of o.result)l[u.modelPath]=u.modelArtifactsInfo;t(l)},o.onerror=l=>(s.close(),n(o.error)),a.oncomplete=()=>s.close()},r.onerror=s=>n(r.error)})}async removeModel(t){return t=fme(t),new Promise((n,r)=>{const s=this.indexedDB.open(wA,kA);s.onupgradeneeded=()=>SA(s),s.onsuccess=()=>{const a=s.result,i=a.transaction(nc,"readwrite"),o=i.objectStore(nc),l=o.get(t);let u;l.onsuccess=()=>{if(l.result==null)return a.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const c=o.delete(t),d=()=>{u=a.transaction(rh,"readwrite");const p=u.objectStore(rh).delete(t);p.onsuccess=()=>n(l.result.modelArtifactsInfo),p.onerror=f=>r(l.error)};c.onsuccess=d,c.onerror=h=>(d(),a.close(),r(l.error))}},l.onerror=c=>(a.close(),r(l.error)),i.oncomplete=()=>{u==null?a.close():u.oncomplete=()=>a.close()}},s.onerror=a=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ql="/",wm="tensorflowjs_models",Aq="info",gme="model_topology",yme="weight_specs",bme="weight_data",vme="model_metadata";function Rq(e){return{info:[wm,e,Aq].join(Ql),topology:[wm,e,gme].join(Ql),weightSpecs:[wm,e,yme].join(Ql),weightData:[wm,e,bme].join(Ql),modelMetadata:[wm,e,vme].join(Ql)}}function Dq(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function xme(e){const t=e.split(Ql);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(Ql)}function wme(e){return e.startsWith(Rh.URL_SCHEME)?e.slice(Rh.URL_SCHEME.length):e}class Rh{constructor(t){if(!_e().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Rq(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),s=gF(t),a=sd.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,tme(a));const i={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw Dq(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=s;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const o=JSON.parse(a);n.format=o.format,n.generatedBy=o.generatedBy,n.convertedBy=o.convertedBy,o.signature!=null&&(n.signature=o.signature),o.userDefinedMetadata!=null&&(n.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(n.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(n.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(n.trainingConfig=o.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=nme(i),n}}Rh.URL_SCHEME="localstorage://";const Oq=e=>_e().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Rh.URL_SCHEME)?kme(e.slice(Rh.URL_SCHEME.length)):null;es.registerSaveRouter(Oq);es.registerLoadRouter(Oq);function kme(e){return new Rh(e)}class Sme{constructor(){Y(_e().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Y(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=wm+Ql,r=Ql+Aq;for(let s=0;s<this.LS.length;++s){const a=this.LS.key(s);if(a.startsWith(n)&&a.endsWith(r)){const i=xme(a);t[i]=JSON.parse(this.LS.getItem(a))}}return t}async removeModel(t){t=wme(t);const n=Rq(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(n.info));return Dq(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pV="://";class al{constructor(){this.managers={}}static getInstance(){return al.instance==null&&(al.instance=new al),al.instance}static registerManager(t,n){Y(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(pV)&&(t=t.slice(0,t.indexOf(pV))),Y(t.length>0,()=>"scheme must not be an empty string.");const r=al.getInstance();Y(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){const n=al.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(al.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ime{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!_e().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return uq(t)}}if(_e().get("IS_BROWSER")){_e().setPlatform("browser",new Ime);try{al.registerManager(Rh.URL_SCHEME,new Sme)}catch{}try{al.registerManager(Ah.URL_SCHEME,new mme)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cme={importFetch:()=>require("node-fetch")};let aE;class Nme{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return _e().global.fetch!=null?_e().global.fetch(t,n):(aE==null&&(aE=Cme.importFetch()),aE(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}_e().get("IS_NODE")&&!_e().get("IS_BROWSER")&&_e().setPlatform("node",new Nme);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(e,t="float32",n){return t=t||"float32",Su(e),new Ss(e,t,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tme(e,t){const n=re(e,"x","cast");if(!ufe(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},s={dtype:t};return fe.runKernel(D0,r,s)}const at=Se({cast_:Tme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $me(e){const n={x:re(e,"x","clone","string_or_numeric")};return fe.runKernel(H0,n)}const ph=Se({clone_:$me});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eme(e,t=!1){console.log(e.toString(t))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Sq();const _me={buffer:Gt,cast:at,clone:ph,print:Eme};Wfe(_me);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ame(e,t){let n=re(e,"a","add"),r=re(t,"b","add");[n,r]=br(n,r);const s={a:n,b:r};return fe.runKernel(dy,s)}const Ge=Se({add_:Ame});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rme(e,t){let n=re(e,"a","floorDiv"),r=re(t,"b","floorDiv");[n,r]=br(n,r);const s={a:n,b:r};return fe.runKernel(j0,s)}const Fq=Se({floorDiv_:Rme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dme(e,t){let n=re(e,"a","div"),r=re(t,"b","div");if([n,r]=br(n,r),n.dtype==="int32"&&r.dtype==="int32")return Fq(n,r);const s={a:n,b:r},a={};return fe.runKernel(L0,s,a)}const Ct=Se({div_:Dme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ome(e,t){let n=re(e,"a","mul"),r=re(t,"b","mul");[n,r]=br(n,r);const s={a:n,b:r};return fe.runKernel(tx,s)}const me=Se({mul_:Ome});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fme(e){const t=re(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return fe.runKernel(sC,n)}else{const n={x:t};return fe.runKernel(JI,n)}}const Us=Se({abs_:Fme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mme(e){const n={x:re(e,"x","acos")};return fe.runKernel(N0,n)}const Pme=Se({acos_:Mme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lme(e){const n={x:re(e,"x","acosh")};return fe.runKernel(T0,n)}const zme=Se({acosh_:Lme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bme(e,t=null,n=!1){const s={x:re(e,"x","all","bool")},a={axis:t,keepDims:n};return fe.runKernel(NO,s,a)}const Mq=Se({all_:Bme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wme(e,t=null,n=!1){const s={x:re(e,"x","any","bool")},a={axis:t,keepDims:n};return fe.runKernel(TO,s,a)}const IA=Se({any_:Wme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vme(e,t=0){const r={x:re(e,"x","argMax")},s={axis:t};return fe.runKernel(ZI,r,s)}const F1=Se({argMax_:Vme});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ume(e,t=0){const r={x:re(e,"x","argMin")},s={axis:t};return fe.runKernel(QI,r,s)}const jme=Se({argMin_:Ume});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gme(e){const n={x:re(e,"x","asin")};return fe.runKernel($0,n)}const Hme=Se({asin_:Gme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qme(e){const n={x:re(e,"x","asinh")};return fe.runKernel(E0,n)}const Kme=Se({asinh_:qme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xme(e){const n={x:re(e,"x","atan")};return fe.runKernel(_0,n)}const Yme=Se({atan_:Xme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jme(e,t){let n=re(e,"a","atan2"),r=re(t,"b","atan2");[n,r]=br(n,r);const s={a:n,b:r};return fe.runKernel(R0,s)}const Zme=Se({atan2_:Jme});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qme(e){const n={x:re(e,"x","atanh")};return fe.runKernel(A0,n)}const ege=Se({atanh_:Qme});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(e,t,n,r,s="NHWC",a){const i=e[3],o=[...t,i],l=Cu(s);return Cs(e,o,n,a,r,null,null,l)}function no(e,t,n,r,s,a,i="channelsLast"){const[o,l]=M1(t);let u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return Cs(e,u,n,r,s,a,!1,i)}function Iu(e,t,n,r,s,a,i="NDHWC"){const[o,l,u]=CA(t);let c,d;if(i==="NDHWC")d="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return ad(e,c,n,r,s,!1,d,a)}function Cs(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d]=e;else if(o==="channelsFirst")[l,d,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);const[h,p,,f]=t,[m,g]=M1(n),[y,b]=M1(r),x=Zm(h,y),v=Zm(p,b),{padInfo:w,outHeight:k,outWidth:S}=rge(s,u,c,m,g,x,v,a,o),I=i?f*d:f;let $;return o==="channelsFirst"?$=[l,I,k,S]:o==="channelsLast"&&($=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:$,filterShape:t}}function ad(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d,h]=e;else if(i==="channelsFirst")[l,h,u,c,d]=e;else throw new Error(`Unknown dataFormat ${i}`);const[p,f,m,,g]=t,[y,b,x]=CA(n),[v,w,k]=CA(r),S=Zm(p,v),I=Zm(f,w),$=Zm(m,k),{padInfo:C,outDepth:T,outHeight:N,outWidth:E}=sge(s,u,c,d,y,b,x,S,I,$,o),_=a?g*h:g;let R;return i==="channelsFirst"?R=[l,_,T,N,E]:i==="channelsLast"&&(R=[l,T,N,E,_]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:N,outWidth:E,outChannels:_,padInfo:C,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:$,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:R,filterShape:t}}function tge(e,t,n,r,s){r==null&&(r=yF(e,t,n));const a=e[0],i=e[1],o=P1((a-t+2*r)/n+1,s),l=P1((i-t+2*r)/n+1,s);return[o,l]}function nge(e,t,n,r,s,a){s==null&&(s=yF(e,t[0],r[0]));const i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=P1((e[o]-t[o]+2*s)/r[o]+1,a));return i}function yF(e,t,n,r=1){const s=Zm(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function M1(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function CA(e){return typeof e=="number"?[e,e,e]:e}function Zm(e,t){return t<=1?e:e+(e-1)*(t-1)}function rge(e,t,n,r,s,a,i,o,l){let u,c,d;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const p=tge([t,n],a,r,e,o);c=p[0],d=p[1]}else if(e==="same"){c=Math.ceil(t/r),d=Math.ceil(n/s);const h=Math.max(0,(c-1)*r+a-t),p=Math.max(0,(d-1)*s+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2),y=p-g;u={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){const h=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:h===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=P1((t-a+h+p)/r+1,o),d=P1((n-i+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:d}}function sge(e,t,n,r,s,a,i,o,l,u,c){let d,h,p,f;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const g=nge([t,n,r,1],[o,l,u],1,[s,a,i],e,c);h=g[0],p=g[1],f=g[2]}else if(e==="same"){h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);const m=(h-1)*s+o-t,g=(p-1)*a+l-n,y=(f-1)*i+u-r,b=Math.floor(m/2),x=m-b,v=Math.floor(g/2),w=g-v,k=Math.floor(y/2),S=y-k;d={top:v,bottom:w,left:k,right:S,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function P1(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Dh(e){const[t,n,r]=M1(e);return t===1&&n===1&&r===1}function Ps(e,t){return Dh(e)||Dh(t)}function Oh(e){return M1(e).every(t=>t>0)}function Cu(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Ta(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")Y(xg(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{Y(xg(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function age(e,t){const r={x:re(e,"x","reshape","string_or_numeric")},s={shape:t};return fe.runKernel(LC,r,s)}const we=Se({reshape_:age});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ige(e,t,n,r,s){const a=re(e,"x","avgPool","float32"),i=1;Y(Ps(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=we(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),Ta("avgPool",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s};let d=fe.runKernel(eC,u,c);return d=at(d,a.dtype),l?we(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const bF=Se({avgPool_:ige});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oge(e,t,n,r,s,a="NDHWC"){const i=re(e,"x","avgPool3d","float32");let o=i,l=!1;i.rank===4&&(l=!0,o=we(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),Y(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Y(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),Ta("avgPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a};let d=fe.runKernel(tC,u,c);return d=at(d,o.dtype),l?we(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const lge=Se({avgPool3d_:oge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uge(e,t=0){Y(e.length>=1,()=>"Pass at least one tensor to concat");const n=Tq(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return ph(n[0]);const r=n,s={axis:t};return fe.runKernel(aC,r,s)}const ga=Se({concat_:uge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cge(e,t,n=!1,r=!1){let s=re(e,"a","matMul"),a=re(t,"b","matMul");[s,a]=br(s,a);const i={a:s,b:a},o={transposeA:n,transposeB:r};return fe.runKernel(nC,i,o)}const ln=Se({matMul_:cge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dge(e){const n={x:re(e,"x","sigmoid","float32")};return fe.runKernel(hx,n)}const hy=Se({sigmoid_:dge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hge(e,t,n){const r=re(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},a={begin:t,size:n};return fe.runKernel(UC,s,a)}const Dn=Se({slice_:hge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pge(e){const n={x:re(e,"x","tanh","float32")};return fe.runKernel(bx,n)}const vF=Se({tanh_:pge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fge(e,t,n){const r=re(e,"x","batchToSpaceND"),s=t.reduce((o,l)=>o*l);Y(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),Y(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),Y(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);const a={x:r},i={blockShape:t,crops:n};return fe.runKernel(rC,a,i)}const xF=Se({batchToSpaceND_:fge});function mge(e){let t;return e.rank===0||e.rank===1?t=we(e,[1,1,1,e.size]):e.rank===2?t=we(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=we(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gge(e,t,n,r,s,a){a==null&&(a=.001);const i=re(e,"x","batchNorm"),o=re(t,"mean","batchNorm"),l=re(n,"variance","batchNorm");let u;s!=null&&(u=re(s,"scale","batchNorm"));let c;r!=null&&(c=re(r,"offset","batchNorm")),Y(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:mge(i),scale:u,offset:c,mean:o,variance:l},p={varianceEpsilon:a},f=fe.runKernel(fC,h,p);return we(f,i.shape)}const eN=Se({batchNorm_:gge});function yge(e,t,n,r,s,a){const i=re(e,"x","batchNorm"),o=re(t,"mean","batchNorm"),l=re(n,"variance","batchNorm");let u;s!=null&&(u=re(s,"scale","batchNorm"));let c;return r!=null&&(c=re(r,"offset","batchNorm")),Y(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),Y(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),Y(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),eN(i,o,l,c,u,a)}const bge=Se({batchNorm2d_:yge});function vge(e,t,n,r,s,a){const i=re(e,"x","batchNorm"),o=re(t,"mean","batchNorm"),l=re(n,"variance","batchNorm");let u;s!=null&&(u=re(s,"scale","batchNorm"));let c;return r!=null&&(c=re(r,"offset","batchNorm")),Y(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),Y(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),Y(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),eN(i,o,l,c,u,a)}const xge=Se({batchNorm3d_:vge});function wge(e,t,n,r,s,a){const i=re(e,"x","batchNorm"),o=re(t,"mean","batchNorm"),l=re(n,"variance","batchNorm");let u;s!=null&&(u=re(s,"scale","batchNorm"));let c;return r!=null&&(c=re(r,"offset","batchNorm")),Y(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),Y(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),Y(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&Y(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&Y(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),eN(i,o,l,c,u,a)}const kge=Se({batchNorm4d_:wge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sge(e,t,n){const r=re(e,"x","bincount"),s=re(t,"weights","bincount");Y(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const a={x:r,weights:s},i={size:n};return fe.runKernel(_O,a,i)}const Ige=Se({bincount_:Sge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cge(e,t){let n=re(e,"broadcastTo","x");const r=n.shape;if(Su(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const u=n.shape.slice();for(;u.length<t.length;)u.unshift(1);n=we(n,u)}const s=n.shape,a=Array.from(t);for(let u=t.length-1;u>=0;u--)if(s[u]===t[u])a[u]=1;else if(n.shape[u]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((u,c)=>u>1?c:-1).filter(u=>u>=0).length===0)return ph(n);const o={x:n},l={reps:a};return fe.runKernel(vx,o,l)}const a1=Se({broadcastTo_:Cge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nge(e){const n={x:re(e,"x","ceil","float32")};return fe.runKernel(O0,n)}const Tge=Se({ceil_:Nge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(e,t,n){Su(e),n=n||uy(t);const r={shape:e,value:t,dtype:n};return fe.runKernel(GO,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ge(e,t,n){const r=re(e,"x","clipByValue");if(Y(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return tN(r.shape,t,r.dtype);const s={x:r},a={clipValueMin:t,clipValueMax:n};return fe.runKernel(F0,s,a)}const wi=Se({clipByValue_:$ge});function Ege(e){return ga(e,0)}const _ge=Se({concat1d_:Ege});function Age(e,t){return ga(e,t)}const Rge=Se({concat2d_:Age});function Dge(e,t){return ga(e,t)}const Oge=Se({concat3d_:Dge});function Fge(e,t){return ga(e,t)}const Mge=Se({concat4d_:Fge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pge(e,t,n,r,s="NHWC",a=[1,1],i){const o=re(e,"x","conv2d","float32"),l=re(t,"filter","conv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=we(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),Y(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),Ta("conv2d",r,i);const d=s==="NHWC"?u.shape[3]:u.shape[1];Y(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),Y(Ps(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Y(Oh(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),Y(Oh(n),()=>"Error in conv2D: Strides should be larger than 0.");const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=fe.runKernel(iC,h,p);return c?we(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Fh=Se({conv2d_:Pge});function Lge(e,t,n,r,s="NWC",a=1,i){const o=re(e,"x","conv1d"),l=re(t,"filter","conv1d");let u=o,c=!1;o.rank===2&&(c=!0,u=we(o,[1,o.shape[0],o.shape[1]])),Y(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),Y(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),Ta("conv1d",r,i),Y(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Y(Ps(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),Y(Oh(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),Y(Oh(n),()=>"Error in conv1D: Stride should be larger than 0."),Y(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const d=we(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=we(u,[u.shape[0],1,u.shape[1],u.shape[2]]),g=Fh(h,d,[1,n],r,"NHWC",[1,a],i);return c?we(g,[g.shape[2],g.shape[3]]):we(g,[g.shape[0],g.shape[2],g.shape[3]])}const Pq=Se({conv1d_:Lge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zge(e,t,n,r,s,a="NHWC",i){Y(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=we(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),Y(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),Y(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Y(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const c=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?l.shape[3]:l.shape[1];Y(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),Y(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),Ta("conv2dDerInput",s,i);const h={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=fe.runKernel(oC,h,p);return u?we(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const wF=Se({conv2DBackpropInput_:zge});function Bge(e,t,n,r,s,a){const i=re(e,"x","conv2dTranspose"),o=re(t,"filter","conv2dTranspose");return wF(n,i,o,r,s,"NHWC",a)}const Lq=Se({conv2dTranspose_:Bge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wge(e,t,n,r,s="NDHWC",a=[1,1,1]){const i=re(e,"x","conv3d"),o=re(t,"filter","conv3d");let l=i,u=!1;i.rank===4&&(u=!0,l=we(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Y(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),Y(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),Y(Ps(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),Y(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),Y(Oh(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),Y(Oh(n),()=>"Error in conv3D: Strides should be larger than 0.");const c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=fe.runKernel(lC,c,d);return u?we(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Vge=Se({conv3d_:Wge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uge(e,t,n,r,s){Y(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=we(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);const l=a[4],u=i.shape[4];Y(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),Y(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),Y(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Y(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Y(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);const c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=fe.runKernel(FO,c,d);return o?we(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const zq=Se({conv3DBackpropInput_:Uge});function jge(e,t,n,r,s){const a=re(e,"x","conv3dTranspose"),i=re(t,"filter","conv3dTranspose");return zq(n,a,i,r,s)}const Gge=Se({conv3dTranspose_:jge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hge(e){const n={x:re(e,"x","cos","float32")};return fe.runKernel(M0,n)}const kF=Se({cos_:Hge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qge(e){const n={x:re(e,"x","cosh","float32")};return fe.runKernel(P0,n)}const Bq=Se({cosh_:qge});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kge(e,t=0,n=!1,r=!1){const a={x:re(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:r};return fe.runKernel(MO,a,i)}const NA=Se({cumprod_:Kge});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xge(e,t=0,n=!1,r=!1){const a={x:re(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:r};return fe.runKernel(uC,a,i)}const Wq=Se({cumsum_:Xge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yge(e,t,n,r=!1){const s=re(e,"x","denseBincount"),a=re(t,"weights","denseBincount");Y(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),Y(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);const i={x:s,weights:a},o={size:n,binaryOutput:r};return fe.runKernel(LO,i,o)}const fV=Se({denseBincount_:Yge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jge(e,t,n="NHWC"){const r=re(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];Y(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),Y(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),Y(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),Y(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);const o={x:r},l={blockSize:t,dataFormat:n};return fe.runKernel(zO,o,l)}const Zge=Se({depthToSpace_:Jge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qge(e,t,n,r,s="NHWC",a=[1,1],i){const o=re(e,"x","depthwiseConv2d","float32"),l=re(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;o.rank===3&&(c=!0,u=we(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),Y(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=s==="NHWC"?u.shape[3]:u.shape[1];Y(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),Ta("depthwiseConv2d",r,i);const h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=fe.runKernel(cC,h,p);return c?we(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const SF=Se({depthwiseConv2d_:Qge});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eye(e,t,n,r,s=[1,1],a="NHWC"){const i=re(e,"x","dilation2d"),o=re(t,"filter","dilation2d");Y(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),Y(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),Y(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;i.rank===3&&(l=we(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),Y(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const c={x:l,filter:o},d={strides:n,pad:r,dilations:s},h=fe.runKernel(dC,c,d);return u?we(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const tye=Se({dilation2d_:eye});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ig(e,t){const n=e.length,r=[];for(let s=0;s<n;s++){const a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function Xr(e,t){const n=[];for(let r=0;r<t.length;r++){const s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function Ot(e,t){const n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){const o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nye(e,t){let n=re(e,"a","equal","string_or_numeric"),r=re(t,"b","equal","string_or_numeric");[n,r]=br(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(hC,s)}const Al=Se({equal_:nye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rye(e,t,n){const r=re(t,"a","where"),s=re(n,"b","where"),a=re(e,"condition","where","bool"),i=Ot(Ot(a.shape,r.shape),s.shape),o=a1(a,i),l=a1(r,i),u=a1(s,i),c={condition:o,t:l,e:u};return fe.runKernel(VC,c)}const Ys=Se({where_:rye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sye(e){const n={x:re(e,"x","zerosLike")};return fe.runKernel(YC,n)}const Qt=Se({zerosLike_:sye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aye(e,t){let n=re(e,"a","div"),r=re(t,"b","div");[n,r]=br(n,r);const s=Ct(n,r),a=Qt(s),i=Al(r,a);return Ys(i,a,s)}const iye=Se({divNoNan_:aye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oye(e,t){const n=re(e,"t1","dot"),r=re(t,"t2","dot");Y((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(Y(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){const i=we(n,[1,-1]),o=we(r,[-1,1]),l=ln(i,o);return we(l,[])}else if(n.rank===1&&r.rank===2){const i=we(n,[1,-1]),o=we(r,[r.shape[0],r.shape[1]]),l=ln(i,o);return we(l,[l.size])}else if(n.rank===2&&r.rank===1){const i=we(r,[-1,1]),o=ln(n,i);return we(o,[o.size])}else{const i=we(r,[r.shape[0],r.shape[1]]);return ln(n,i)}}const lye=Se({dot_:oye});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uye(e,...t){const n=t.map((s,a)=>re(s,`tensors${a}`,"einsum")),r={equation:e};return fe.runKernel(VO,n,r)}const mv=Se({einsum_:uye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cye(e){const n={x:re(e,"x","elu","float32")};return fe.runKernel(z0,n)}const nN=Se({elu_:cye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dye(e){let t=re(e,"x","erf");Y(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=at(t,"float32"));const n={x:t};return fe.runKernel(B0,n)}const hye=Se({erf_:dye});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IF(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Vq(e,t,n){const r=e.length+t.length,s=[];let a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function ps(e,t){const n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);const s=t.map(a=>e[a]);return[n,s]}function Ar(e,t){const n=t.map(r=>1);return Vq(e,n,t)}function Ns(e,t,n){Y(IF(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function lr(e,t){if(IF(e,t))return null;const n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function id(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function vr(e,t){const n=[];for(let r=t-e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pye(e,t=null,n=!1){const s={x:re(e,"x","max")},a={reductionIndices:t,keepDims:n};return fe.runKernel(IC,s,a)}const Ao=Se({max_:pye});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fye(e,t=null,n=!1){const s={x:re(e,"x","min")},a={axis:t,keepDims:n};return fe.runKernel($C,s,a)}const mS=Se({min_:fye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mye(e,t){let n=re(e,"base","pow"),r=re(t,"exp","pow");[n,r]=br(n,r);const s={a:n,b:r};return fe.runKernel(nx,s)}const Cg=Se({pow_:mye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function un(e,t){if((Zi(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Zi(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return QC(e,[],[],t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gye(e){const n={x:re(e,"x","sqrt","float32")};return fe.runKernel(fx,n)}const Qs=Se({sqrt_:gye});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yye(e){const t=re(e,"x","square"),n={};return fe.runKernel("Square",{x:t},n)}const Bn=Se({square_:yye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bye(e,t=null,n=!1){let r=re(e,"x","sum");r.dtype==="bool"&&(r=at(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return fe.runKernel(jC,s,a)}const St=Se({sum_:bye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vye(e,t="euclidean",n=null,r=!1){e=re(e,"x","norm");const s=Uq(e,t,n);let a=s.shape;if(r){const i=Ht(n,e.shape);a=Ar(s.shape,i)}return we(s,a)}function Uq(e,t,n=null){if(e.rank===0)return Us(e);if(e.rank!==1&&n===null)return Uq(we(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return St(Us(e),n);if(t===1/0)return Ao(Us(e),n);if(t===-1/0)return mS(Us(e),n);if(t==="euclidean"||t===2)return Qs(St(Cg(Us(e),un(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return Ao(St(Us(e),n[0]),n[1]-1);if(t===1/0)return Ao(St(Us(e),n[1]),n[0]);if(t===-1/0)return mS(St(Us(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Qs(St(Bn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const rN=Se({norm_:vye});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xye(e,t=null,n=!1){return rN(e,"euclidean",t,n)}const wye=Se({euclideanNorm_:xye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kye(e){const n={x:re(e,"x","exp")};return fe.runKernel(W0,n)}const Rl=Se({exp_:kye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sye(e,t=0){const n=re(e,"x","expandDims","string_or_numeric");Y(t<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},s={dim:t};return fe.runKernel(pC,r,s)}const da=Se({expandDims_:Sye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iye(e){const n={x:re(e,"x","expm1")};return fe.runKernel(V0,n)}const Cye=Se({expm1_:Iye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nye(e,t){const n=re(e,"x","tile","string_or_numeric");Y(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const r={x:n},s={reps:t};return fe.runKernel(vx,r,s)}const No=Se({tile_:Nye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tye(e,t,n,r="float32"){t==null&&(t=e);const s=Gt([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);const i=we(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return No(da(i,0),[n[0],1,1]);if(n.length===2)return No(da(da(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return No(da(da(da(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const jq=Se({eye_:Tye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ye(e){const n={x:re(e,"x","floor","float32")};return fe.runKernel(U0,n)}const sN=Se({floor_:$ye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eye(e,t,n=0,r=0){const s=re(e,"x","gather"),a=re(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return fe.runKernel(mC,i,o)}const CF=Se({gather_:Eye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ye(e,t){let n=re(e,"a","greater","string_or_numeric"),r=re(t,"b","greater","string_or_numeric");[n,r]=br(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(gC,s)}const Ti=Se({greater_:_ye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aye(e,t){let n=re(e,"a","greaterEqual","string_or_numeric"),r=re(t,"b","greaterEqual","string_or_numeric");[n,r]=br(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(G0,s)}const gp=Se({greaterEqual_:Aye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rye(e){const n={input:re(e,"input","imag")};return fe.runKernel(KO,n)}const NF=Se({imag_:Rye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dye(e){const n={x:re(e,"x","isFinite")};return fe.runKernel(q0,n)}const Oye=Se({isFinite_:Dye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fye(e){const n={x:re(e,"x","isInf")};return fe.runKernel(K0,n)}const Mye=Se({isInf_:Fye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pye(e){const n={x:re(e,"x","isNaN")};return fe.runKernel(X0,n)}const Lye=Se({isNaN_:Pye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zye(e,t=.2){const r={x:re(e,"x","leakyRelu")},s={alpha:t};return fe.runKernel(yC,r,s)}const TF=Se({leakyRelu_:zye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bye(e,t){let n=re(e,"a","less","string_or_numeric"),r=re(t,"b","less","string_or_numeric");[n,r]=br(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(bC,s)}const gS=Se({less_:Bye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wye(e,t){let n=re(e,"a","lessEqual","string_or_numeric"),r=re(t,"b","lessEqual","string_or_numeric");[n,r]=br(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(vC,s)}const py=Se({lessEqual_:Wye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vye(e,t=5,n=1,r=1,s=.5){const a=re(e,"x","localResponseNormalization");Y(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),Y(xg(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=we(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=fe.runKernel(SC,l,u);return o?we(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Uye=Se({localResponseNormalization_:Vye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jye(e){const n={x:re(e,"x","log","float32")};return fe.runKernel(Y0,n)}const Dl=Se({log_:jye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gye(e){const n={x:re(e,"x","log1p")};return fe.runKernel(J0,n)}const Gq=Se({log1p_:Gye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hye(e,t){Y(uA(e),()=>"The f passed in variableGrads(f) must be a function"),Y(t==null||Array.isArray(t)&&t.every(u=>u instanceof pS),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const u in fe.registeredVariables)t.push(fe.registeredVariables[u])}const r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),Y(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const a=!0,{value:i,grads:o}=fe.gradients(e,t,null,a);Y(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),Y(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Ng(e){return fe.customGrad(e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qye(e){const n={x:re(e,"x","neg")};return fe.runKernel(_C,n)}const yr=Se({neg_:qye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kye(e){const n={x:re(e,"x","softplus")};return fe.runKernel(px,n)}const kx=Se({softplus_:Kye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xye(e){const t=re(e,"x","logSigmoid");return Ng(r=>({value:yr(kx(yr(r))),gradFunc:i=>me(i,hy(yr(r)))}))(t)}const Yye=Se({logSigmoid_:Xye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jye(e,t){let n=re(e,"a","sub"),r=re(t,"b","sub");[n,r]=br(n,r);const s={a:n,b:r};return fe.runKernel(gx,s)}const Tt=Se({sub_:Jye});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(e,t=-1){const n=re(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Ng((s,a)=>{const o=Ao(s,t,!0),l=Tt(s,o),u=Tt(at(l,"float32"),Dl(St(Rl(l),t,!0)));return a([u]),{value:u,gradFunc:(d,h)=>{const[p]=h,f=!0,m=Rl(p);return Tt(d,me(St(d,t,f),m))}}})(n)}const Hq=Se({logSoftmax_:Zye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qye(e,t=null,n=!1){const r=re(e,"x","logSumExp"),s=Ht(t,r.shape),a=Ao(r,s,!0),i=Tt(r,a),o=Rl(i),l=St(o,s),u=Dl(l),c=Ge(we(a,u.shape),u);if(n){const d=Ar(c.shape,s);return we(c,d)}return c}const qq=Se({logSumExp_:Qye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(e,t){const n=re(e,"a","logicalAnd","bool"),r=re(t,"b","logicalAnd","bool");Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(xC,s)}const pu=Se({logicalAnd_:ebe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tbe(e){const n={x:re(e,"x","logicalNot","bool")};return fe.runKernel(wC,n)}const $F=Se({logicalNot_:tbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(e,t){const n=re(e,"a","logicalOr","bool"),r=re(t,"b","logicalOr","bool");Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(kC,s)}const Kq=Se({logicalOr_:nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rbe(e,t){const n=re(e,"a","logicalXor","bool"),r=re(t,"b","logicalXor","bool");return Ot(n.shape,r.shape),pu(Kq(e,t),$F(pu(e,t)))}const sbe=Se({logicalXor_:rbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function abe(e,t,n,r,s){const a=re(e,"x","maxPool"),i=1;let o=a,l=!1;a.rank===3&&(l=!0,o=we(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),Y(Ps(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),Ta("maxPool",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=fe.runKernel(CC,u,c);return l?we(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const EF=Se({maxPool_:abe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(e,t=[1,1,1],n,r,s,a="NDHWC"){const i=re(e,"x","maxPool3d");let o=i,l=!1;i.rank===4&&(l=!0,o=we(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),Y(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),Y(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),Ta("maxPool3d",r,s);const u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=fe.runKernel(NC,u,c);return l?we(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const obe=Se({maxPool3d_:ibe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(e,t){let n=re(e,"a","maximum"),r=re(t,"b","maximum");[n,r]=br(n,r),n.dtype==="bool"&&(n=at(n,"int32"),r=at(r,"int32")),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(Z0,s)}const od=Se({maximum_:lbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ube(e,t=null,n=!1){const s={x:re(e,"x","mean")},a={axis:t,keepDims:n};return fe.runKernel(TC,s,a)}const Nr=Se({mean_:ube});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function os(e,t="float32"){if(Su(e),t==="complex64"){const r=os(e,"float32"),s=os(e,"float32");return _h(r,s)}const n=Os(Me(e),t);return fe.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ld(e,t="float32"){if(Su(e),t==="complex64"){const r=ld(e,"float32"),s=os(e,"float32");return _h(r,s)}const n=kO(Me(e),t);return fe.makeTensor(n,e,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(e,t){let n=re(e,"a","minimum"),r=re(t,"b","minimum");[n,r]=br(n,r),n.dtype==="bool"&&(n=at(n,"int32"),r=at(r,"int32")),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(Q0,s)}const L1=Se({minimum_:cbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(e,t,n){Y(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=re(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Y(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)Y(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Y(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);const a={paddings:t,mode:n},i={x:r};return fe.runKernel(EC,i,a)}const hbe=Se({mirrorPad_:dbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pbe(e,t){let n=re(e,"a","mod"),r=re(t,"b","mod");[n,r]=br(n,r);const s={a:n,b:r};return fe.runKernel(ex,s)}const fbe=Se({mod_:pbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mbe(e,t=null,n=!1){e=re(e,"x","moments");const r=Ht(t,e.shape),s=Nr(e,r,n);let a=s.shape;n||(a=Ar(s.shape,r));const i=Bn(Tt(at(e,"float32"),we(s,a))),o=Nr(i,r,n);return{mean:s,variance:o}}const _F=Se({moments_:mbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gbe(e,t){let n=re(e,"a","notEqual","string_or_numeric"),r=re(t,"b","notEqual","string_or_numeric");[n,r]=br(n,r),Ot(n.shape,r.shape);const s={a:n,b:r};return fe.runKernel(AC,s)}const yS=Se({notEqual_:gbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ybe(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:re(e,"indices","oneHot","int32")},o={dtype:s,depth:t,onValue:n,offValue:r};return fe.runKernel(DC,i,o)}const Xq=Se({oneHot_:ybe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bbe(e){const n={x:re(e,"x","onesLike")};return fe.runKernel(RC,n)}const Qi=Se({onesLike_:bbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vbe(e,t,n=0){const r=re(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:t,constantValue:n},a={x:r};return fe.runKernel(FC,a,s)}const AF=Se({pad_:vbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(e,t,n){const r=re(e,"x","spaceToBatchND");Y(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),Y(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),Y(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const s={x:r},a={blockShape:t,paddings:n};return fe.runKernel(GC,s,a)}const RF=Se({spaceToBatchND_:xbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wbe(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");const o=re(e,"x","maxPool");let l=o,u=!1;o.rank===3&&(u=!0,l=we(o,[1,o.shape[0],o.shape[1],o.shape[2]])),Y(Ps(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);const c=no(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth];let h;r==="same"?h=Sbe([c.filterHeight,c.filterWidth],d):h=[[0,0],[0,0]];const p=d[0]===1&&d[1]===1,[f,m]=kbe([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:RF(l,d,f),x=(n==="avg"?()=>bF(y,t,a,g,i):()=>EF(y,t,a,g,i))(),v=p?x:xF(x,d,m);return u?we(v,[v.shape[1],v.shape[2],v.shape[3]]):v}function kbe(e,t,n){const r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=e.concat(r,s),i=t.map((c,d)=>(c-a[d]%c)%c),o=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],o[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}function Sbe(e,t){const r=e.map((i,o)=>i+(i-1)*(t[o]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),a=r.map((i,o)=>i-s[o]);return r.map((i,o)=>[s[o],a[o]])}const Ibe=Se({pool_:wbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cbe(e,t){const n=re(e,"x","prelu"),r=re(t,"alpha","prelu"),s={x:n,alpha:r};return fe.runKernel(MC,s)}const DF=Se({prelu_:Cbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbe(e,t=null,n=!1){let r=re(e,"x","prod");r.dtype==="bool"&&(r=at(r,"int32"));const s={x:r},a={axis:t,keepDims:n};return fe.runKernel(PC,s,a)}const Tbe=Se({prod_:Nbe});var OF={exports:{}};OF.exports;(function(e){(function(t,n,r){function s(l){var u=this,c=o();u.next=function(){var d=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=d-(u.c=d|0)},u.c=1,u.s0=c(" "),u.s1=c(" "),u.s2=c(" "),u.s0-=c(l),u.s0<0&&(u.s0+=1),u.s1-=c(l),u.s1<0&&(u.s1+=1),u.s2-=c(l),u.s2<0&&(u.s2+=1),c=null}function a(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function i(l,u){var c=new s(l),d=u&&u.state,h=c.next;return h.int32=function(){return c.next()*4294967296|0},h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32},h.quick=h,d&&(typeof d=="object"&&a(d,c),h.state=function(){return a(c,{})}),h}function o(){var l=4022871197,u=function(c){c=String(c);for(var d=0;d<c.length;d++){l+=c.charCodeAt(d);var h=.02519603282416938*l;l=h>>>0,h-=l,h*=l,l=h>>>0,h-=l,l+=h*4294967296}return(l>>>0)*23283064365386963e-26};return u}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.alea=i})(mr,e,!1)})(OF);var $be=OF.exports,FF={exports:{}};FF.exports;(function(e){(function(t,n,r){function s(o){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xor128=i})(mr,e,!1)})(FF);var Ebe=FF.exports,MF={exports:{}};MF.exports;(function(e){(function(t,n,r){function s(o){var l=this,u="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:u+=o;for(var c=0;c<u.length+64;c++)l.x^=u.charCodeAt(c)|0,c==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function a(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xorwow=i})(mr,e,!1)})(MF);var _be=MF.exports,PF={exports:{}};PF.exports;(function(e){(function(t,n,r){function s(o){var l=this;l.next=function(){var c=l.x,d=l.i,h,p;return h=c[d],h^=h>>>7,p=h^h<<24,h=c[d+1&7],p^=h^h>>>10,h=c[d+3&7],p^=h^h>>>3,h=c[d+4&7],p^=h^h<<7,h=c[d+7&7],h=h^h<<13,p^=h^h<<9,c[d]=p,l.i=d+1&7,p};function u(c,d){var h,p=[];if(d===(d|0))p[0]=d;else for(d=""+d,h=0;h<d.length;++h)p[h&7]=p[h&7]<<15^d.charCodeAt(h)+p[h+1&7]<<13;for(;p.length<8;)p.push(0);for(h=0;h<8&&p[h]===0;++h);for(h==8?p[7]=-1:p[h],c.x=p,c.i=0,h=256;h>0;--h)c.next()}u(l,o)}function a(o,l){return l.x=o.x.slice(),l.i=o.i,l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(c.x&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xorshift7=i})(mr,e,!1)})(PF);var Abe=PF.exports,LF={exports:{}};LF.exports;(function(e){(function(t,n,r){function s(o){var l=this;l.next=function(){var c=l.w,d=l.X,h=l.i,p,f;return l.w=c=c+1640531527|0,f=d[h+34&127],p=d[h=h+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=d[h]=f^p,l.i=h,f+(c^c>>>16)|0};function u(c,d){var h,p,f,m,g,y=[],b=128;for(d===(d|0)?(p=d,d=null):(d=d+"\0",p=0,b=Math.max(b,d.length)),f=0,m=-32;m<b;++m)d&&(p^=d.charCodeAt((m+32)%d.length)),m===0&&(g=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(g=g+1640531527|0,h=y[m&127]^=p+g,f=h==0?f+1:0);for(f>=128&&(y[(d&&d.length||0)&127]=-1),f=127,m=4*128;m>0;--m)p=y[f+34&127],h=y[f=f+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,y[f]=p^h;c.w=g,c.X=y,c.i=f}u(l,o)}function a(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function i(o,l){o==null&&(o=+new Date);var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(c.X&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.xor4096=i})(mr,e,!1)})(LF);var Rbe=LF.exports,zF={exports:{}};zF.exports;(function(e){(function(t,n,r){function s(o){var l=this,u="";l.next=function(){var d=l.b,h=l.c,p=l.d,f=l.a;return d=d<<25^d>>>7^h,h=h-p|0,p=p<<24^p>>>8^f,f=f-d|0,l.b=d=d<<20^d>>>12^h,l.c=h=h-p|0,l.d=p<<16^h>>>16^f,l.a=f-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):u+=o;for(var c=0;c<u.length+20;c++)l.b^=u.charCodeAt(c)|0,l.next()}function a(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function i(o,l){var u=new s(o),c=l&&l.state,d=function(){return(u.next()>>>0)/4294967296};return d.double=function(){do var h=u.next()>>>11,p=(u.next()>>>0)/4294967296,f=(h+p)/(1<<21);while(f===0);return f},d.int32=u.next,d.quick=d,c&&(typeof c=="object"&&a(c,u),d.state=function(){return a(u,{})}),d}n&&n.exports?n.exports=i:r&&r.amd?r(function(){return i}):this.tychei=i})(mr,e,!1)})(zF);var Dbe=zF.exports,Yq={exports:{}};const Obe={},Fbe=Object.freeze(Object.defineProperty({__proto__:null,default:Obe},Symbol.toStringTag,{value:"Module"})),Mbe=ule(Fbe);(function(e){(function(t,n,r){var s=256,a=6,i=52,o="random",l=r.pow(s,a),u=r.pow(2,i),c=u*2,d=s-1,h;function p(v,w,k){var S=[];w=w==!0?{entropy:!0}:w||{};var I=y(g(w.entropy?[v,x(n)]:v??b(),3),S),$=new f(S),C=function(){for(var T=$.g(a),N=l,E=0;T<u;)T=(T+E)*s,N*=s,E=$.g(1);for(;T>=c;)T/=2,N/=2,E>>>=1;return(T+E)/N};return C.int32=function(){return $.g(4)|0},C.quick=function(){return $.g(4)/4294967296},C.double=C,y(x($.S),n),(w.pass||k||function(T,N,E,_){return _&&(_.S&&m(_,$),T.state=function(){return m($,{})}),E?(r[o]=T,N):T})(C,I,"global"in w?w.global:this==r,w.state)}function f(v){var w,k=v.length,S=this,I=0,$=S.i=S.j=0,C=S.S=[];for(k||(v=[k++]);I<s;)C[I]=I++;for(I=0;I<s;I++)C[I]=C[$=d&$+v[I%k]+(w=C[I])],C[$]=w;(S.g=function(T){for(var N,E=0,_=S.i,R=S.j,z=S.S;T--;)N=z[_=d&_+1],E=E*s+z[d&(z[_]=z[R=d&R+N])+(z[R]=N)];return S.i=_,S.j=R,E})(s)}function m(v,w){return w.i=v.i,w.j=v.j,w.S=v.S.slice(),w}function g(v,w){var k=[],S=typeof v,I;if(w&&S=="object")for(I in v)try{k.push(g(v[I],w-1))}catch{}return k.length?k:S=="string"?v:v+"\0"}function y(v,w){for(var k=v+"",S,I=0;I<k.length;)w[d&I]=d&(S^=w[d&I]*19)+k.charCodeAt(I++);return x(w)}function b(){try{var v;return h&&(v=h.randomBytes)?v=v(s):(v=new Uint8Array(s),(t.crypto||t.msCrypto).getRandomValues(v)),x(v)}catch{var w=t.navigator,k=w&&w.plugins;return[+new Date,t,k,t.screen,x(n)]}}function x(v){return String.fromCharCode.apply(0,v)}if(y(r.random(),n),e.exports){e.exports=p;try{h=Mbe}catch{}}else r["seed"+o]=p})(typeof self<"u"?self:mr,[],Math)})(Yq);var Pbe=Yq.exports,Lbe=$be,zbe=Ebe,Bbe=_be,Wbe=Abe,Vbe=Rbe,Ube=Dbe,yp=Pbe;yp.alea=Lbe;yp.xor128=zbe;yp.xorwow=Bbe;yp.xorshift7=Wbe;yp.xor4096=Vbe;yp.tychei=Ube;var BF=yp;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jq{constructor(t,n,r,s,a){this.mean=t,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=a||Math.random();this.random=BF.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let t,n,r=!1;for(;!r;){let s,a,i;do s=2*this.random()-1,a=2*this.random()-1,i=s*s+a*a;while(i>=1||i===0);const o=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*s*o,n=this.mean+this.stdDev*a*o,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class jbe{constructor(t=0,n=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=n-t,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`);this.random=BF.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gbe(e,t=0,n=1,r,s){if(Su(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new Jq(t,n,r,!1,s),i=Gt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const Hbe=Se({randomNormal_:Gbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(e,t=0,n=1,r="float32",s){Su(e);const a=Gt(e,r),i=new jbe(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}const Sx=Se({randomUniform_:qbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const s={start:e,stop:t,step:n,dtype:r};return fe.runKernel(tF,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(e){const n={input:re(e,"input","real")};return fe.runKernel(nF,n)}const bS=Se({real_:Kbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xbe(e){const n={x:re(e,"x","reciprocal")};return fe.runKernel(rx,n)}const Ybe=Se({reciprocal_:Xbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jbe(e){const n={x:re(e,"x","relu")};return fe.runKernel(sx,n)}const bp=Se({relu_:Jbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zbe(e){const n={x:re(e,"x","relu6")};return fe.runKernel(ax,n)}const Zq=Se({relu6_:Zbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qbe(e,t){const r={x:re(e,"x","reverse")},s={dims:t};return fe.runKernel(WC,r,s)}const Mh=Se({reverse_:Qbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eve(e){const n={x:re(e,"x","round")};return fe.runKernel(ix,n)}const Qq=Se({round_:eve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tve(e){const n={x:re(e,"x","rsqrt","float32")};return fe.runKernel(ox,n)}const e9=Se({rsqrt_:tve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(e){const n={x:re(e,"x","selu")};return fe.runKernel(lx,n)}const t9=Se({selu_:nve});function rve(e,t,n,r,s,a=[1,1],i="NHWC"){const o=re(e,"x","separableConv2d"),l=re(t,"depthwiseFilter","separableConv2d"),u=re(n,"pointwiseFilter","separableConv2d");let c=o,d=!1;if(o.rank===3&&(d=!0,c=we(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Y(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),Y(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Y(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Y(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),Y(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);const h=l.shape[2],p=l.shape[3];Y(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);const f=SF(c,l,r,s,i,a),g=Fh(f,u,1,"valid",i);return d?we(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const n9=Se({separableConv2d_:rve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(e){const n={x:re(e,"x","sign")};return fe.runKernel(dx,n)}const ave=Se({sign_:sve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ive(e){const n={x:re(e,"x","sin","float32")};return fe.runKernel(ux,n)}const r9=Se({sin_:ive});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ove(e){const n={x:re(e,"x","sinh")};return fe.runKernel(cx,n)}const s9=Se({sinh_:ove});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lve(e,t,n){const r=re(e,"x","slice1d");return Y(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Dn(r,[t],[n])}const WF=Se({slice1d_:lve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uve(e,t,n){const r=re(e,"x","slice2d");return Y(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Dn(r,t,n)}const a9=Se({slice2d_:uve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cve(e,t,n){const r=re(e,"x","slice3d");return Y(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Dn(r,t,n)}const VF=Se({slice3d_:cve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dve(e,t,n){const r=re(e,"x","slice4d");return Y(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Dn(r,t,n)}const vS=Se({slice4d_:dve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hve(e,t=-1){const n=re(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const r={logits:n},s={dim:t};return fe.runKernel(qC,r,s)}const UF=Se({softmax_:hve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pve(e){Y(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return fe.runKernel(jO,t)}const i9=Se({fft_:pve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fve(e){Y(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return fe.runKernel(qO,t)}const TA=Se({ifft_:fve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mve(e){const t=e.shape[e.shape.length-1],n=e.size/t;let r;if(t<=2){const s=we(e,[n,t]);r=TA(s)}else{const s=[n,2*(t-1)],a=we(bS(e),[n,t]),i=we(NF(e),[n,t]),o=Mh(Dn(a,[0,1],[n,t-2]),1),l=me(Mh(Dn(i,[0,1],[n,t-2]),1),un(-1)),u=ga([a,o],1),c=ga([i,l],1),d=we(_h(u,c),[s[0],s[1]]);r=TA(d)}if(r=bS(r),e.rank===3&&e.shape[0]!==0){const s=r,a=e.shape[0];r=we(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}const gve=Se({irfft_:mve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yve(e,t,n=0){const s={x:re(e,"x","split")},a={numOrSizeSplits:t,axis:n};return fe.runKernel(HC,s,a)}const yi=Se({split_:yve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bve(e,t){Y(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const r=e.size/n;let s;if(t!=null&&t<n){const f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=Dn(e,f,m),n=t}else if(t!=null&&t>n){const f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,s=ga([e,os(f)],e.shape.length-1),n=t}else s=e;const a=Qt(s),i=we(_h(s,a),[r,n]),o=i9(i),l=Math.floor(n/2)+1,u=bS(o),c=NF(o),d=yi(u,[l,n-l],u.shape.length-1),h=yi(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,we(_h(d[0],h[0]),p)}const vve=Se({rfft_:bve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xve(e,t){let n=re(e,"a","squaredDifference"),r=re(t,"b","squaredDifference");[n,r]=br(n,r),Ot(n.shape,r.shape);const s={a:n,b:r},a={};return fe.runKernel(mx,s,a)}const wve=Se({squaredDifference_:xve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(e,t){const n=re(e,"x","squeeze","string_or_numeric");return we(n,nd(n.shape,t).newShape)}const Ix=Se({squeeze_:kve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sve(e,t=0){const n=Tq(e,"tensors","stack","string_or_numeric");Y(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Y(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,s={axis:t};return fe.runKernel(OC,r,s)}const fu=Se({stack_:Sve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(e,t=0){const r={x:re(e,"x","step")},s={alpha:t};return fe.runKernel(xx,r,s)}const Cx=Se({step_:Ive});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(e,t,n,r,s=0,a=0,i=0,o=0,l=0){const c={x:re(e,"x","stridedSlice","string_or_numeric")},d={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return fe.runKernel(oF,c,d)}const Nve=Se({stridedSlice_:Cve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tve(e){const n={x:re(e,"x","tan","float32")};return fe.runKernel(yx,n)}const $ve=Se({tan_:Tve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(e,t){D8(e);const n=ZC(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return QC(e,null,n,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2(e,t,n){if(D8(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=ZC(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return QC(e,t,r,n)}function o9(e,t,n){const r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function Eve(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}o9(n,t,e)}function vp(e,t,n){const r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length;let i=1;for(let d=s;d<a;++d)i*=n[d];const o=s<1?1:s,l=Me(t.shape)/o,u=[...kt(n.slice(0,s)),1],c=Me(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _ve(e,t=1,n=!0){const r=re(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);const a={x:r},i={k:t,sorted:n},[o,l]=fe.runKernel(lF,a,i);return{values:o,indices:l}}const Ave=Se({topk_:_ve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(e,t=0,n=1,r,s){if(Su(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new Jq(t,n,r,!0,s),i=Gt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}const l9=Se({truncatedNormal_:Rve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dve(e,t=0){const n=re(e,"x","unique","string_or_numeric");Y(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},s={axis:t},[a,i]=fe.runKernel(cF,r,s);return{values:a,indices:i}}const Ove=Se({unique_:Dve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fve(e,t,n){const r=re(e,"x","unsortedSegmentSum"),s=re(t,"segmentIds","unsortedSegmentSum","int32");Y(xg(n),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:s},i={numSegments:n};return fe.runKernel(XC,a,i)}const u9=Se({unsortedSegmentSum_:Fve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(e,t=0){const n=re(e,"x","unstack","string_or_numeric");Y(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},s={axis:t};return fe.runKernel(KC,r,s)}const Ph=Se({unstack_:Mve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pve(e,t=!0,n,r){return fe.makeVariable(e,t,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c9(e,t){const n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);const r=Gt(e,"int32"),s=Gt([n.length,e.length],"int32");for(let a=0;a<n.length;a++){const i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lve(e,t,n){const r=re(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),Y(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{Y(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const s={x:r},a={perm:t};return r.dtype==="complex64"?Ee(()=>{let i=bS(r),o=NF(r);return i=fe.runKernel(Xm,{x:i},a),o=fe.runKernel(Xm,{x:o},a),n&&(o=yr(o)),_h(i,o)}):fe.runKernel(Xm,s,a)}const Zt=Se({transpose_:Lve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zve(e,t){if(t==null)return e.shape.slice();if(cn(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve(e,t,n,r){const s=re(e,"x","dropout");if(Y(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),Y(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Lr?s.clone():s;const a=zve(s,n),i=1-t,o=Ct(sN(Ge(Sx(a,0,1,"float32",r),i)),i);return me(s,o)}const Wve=Se({dropout_:Bve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vve(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=we(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=we(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Y(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),Y(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Y(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const u=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?l.shape[3]:l.shape[1];Y(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),Y(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),Ta("conv2dDerFilter",s,i);const d={x:o,dy:l},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return fe.runKernel(DO,d,h)}const jF=Se({conv2DBackpropFilter_:Vve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return me(e,Cx(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function HF(e,t){let n=t;const r=Xr(e.shape,t.shape);return r.length>0&&(n=St(n,r)),we(n,e.shape)}function qF(e,t,n,r){if(t==="linear")return e;if(t==="relu")return bp(e);if(t==="elu")return nN(e);if(t==="relu6")return Zq(e);if(t==="prelu")return DF(e,n);if(t==="leakyrelu")return TF(e,r);if(t==="sigmoid")return hy(e);throw new Error(`Unknown fused activation ${t}.`)}const KF=(e,t)=>!(e>0)||t==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uve({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",KF(fe.state.gradientDepth,l)===!1){Y(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=Fh(e,t,n,r,s,a,i);return o!=null&&(k=Ge(k,o)),qF(k,l,u,c)}const d=re(e,"x","conv2d","float32"),h=re(t,"filter","conv2d","float32");let p=d,f=!1;d.rank===3&&(f=!0,p=we(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),Y(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),Ta("fused conv2d",r,i);const m=s==="NHWC"?p.shape[3]:p.shape[1];Y(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),Y(Ps(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);const g=Cs(p.shape,h.shape,n,a,r,i);let y;o!=null&&(y=re(o,"bias","fused conv2d"),[y]=br(y,d),s==="NHWC"?Ot(g.outShape,y.shape):(Y(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),Y(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){const k=u.shape;if(Y(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)Y(k[0]===1||k[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${g.outChannels}).`);else if(k.length===3)try{Ot(k,g.outShape)}catch{const I=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(I)}b=re(u,"prelu weights","fused conv2d")}const x=(k,S)=>{Y(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[I,$,C,T]=S,N=GF(k,C,l);Y(Dh(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const E=wF($.shape,N,I,n,r),_=jF($,N,I.shape,n,r),R=[E,_];if(T!=null){const z=HF(T,N);R.push(z)}return R},v={x:p,filter:h,bias:y,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?Ng((S,I,$)=>{let C=fe.runKernel(cS,v,w);return $([I,S,C]),f&&(C=we(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:x}})(p,h):Ng((S,I,$,C)=>{let T=fe.runKernel(cS,v,w);return C([I,S,T,$]),f&&(T=we(T,[T.shape[1],T.shape[2],T.shape[3]])),{value:T,gradFunc:x}})(p,h,y)}const jve=Se({fusedConv2d_:Uve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gve(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=we(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=we(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return fe.runKernel(BO,u,c)}const Hve=Se({depthwiseConv2dNativeBackpropFilter_:Gve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qve(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=we(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=fe.runKernel(WO,u,c);return l?we(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Kve=Se({depthwiseConv2dNativeBackpropInput_:qve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xve({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(KF(fe.state.gradientDepth,a)===!1){let T=ln(e,t,n,r);return s!=null&&(T=Ge(T,s)),qF(T,a,i,o)}let l=re(e,"a","fused matMul"),u=re(t,"b","fused matMul");[l,u]=br(l,u);const c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=Me(f),y=Me(m);Y(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);const x=Ot(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),v=n?we(l,[g,c,h]):we(l,[g,h,c]),w=r?we(u,[y,p,d]):we(u,[y,d,p]);let k;s!=null&&(k=re(s,"bias","fused matMul"),[k]=br(k,l),Ot(x,k.shape));let S;i!=null&&(S=re(i,"prelu weights","fused matMul"));const I=(T,N)=>{const[E,_,R,z]=N,W=GF(we(T,R.shape),R,a);let F,L;if(!n&&!r?(F=ln(W,_,!1,!0),L=ln(E,W,!0,!1)):!n&&r?(F=ln(W,_,!1,!1),L=ln(W,E,!0,!1)):n&&!r?(F=ln(_,W,!1,!0),L=ln(E,W,!1,!1)):(F=ln(_,W,!0,!0),L=ln(W,E,!0,!0)),s!=null){const O=HF(z,W);return[F,L,O]}else return[F,L]},$={a:v,b:w,bias:k,preluActivationWeights:S},C={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?Ng((N,E,_)=>{const R=fe.runKernel(uS,$,C);return _([N,E,R]),{value:we(R,x),gradFunc:I}})(v,w):Ng((N,E,_,R)=>{const z=fe.runKernel(uS,$,C);return R([N,E,z,_]),{value:we(z,x),gradFunc:I}})(v,w,k)}const mV=Se({fusedMatMul_:Xve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yve(e,t,n,r,s="bilinear",a=0){const i=re(e,"image","cropAndResize"),o=re(t,"boxes","cropAndResize","float32"),l=re(n,"boxInd","cropAndResize","int32"),u=o.shape[0];Y(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),Y(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),Y(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),Y(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Y(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Y(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return fe.runKernel(PO,c,d)}const Jve=Se({cropAndResize_:Yve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zve(e){const t=re(e,"image","flipLeftRight","float32");Y(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};return fe.runKernel(HO,n,{})}const Qve=Se({flipLeftRight_:Zve});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1e(e){const t=re(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),Y(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,No(t,s)}const t1e=Se({grayscaleToRGB_:e1e});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n1e(e){const t=re(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];Y(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),Y(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=t.dtype,a=at(t,"float32"),i=Ua([.2989,.587,.114]);let o;switch(t.rank){case 2:o=mv("ij,j->i",a,i);break;case 3:o=mv("ijk,k->ij",a,i);break;case 4:o=mv("ijkl,l->ijk",a,i);break;case 5:o=mv("ijklm,m->ijkl",a,i);break;case 6:o=mv("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=da(o,-1),at(o,s)}const r1e=Se({rgbToGrayscale_:n1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1e(e,t,n=0,r=.5){const s=re(e,"image","rotateWithOffset","float32");Y(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const a={image:s},i={radians:t,fillValue:n,center:r};return fe.runKernel(dF,a,i)}const a1e=Se({rotateWithOffset_:s1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fy(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);const i=e.shape[0];return n=Math.min(n,i),Y(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Y(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),Y(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),Y(t.rank===1,()=>"scores must be a 1D tensor"),Y(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),Y(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=re(e,"boxes","nonMaxSuppression","float32"),i=re(t,"scores","nonMaxSuppression","float32"),o=fy(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return fe.runKernel(ZO,{boxes:a,scores:i},l)}const o1e=Se({nonMaxSuppression_:i1e});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l1e(e,t,n){const r=u1e(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function u1e(e,t,n){return d1e(e,t,n||c1e)}function c1e(e,t){return e>t?1:e<t?-1:0}function d1e(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);const o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XF(e,t,n,r,s){return ZF(e,t,n,r,s,0)}function YF(e,t,n,r,s,a){return ZF(e,t,n,r,s,0,!1,a,!0)}function JF(e,t,n,r,s,a){return ZF(e,t,n,r,s,a,!0)}function ZF(e,t,n,r,s,a,i=!1,o=!1,l=!1){const u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(gV);const c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&u.length>0;){const g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<s)break;let v=!1;for(let w=d.length-1;w>=x;--w){const k=h1e(e,b,d[w]);if(k>=r){v=!0;break}if(g.score=g.score*p1e(r,c,k),g.score<=s)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&l1e(u,g,gV))}const p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));const m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function h1e(e,t,n){const r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;const m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function p1e(e,t,n){const r=Math.exp(t*n*n);return n<=e?r:0}function gV(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function f1e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){const a=re(e,"boxes","nonMaxSuppressionAsync"),i=re(t,"scores","nonMaxSuppressionAsync"),o=fy(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;const l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=XF(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),Ua(d,"int32")}const m1e=f1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g1e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=re(e,"boxes","nonMaxSuppression"),o=re(t,"scores","nonMaxSuppression"),l=fy(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=fe.runKernel(eF,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}const y1e=Se({nonMaxSuppressionWithScore_:g1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function b1e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){const i=re(e,"boxes","nonMaxSuppressionAsync"),o=re(t,"scores","nonMaxSuppressionAsync"),l=fy(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;const u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=JF(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ua(h,"int32"),selectedScores:Ua(p)}}const v1e=b1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=re(e,"boxes","nonMaxSuppression"),o=re(t,"scores","nonMaxSuppression"),l=fy(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},f=fe.runKernel(QO,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}const w1e=Se({nonMaxSuppressionPadded_:x1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function k1e(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){const i=re(e,"boxes","nonMaxSuppressionAsync"),o=re(t,"scores","nonMaxSuppressionAsync"),l=fy(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=YF(h,p,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:Ua(f,"int32"),validOutputs:un(m,"int32")}}const S1e=k1e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1e(e,t,n=!1,r=!1){const s=re(e,"images","resizeBilinear");Y(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),Y(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),Y(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=we(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=fe.runKernel(BC,o,l);return i?we(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const d9=Se({resizeBilinear_:I1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1e(e,t,n=!1,r=!1){const s=re(e,"images","resizeNearestNeighbor");Y(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),Y(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),Y(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),Y(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=we(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=fe.runKernel(zC,o,l);return i?we(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const h9=Se({resizeNearestNeighbor_:C1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N1e(e,t="binary",n=!1,r=.5){const s=re(e,"image","threshold"),a=.2989,i=.587,o=.114,l=s.shape[0]*s.shape[1];let u=me(Ua([r]),255),c,d,h,p;if(Y(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),Y(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),Y(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),Y(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,d,h]=yi(s,[1,1,1],-1);const g=me(c,a),y=me(d,i),b=me(h,o);p=Ge(Ge(g,y),b)}else p=e;if(t==="otsu"){const g=Ige(at(Qq(p),"int32"),hh([]),256);u=T1e(g,l)}const f=n?py(p,u):Ti(p,u);return at(me(f,255),"int32")}function T1e(e,t){let n=Ua([-1]),r=Ua([0]),s=Ua([0]),a,i,o,l,u,c;for(let d=0;d<e.size-1;d++){a=Dn(e,0,d+1),i=Dn(e,d+1),u=Ct(St(a),t),c=Ct(St(i),t);const h=St(me(a,z1(0,a.size)));o=Ct(h,St(a));const p=tN(i.shape,a.size),f=Ge(z1(0,i.size),p),m=me(i,f);l=Ct(St(m),St(i));const g=Tt(o,l),y=Tt(o,l),b=me(u,c);s=me(me(b,g),y);const x=Ti(s,r);r=Ys(x,s,r),n=Ys(x,Ua([d]),n)}return n}const $1e=Se({threshold_:N1e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1e(e,t,n="nearest",r="constant",s=0,a){const i=re(e,"image","transform","float32"),o=re(t,"transforms","transform","float32");Y(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),Y(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Y(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return fe.runKernel(uF,l,u)}const _1e=Se({transform_:E1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1e(e,t,n){const r=re(e,"a","bandPart");Y(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[a,i]=r.shape.slice(-2);let o,l;typeof t=="number"?(Y(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),Y(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=re(t<0?a:t,"numLower","bandPart")):(Y(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=Ys(gS(t,0),a,L1(t,a))),typeof n=="number"?(Y(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),Y(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=re(n<0?i:n,"numUpper","bandPart")):(Y(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=Ys(gS(n,0),i,L1(n,i)));const u=we(z1(0,a,1,"int32"),[-1,1]),c=z1(0,i,1,"int32"),d=Tt(u,c),h=pu(py(d,o),gp(d,yr(l))),p=os([a,i],r.dtype);return we(fu(Ph(we(r,[-1,a,i])).map(f=>Ys(h,f,p))),s)}const R1e=Se({bandPart_:A1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1e(e){let t;if(Array.isArray(e)){t=!1,Y(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=e[0].shape[0];for(let a=1;a<e.length;++a)Y(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=yi(e,e.shape[0],0).map(s=>Ix(s,[0]));Y(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[],r=e;for(let s=0;s<e.length;++s)n.push(fe.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){const o=me(St(me(n[i],a)),n[i]);a=Tt(a,o)}return Ct(a,rN(a,"euclidean"))}));return t?fu(n,0):n}const O1e=Se({gramSchmidt_:D1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1e(e,t=!1){if(Y(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return yV(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=Ph(we(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(l=>{const[u,c]=yV(l,t);s.push(u),a.push(c)});const i=we(fu(s,0),e.shape),o=we(fu(a,0),e.shape);return[i,o]}}function yV(e,t=!1){return fe.tidy(()=>{Y(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0],r=e.shape[1];let s=jq(n),a=ph(e);const i=v2([[1]],[1,1]);let o=ph(i);const l=n>=r?r:n;for(let u=0;u<l;++u){const c=a,d=o,h=s;[o,a,s]=fe.tidy(()=>{const p=Dn(a,[u,u],[n-u,1]),f=rN(p),m=Dn(a,[u,u],[1,1]),g=Ys(Ti(m,0),v2([[-1]]),v2([[1]])),y=Tt(m,me(g,f)),b=Ct(p,y);b.shape[0]===1?o=ph(i):o=ga([i,Dn(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const x=yr(Ct(ln(g,y),f)),v=Dn(a,[u,0],[n-u,r]),w=me(x,o),k=Zt(o);if(u===0)a=Tt(v,ln(w,ln(k,v)));else{const $=Tt(v,ln(w,ln(k,v)));a=ga([Dn(a,[0,0],[u,r]),$],0)}const S=Zt(w),I=Dn(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=Tt(I,ln(ln(I,o),S));else{const $=Tt(I,ln(ln(I,o),S));s=ga([Dn(s,[0,0],[n,u]),$],1)}return[o,a,s]}),Vt([c,d,h])}return!t&&n>r&&(s=Dn(s,[0,0],[n,r]),a=Dn(a,[0,0],[r,r])),[s,a]})}const M1e=Se({qr_:F1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ru={flipLeftRight:Qve,grayscaleToRGB:t1e,resizeNearestNeighbor:h9,resizeBilinear:d9,rgbToGrayscale:r1e,rotateWithOffset:a1e,cropAndResize:Jve,nonMaxSuppression:o1e,nonMaxSuppressionAsync:m1e,nonMaxSuppressionWithScore:y1e,nonMaxSuppressionWithScoreAsync:v1e,nonMaxSuppressionPadded:w1e,nonMaxSuppressionPaddedAsync:S1e,threshold:$1e,transform:_1e},P1e={bandPart:R1e,gramSchmidt:O1e,qr:M1e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L1e=new Map,z1e=new Map;class my{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class zi{constructor(){this.classNameMap={}}static getMap(){return zi.instance==null&&(zi.instance=new zi),zi.instance}static register(t){zi.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Ve(e,t,n){Y(e.className!=null,()=>"Class being registered does not have the static className property defined."),Y(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),Y(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);const r=n,s=t+">"+r;return zi.register(e),L1e.set(s,e),z1e.set(e,s),e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ud extends my{minimize(t,n=!1,r){const{value:s,grads:a}=this.computeGradients(t,r);if(r!=null){const i=r.map(o=>({name:o.name,tensor:a[o.name]}));this.applyGradients(i)}else this.applyGradients(a);return Vt(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return Hye(t,n)}dispose(){this.iterations_!=null&&Vt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:un(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ud,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p9 extends ud{static get className(){return"Adadelta"}constructor(t,n,r=null){super(),this.learningRate=t,this.rho=n,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=fe.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=fe.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:Ee(()=>Qt(a).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:Ee(()=>Qt(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const l=this.accumulatedGrads[s].variable,u=this.accumulatedUpdates[s].variable;Ee(()=>{const c=Ge(me(l,this.rho),me(Bn(o),1-this.rho)),d=me(Ct(Qs(Ge(u,this.epsilon)),Qs(Ge(l,this.epsilon))),o),h=Ge(me(u,this.rho),me(Bn(d),1-this.rho));l.assign(c),u.assign(h);const p=Ge(me(d,-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Vt(this.accumulatedGrads.map(t=>t.variable)),Vt(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class f9 extends ud{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=fe.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:Ee(()=>tN(a.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(t)?t[s].tensor:t[r];if(i==null)return;const o=this.accumulatedGrads[s].variable;Ee(()=>{const l=Ge(o,Bn(i));o.assign(l);const u=Ge(me(Ct(i,Qs(Ge(l,fe.backend.epsilon()))),-this.learningRate),a);a.assign(u)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Vt(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m9 extends ud{static get className(){return"Adam"}constructor(t,n,r,s=null){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Ee(()=>{this.accBeta1=un(n).variable(),this.accBeta2=un(r).variable()}),s==null&&(this.epsilon=fe.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Ee(()=>{const r=Tt(1,this.accBeta1),s=Tt(1,this.accBeta2);n.forEach((a,i)=>{const o=fe.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:Ee(()=>Qt(o).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:Ee(()=>Qt(o).variable(l))});const u=Array.isArray(t)?t[i].tensor:t[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedSecondMoment[i].variable,h=Ge(me(c,this.beta1),me(u,1-this.beta1)),p=Ge(me(d,this.beta2),me(Bn(u),1-this.beta2)),f=Ct(h,r),m=Ct(p,s);c.assign(h),d.assign(p);const g=Ge(me(Ct(f,Ge(Qs(m),this.epsilon)),-this.learningRate),o);o.assign(g)}),this.accBeta1.assign(me(this.accBeta1,this.beta1)),this.accBeta2.assign(me(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Vt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Vt(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),Ee(()=>{this.accBeta1.assign(Cg(this.beta1,this.iterations_+1)),this.accBeta2.assign(Cg(this.beta2,this.iterations_+1))});const n=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g9 extends ud{static get className(){return"Adamax"}constructor(t,n,r,s=null,a=0){super(),this.learningRate=t,this.beta1=n,this.beta2=r,this.epsilon=s,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Ee(()=>{this.iteration=un(0).variable(),this.accBeta1=un(n).variable()}),s==null&&(this.epsilon=fe.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);Ee(()=>{const r=Tt(1,this.accBeta1),s=Ct(-this.learningRate,Ge(me(this.iteration,this.decay),1));n.forEach((a,i)=>{const o=fe.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:Qt(o).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:Qt(o).variable(l)});const u=Array.isArray(t)?t[i].tensor:t[a];if(u==null)return;const c=this.accumulatedFirstMoment[i].variable,d=this.accumulatedWeightedInfNorm[i].variable,h=Ge(me(c,this.beta1),me(u,1-this.beta1)),p=me(d,this.beta2),f=Us(u),m=od(p,f);c.assign(h),d.assign(m);const g=Ge(me(Ct(s,r),Ct(h,Ge(m,this.epsilon))),o);o.assign(g)}),this.iteration.assign(Ge(this.iteration,1)),this.accBeta1.assign(me(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Vt(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Vt(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QF extends ud{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=Array.isArray(t)?t[s].tensor:t[r];if(a==null)return;const i=fe.registeredVariables[r];Ee(()=>{const o=Ge(me(this.c,a),i);i.assign(o)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=wl(un(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y9 extends QF{static get className(){return"Momentum"}constructor(t,n,r=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=r,this.accumulations=[],this.m=un(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=fe.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:Ee(()=>Qt(a).variable(!1))});const i=this.accumulations[s].variable,o=Array.isArray(t)?t[s].tensor:t[r];o!=null&&Ee(()=>{let l;const u=Ge(me(this.m,i),o);this.useNesterov?l=Ge(me(this.c,Ge(o,me(u,this.m))),a):l=Ge(me(this.c,u),a),i.assign(u),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Vt(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class b9 extends ud{static get className(){return"RMSProp"}constructor(t,n=.9,r=0,s=null,a=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,s==null&&(this.epsilon=fe.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,s)=>{const a=fe.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:Ee(()=>Qt(a).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:Ee(()=>Qt(a).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:Ee(()=>Qt(a).variable(i))});const o=Array.isArray(t)?t[s].tensor:t[r];if(o==null)return;const l=this.accumulatedMeanSquares[s].variable,u=this.accumulatedMoments[s].variable;Ee(()=>{const c=Ge(me(l,this.decay),me(Bn(o),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[s].variable,h=Ge(me(d,this.decay),me(o,1-this.decay)),p=Ct(me(o,this.learningRate),Qs(Tt(c,Ge(Bn(h),this.epsilon)))),f=Ge(me(u,this.momentum),p);l.assign(c),d.assign(h),u.assign(f);const m=Tt(a,f);a.assign(m)}else{const d=Ge(me(l,this.decay),me(Bn(o),1-this.decay)),h=Ge(me(u,this.momentum),Ct(me(o,this.learningRate),Qs(Ge(d,this.epsilon))));l.assign(d),u.assign(h);const p=Tt(a,h);a.assign(p)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Vt(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Vt(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Vt(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B1e=[p9,f9,m9,g9,y9,b9,QF];function W1e(){for(const e of B1e)Ve(e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bV(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let s=0;const a=l=>(l.then(u=>{const c=n+ ++s/e.length*(r-n);return t(c),u}),l);function i(l){Y(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){Y(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),Y(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),Y(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function V1e(e,t){t==null&&(t={});const n=t.fetchFunc==null?_e().platform.fetch:t.fetchFunc,r=e.map(d=>n(d,t.requestInit,{isBinary:!0})),s=0,a=.5,o=(t.onProgress==null?await Promise.all(r):await bV(r,t.onProgress,s,a)).map(d=>d.arrayBuffer()),l=.5,u=1;return t.onProgress==null?await Promise.all(o):await bV(o,t.onProgress,l,u)}function U1e(e,t){var n;const r=t.fetchFunc==null?_e().platform.fetch:t.fetchFunc;let s=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;s<e.length;){a||(a=(await r(e[s],t.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:u}=await a.read();if(l){s++,a=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,s/e.length);continue}i.enqueue(u);return}i.close()}})}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j1e="application/octet-stream",G1e="application/json";class e3{constructor(t,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(Y(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=_e().platform.fetch,Y(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&Y(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{},this.loadOptions=n}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s=sme(t,r);if(n.body.append("model.json",new Blob([JSON.stringify(s)],{type:G1e}),"model.json"),t.weightData!=null){const i=sd.join(t.weightData);n.body.append("model.weights.bin",new Blob([i],{type:j1e}),"model.weights.bin")}const a=await this.fetch(this.path,n);if(a.ok)return{modelArtifactsInfo:gF(t),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await t.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=n.modelTopology,s=n.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return n}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return ime(t,n=>this.loadWeights(n))}async loadStream(){const t=await this.loadModelJSON(),n=await this.getWeightUrls(t.weightsManifest),r=hV(t.weightsManifest),s=()=>U1e(n,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(t){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=H1e(n),a=this.weightPathPrefix||r,i=[],o=[];for(const l of t)for(const u of l.paths)this.weightUrlConverter!=null?o.push(this.weightUrlConverter(u)):i.push(a+u+s);return this.weightUrlConverter&&i.push(...await Promise.all(o)),i}async loadWeights(t){const n=await this.getWeightUrls(t),r=hV(t),s=await V1e(n,this.loadOptions);return[r,s]}}e3.URL_SCHEME_REGEX=/^https?:\/\//;function H1e(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function vV(e){return e.match(e3.URL_SCHEME_REGEX)!=null}const v9=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>vV(r)):n=vV(e),n)return x9(e,t)}return null};es.registerSaveRouter(v9);es.registerLoadRouter(v9);function x9(e,t){return new e3(e,t)}function q1e(e,t){return x9(e,t)}function t3(e,t){const n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(Me(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const s=t.shape,a=s[s.length-1];let i=1;for(let d=0;d<s.length-1;++d)i*=s[d];const o=e.shape,l=s.slice();l.pop();let u=1;for(let d=a;d<n;++d)u*=o[d],l.push(o[d]);const c=[...kt(e.shape).map(d=>d/u),1].slice(0,a);return[l,i,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $A=-2,K1e=-1;function n3(e,t,n){const r=e.shape.length;Y(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),Y(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)Y(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function X1e(e){const t=[];let n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function r3(e,t,n){const r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function w9(e,t,n,r){const s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function k9(e,t,n){return n<=e?n:n-(t-1)}function S9(e,t){const n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function Y1e(e,t,n,r,s,a,i,o,l){const u=e.length;let c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){const p=t[0],f=n+1;c=I9(i,p,f,r,e),d=C9(o,p,f,s,e),h=w9(a,p,f,e)}else for(let p=0;p<u;p++)c[p]=T9(i,r,a,e,p,l),d[p]=$9(o,s,a,e,p,l),h[p]=N9(a,p,l);return{begin:c,end:d,strides:h}}function I9(e,t,n,r,s){const a=[...s],i=S9(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{const l=k9(t,n,o);let u=r[l];e&1<<l&&(u=0),a[o]=u}return a}function C9(e,t,n,r,s){const a=[...s],i=S9(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{const l=k9(t,n,o);let u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[o]=u}for(let o=0;o<a.length;o++){const l=s[o];a[o]<0&&(a[o]+=l),a[o]=$h(0,a[o],s[o])}return a}function N9(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function T9(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),i=$h(0,i,l-1),i}function $9(e,t,n,r,s,a){let i=t[s];const o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);const l=r[s];return i<0&&(i+=l),o>0?i=$h(0,i,l):i=$h(-1,i,l-1),i}function s3(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function a3(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function aN(e,t,n){let r;const s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{Y(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(Y(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function i3(e,t,n,r,s,a,i,o,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let x=0;x<d.dims;x++)c&&1<<x&o&&d.numAddAxisAfterEllipsis++,1<<x&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);const h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};J1e(d,h);let p=!0,f=!0,m=!0;const g=[],y=[];for(let x=0;x<e.length;++x){if(h.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);const v=!!(h.shrinkAxisMask&1<<x),w=e[x];if(w===-1){g.push(v?1:-1);continue}const k=[h.beginMask&1<<x,h.endMask&1<<x],S=[h.strides[x]>0?0:-1,h.strides[x]>0?w:w-1];if(v&&h.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[x]===1;const I=!!(h.beginMask&1<<x&&h.endMask&1<<x);if(h.beginValid&&h.endValid){if(v){const N=h.begin[x]<0?w+h.begin[x]:h.begin[x];if(h.begin[x]=N,h.end[x]=h.begin[x]+1,N<0||N>=w)throw Error(`slice index ${h.begin[x]} of dimension ${x} out of bounds.`)}else h.begin[x]=xV(h.begin[x],0,h.strides[x],w,k,S),h.end[x]=xV(h.end[x],1,h.strides[x],w,k,S);const T=h.strides[x]===1&&h.begin[x]===0&&h.end[x]===w;p=p&&T,f=f&&(x===0&&h.strides[x]===1||T)}else p=p&&h.strides[x]===1&&I,f=f&&(x===0&&h.strides[x]===1||I);let $,C=!1;if(h.beginValid&&h.endValid?($=h.end[x]-h.begin[x],C=!0):v?($=1,C=!0):I&&w>=0&&(h.strides[x]<0?$=-w:$=w,C=!0),C){let T;$===0||$<0!=h.strides[x]<0?T=0:T=Math.trunc($/h.strides[x])+($%h.strides[x]!==0?1:0),g.push(T)}else g.push(-1)}for(let x=0;x<h.finalShapeGatherIndices.length;++x){const v=h.finalShapeGatherIndices[x];v>=0?y.push(g[v]):v===$A&&y.push(1)}return{finalShapeSparse:y.filter((x,v)=>h.finalShapeGatherIndices[v]!==$A),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function J1e(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){const s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push($A),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(K1e),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function xV(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{const i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}const Z1e=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:n3,computeFlatOffset:a3,computeOutShape:r3,getNormalizedAxes:Y1e,isSliceContinous:s3,maskToAxes:X1e,parseSliceParams:aN,sliceInfo:i3,startForAxis:T9,startIndicesWithElidedDims:I9,stopForAxis:$9,stopIndicesWithElidedDims:C9,stridesForAxis:N9,stridesWithElidedDims:w9},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Q1e{static sgd(t){return new QF(t)}static momentum(t,n,r=!1){return new y9(t,n,r)}static rmsprop(t,n=.9,r=0,s=null,a=!1){return new b9(t,n,r,s,a)}static adam(t=.001,n=.9,r=.999,s=null){return new m9(t,n,r,s)}static adadelta(t=.001,n=.95,r=null){return new p9(t,n,r)}static adamax(t=.002,n=.9,r=.999,s=null,a=0){return new g9(t,n,r,s,a)}static adagrad(t,n=.1){return new f9(t,n)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hm=Q1e;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e0e=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e())();function E9(){return new Promise(e=>e0e(()=>e()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o3(e,t){const n=e[0].length;e.forEach((s,a)=>{Y(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),Y(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)Y(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function kl(e,t){const n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Io;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(Io||(Io={}));function _9(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){const a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function A9(e){const t={FIRST_DIM_SIZE:Io.FIRST_DIM_SIZE,VALUE_ROWIDS:Io.VALUE_ROWIDS,ROW_LENGTHS:Io.ROW_LENGTHS,ROW_SPLITS:Io.ROW_SPLITS,ROW_LIMITS:Io.ROW_LIMITS,ROW_STARTS:Io.ROW_STARTS},n=[];for(const r of e)if(r in t)n.push(t[r]);else break;return n}function R9(e){return e.length===0?0:e[0]===Io.FIRST_DIM_SIZE?e.length-1:e.length}function D9(e,t){if(e==null||t==null)return;const n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){const a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l3=30;function iN(e){return e<=l3?e:cA(e,Math.floor(Math.sqrt(e)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3(e,t,n){const r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nx(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function Tx(e,t,n=!0){const r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{const s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function $x(e,t,n,r=!0){const s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function c3(e,t){const n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function d3(e,t,n){const r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN=1.7580993408473768,lN=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h3=.3275911,p3=.254829592,f3=-.284496736,m3=1.421413741,g3=-1.453152027,y3=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mu(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function O9(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function F9(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function M9(e){const t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function b3(e,t){const n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function P9(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function L9(e,t){const n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){const a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function z9(e,t,n){const r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iE="->",t0e=/->/g,wV=",",kV="...";function v3(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(t0e,"").length)/iE.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${iE}").`);const[r,s]=e.split(iE);Y(r.indexOf(kV)===-1,()=>`The ellipsis notation ("${kV}") is not supported yet.`);const a=r.split(wV),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<s.length;++h){const p=s[h];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<r.length;++h){const p=r[h];o.indexOf(p)===-1&&p!==wV&&o.push(p)}const l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<a[h].length;++p)l[h].push(o.indexOf(a[h][p]))}const u=o.length,c=s.length,d=[];for(let h=c;h<u;++h)d.push(h);return{allDims:o,summedDims:d,idDims:l}}function x3(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;const r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function w3(e,t,n){const r=new Array(e);for(let s=0;s<n.length;++s){const a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:Y(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function k3(e,t){const n=e,r=[];let s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);const a=[];for(let i=0;i<n.length;++i){const o=n[i],l=n0e(t,o);for(const u of l)a.indexOf(u)===-1&&(r[i].push(u),a.push(u))}return{path:n,steps:r}}function S3(e){return e.every((t,n)=>t===n)}function n0e(e,t){const n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function I3(e,t,n=0){let r=[];if(typeof t=="number")Y(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{const s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);Y(s<=1,()=>"There should be only one negative value in split array.");const a=t.indexOf(-1);if(a!==-1){const i=t.reduce((o,l)=>l>0?o+l:o);t[a]=e.shape[n]-i}Y(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B9(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function W9(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function V9(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U9(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function j9(e,t){return`size ${e} must be non-negative, not ${t}`}function G9(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function H9(e,t){const n=Me(e),r=Me(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function q9(e,t){const n=Me(e),r=Me(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EA(){return"segment ids must be >= 0"}function K9(){return"segment ids are not increasing"}function X9(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Y9(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J9(e,t){let n=!1,r;for(e<=l3?(r=e,n=!0):r=cA(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=cA(e,r+1);return r}function Z9(e,t,n){const r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function C3(e,t,n,r){const s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const i=e.shape[n],o=[];let l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}const r0e=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:C3,computeOutShape:Z9,segOpComputeOptimalWindowSize:J9},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gu(e){try{return e.map(t=>Ac(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function Q9(e){return e.map(t=>wc(t))}const s0e=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:p3,ERF_A2:f3,ERF_A3:m3,ERF_A4:g3,ERF_A5:y3,ERF_P:h3,PARALLELIZE_THRESHOLD:l3,get RowPartitionType(){return Io},SELU_SCALE:lN,SELU_SCALEALPHA:oN,applyActivation:qF,assertAndGetBroadcastShape:Ot,assertAxesAreInnerMostDims:Ns,assertParamsConsistent:o3,assignToTypedArray:P9,axesAreInnerMostDims:IF,calculateShapes:vp,checkEinsumDimSizes:w3,checkPadOnDimRoundingMode:Ta,combineLocations:Vq,combineRaggedTensorToTensorShapes:_9,complexWithEvenIndex:F9,complexWithOddIndex:M9,computeConv2DInfo:Cs,computeConv3DInfo:ad,computeDefaultPad:yF,computeDilation2DInfo:wx,computeOptimalWindowSize:iN,computeOutAndReduceShapes:ps,computeOutShape:kl,computePool2DInfo:no,computePool3DInfo:Iu,convertConv2DDataFormat:Cu,decodeEinsumEquation:v3,eitherStridesOrDilationsAreOne:Ps,expandShapeToKeepDim:Ar,exponent:z9,exponents:L9,fromStringArrayToUint8:Q9,fromUint8ToStringArray:gu,getAxesPermutation:lr,getBroadcastDims:Ig,getComplexWithIndex:b3,getEinsumComputePath:k3,getEinsumPermutation:x3,getFusedBiasGradient:HF,getFusedDyActivation:GF,getImageCenter:u3,getInnerMostAxes:vr,getPermuted:Tx,getRaggedRank:R9,getReductionAxes:Xr,getReshaped:Nx,getReshapedPermuted:$x,getRowPartitionTypesHelper:A9,getSliceBeginCoords:c3,getSliceSize:d3,getSparseFillEmptyRowsIndicesDenseShapeMismatch:B9,getSparseFillEmptyRowsNegativeIndexErrorMessage:W9,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:V9,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:G9,getSparseReshapeInputOutputMismatchErrorMessage:q9,getSparseReshapeInputOutputMultipleErrorMessage:H9,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:U9,getSparseReshapeNegativeOutputDimErrorMessage:j9,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Y9,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:EA,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:K9,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:X9,getUndoAxesPermutation:id,isIdentityPermutation:S3,log:Sfe,mergeRealAndImagArrays:mu,prepareAndValidate:t3,prepareSplitSize:I3,segment_util:r0e,shouldFuse:KF,slice_util:Z1e,splitRealAndImagArrays:O9,stridesOrDilationsArePositive:Oh,tupleValuesAreOne:Dh,upcastType:Xa,validateDefaultValueShape:D9,validateInput:Eve,validateUpdateShape:o9,warn:li},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */W1e();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e7={kernelName:JI,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,Cx(at(n,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0e={kernelName:N0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Bn(at(n,"float32")),s=Qs(Tt(un(1),r));return yr(Ct(e,s))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i0e={kernelName:T0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Qs(Tt(Bn(at(n,"float32")),1));return Ct(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o0e={kernelName:dy,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{let o=e;const l=Xr(n.shape,s);return l.length>0&&(o=St(o,l)),we(o,n.shape)},b:()=>{let o=e;const l=Xr(r.shape,s);return l.length>0&&(o=St(o,l)),we(o,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l0e={kernelName:CO,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u0e={kernelName:ZI,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qt(n)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c0e={kernelName:QI,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Qt(n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d0e={kernelName:$0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,Qs(Tt(un(1),Bn(at(n,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h0e={kernelName:E0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Qs(Ge(un(1),Bn(at(n,"float32"))));return Ct(e,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p0e={kernelName:R0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=Ge(Bn(n),Bn(r));let l=me(e,Ct(r,o));const u=Xr(n.shape,s);return u.length>0&&(l=St(l,u)),we(l,n.shape)},b:()=>{const o=Ge(Bn(n),Bn(r));let l=yr(me(e,Ct(n,o)));const u=Xr(r.shape,s);return u.length>0&&(l=St(l,u)),we(l,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f0e={kernelName:_0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,Ge(Bn(at(n,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m0e={kernelName:A0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,Tt(un(1),Bn(at(n,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0e(e,t,n,r,s,a){const i=re(e,"dy","avgPool3dGrad"),o=re(t,"input","avgPool3dGrad");let l=i,u=o,c=!1;o.rank===4&&(c=!0,l=we(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=we(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),Y(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),Ta("avgPool3dGrad",s,a);const d={dy:l,input:u},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=fe.runKernel(EO,d,h);return c?we(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const y0e=Se({avgPool3dGrad_:g0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b0e={kernelName:tC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>y0e(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0e(e,t,n,r,s){const a=re(e,"dy","avgPoolGrad"),i=re(t,"input","avgPoolGrad");Y(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;i.rank===3&&(u=!0,o=we(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=we(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),Y(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},h=fe.runKernel($O,c,d);return u?we(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const x0e=Se({avgPoolGrad_:v0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w0e={kernelName:eC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>x0e(e,r,s,a,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k0e={kernelName:nC,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>ln(e,s,!1,!0),b:()=>ln(r,e,!0,!1)}:!a&&i?{a:()=>ln(e,s,!1,!1),b:()=>ln(e,r,!0,!1)}:a&&!i?{a:()=>ln(s,e,!1,!0),b:()=>ln(r,e,!1,!1)}:{a:()=>ln(s,e,!0,!0),b:()=>ln(e,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S0e={kernelName:rC,gradFunc:(e,t,n)=>{const{blockShape:r,crops:s}=n;return{x:()=>RF(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I0e={kernelName:vfe,gradFunc:(e,t,n)=>{const r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);const o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>St(e,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C0e={kernelName:D0,gradFunc:e=>({x:()=>e.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N0e={kernelName:O0,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T0e={kernelName:F0,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>Ys(pu(gp(r,s),py(r,a)),e,Qt(e))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $0e={kernelName:sC,inputsToSave:["x"],gradFunc:e7.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E0e={kernelName:aC,saveAllInputs:!0,gradFunc:(e,t,n)=>{const r=t.map(l=>l.shape),{axis:s}=n,a=Ht(s,t[0].shape)[0],i=r.map(l=>l[a]);return yi(e,i,a).map(l=>()=>l)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _0e={kernelName:iC,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return Y(Dh(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>wF(r.shape,e,s,i,o,l),filter:()=>jF(r,e,s.shape,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A0e={kernelName:oC,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>Fh(e,s,a,i,o,1,l),filter:()=>jF(e,r,s.shape,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R0e(e,t,n,r,s){let a=e;e.rank===4&&(a=we(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=we(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),Y(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),Y(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),Y(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),Y(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),Y(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);const o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return fe.runKernel(OO,o,l)}const D0e=Se({conv3DBackpropFilter_:R0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O0e={kernelName:lC,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a}=n;Y(Dh(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[i,o]=t;return{x:()=>zq(i.shape,e,o,s,a),filter:()=>D0e(i,e,o.shape,s,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F0e={kernelName:M0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(yr(r9(at(n,"float32"))),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M0e={kernelName:P0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(s9(at(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P0e={kernelName:uC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{const o=lr([s],r.rank);let l=Wq(e,s,a,!i);return o!=null&&(l=Zt(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L0e={kernelName:cC,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];Y(Dh(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,u]=t;return Y(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),Y(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),Y(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Y(Ps(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),Ta("depthwiseConv2d",a,i),{x:()=>Kve(l.shape,e,u,s,a,o,i),filter:()=>Hve(l,e,u.shape,s,a,o,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z0e={kernelName:dC,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>fe.runKernel(dA,a,n),filter:()=>fe.runKernel(hA,i,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B0e={kernelName:z0,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,r={dy:e,y:n};return{x:()=>fe.runKernel(UO,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W0e={kernelName:B0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=me(Rl(yr(Bn(n))),2/Math.sqrt(Math.PI));return{x:()=>me(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V0e={kernelName:W0,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U0e={kernelName:pC,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>we(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j0e={kernelName:V0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,Rl(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G0e={kernelName:U0,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H0e={kernelName:j0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=Ct(e,at(r,"float32")),l=Xr(n.shape,s);return l.length>0?we(St(o,l),n.shape):o},b:()=>{let o=me(e,at(n,"float32"));const l=Xr(r.shape,s);l.length>0&&(o=we(St(o,l),r.shape));const u=Bn(r);return yr(Ct(o,at(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q0e={kernelName:fC,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:r}=n,[s,a,i,o]=t,l=o??un(1),u=Xr(a.shape,s.shape),c=[];if(a.rank===1){for(let v=0;v<s.shape.length-1;++v)c.push(s.shape[v]);c.push(1)}const d=Tt(s,a),h=me(e,l),p=e9(Ge(i,un(r))),f=me(me(me(p,p),p),un(-.5));return{x:()=>a.rank===1?we(me(me(e,No(we(p,[1,1,1,a.shape[0]]),c)),l),s.shape):we(me(me(e,p),l),s.shape),mean:()=>{let v=me(me(p,un(-1)),h);return a.rank===1&&(v=St(v,u)),we(v,a.shape)},variance:()=>{let v=me(me(f,d),h);return a.rank===1&&(v=St(v,u)),we(v,a.shape)},scale:()=>{const v=me(d,p);let w=me(e,v);return a.rank===1&&(w=St(w,u)),we(w,a.shape)},offset:()=>{let v=e;return a.rank===1&&(v=St(v,u)),we(v,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K0e={kernelName:mC,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[r,s]=t,{axis:a,batchDims:i}=n,o=Ht(a,r.shape)[0],l=(u,c,d)=>()=>{const h=u.shape,p=c.size,f=h.slice(0,o),m=f.length,g=h.slice(a,h.length).slice(1),y=g.length,b=SV(0,m),x=SV(m+1,m+1+y),v=IV([f,[p],g]),w=we(d,v),k=we(c,[p]),S=IV([[m],b,x]),I=Zt(w,S);let $=u9(I,k,u.shape[o]);const C=id(S);return $=Zt($,C),$};if(i===1){const u=r.shape[0],c=r.split(u,0);return{x:()=>fu(c.map((p,f)=>l(p,s.slice(f,1),e.slice(f,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,e),indices:()=>s}}};function SV(e,t){const n=[];for(let r=e;r<t;++r)n.push(r);return n}function IV(e){const t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X0e={kernelName:G0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>Qt(n),b:()=>Qt(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y0e={kernelName:H0,gradFunc:e=>({x:()=>at(e,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J0e={kernelName:q0,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z0e={kernelName:K0,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q0e={kernelName:X0,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const exe={kernelName:yC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{alpha:s}=n,a=Ti(r,0);return{x:()=>Ys(a,e,me(e,s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const txe={kernelName:J0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,Ge(n,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nxe={kernelName:Y0,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,at(n,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rxe={kernelName:wfe,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;return{logits:()=>{const i=Rl(r);return Tt(e,me(St(e,s,!0),i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sxe(e,t,n,r=5,s=1,a=1,i=.5){const o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return fe.runKernel(XO,o,l)}const axe=Se({localResponseNormalizationBackprop_:sxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ixe={kernelName:SC,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>axe(r,s,e,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t7(e,t,n,r){return t.rank<n.rank&&(t=we(t,Ar(t.shape,r))),e.rank<n.rank&&(e=we(e,Ar(e.shape,r))),{x:()=>me(e,at(Al(n,t),e.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CV={kernelName:IC,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=Ht(s,a.shape),l=t7(e,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oxe={kernelName:Z0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>me(e,at(gp(n,r),"float32")),b:()=>me(e,at(gS(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lxe(e,t,n,r,s,a,i){const o=re(e,"dy","maxPool3dGrad"),l=re(t,"input","maxPool3dGrad"),u=re(n,"output","maxPool3dGrad");let c=o,d=l,h=u,p=!1;l.rank===4&&(p=!0,c=we(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=we(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=we(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),Y(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),Y(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),Y(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),Ta("maxPool3dGrad",a,i);const f={dy:c,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=fe.runKernel(JO,f,m);return p?we(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const uxe=Se({maxPool3dGrad_:lxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cxe={kernelName:NC,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>uxe(e,r,s,a,i,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(e,t,n,r,s,a,i){const o=re(e,"dy","maxPoolGrad"),l=re(t,"input","maxPoolGrad"),u=re(n,"output","maxPoolGrad");Y(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),Y(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),Y(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),Ta("maxPoolGrad",a,i);const c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return fe.runKernel(YO,c,d)}const hxe=Se({maxPoolGrad_:dxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pxe={kernelName:CC,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>hxe(e,r,s,a,i,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fxe={kernelName:TC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n,a=Ht(s,r.shape),o=ps(r.shape,a)[1],l=Me(o);return{x:()=>{const c=r.shape.slice();a.forEach(p=>{c[p]=1});const d=we(e,c);return Ct(me(d,ld(r.shape,"float32")),l)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mxe={kernelName:$C,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const r=n,{axis:s}=r,[a,i]=t,o=Ht(s,a.shape),l=t7(e,i,a,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gxe={kernelName:Q0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t;return{a:()=>me(e,at(py(n,r),"float32")),b:()=>me(e,at(Ti(n,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yxe={kernelName:EC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Dn(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bxe={kernelName:ex,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=Xr(n.shape,s);return o.length>0?we(St(e,o),n.shape):e},b:()=>{const o=me(e,yr(sN(Ct(n,r)))),l=Xr(r.shape,s);return l.length>0?we(St(o,l),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vxe={kernelName:tx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=me(e,at(r,"float32")),l=Xr(n.shape,s);return l.length>0?we(St(o,l),n.shape):o},b:()=>{const o=me(e,at(n,"float32")),l=Xr(r.shape,s);return l.length>0?we(St(o,l),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xxe={kernelName:_C,gradFunc:e=>({x:()=>yr(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wxe={kernelName:DC,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>os(n.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kxe={kernelName:RC,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sxe={kernelName:OC,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:r}=n;return Ph(e,r).map(a=>()=>a)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NV={kernelName:FC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Dn(e,a,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ixe={kernelName:nx,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,r,s]=t,a=n,i=r,o=Ot(a.shape,i.shape);return{a:()=>{const c=at(i,"float32");let d=me(e,me(c,Cg(a,Tt(c,un(1)))));const h=Xr(a.shape,o);return h.length>0&&(d=St(d,h)),we(d,a.shape)},b:()=>{const c=Ti(a,0),d=Ys(c,Dl(a),Qt(a));let h=me(e,me(s,d));const p=Xr(i.shape,o);return p.length>0&&(h=St(h,p)),we(h,i.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cxe={kernelName:MC,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,r]=t,s=Ti(n,0);return{x:()=>Ys(s,e,me(e,r)),alpha:()=>{let a=Ys(s,Qt(e),me(e,n));const i=Xr(r.shape,e.shape);return i.length>0&&(a=St(a,i)),we(a,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nxe(e,t,n){const r=e.shape.slice();r[n]=1;const s=we(t,r),a=NA(e,n,!0,!1),i=NA(e,n,!0,!0),o=me(a,i);return me(s,o)}function Txe(e,t,n){const r=e.shape.length,s=r-n.length,a=lr(n,r);let i=e;a!=null&&(i=Zt(e,a));const o=i.shape.slice(),u=o.splice(r-n.length,n.length).reduce((h,p)=>h*p,1);o.push(u);const c=i.reshape(o);let d=Nxe(c,t,s);if(d=d.reshape(i.shape),a!=null){const h=id(a);d=Zt(d,h)}return d}const $xe={kernelName:PC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{axis:s}=n;let a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>Txe(r,e,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Exe={kernelName:L0,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{const o=Ct(e,at(r,"float32")),l=Xr(n.shape,s);return l.length>0?we(St(o,l),n.shape):o},b:()=>{let o=me(e,at(n,"float32"));const l=Xr(r.shape,s);l.length>0&&(o=we(St(o,l),r.shape));const u=Bn(r);return yr(Ct(o,at(u,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _xe={kernelName:rx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,yr(Bn(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Axe={kernelName:ax,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,r=me(py(n,6),Cx(n));return{x:()=>me(e,at(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rxe={kernelName:sx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,at(Cx(n),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dxe={kernelName:LC,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>we(e,n.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oxe={kernelName:BC,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>fe.runKernel(sF,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fxe={kernelName:zC,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[r]=t,s={dy:e,images:r};return{images:()=>fe.runKernel(rF,s,n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mxe={kernelName:WC,gradFunc:(e,t,n)=>{const{dims:r}=n,s=Ht(r,e.shape);return{x:()=>Mh(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pxe={kernelName:ix,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lxe={kernelName:ox,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>yr(Ct(e,me(Cg(n,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zxe={kernelName:VC,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>at(Qt(n),"float32"),t:()=>me(e,at(n,e.dtype)),e:()=>me(e,at($F(n),e.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bxe={kernelName:lx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const r=Ti(n,un(0)),s=un(oN),a=un(lN),i=me(e,a),o=me(me(e,s),Rl(at(n,"float32")));return Ys(r,i,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wxe={kernelName:hx,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,me(n,Tt(un(1),n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vxe={kernelName:dx,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uxe={kernelName:ux,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(kF(at(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jxe={kernelName:cx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(Bq(at(n,"float32")),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gxe={kernelName:UC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=aN(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>AF(e,u)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hxe={kernelName:qC,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[r]=t,{dim:s}=n,a=!0,i=me(e,r);return{logits:()=>Tt(i,me(St(i,[s],a),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qxe={kernelName:px,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,hy(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TV={kernelName:GC,gradFunc:(e,t,n)=>{const{blockShape:r,paddings:s}=n;return{x:()=>xF(e,r,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $V={kernelName:HC,gradFunc:(e,t,n)=>{const{axis:r}=n;return{x:()=>ga(e,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kxe={kernelName:fx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,me(Qs(at(n,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xxe={kernelName:aF,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(e,me(at(n,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yxe={kernelName:mx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=un(2);return{a:()=>me(e,me(s,Tt(n,r))),b:()=>me(e,me(s,Tt(r,n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jxe={kernelName:xx,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zxe={kernelName:gx,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,r]=t,s=Ot(n.shape,r.shape);return{a:()=>{let o=e;const l=Xr(n.shape,s);return l.length>0&&(o=St(o,l)),we(o,n.shape)},b:()=>{let o=e;const l=Xr(r.shape,s);return l.length>0&&(o=St(o,l)),we(yr(o),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qxe={kernelName:jC,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,s=r.shape.slice(),{axis:a}=n;Ht(a,r.shape).forEach(u=>{s[u]=1});const o=we(e,s),l=me(o,ld(r.shape,"float32"));return{x:()=>l}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ewe={kernelName:yx,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ct(e,Bn(kF(n)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const twe={kernelName:bx,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>me(Tt(un(1),Bn(n)),e)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nwe={kernelName:vx,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[r]=t,{reps:s}=n;return{x:()=>{let i=Qt(r);if(r.rank===1)for(let o=0;o<s[0];++o)i=Ge(i,Dn(e,[o*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)i=Ge(i,Dn(e,[o*r.shape[0],l*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)i=Ge(i,Dn(e,[o*r.shape[0],l*r.shape[1],u*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let o=0;o<s[0];++o)for(let l=0;l<s[1];++l)for(let u=0;u<s[2];++u)for(let c=0;c<s[3];++c)i=Ge(i,Dn(e,[o*r.shape[0],l*r.shape[1],u*r.shape[2],c*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return i}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rwe={kernelName:Xm,gradFunc:(e,t,n)=>{const r=n,{perm:s}=r,a=id(s);return{x:()=>Zt(e,a)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const swe={kernelName:KC,gradFunc:(e,t,n)=>{const r=n,{axis:s}=r;return{value:()=>fu(e,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const awe={kernelName:XC,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>iwe(e,n)}}};function iwe(e,t){const n=od(t,Qt(t)),r=CF(e,n);let s=gp(t,un(0,"int32"));const a=r.rank-s.rank;for(let o=0;o<a;++o)s=da(s,o+1);s=pu(s,ld(r.shape,"bool"));const i=Qt(r);return Ys(s,r,i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const owe={kernelName:YC,gradFunc:e=>({x:()=>Qt(e)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lwe=[e7,a0e,i0e,o0e,l0e,u0e,c0e,d0e,h0e,p0e,f0e,m0e,b0e,w0e,k0e,S0e,I0e,C0e,N0e,T0e,$0e,E0e,A0e,_0e,O0e,F0e,M0e,P0e,L0e,z0e,Exe,B0e,W0e,V0e,U0e,j0e,H0e,G0e,q0e,K0e,X0e,Y0e,J0e,Z0e,Q0e,exe,txe,nxe,rxe,ixe,CV,CV,oxe,cxe,pxe,fxe,mxe,gxe,yxe,bxe,vxe,xxe,wxe,kxe,Sxe,NV,NV,Ixe,Cxe,$xe,_xe,Axe,Rxe,Dxe,Oxe,Fxe,Mxe,Pxe,Lxe,zxe,Bxe,Wxe,Vxe,Uxe,jxe,Gxe,Hxe,qxe,TV,TV,$V,$V,Kxe,Yxe,Xxe,Jxe,Zxe,Qxe,ewe,twe,nwe,rwe,swe,awe,owe];for(const e of lwe)Ife(e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.abs=function(){return this.throwIfDisposed(),Us(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.acos=function(){return this.throwIfDisposed(),Pme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.acosh=function(){return this.throwIfDisposed(),zme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.add=function(e){return this.throwIfDisposed(),Ge(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.all=function(e,t){return this.throwIfDisposed(),Mq(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.any=function(e,t){return this.throwIfDisposed(),IA(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.argMax=function(e){return this.throwIfDisposed(),F1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.argMin=function(e){return this.throwIfDisposed(),jme(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.asScalar=function(){return this.throwIfDisposed(),Y(this.size===1,()=>"The array must have only 1 element."),we(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.asType=function(e){return this.throwIfDisposed(),at(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.as1D=function(){return this.throwIfDisposed(),we(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.as2D=function(e,t){return this.throwIfDisposed(),we(this,[e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),we(this,[e,t,n])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),we(this,[e,t,n,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),we(this,[e,t,n,r,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.asin=function(){return this.throwIfDisposed(),Hme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.asinh=function(){return this.throwIfDisposed(),Kme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.atan=function(){return this.throwIfDisposed(),Yme(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.atan2=function(e){return this.throwIfDisposed(),Zme(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.atanh=function(){return this.throwIfDisposed(),ege(this)};Oe().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),bF(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),xF(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),eN(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.broadcastTo=function(e){return this.throwIfDisposed(),a1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.cast=function(e){return this.throwIfDisposed(),at(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.ceil=function(){return this.throwIfDisposed(),Tge(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),wi(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Lr&&(e=[e]),ga([this,...e],t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Pq(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),Lq(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Fh(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.cos=function(){return this.throwIfDisposed(),kF(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.cosh=function(){return this.throwIfDisposed(),Bq(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),NA(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Wq(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),Zge(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),SF(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),tye(this,e,t,n,r,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.divNoNan=function(e){return this.throwIfDisposed(),iye(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.div=function(e){return this.throwIfDisposed(),Ct(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.dot=function(e){return this.throwIfDisposed(),lye(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.elu=function(){return this.throwIfDisposed(),nN(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.equal=function(e){return this.throwIfDisposed(),Al(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.erf=function(){return this.throwIfDisposed(),hye(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),wye(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.exp=function(){return this.throwIfDisposed(),Rl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.expandDims=function(e){return this.throwIfDisposed(),da(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.expm1=function(){return this.throwIfDisposed(),Cye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.fft=function(){return this.throwIfDisposed(),i9(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.flatten=function(){return this.throwIfDisposed(),we(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.floor=function(){return this.throwIfDisposed(),sN(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.floorDiv=function(e){return this.throwIfDisposed(),Fq(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.gather=function(e,t,n){return this.throwIfDisposed(),CF(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.greaterEqual=function(e){return this.throwIfDisposed(),gp(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.greater=function(e){return this.throwIfDisposed(),Ti(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.ifft=function(){return this.throwIfDisposed(),TA(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.irfft=function(){return this.throwIfDisposed(),gve(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.isFinite=function(){return this.throwIfDisposed(),Oye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.isInf=function(){return this.throwIfDisposed(),Mye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.isNaN=function(){return this.throwIfDisposed(),Lye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.leakyRelu=function(e){return this.throwIfDisposed(),TF(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.lessEqual=function(e){return this.throwIfDisposed(),py(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.less=function(e){return this.throwIfDisposed(),gS(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),Uye(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.logSigmoid=function(){return this.throwIfDisposed(),Yye(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Hq(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),qq(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.log=function(){return this.throwIfDisposed(),Dl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.log1p=function(){return this.throwIfDisposed(),Gq(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.logicalAnd=function(e){return this.throwIfDisposed(),pu(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.logicalNot=function(){return this.throwIfDisposed(),$F(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.logicalOr=function(e){return this.throwIfDisposed(),Kq(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.logicalXor=function(e){return this.throwIfDisposed(),sbe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),ln(this,e,t,n)};Oe().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),EF(this,e,t,n,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.max=function(e,t){return this.throwIfDisposed(),Ao(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.maximum=function(e){return this.throwIfDisposed(),od(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.mean=function(e,t){return this.throwIfDisposed(),Nr(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.min=function(e,t){return this.throwIfDisposed(),mS(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.minimum=function(e){return this.throwIfDisposed(),L1(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),hbe(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.mod=function(e){return this.throwIfDisposed(),fbe(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.mul=function(e){return this.throwIfDisposed(),me(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.neg=function(){return this.throwIfDisposed(),yr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.norm=function(e,t,n){return this.throwIfDisposed(),rN(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.notEqual=function(e){return this.throwIfDisposed(),yS(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Xq(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.onesLike=function(){return this.throwIfDisposed(),Qi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.pad=function(e,t){return this.throwIfDisposed(),AF(this,e,t)};Oe().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),Ibe(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.pow=function(e){return this.throwIfDisposed(),Cg(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.prelu=function(e){return this.throwIfDisposed(),DF(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.prod=function(e,t){return this.throwIfDisposed(),Tbe(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.reciprocal=function(){return this.throwIfDisposed(),Ybe(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.relu=function(){return this.throwIfDisposed(),bp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.relu6=function(){return this.throwIfDisposed(),Zq(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.reshapeAs=function(e){return this.throwIfDisposed(),we(this,e.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.reshape=function(e){return this.throwIfDisposed(),we(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),d9(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),h9(this,e,t,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.reverse=function(e){return this.throwIfDisposed(),Mh(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.rfft=function(){return this.throwIfDisposed(),vve(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.round=function(){return this.throwIfDisposed(),Qq(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.rsqrt=function(){return this.throwIfDisposed(),e9(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.selu=function(){return this.throwIfDisposed(),t9(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),n9(this,e,t,n,r,s,a)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.sigmoid=function(){return this.throwIfDisposed(),hy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.sign=function(){return this.throwIfDisposed(),ave(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.sin=function(){return this.throwIfDisposed(),r9(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.sinh=function(){return this.throwIfDisposed(),s9(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.slice=function(e,t){return this.throwIfDisposed(),Dn(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.softmax=function(e){return this.throwIfDisposed(),UF(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.softplus=function(){return this.throwIfDisposed(),kx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),RF(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.split=function(e,t){return this.throwIfDisposed(),yi(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.sqrt=function(){return this.throwIfDisposed(),Qs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.square=function(){return this.throwIfDisposed(),Bn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.squaredDifference=function(e){return this.throwIfDisposed(),wve(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.squeeze=function(e){return this.throwIfDisposed(),Ix(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Lr?[this,e]:[this,...e];return fu(n,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.step=function(e){return this.throwIfDisposed(),Cx(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),Nve(this,e,t,n,r,s,a,i,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.sub=function(e){return this.throwIfDisposed(),Tt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.sum=function(e,t){return this.throwIfDisposed(),St(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.tan=function(){return this.throwIfDisposed(),$ve(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.tanh=function(){return this.throwIfDisposed(),vF(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.tile=function(e){return this.throwIfDisposed(),No(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.toBool=function(){return this.throwIfDisposed(),at(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.toFloat=function(){return this.throwIfDisposed(),at(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.toInt=function(){return this.throwIfDisposed(),at(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.topk=function(e,t){return this.throwIfDisposed(),Ave(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.transpose=function(e){return this.throwIfDisposed(),Zt(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.unique=function(e){return this.throwIfDisposed(),Ove(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),u9(this,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.unstack=function(e){return this.throwIfDisposed(),Ph(this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.where=function(e,t){return this.throwIfDisposed(),Ys(e,this,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Oe().prototype.zerosLike=function(){return this.throwIfDisposed(),Qt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ol extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ol.prototype)}}class ji extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ji.prototype)}}class de extends Error{constructor(t){super(t),Object.setPrototypeOf(this,de.prototype)}}class Pt extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Pt.prototype)}}class N3 extends Error{constructor(t){super(t),Object.setPrototypeOf(this,N3.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class n7{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let n;return this.cache.has(t)&&(n=this.cache.get(t),this.cache.delete(t),this.cache.set(t,n)),n}put(t,n){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,n)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let n=0;n<this.maxEntries-t;n++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lh(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{const n=new Array(t);return n.fill(e),n}}function ll(e,t){if(!e)throw new N3(t)}function EV(e,t){let n=0;for(const r of e)r===t&&n++;return n}function ha(e){return e.length===1?e[0]:e}function fn(e){return Array.isArray(e)?e:[e]}function Xl(e){const n=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return n[0]!=="_"?n:"private"+n}function Gd(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}let _i={};function T3(e){if(e==null)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function _A(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>_A(t));else{const t=Object.keys(e);for(const n of t){const r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:_A(r))}}}function Ex(e,t={},n={},r="object",s=!1){if(typeof e=="string"){const a=e;let i;if(a in n)i=n[a];else if(a in _i)i=_i[a];else if(i=t[a],i==null)throw new de(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{const a=e;if(a.className==null||a.config==null)throw new de(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const i=a.className;let o,l;if(i in n?[o,l]=n[i]:i in _i?[o,l]=_i.className:i in t&&([o,l]=t[i]),o==null)throw new de(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const u={};for(const p of Object.keys(_i))u[p]=_i[p];for(const p of Object.keys(n))u[p]=n[p];const c=a.config;c.customObjects=u;const d=Object.assign({},_i);for(const p of Object.keys(n))_i[p]=n[p];_A(a.config);const h=l(o,a.config,n,s);return _i=Object.assign({},d),h}else{const u=Object.assign({},_i);for(const d of Object.keys(n))_i[d]=n[d];const c=new o(a.config);return _i=Object.assign({},u),c}}}function uwe(e,t){return e<t?-1:e>t?1:0}function Ik(e,t){return-1*uwe(e,t)}function kc(e){if(e==null)return e;const t=[];for(const n of e)t.indexOf(n)===-1&&t.push(n);return t}function cwe(e){if(e==null)throw new de(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function xp(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new de(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function $3(e,t,n=0,r=1/0){return ll(n>=0),ll(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function us(e,t){Array.isArray(e)?(Y(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>us(n,`element ${r+1} of ${t}`))):Y(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${r7(e)}.`)}function r7(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>r7(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function dwe(e,t,n){let r=n!=null?n():ca(),s;return(...i)=>{const o=n!=null?n():ca();return o-r<t||(r=o,s=e(...i)),s}}function s7(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let hwe=0;function a7(){return hwe++}const Ck={};function uN(e=""){return e in Ck||(Ck[e]=0),Ck[e]+=1,e+Ck[e].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const pwe=["channelsFirst","channelsLast"],fwe=["nearest","bilinear"],mwe=["valid","same","causal"],gwe=["max","avg"],ywe=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const pm=new Map;function xr(e){xp(pwe,"DataFormat",e)}function bwe(e){xp(fwe,"InterpolationFormat",e)}function $i(e){xp(mwe,"PaddingMode",e)}function i7(e){xp(gwe,"PoolMode",e)}const i1=[],_V="/";function fh(e,t){i1.push(e);try{const n=t();return i1.pop(),n}catch(n){throw i1.pop(),n}}function vwe(){return i1.length===0?"":i1.join(_V)+_V}function o7(e){if(!u7(e))throw new Error("Not a valid tensor name: '"+e+"'");return vwe()+e}function l7(e){if(!u7(e))throw new Error("Not a valid tensor name: '"+e+"'");pm.has(e)||pm.set(e,0);const t=pm.get(e);if(pm.set(e,pm.get(e)+1),t>0){const n=`${e}_${t}`;return pm.set(n,1),n}else return e}const xwe=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function u7(e){return!!e.match(xwe)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wwe(e){return e===parseInt(e.toString(),10)}function Sc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function Tg(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r<t&&(t=r)}return t}function Rc(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const r=e[n];r>t&&(t=r)}return t}function Po(e,t){if(t<e)throw new de(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let r=e;r<t;++r)n.push(r);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let oE;function Br(){return oE==null&&(oE=Yfe().epsilon()),oE}function Lo(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Sl(e,t){return at(e,t)}function _x(e,t=-1){const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),we(e,n)}function kwe(e,t){return Ee(()=>{if(e.shape.length!==2)throw new de(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);const n=_x(e,1);return AA(n,[1,t,1])})}function Swe(e){const t=[Sc(e.shape)];return we(e,t)}function Iwe(e){if(e.rank<=1)throw new de(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],Sc(e.shape,1)];return we(e,t)}function mh(e,t,n){return Ee(()=>{switch(e.rank){case 1:return WF(e,t,n);case 2:return a9(e,[t,0],[n,e.shape[1]]);case 3:return VF(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return vS(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Dn(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Dn(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new de(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function lE(e,t,n){return Ee(()=>{switch(e.rank){case 1:return WF(e,t,n);case 2:return a9(e,[0,t],[e.shape[0],n]);case 3:return VF(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return vS(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new de(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Nk(e,t,n,r){return Ee(()=>{switch(e.rank){case 1:return WF(e,t,n);case 2:switch(r){case 1:return mh(e,t,n);case 2:return lE(e,t,n);default:throw new de(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return mh(e,t,n);case 2:return VF(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return lE(e,t,n);default:throw new de(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return mh(e,t,n);case 2:return vS(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return vS(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return lE(e,t,n);default:throw new de(`The axis is not within the rank of the tensor ${r}`)}default:throw new de(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function E3(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),ga(e,t)}function AV(e,t){switch(e.rank){case 1:return _ge([e,t]);case 2:return Rge([e,t],0);case 3:return Oge([e,t],0);case 4:return Mge([e,t],0);default:throw new de(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function AA(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new de(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return No(e,t)}function cN(e,t=0,n=1,r,s){return Hbe(e,t,n,r,s)}function Il(e,t,n,r){if(e.rank<2||t.rank<2)throw new Pt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){const s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new Pt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return mV({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?RA(e.rank,r,Lo()):null,activation:n});{const s=e.shape.slice(),a=s.pop();e=we(e,[-1,a]);const i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(f,m)=>m===0?t.rank-2:m<=t.rank-2?m-1:m);t=we(Zt(t,c),[l,-1]);const d=[...s,...u];return we(mV({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?RA(e.rank,r,Lo()):null,activation:n}),d)}}function c7(e,t,n){return Ee(()=>(Array.isArray(t)?t=Ua(t,"int32"):t=at(t,"int32"),CF(e,t,n)))}function Ax(e){return me(e,e)}function RA(e,t,n){const r=t.shape;if(t.rank!==1&&t.rank!==e)throw new de(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?we(t,[1,r[0],1,1,1]):we(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?we(t,[1,1,1,1,r[0]]):we(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?we(t,[1,r[0],1,1]):we(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?we(t,[1,1,1,r[0]]):we(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?we(t,[1,r[0],1]):we(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?we(t,[1,1,r[0]]):we(t,[1].concat(r))}else if(e<3)return t;throw new de(`Unsupported input rank by biasAdd: ${t.rank}`)}function Go(e,t,n){return Ee(()=>(n==null&&(n=Lo()),xr(n),Ge(e,RA(e.rank,t,n))))}function Cwe(e,t=1){if(t!==1)throw new Pt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return nN(e)}function Nwe(e){return Ee(()=>Ct(e,Ge(Us(e),1)))}function d7(e,t,n,r){return Ee(()=>Wve(e,t,n,r))}function Twe(e){return Ee(()=>{const t=Ge(.5,me(.2,e));return wi(t,0,1)})}function Rx(e,t,n=!1){return n?e():t()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const $we=["fanIn","fanOut","fanAvg"],Ewe=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _we(e){xp($we,"FanMode",e)}function Awe(e){xp(Ewe,"Distribution",e)}class ro extends my{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class h7 extends ro{apply(t,n){return os(t,n)}}h7.className="Zeros";Ve(h7);class _3 extends ro{apply(t,n){return ld(t,n)}}_3.className="Ones";Ve(_3);class p7 extends ro{constructor(t){if(super(),typeof t!="object")throw new de(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new de(`config must have value set but got ${t}`);this.value=t.value}apply(t,n){return Ee(()=>me(un(this.value),ld(t,n)))}getConfig(){return{value:this.value}}}p7.className="Constant";Ve(p7);class f7 extends ro{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,n){return Sx(t,this.minval,this.maxval,n,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}f7.className="RandomUniform";Ve(f7);class m7 extends ro{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Pt(`randomNormal does not support dType ${n}.`);return cN(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}m7.className="RandomNormal";Ve(m7);class g7 extends ro{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Pt(`truncatedNormal does not support dType ${n}.`);return l9(t,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}g7.className="TruncatedNormal";Ve(g7);class y7 extends ro{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,n){return Ee(()=>{if(t.length!==2||t[0]!==t[1])throw new de("Identity matrix initializer can only be used for 2D square matrices.");return me(this.gain,jq(t[0]))})}getConfig(){return{gain:this.gain}}}y7.className="Identity";Ve(y7);function Rwe(e,t="channelsLast"){let n,r;if(xr(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){const s=Sc(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){const s=Sc(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{const s=Sc(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}class Ya extends ro{constructor(t){if(super(),t.scale<0)throw new de(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,_we(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Awe(this.distribution),this.seed=t.seed}apply(t,n){const r=Rwe(t),s=r[0],a=r[1];let i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,s):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(s+a)/2),this.distribution==="normal"){const o=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Pt(`${this.getClassName()} does not support dType ${n}.`);return l9(t,0,o,n,this.seed)}else{const o=Math.sqrt(3*i);return Sx(t,-o,o,n,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ya.className="VarianceScaling";Ve(Ya);class A3 extends Ya{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ya.className}}A3.className="GlorotUniform";Ve(A3);class R3 extends Ya{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ya.className}}R3.className="GlorotNormal";Ve(R3);class D3 extends Ya{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ya.className}}D3.className="HeNormal";Ve(D3);class O3 extends Ya{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ya.className}}O3.className="HeUniform";Ve(O3);class F3 extends Ya{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ya.className}}F3.className="LeCunNormal";Ve(F3);class M3 extends Ya{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ya.className}}M3.className="LeCunUniform";Ve(M3);class b7 extends ro{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,n){return Ee(()=>{if(t.length<2)throw new Pt("Shape must be at least 2D.");if(n!=="int32"&&n!=="float32"&&n!==void 0)throw new TypeError(`Unsupported data type ${n}.`);n=n;const r=Me(t.slice(0,-1)),s=t[t.length-1],a=r*s;a>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${a}) elements: Slowness may result.`);const i=[Math.max(s,r),Math.min(s,r)],o=cN(i,0,1,n,this.seed),l=P1e.qr(o,!1);let u=l[0];const d=l[1].flatten().stridedSlice([0],[Math.min(s,r)*Math.min(s,r)],[Math.min(s,r)+1]);return u=me(u,d.sign()),r<s&&(u=u.transpose()),me(un(this.gain),u.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}b7.className="Orthogonal";Ve(b7);const RV={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function DV(e,t={}){return Ex(e,zi.getMap().classNameMap,t,"initializer")}function ar(e){return T3(e)}function Xn(e){if(typeof e=="string"){const t=e in RV?RV[e]:e;if(t==="GlorotNormal")return new R3;if(t==="GlorotUniform")return new A3;if(t==="HeNormal")return new D3;if(t==="HeUniform")return new O3;if(t==="LeCunNormal")return new F3;if(t==="LeCunUniform")return new M3;{const n={};return n.className=t,n.config={},DV(n)}}else return e instanceof ro?e:DV(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function DA(e){return Array.isArray(e)&&Array.isArray(e[0])}function xS(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function $t(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new de(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function nn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new de(`Expected exactly 1 Shape; got ${e.length}`)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wS(e){let t=0;for(const n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const OV="Variable";class Dwe{constructor(t,n="float32",r=OV,s=!0,a=null){this.dtype=n??"float32",this.shape=t.shape,this.id=a7(),r=r??OV,this.originalName=o7(r),this.name=l7(this.originalName),this.trainable_=s,this.constraint=a,this.val=Pve(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),Owe(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Owe(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function OA(e){return e.map(t=>t.read())}function P3(e){e.forEach(t=>{t[0].write(t[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Wr{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class Ol{constructor(t,n,r,s,a,i,o){this.dtype=t,this.shape=n,this.sourceLayer=r,this.inputs=s,this.callArgs=a,this.outputTensorIndex=o,this.id=a7(),i!=null&&(this.originalName=o7(i),this.name=l7(this.originalName)),this.rank=n.length}}let Fwe=0,dN=class{constructor(t,n){this.callArgs=n,this.id=Fwe++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r!=null&&r.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const n of this.inboundLayers)n!=null?t.push(n.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},Mwe=0;class qt extends my{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Mwe++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=t.name;if(!n){const r=this.getClassName();n=Xl(r)+"_"+uN(r)}if(this.name=n,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let a=null;t.batchSize!=null&&(a=t.batchSize),r=[a].concat(t.inputShape)}this.batchInputShape=r;let s=t.dtype;s==null&&(s=t.inputDType),s==null&&(s="float32"),this.dtype=s}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,n){return t.name+"_ib-"+n.toString()}getNodeAtIndex(t,n){if(this.inboundNodes.length===0)throw new ji(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=t)throw new de(`Asked to get ${n} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ha(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ha(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ol(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ol(`Layer ${this.name} is not connected, no input to return.`);return ha(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ol(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ol(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ha(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(n=>n.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const n=fn(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=fn(this.inputSpec);if(n.length!==r.length)throw new de(`Layer ${this.name} expects ${r.length} inputs, but it received ${n.length} input tensors. Input received: ${t}`);for(let s=0;s<n.length;s++){const a=n[s],i=r[s];if(i==null)continue;const o=a.rank;if(i.ndim!=null&&o!==i.ndim)throw new de(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${i.ndim}, found ndim=${o}`);if(i.maxNDim!=null&&o>i.maxNDim)throw new de(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${i.maxNDim}, found ndim=${o}`);if(i.minNDim!=null&&o<i.minNDim)throw new de(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${i.minNDim}, found ndim=${o}.`);if(i.dtype!=null&&a.dtype!==i.dtype)throw new de(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${i.dtype}, found dtype=${a.dtype}.`);if(i.axes){const l=a.shape;for(const u in i.axes){const c=Number(u),d=i.axes[u],h=c>=0?l[c]:l[l.length+c];if(d!=null&&[d,null].indexOf(h)===-1)throw new de(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${d} but got shape ${l}.`)}}if(i.shape!=null)for(let l=0;l<i.shape.length;++l){const u=i.shape[l],c=a.shape[l];if(u!=null&&c!=null&&u!==c)throw new de(`Input ${s} is incompatible with layer ${this.name}: expected shape=${i.shape}, found shape=${a.shape}.`)}}}call(t,n){return t}invokeCallHook(t,n){this._callHook!=null&&this._callHook(t,n)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,n){n=n||{},this.assertNotDisposed();const r=fn(t),s=zwe(t),a=Bwe(t);if(s===a)throw new de("Arguments to apply() must be all SymbolicTensors or all Tensors");return fh(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const i=[];for(const o of fn(t))i.push(o.shape);this.build(ha(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(t),a){let i=this.call(t,n);this.supportsMasking&&this.setMaskMetadata(t,i);const o=fn(i),l=[];for(let u of o)r.indexOf(u)!==-1&&(u=u.clone()),l.push(u);if(i=ha(l),this.activityRegularizer!=null)throw new Pt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{const i=Pwe(t),o=this.computeOutputShape(i);let l;const u=Lwe(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?i[0]:i),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((c,d)=>new Ol(u,c,this,fn(t),n,this.name,d)):l=new Ol(u,o,this,fn(t),n,this.name),this.addInboundNode(t,l,null,null,i,o,n),this._refCount++,this.activityRegularizer!=null)throw new Pt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((r,s)=>{r!=null&&t[s]!=null&&t[s]!==r&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ol(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const n of this.inboundNodes){const r=JSON.stringify(n.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){const n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new ol(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ji(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return wS(this.weights)}build(t){this.built=!0}getWeights(t=!1){return OA(t?this.trainableWeights:this.weights)}setWeights(t){Ee(()=>{const n=this.weights;if(n.length!==t.length)throw new de(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${n.length} weights. Provided weights: ${t}...`);if(n.length===0)return;const r=[],s=OA(n);for(let a=0;a<s.length;++a){const i=s[a],o=n[a],l=t[a];if(!cn(i.shape,l.shape))throw new de(`Layer weight shape ${i.shape} not compatible with provided weight shape ${l.shape}`);r.push([o,l])}P3(r)})}addWeight(t,n,r,s,a,i,o,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new de(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(s=l!=null?l():Xn("zeros"));const u=s.apply(n,r),c=new Dwe(u,r,t,i,o);return u.dispose(),a!=null&&this.addLoss(()=>a.apply(c.read())),i==null&&(i=!0),i?this._trainableWeights.push(c):this._nonTrainableWeights.push(c),c}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=fn(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}setMaskMetadata(t,n,r){if(!this.supportsMasking)return;const s=this.computeMask(t,r),a=fn(n),i=fn(s);if(a.length!==i.length)throw new Error(`${this.name} outputs ${a.length} tensors but ${a.length} masks for those tensors`);for(let o=0;o<a.length;o++)a[o].kerasMask=i[o]}addInboundNode(t,n,r,s,a,i,o=null){const l=fn(t);n=fn(n),r=fn(r),s=fn(s),a=xS(a),i=xS(i);const u=[],c=[],d=[];for(const h of l)u.push(h.sourceLayer),c.push(h.nodeIndex),d.push(h.tensorIndex);new dN({outboundLayer:this,inboundLayers:u,nodeIndices:c,tensorIndices:d,inputTensors:l,outputTensors:n,inputMasks:r,outputMasks:s,inputShapes:a,outputShapes:i},o);for(let h=0;h<n.length;h++)n[h].sourceLayer=this,n[h].nodeIndex=this.inboundNodes.length-1,n[h].tensorIndex=h}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function Pwe(e){e=fn(e);const t=[];for(const n of e)t.push(n.shape);return ha(t)}function Lwe(e){return"float32"}function v7(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{const r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{const s=[];for(let a=0;a<r.inboundLayers.length;a++){const i=r.inputTensors[a],o=r.inboundLayers[a],l=r.nodeIndices[a],u=v7(i,o,l);for(const c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}function zwe(e){let t=!0;for(const n of fn(e))if(!(n instanceof Ol)){t=!1;break}return t}function Bwe(e){let t=!0;for(const n of fn(e))if(n instanceof Ol){t=!1;break}return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Dx extends qt{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:uN("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new de("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=t.batchInputShape;if(n==null){if(t.inputShape==null)throw new de("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new de("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=t.dtype||"float32";this.batchInputShape=n,this.dtype=r,this.inputSpec=[{shape:n}];const s=new Ol(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new dN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(t,n){throw new de(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Dx.className="InputLayer";Ve(Dx);function Wwe(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new de("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Dx({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vwe(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return at(t,e.dtype)}catch{throw new de(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}class rc{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof rc)for(const n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(const n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=Vwe(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new de(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Ol){if(this.id2Value[t.id]==null)throw new de(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const n=this.name2Id[t];if(n==null)throw new de(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Ol){if(this.id2Value[t.id]==null)throw new de(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const n=this.name2Id[t];if(n==null)throw new de(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&Vt(this.id2Mask)}}const kS=new n7,SS=new n7;function Uwe(e){kS!=null&&kS.setMaxEntries(e),SS!=null&&SS.setMaxEntries(e)}function Fv(e,t,n,r){const s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(f=>f.name),l=[],u=t.names();for(const f of o)u.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let d=kS.get(c),h;if(d==null){const f=jwe(i,t);d=f.sorted,h=f.recipientCounts,kS.put(c,d),SS.put(c,h)}h={},s||Object.assign(h,SS.get(c));const p=new rc(t);for(let f=0;f<d.length;++f){if(r!=null){const $=xA().numTensors;$>r.maxNumTensors&&(r.maxNumTensors=$),$<r.minNumTensors&&(r.minNumTensors=$)}const m=d[f],g=m.sourceLayer;if(g instanceof Dx)continue;const y=[],b=[],x=[];let v=!1;for(const $ of m.inputs){const C=p.getValue($),T=p.getMask($);y.push(C),b.push(T),T!=null&&(v=!0),s||(h[$.name]--,h[$.name]===0&&!t.hasKey($)&&o.indexOf($.name)===-1&&!C.isDisposed&&$.sourceLayer.stateful!==!0&&x.push(C))}v&&(n=n||{},n.mask=b[0]);const w=fn(g.apply(y,n));let k=null;g.supportsMasking&&(k=g.computeMask(y,b));const S=Hwe(m),I=Array.isArray(S)?S:[S];for(let $=0;$<I.length;++$){p.hasKey(I[$])||p.add(I[$],w[$],Array.isArray(k)?k[0]:k);const C=o.indexOf(I[$].name);C!==-1&&(l[C]=w[$])}s||Vt(x)}return p.disposeMasks(),a?l:l[0]}function jwe(e,t){Y(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){const s=FV(e[0],t);n=s.sorted,r=s.recipientMap}else{const s=new Set;for(const a of e){const{sorted:i,recipientMap:o}=FV(a,t);for(const l of i)s.has(l.name)||(n.push(l),s.add(l.name));for(const l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:Gwe(r)}}function Gwe(e){const t={};for(const n in e)t[n]=e[n].size;return t}function FV(e,t){const n=new Set,r=[],s={};for(const o of t.names())n.add(o);const a=[],i=[];for(a.push(e);a.length>0;){const o=a[a.length-1];if(n.has(o.name)){a.pop();continue}const l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(const u of o.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(o.name),!n.has(u.name)&&a.push(u)}}return{sorted:r,recipientMap:s}}function Hwe(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(const s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qwe=_e();qwe.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Uwe);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function L3(e,t){return Ee(()=>Qs(St(me(e,e),t,!0)))}class Ox extends my{getConfig(){return{}}}class x7 extends Ox{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Ee(()=>{const n=L3(t,this.axis),r=wi(n,0,this.maxValue);return me(t,Ct(r,Ge(Br(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}x7.className="MaxNorm";Ve(x7);class w7 extends Ox{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Ee(()=>Ct(t,Ge(Br(),L3(t,this.axis))))}getConfig(){return{axis:this.axis}}}w7.className="UnitNorm";Ve(w7);class k7 extends Ox{apply(t){return bp(t)}}k7.className="NonNeg";Ve(k7);class S7 extends Ox{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return Ee(()=>{const n=L3(t,this.axis),r=Ge(me(this.rate,wi(n,this.minValue,this.maxValue)),me(1-this.rate,n));return me(t,Ct(r,Ge(Br(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}S7.className="MinMaxNorm";Ve(S7);const MV={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function jr(e){return T3(e)}function PV(e,t={}){return Ex(e,zi.getMap().classNameMap,t,"constraint")}function Gr(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in MV?MV[e]:e,config:{}};return PV(n)}else return e instanceof Ox?e:PV(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function Ad(e){if(e==null)return;const t=[],n=[],r=[];for(const s in e){const a=e[s];if(typeof a!="number"){const i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){const s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];Vt(r)}}function I7(e){if(e!=null)for(const t in e){const n=e[t];typeof n!="number"&&n.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var LV;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(LV||(LV={}));const Kwe=125;class B1{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,n){}async onEpochEnd(t,n){}async onBatchBegin(t,n){}async onBatchEnd(t,n){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class Xwe{constructor(t,n=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=n}append(t){this.callbacks.push(t)}setParams(t){for(const n of this.callbacks)n.setParams(t)}setModel(t){for(const n of this.callbacks)n.setModel(t)}async onEpochBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochBegin(t,n)}async onEpochEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onEpochEnd(t,n)}async onBatchBegin(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchBegin(t,n)}async onBatchEnd(t,n){n==null&&(n={});for(const r of this.callbacks)await r.onBatchEnd(t,n)}async onTrainBegin(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const n of this.callbacks)await n.onTrainEnd(t)}}class Ywe extends B1{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,n){n==null&&(n={});const r=n.size==null?0:n.size;this.seen+=r;for(const s in n){const a=n[s];if(typeof a=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+a*r;else{let i;s in this.totals?i=this.totals[s]:this.totals[s]=0;const o=Ee(()=>Ge(this.totals[s],me(a,r)));this.totals[s]=o,i!=null&&i.dispose()}}}async onEpochEnd(t,n){if(n!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?n[r]=this.totals[r]/this.seen:Ee(()=>{const s=me(Ct(1,this.seen),this.totals[r]);n[r]=s,this.totals[r].dispose(),wl(n[r])}))}}class Jwe extends B1{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,n){n==null&&(n={}),this.epoch.push(t);for(const r in n)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(n[r])}async syncData(){const t=[],n=[],r=[];for(const a in this.history){const i=this.history[a];for(let o=0;o<i.length;++o)if(typeof i[o]!="number"){const l=i[o];t.push(l.data()),n.push(a),r.push(o)}}const s=await Promise.all(t);for(let a=0;a<s.length;++a)this.history[n[a]][r[a]].dispose(),this.history[n[a]][r[a]]=s[a][0]}}class Zwe extends B1{constructor(t,n){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||E9,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Kwe),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");lA(this.yieldEvery)&&(this.maybeWait=dwe(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,n,r){const s=[];this.yield!=null&&(await Ad(r),s.push(this.yield(t,n,r))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(t,n){this.currentEpoch=t,this.epochBegin!=null&&(await Ad(n),await this.epochBegin(t,n))}async onEpochEnd(t,n){const r=[];this.epochEnd!=null&&(await Ad(n),r.push(this.epochEnd(t,n))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(t,n){this.batchBegin!=null&&(await Ad(n),await this.batchBegin(t,n))}async onBatchEnd(t,n){const r=[];this.batchEnd!=null&&(await Ad(n),r.push(this.batchEnd(t,n))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):lA(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,n)),await Promise.all(r)}async onTrainBegin(t){this.trainBegin!=null&&(await Ad(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await Ad(t),await this.trainEnd(t))}}function C7(e,t){return e==null&&(e={}),e instanceof B1?[e]:Array.isArray(e)&&e[0]instanceof B1?e:fn(e).map(r=>new Zwe(r,t))}class Oi{constructor(){}static registerCallbackConstructor(t,n){Y(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Oi.checkForDuplicate(n),Oi.constructors[t]==null&&(Oi.constructors[t]=[]),Oi.constructors[t].push(n)}static checkForDuplicate(t){for(const n in Oi.constructors)Oi.constructors[+n].forEach(s=>{if(s===t)throw new de("Duplicate callback constructor.")})}static clear(){Oi.constructors={}}static createCallbacks(t){const n=[];for(const r in Oi.constructors){const s=+r;t>=s&&n.push(...Oi.constructors[s])}return n.map(r=>new r)}}Oi.constructors={};function N7(e,t,n,r,s,a,i,o,l){const u=new Jwe,c=[new Ywe,...Oi.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);const d=new Xwe(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Cl(e,t={},n=!1){return Ex(e,zi.getMap().classNameMap,t,"layer",n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function IS(e,t){return Ee(()=>{e.dtype!=="float32"&&(e=at(e,"float32"));const n=St(Ax(e),t,!0),r=tN(n.shape,Br()),s=Qs(od(n,r));return Ct(e,s)})}function hN(e,t){return Ee(()=>Nr(Ax(Tt(t,e)),-1))}function z3(e,t){return Ee(()=>Nr(Us(Tt(t,e)),-1))}function B3(e,t){return Ee(()=>{const n=Tt(e,t),r=wi(Us(e),Br(),Number.MAX_VALUE),s=Us(Ct(n,r));return me(100,Nr(s,-1))})}function Qwe(e,t){return Ee(()=>{const n=wi(t,Br(),Number.MAX_VALUE),r=Dl(Ge(1,n)),s=wi(e,Br(),Number.MAX_VALUE),a=Dl(Ge(1,s));return Nr(Ax(Tt(r,a)),-1)})}function eke(e,t){return Ee(()=>{const n=od(0,Tt(1,me(e,t)));return Nr(Ax(n),-1)})}function tke(e,t){return Ee(()=>{const n=od(0,Tt(1,me(e,t)));return Nr(n,-1)})}function nke(e,t){return Ee(()=>{const n=St(me(e,t),-1),r=Ao(me(Tt(1,e),t),-1);return od(0,Ge(1,Tt(r,n)))})}function rke(e,t){return Ee(()=>{const n=Math.log(2),r=Tt(t,e),s=Tt(Ge(r,kx(me(-2,r))),n);return Nr(s,-1)})}function W1(e,t,n=!1){return Ee(()=>{if(n)t=UF(t);else{const r=St(t,t.shape.length-1,!0);t=Ct(t,r)}return t=wi(t,Br(),1-Br()),yr(St(me(at(e,"float32"),Dl(t)),t.shape.length-1))})}function CS(e,t,n=!1){return Ee(()=>{const r=at(sN(Swe(e)),"int32");t=wi(t,Br(),1-Br());const s=t.shape,a=we(Xq(r,s[s.length-1]),s);return W1(a,t,n)})}function ske(e,t){if(!cn(e.shape,t.shape))throw new de(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Ee(()=>{const n=bp(t),r=yr(Us(t));return Ge(Tt(n,me(t,e)),Gq(Rl(r)))})}function pN(e,t){return Ee(()=>{let n;return n=wi(t,Br(),1-Br()),n=Dl(Ct(n,Tt(1,n))),Nr(ske(e,n),-1)})}function ake(e,t){return Ee(()=>{const n=wi(e,Br(),1),r=wi(t,Br(),1);return St(me(e,Dl(Ct(n,r))),-1)})}function ike(e,t){return Ee(()=>{const n=Dl(Ge(Br(),t));return Nr(Tt(t,me(e,n)),-1)})}function T7(e,t){return Ee(()=>{const n=IS(e,-1),r=IS(t,-1),s=me(n,r);return yr(St(s,-1))})}const NS={meanSquaredError:hN,meanAbsoluteError:z3,meanAbsolutePercentageError:B3,meanSquaredLogarithmicError:Qwe,squaredHinge:eke,hinge:tke,categoricalHinge:nke,logcosh:rke,categoricalCrossentropy:W1,sparseCategoricalCrossentropy:CS,binaryCrossentropy:pN,kullbackLeiblerDivergence:ake,poisson:ike,cosineProximity:T7};function uE(e){if(typeof e=="string"){if(e in NS)return NS[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new de(t)}else return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $7(e,t){return Ee(()=>{const n=me(.5,Qi(t)),r=Sl(Ti(t,n),e.dtype);return Nr(Al(e,r),-1)})}function E7(e,t){return Ee(()=>Sl(Al(F1(e,-1),F1(t,-1)),"float32"))}function oke(e,t){return Ee(()=>at(St(pu(Al(e,1),Al(t,1))),"float32"))}function lke(e,t){return Ee(()=>at(St(pu(Al(e,0),Al(t,1))),"float32"))}function uke(e,t){return Ee(()=>{const n=oke(e,t),r=lke(e,t),s=Ge(n,r);return at(Ys(Ti(s,0),Ct(n,s),0),"float32")})}function cke(e,t){return pN(e,t)}function dke(e,t){return e.rank===t.rank&&(e=Ix(e,[e.rank-1])),t=F1(t,-1),t.dtype!==e.dtype&&(t=at(t,e.dtype)),at(Al(e,t),"float32")}const hke=hN,pke=hN,fke=z3,mke=z3,gke=B3,yke=B3,_7=W1,bke=T7,A7=CS,TS={binaryAccuracy:$7,categoricalAccuracy:E7,precision:uke,categoricalCrossentropy:_7,sparseCategoricalCrossentropy:A7,mse:hke,MSE:pke,mae:fke,MAE:mke,mape:gke,MAPE:yke,cosine:bke};function vke(e){if(typeof e=="string"&&e in TS)return TS[e];if(typeof e!="string"&&e!=null)return e;throw new de(`Unknown metric ${e}`)}function Tk(e){if(ll(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(const n of Object.keys(NS))if(NS[n]===e){t=n;break}if(t!==void 0)return t;for(const n of Object.keys(TS))if(TS[n]===e){t=n;break}return t!==void 0?t:e.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function xke(e){const t={Adagrad:()=>hm.adagrad(.01),Adadelta:()=>hm.adadelta(1,.95,Br()),Adam:()=>hm.adam(.001,.9,.999,Br()),Adamax:()=>hm.adamax(.002,.9,.999,Br(),0),RMSProp:()=>hm.rmsprop(.001,.9,0,Br()),SGD:()=>hm.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new de(`Unknown Optimizer ${e}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const zV=1*1024*1024;function BV(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!FA(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const r=JSON.stringify(e);r.length>zV&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${zV}.`)}}function FA(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t)if(typeof n!="string"||!FA(e[n]))return!1;return!0}else if(Array.isArray(e)){for(const t of e)if(!FA(t))return!1;return!0}else return!1;else{const t=typeof e;return t==="string"||t==="number"||t==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wke(e,t,n,r=console.log){const s=Ske(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!s){a.push("Receives inputs"),i=[];for(const c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}r("_".repeat(t)),$S(a,n,r),r("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)s?Ike(o[c],n,r):Cke(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=kke(e),u=wS(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function kke(e){let t;return e.collectedTrainableWeights!=null?t=wS(e.collectedTrainableWeights):t=wS(e.trainableWeights),t}function Ske(e){let t=!0;const n=[],r=[];for(const s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(const s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(const s of e.layers){let a=!1;for(const i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function $S(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function Ike(e,t,n){let r,s;try{s=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}const a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];$S(o,t,n)}function Cke(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}const i=[];for(const d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){const p=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${p}[${f}][${m}]`)}const o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,a,s,e.countParams().toString(),u];$S(c,t,r);for(let d=1;d<i.length;++d)$S(["","","","",i[d]],t,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function R7(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function ES(e,t){if(e===null)return null;if(typeof e=="string")return Gd(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];R7(t,s,a)?n.push(a):n.push(ES(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{const a=Gd(r);n[a]=ES(s,a)}}return n}}function MA(e,t){if(e==null)return null;if(typeof e=="string")return Xl(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){const n=[],r=e.length;for(let s=0;s<r;++s){const a=e[s];R7(t,s,a)?n.push(a):n.push(MA(a,t))}return n}else{const n={};for(const r of Object.keys(e)){const s=e[r],a=Xl(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=MA(s,r)}return n}}/** @license See the LICENSE file. */const D7="4.17.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Nke=e=>{const t=Object.keys(e);if(t.length===0)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))};class vo extends qt{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=uN(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],kc(this.inputs).length!==this.inputs.length)throw new de(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);kc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const x=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;ll(v===0,"input layer has >1 nodes"),ll(w===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const x=this.inputLayers[b];if(!(x instanceof Dx))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const n={},r={},s={},a={},i={},o=[],l=(b,x,v,w,k,S)=>{(w==null||k==null||S==null)&&(w=b.sourceLayer,k=b.nodeIndex,S=b.tensorIndex);const I=w.inboundNodes[k];if(v.indexOf(I)!==-1)throw new ji(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(x.indexOf(I)!==-1)return;this.containerNodes.add(vo.nodeKey(w,k)),w.id in i||(i[w.id]=Object.keys(i).length),v.indexOf(I)===-1&&v.push(I);const $=I.inboundLayers.length;for(let C=0;C<$;C++){const T=I.inputTensors[C],N=I.inboundLayers[C],E=I.nodeIndices[C],_=I.tensorIndices[C];l(T,x,v,N,E,_)}for(x.push(I);v.indexOf(I)>=0;)v.splice(v.indexOf(I),1);o.push(I)},u=[],c=[];for(const b of this.outputs)l(b,u,c);const d=o.slice().reverse();for(const b of d){r[b.id]=b,b.id in n||(n[b.id]=0);let x=n[b.id];const v=s[b.outboundLayer.id]==null?0:s[b.outboundLayer.id];x=Math.max(x,v),s[b.outboundLayer.id]=x,a[b.outboundLayer.id]=b.outboundLayer,n[b.id]=x;for(let w=0;w<b.inboundLayers.length;w++){const k=b.inboundLayers[w],S=b.nodeIndices[w],I=k.inboundNodes[S],$=n[I.id]==null?0:n[I.id];n[I.id]=Math.max(x+1,$),r[I.id]=I}}const h={};for(const b in n){const x=n[b];x in h||(h[x]=[]),h[x].push(r[b])}const p={};for(const b in s){const x=s[b];x in p||(p[x]=[]),p[x].push(a[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(Ik);this.layers=[];for(const b of f){const x=p[b];x.sort((v,w)=>{const k=i[v.id],S=i[w.id];return k<S?-1:k>S?1:0});for(const v of x)v instanceof vo&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(Ik);const m=this.inputs.slice(),g=[];for(const b of f)for(const x of h[b]){const v=x.outboundLayer;if(v!=null){for(const w of x.inputTensors)if(m.indexOf(w)===-1)throw new ji(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(const w of x.outputTensors)m.push(w);g.push(v.name)}}this.nodesByDepth=h;const y=this.layers.map(b=>b.name);for(const b of y){const x=y.filter(v=>v===b).length;if(x!==1)throw new ji(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new dN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(const n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new de("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){const r={};let s=0;const a=Nke(t);a&&this.parseWeights(t);for(const o of this.layers)for(const[l,u]of o.weights.entries()){const c=a?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new de(`Duplicate weight name: ${c}`);r[c]=u,s++}const i=[];for(const o in t){let l=o;if(r[o]==null){const u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new de(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){const o=[];for(const l in r)o.push(l);if(o.length>0)throw new de(`${o.length} of ${s} weights are not set: ${o}`)}P3(i)}parseWeights(t){for(const n in Object.keys(t)){const r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],a=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");a!==n&&(t[a]=t[n],delete t[n])}}updatedConfig(){const t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${D7}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){const r=MA(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return Ee(()=>{t=fn(t);const r=new rc;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Fv(this.outputs,r,n)})}computeMask(t,n){return Ee(()=>{t=fn(t);let r;return n==null?r=Lh(null,t.length):r=fn(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const n=xS(t);if(n.length!==this.inputLayers.length)throw new de(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let o=0;o<n.length;o++){const l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";r[c]=u}const s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Ik);if(s.length>1)for(const o of s){const l=this.nodesByDepth[o];for(const u of l){const c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;const d=[];for(let m=0;m<u.inboundLayers.length;m++){const g=u.inboundLayers[m],y=u.nodeIndices[m],b=u.tensorIndices[m],x=`${g.name}_${y}_${b}`,v=r[x];d.push(v)}const h=c.computeOutputShape(ha(d)),p=xS(h),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++){const g=`${c.name}_${f}_${m}`;r[g]=p[m]}}}const a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${c}`;i.push(d)}for(let o=0;o<i.length;o++){const l=i[o];ll(l in r),a.push(r[l])}return ha(a)}runInternalGraph(t,n){n==null&&(n=Lh(null,t.length));const r={};for(let l=0;l<this.inputs.length;++l){const u=this.inputs[l],c=t[l],d=n[l];r[u.id]=[c,d]}const s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Ik);for(const l of s){const u=this.nodesByDepth[l];for(const c of u){const d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(const m of h)m.id in r&&f.push(r[m.id]);if(f.length===h.length){let m={},g,y,b,x;if(c.callArgs!=null&&(m=c.callArgs),f.length===1){const[v,w]=f[0];m.mask==null&&(m.mask=w),b=fn(d.call(v,m)),x=fn(d.computeMask(v,w)),g=[v],y=[w]}else g=f.map(v=>v[0]),y=f.map(v=>v[1]),m.mask==null&&(m.mask=y),b=fn(d.call(g,m)),x=fn(d.computeMask(g,y));if(d.activityRegularizer)throw new Pt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v){const w=p[v],k=b[v],S=x[v];r[w.id]=[k,S]}}}}const a=[],i=[],o=[];for(const l of this.outputs){ll(l.id in r,`Could not compute output ${l.name} : ${l.id}`);const[u,c]=r[l.id];o.push(u.shape),a.push(u),i.push(c)}return[a,i,o]}buildNodeConversionMap(t){const n={};let r;for(const s of this.layers){r=s instanceof vo?1:0;for(let a=0;a<s.inboundNodes.length;a++){const i=vo.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new de("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const r of this.layers)if(r.name===t)return r;throw new de(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new de(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return Ee(()=>{const t=[];for(const n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){const s=vo.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){const t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(const i of this.layers){const o=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){const h=i.inboundNodes[d],p=vo.nodeKey(i,d);let f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){const m=[];for(let g=0;g<h.inboundLayers.length;g++){const y=h.inboundLayers[g],b=h.nodeIndices[g],x=h.tensorIndices[g],v=vo.nodeKey(y,b);let w=n[v];w==null&&(w=0),m.push([y.name,w,x,f])}u.push(m)}}}const c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;const s=[];for(let i=0;i<this.inputLayers.length;i++){const o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=vo.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.inputLayersTensorIndices[i];s.push([o.name,c,d])}t.inputLayers=s;const a=[];for(let i=0;i<this.outputLayers.length;i++){const o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=vo.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);const d=this.outputLayersTensorIndices[i];a.push([o.name,c,d])}return t.outputLayers=a,t}static fromConfig(t,n,r={},s=!1){const a={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){const b=[];let x;for(const v of y){const w=v[0],k=v[1],S=v[2];if(x=v[3]==null?{}:v[3],!(w in a)){o(g,y);return}const I=a[w];if(I.inboundNodes.length<=k){o(g,y);return}const $=I.inboundNodes[k];b.push($.outputTensors[S])}b.length>0&&g.apply(ha(b),x)}function u(g){const y=g.name,b=Cl(g,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(s),a[y]=b,g.inboundNodes.forEach(v=>{if(!(v instanceof Array))throw new de(`Corrupted configuration, expected array for nodeData: ${v}`);o(b,v)})}const c=n.name,d=n.layers;for(const g of d)u(g);for(;!cwe(i);)for(const g of d){const y=a[g.name];if(y.name in i){const b=i[y.name];delete i[y.name];for(const x of b)l(y,x)}}const h=[],p=[],f=n.inputLayers;for(const g of f){const y=g[0],b=g[1],x=g[2];ll(y in a);const w=a[y].inboundNodes[b].outputTensors;h.push(w[x])}const m=n.outputLayers;for(const g of m){const y=g[0],b=g[1],x=g[2];ll(y in a);const w=a[y].inboundNodes[b].outputTensors;p.push(w[x])}return new t({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new de("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){Ee(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Tke(e,t,n){const r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){const s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function O7(e,t){return Tke(e,t,"classWeight")}async function F7(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){const s=Ee(()=>{if(e.shape.length===1)return ph(e);if(e.shape.length===2){if(e.shape[1]>1)return F1(e,1);if(e.shape[1]===1)return we(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());Vt(s);const i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),Ua(i,"float32")}else return null}function $ke(e,t){return me(e,t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Eke=32;function M7(e,t){let n,r;const s=t;n=s.xs,r=s.ys,Y(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const a=WV("input",e.inputNames,n),i=WV("output",e.outputNames,r),o=a[0].shape[0];Y(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),Y(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<a.length;l++)Y(a[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)Y(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function WV(e,t,n){if(n instanceof Lr)return[n];if(Array.isArray(n))return Y(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{const r=[];for(const s of t){if(n[s]==null)throw new de(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function _ke(e){if(e.length===3)throw new Pt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function Ake(e,t,n){const r=n.batchesPerEpoch!=null;if(Y(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),Y(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),Y(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),Y(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),Y(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const s=n.validationData!=null;let a,i;if(s)if(VV(n.validationData))Y(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{const g=_ke(n.validationData);a=g.xs,i=g.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;s?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();const c=C7(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=N7(c,d,n.epochs,null,null,Rke(t,n),null,s,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const g={};await h.onEpochBegin(f);let y=0,b=0;for(r||(m=await t.iterator());!r||y<n.batchesPerEpoch;){const x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){const{xs:v,ys:w}=M7(e,x.value),k={};k.batch=b,k.size=v[0].shape[0],await h.onBatchBegin(b,k);const S=[];if(n.classWeight!=null){const C=O7(n.classWeight,e.outputNames);for(let T=0;T<C.length;++T)S.push(await F7(w[T],null,C[T]))}const I=v.concat(w).concat(S),$=o(I);Vt(I);for(let C=0;C<l.length;++C){const T=l[C],N=$[C];k[T]=N,wl(N)}await h.onBatchEnd(b,k),I7(k),b++,y++}if(r?y>=n.batchesPerEpoch:x.done){if(s){let v;VV(n.validationData)?v=fn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=fn(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?Eke:n.validationBatchSize,verbose:0}));for(let w=0;w<e.metricsNames.length;++w)g[`val_${e.metricsNames[w]}`]=v[w]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Rke(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function VV(e){return typeof e.iterator=="function"}function Dke(e){return typeof e.next=="function"}async function Oke(e,t,n){n=n||{};const r=n.batches!=null,s=e.testFunction;let a=[];if(n.verbose>0)throw new Pt("Verbose mode is not implemented yet.");Y(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);const i=Dke(t)?t:await t.iterator();let o=0,l=0;for(;!r||l<n.batches;){const u=await i.next();if(a=Ee(()=>{if(u.value){const{xs:c,ys:d}=M7(e,u.value),h=c.concat(d),p=Ee(()=>s(h));if(Vt(h),l===0)for(let m=0;m<p.length;++m)a.push(un(0));const f=h[0].shape[0];for(let m=0;m<p.length;++m){const g=p[m],y=a[m];a[m]=Ee(()=>Ge(a[m],me(f,g))),l>0&&Vt(y)}Vt(p),o+=f,++l}return a}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){const c=a[u];a[u]=Ct(a[u],o),Vt(c)}return ha(a)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function cE(e){Y(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function gv(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>mh(r,t,n-t)):mh(e,t,n-t)}function PA(e,t){return Ee(()=>e==null?null:Array.isArray(e)?e.map(n=>PA(n,t)):c7(e,t.dtype==="int32"?t:at(t,"int32")))}function dE(e,t){const n=[];let r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function P7(e){const t=[];e instanceof Lr&&(e=[e]);for(let n=0;n<e.length;++n){const r=e[n];if(r.rank===1)t.push(_x(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function po(e,t){if(e==null)return;const n=[];if(t instanceof Lr)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(const s in t){const a=t[s];n.push(a.id)}const r=[];if(e instanceof Lr)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(const s in e){const a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fke(e){return e instanceof Lr}function LA(e){return Array.isArray(e)}function UV(e){return!Fke(e)&&!LA(e)}function jV(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(LA(e)&&e.length>0)i=!0;else if(UV(e)){for(const o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new de(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(UV(e)){e=e,a=[];for(const i of t){if(e[i]==null)throw new de(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(LA(e)){if(e=e,e.length!==t.length)throw new de(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new de(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=P7(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new de(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new de(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function Mke(e,t,n){const r=kc(e.map(a=>a.shape[0]));r.sort();const s=kc(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new de(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new de(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!cn(r,s))throw new de(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function Pke(e,t,n){const r=[hN,pN,W1];for(let s=0;s<e.length;++s){const a=e[s],i=t[s],o=n[s];if(i!=null){if(i===W1&&a.shape[a.shape.length-1]===1)throw new de(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){const l=a.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){const d=l[c],h=u[c];if(h!=null&&d!==h)throw new de(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function GV(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new de(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new de(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;const o=a[i];if(o.shape.length!==n[i].length)throw new de(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;const u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new de(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function Lke(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{const r=[];for(const s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}const zke="layers-model";class Qm extends vo{constructor(t){super(t),this.isTraining=!1}summary(t,n,r=console.log){if(!this.built)throw new de("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");wke(this,t,n,r)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=xke(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof ud))throw new de("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const i in t.loss)if(this.outputNames.indexOf(i)===-1)throw new de(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(const i of this.outputNames)t.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(uE(t.loss[i]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new de(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);n=t.loss.map(o=>uE(o))}else{const i=uE(t.loss);this.outputs.forEach(o=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const o=this.internalOutputShapes[i],l=this.outputNames[i];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[i])}const r=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],fh("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([o,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});const s=Lke(t.metrics,this.outputNames),a=(i,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[i]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,i])};fh("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(r.indexOf(i)!==-1)continue;const o=s[i];(u=>{const c="";let d,h,p;for(const f of u){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){const g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===pN?["accuracy","acc"].indexOf(f)!==-1?h=$7:["crossentropy","ce"].indexOf(f)!==-1&&(h=cke):this.lossFunctions[i]===CS?["accuracy","acc"].indexOf(f)!==-1?h=dke:["crossentropy","ce"].indexOf(f)!==-1&&(h=A7):["accuracy","acc"].indexOf(f)!==-1?h=E7:["crossentropy","ce"].indexOf(f)!==-1&&(h=_7);let y;["accuracy","acc"].indexOf(f)!==-1?y="acc":["crossentropy","ce"].indexOf(f)!==-1&&(y="ce"),p=h,d=c+y}else p=vke(f),d=c+Tk(f);let m;fh(d,()=>{m=p}),a(i,d,m)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,n,r={}){const s=r.batchSize==null?32:r.batchSize;cE(s);const a=!0,i=this.standardizeUserDataXY(t,n,a,s);try{const o=i[0].concat(i[1]);this.makeTestFunction();const l=this.testFunction,u=this.testLoop(l,o,s,r.verbose,r.steps);return ha(u)}finally{po(i[0],t),po(i[1],n)}}async evaluateDataset(t,n){return this.makeTestFunction(),Oke(this,t,n)}checkNumSamples(t,n,r,s="steps"){let a;if(r!=null){if(a=null,n!=null)throw new de(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(t!=null)Array.isArray(t)?a=t[0].shape[0]:a=t.shape[0];else throw new de(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return a}execute(t,n){if(Array.isArray(n)&&n.length===0)throw new de("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(n),s=r?n:[n],a=this.retrieveSymbolicTensors(s),i=new rc;if(t instanceof Lr&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new de(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)i.add(this.inputs[l],t[l])}else for(const l of this.inputs){const u=t[l.name];if(u==null)throw new de(`No value is provided for the model's input ${l.name}`);i.add(l,u)}const o=Fv(a,i);return r?o:o[0]}retrieveSymbolicTensors(t){const n=Lh(null,t.length);let r=t.length;for(const s of this.layers){const a=Array.isArray(s.output)?s.output:[s.output],i=a.map(o=>o.name);for(let o=0;o<t.length;++o){const l=i.indexOf(t[o]);if(l!==-1&&(n[o]=a[l],r--),r===0)break}if(r===0)break}if(r>0){const s=[];throw n.forEach((a,i)=>{a==null&&s.push(t[i])}),new de(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(t,n=32,r=!1){return Ee(()=>{const s=this.checkNumSamples(t);if(r)throw new Pt("Verbose predictLoop() is not implemented yet.");const a=dE(s,n),i=this.outputs.map(o=>[]);for(let o=0;o<a.length;++o)Ee(()=>{const u=a[o][0],c=a[o][1],d=gv(t,u,c),h=[];if(Array.isArray(d))for(let f=0;f<d.length;++f)h.push({key:this.inputs[f],value:d[f]});else h.push({key:this.inputs[0],value:d});const p=new rc(h);return Fv(this.outputs,p)}).forEach((u,c)=>i[c].push(u));return ha(i.map(o=>ga(o,0)))})}predict(t,n={}){const r=P7(t);GV(r,this.inputNames,this.feedInputShapes,!1);try{const s=n.batchSize==null?32:n.batchSize;return cE(s),this.predictLoop(r,s)}finally{po(r,t)}}predictOnBatch(t){GV(t,this.inputNames,this.feedInputShapes,!0);const n=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,n)}standardizeUserDataXY(t,n,r=!0,s){if(this.optimizer_==null)throw new ji("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let i=0;i<this.feedOutputShapes.length;++i){const o=this.feedOutputShapes[i];this.feedLossFns[i]===CS?a.push(o.slice(0,o.length-1).concat([1])):a.push(o)}if(t=jV(t,this.feedInputNames,this.feedInputShapes,!1,"input"),n=jV(n,this.feedOutputNames,a,!1,"target"),Mke(t,n),Pke(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&t[0].shape[0]%s!==0)throw new de(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,n]}async standardizeUserData(t,n,r,s,a=!0,i){const[o,l]=this.standardizeUserDataXY(t,n,a,i);if(r!=null)throw new Error("sample weight is not supported yet.");let u=null;if(s!=null){const c=O7(s,this.outputNames);u=[];for(let d=0;d<c.length;++d)u.push(await F7(l[d],null,c[d]))}return[o,l,u]}testLoop(t,n,r,s=0,a){return Ee(()=>{const i=this.checkNumSamples(n,r,a,"steps"),o=[];if(s>0)throw new Pt("Verbose mode is not implemented yet.");if(a!=null)throw new Pt("steps mode in testLoop() is not implemented yet");{const l=dE(i,r),u=Ua(Po(0,i));for(let c=0;c<l.length;++c){const d=l[c][0],h=l[c][1],p=mh(u,d,h-d),f=PA(n,p),m=t(f);if(c===0)for(let g=0;g<m.length;++g)o.push(un(0));for(let g=0;g<m.length;++g){const y=m[g];o[g]=Ge(o[g],me(h-d,y))}}for(let c=0;c<o.length;++c)o[c]=Ct(o[c],i)}return o})}getDedupedMetricsNames(){const t=this.metricsNames,n=[];for(let r=0;r<t.length;++r){const s=t[r];let a=s;if(EV(t,s)>1){const i=EV(t.slice(0,r),s);a+=`_${i}`}n.push(a)}return n}makeTrainFunction(){return t=>{const n=[],r=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],o=()=>{const d=[];for(let m=0;m<this.inputs.length;++m)d.push({key:this.inputs[m],value:r[m]});const h=new rc(d),p=Fv(this.outputs,h,{training:!0});let f;for(let m=0;m<this.lossFunctions.length;++m){const g=this.lossFunctions[m];let y=g(s[m],p[m]);a[m]!=null&&(y=$ke(y,a[m]));const b=Nr(y);n.push(b),m===0?f=y:f=Ge(f,y)}for(let m=0;m<this.metricsTensors.length;++m){let g;if(this.outputs.length>1&&m<this.outputs.length)g=n[m];else{const y=this.metricsTensors[m][0],b=this.metricsTensors[m][1];g=Nr(y(s[b],p[b]))}wl(g),i.push(g)}return f=Nr(f),this.calculateLosses().forEach(m=>{f=Ge(f,m)}),f},l=this.collectedTrainableWeights.map(d=>d.read()),u=!0;return[this.optimizer_.minimize(o,u,l)].concat(i)}}makeTestFunction(){this.testFunction=t=>Ee(()=>{const n=[];let r;const s=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let u=0;u<this.inputs.length;++u)i.push({key:this.inputs[u],value:s[u]});const o=new rc(i),l=Fv(this.outputs,o);for(let u=0;u<this.lossFunctions.length;++u){const c=this.lossFunctions[u],d=Nr(c(a[u],l[u]));u===0?r=d:r=Ge(r,d),n.push(r)}for(let u=0;u<this.metricsTensors.length;++u){const c=this.metricsTensors[u][0],d=this.metricsTensors[u][1],h=Nr(c(a[d],l[d]));n.push(h)}return n})}async fit(t,n,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let s,a,i,o,l,u,c,d,h;try{const p=r.batchSize==null?32:r.batchSize;cE(p);const f=!1,m=await this.standardizeUserData(t,n,r.sampleWeight,r.classWeight,f,p);s=m[0],a=m[1],h=m[2];let g=!1,y;if(r.validationData!=null&&r.validationData.length>0){if(g=!0,r.validationData.length===2)l=r.validationData[0],u=r.validationData[1];else throw r.validationData.length===3?new Pt("validationData including sample weights is not supported yet."):new de(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const $=!0,C=await this.standardizeUserData(l,u,null,null,$,p);c=C[0],d=C[1],y=c.concat(d)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){g=!0;const $=Math.floor(s[0].shape[0]*(1-r.validationSplit)),C=s[0].shape[0];c=gv(s,$,C),i=s,s=gv(s,0,$),d=gv(a,$,C),o=a,a=gv(a,0,$),y=c.concat(d)}else r.validationSteps!=null&&(g=!0);const b=s.concat(a).concat(h);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let w,k;g?(this.makeTestFunction(),w=this.testFunction,k=v.slice().concat(v.map($=>"val_"+$))):(w=null,y=[],k=v.slice());const S=C7(r.callbacks,r.yieldEvery);return await this.fitLoop(x,b,v,p,r.epochs,r.verbose,S,w,y,r.shuffle,k,r.initialEpoch,null,null)}finally{this.isTraining=!1,po(s,t),po(a,n),po(i,t),po(o,n),po(c,l),po(d,u),h!=null&&Vt(h)}}async fitLoop(t,n,r,s,a,i,o,l,u,c,d,h,p,f){s==null&&(s=32),a==null&&(a=1),c==null&&(c=!0),h==null&&(h=0);let m=!1;if(l!=null&&u!=null&&(m=!0),f!=null&&(m=!0,p==null))throw new de("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(n,s,p,"steps_per_epoch");let y;g!=null&&(y=Po(0,g)),i==null&&(i=1);const{callbackList:b,history:x}=N7(o,i,a,h,g,p,s,m,d);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<a;++v){await b.onEpochBegin(v);const w={};if(p!=null)throw new Pt("stepsPerEpoch mode is not implemented yet.");{if(c==="batch")throw new Pt("batch shuffling is not implemneted yet");c&&ife(y);const k=Ua(y),S=dE(g,s);for(let I=0;I<S.length;++I){const $={};if(await b.onBatchBegin(I,$),Ee(()=>{const C=S[I][0],T=S[I][1],N=mh(k,C,T-C);$.batch=I,$.size=T-C;const E=PA(n,N),_=t(E);for(let R=0;R<r.length;++R){const z=r[R],W=_[R];$[z]=W,wl(W)}if(I===S.length-1&&m){const R=this.testLoop(l,u,s);for(let z=0;z<r.length;++z){const W=r[z],F=R[z];wl(F),w["val_"+W]=F}}}),await b.onBatchEnd(I,$),I7($),this.stopTraining_)break}k.dispose()}if(await b.onEpochEnd(v,w),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,n){return Ake(this,t,n)}async trainOnBatch(t,n){const r=await this.standardizeUserData(t,n),s=r[0],a=r[1],o=this.makeTrainFunction()(s.concat(a)),l=[];for(const u of o){const c=await u.data();l.push(c[0])}return Vt(o),po(r[0],t),po(r[1],n),ha(l)}getNamedWeights(t){const n=[],r=t!=null&&t.trainableOnly,s=r?this.trainableWeights:this.weights,a=this.getWeights(r);for(let i=0;i<s.length;++i)r&&!s[i].trainable||n.push({name:s[i].originalName,tensor:a[i]});return n}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const n=xA().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=n-xA().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Xl(this.loss);else if(Array.isArray(this.loss)){for(const n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(n=>Xl(n))}else{const n=Object.keys(this.loss);t={};const r=this.loss;for(const s of n)if(typeof r[s]=="string")t[s]=Xl(r[s]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Xl(Tk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Xl(Tk(t)));{const t={};for(const n in this.metrics)t[n]=Xl(Tk(this.metrics[n]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const n=ES(t.optimizer_config),r=Cl(n);let s;if(typeof t.loss=="string")s=Gd(t.loss);else if(Array.isArray(t.loss))s=t.loss.map(i=>Gd(i));else if(t.loss!=null){s={};for(const i in t.loss)s[i]=Gd(t.loss[i])}let a;if(Array.isArray(t.metrics))a=t.metrics.map(i=>Gd(i));else if(t.metrics!=null){a={};for(const i in t.metrics)a[i]=Gd(t.metrics[i])}this.compile({loss:s,metrics:a,optimizer:r})}async save(t,n){if(typeof t=="string"){const u=dme(t);if(u.length===0)throw new de(`Cannot find any save handlers for URL '${t}'`);if(u.length>1)throw new de(`Found more than one (${u.length}) save handlers for URL '${t}'`);t=u[0]}if(t.save==null)throw new de("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await cV(this.getNamedWeights(n)),s=!1,a=null,o={modelTopology:this.toJSON(a,s),format:zke,generatedBy:`TensorFlow.js tfjs-layers v${D7}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const u="optimizer",{data:c,specs:d}=await cV(await this.optimizer.getWeights(),u);r.specs.push(...d),r.data=rme([r.data,c])}return this.userDefinedMetadata!=null&&(BV(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=r.data,o.weightSpecs=r.specs,t.save(o)}setUserDefinedMetadata(t){BV(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Qm.className="Model";Ve(Qm);class L7 extends Qm{}L7.className="Functional";Ve(L7);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function _S(e,t){if(t==null&&(t={}),typeof e=="string"){const n=hme(e,t);if(n.length===0)n.push(q1e(e,t));else if(n.length>1)throw new de(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return Bke(e,void 0,t)}async function Bke(e,t,n){if(n==null&&(n={}),e.load==null)throw new de("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await e.load();let s=r.modelTopology;s.model_config!=null&&(s=s.model_config);const a=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&a,o=Cl(ES(s),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new de("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:u,optimizerWeights:c}=Wke(r.weightData,r.weightSpecs);o.loadWeights(u,a),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),Vt(u),Vt(c.map(d=>d.tensor))}return o}function Wke(e,t){const n=Jfe(e,t),r={},s=[];return t.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}class V1 extends Qm{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:uN("sequential_"),t.layers!=null)for(const n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new de(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const n=t instanceof V1||t instanceof Qm;let r;if(n){if(r=t,r.outputs.length!==1)throw new de("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new de("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new de("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const s=Wwe({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new de(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new de("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=v7(this.outputs[0])}this.inboundNodes=[],new dN({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Lh(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{const s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(nn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Qm({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new ji("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new ji("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new ji("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new ji("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new de("Legacy serialization format not supported yet.");a=n}else Y(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;const o=new t(i);if(!(o instanceof V1))throw new Pt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of a){const c=Cl(l,void 0,s);s&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(t){if(this.model==null)throw new de("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new de("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const n of this.layers){const r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}}V1.className="Sequential";Ve(V1);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let $a=class extends my{getConfig(){return{}}};class z7 extends $a{apply(t,n=1){return Cwe(t,n)}}z7.className="elu";Ve(z7);class B7 extends $a{apply(t){return t9(t)}}B7.className="selu";Ve(B7);class W7 extends $a{apply(t){return bp(t)}}W7.className="relu";Ve(W7);class V7 extends $a{apply(t){return Ee(()=>L1(6,bp(t)))}}V7.className="relu6";Ve(V7);class U7 extends $a{apply(t){return t}}U7.className="linear";Ve(U7);class j7 extends $a{apply(t){return hy(t)}}j7.className="sigmoid";Ve(j7);class G7 extends $a{apply(t){return Twe(t)}}G7.className="hardSigmoid";Ve(G7);class H7 extends $a{apply(t){return kx(t)}}H7.className="softplus";Ve(H7);class q7 extends $a{apply(t){return Nwe(t)}}q7.className="softsign";Ve(q7);class K7 extends $a{apply(t){return vF(t)}}K7.className="tanh";Ve(K7);let W3=class extends $a{apply(t,n=-1){return UF(t,n)}};W3.className="softmax";Ve(W3);class X7 extends $a{apply(t,n=-1){return Hq(t,n)}}X7.className="logSoftmax";Ve(X7);class Y7 extends $a{apply(t,n=1){return Ee(()=>me(hy(me(t,n)),t))}}Y7.className="swish";Ve(Y7);class J7 extends $a{apply(t){return Ee(()=>me(t,vF(kx(t))))}}J7.className="mish";Ve(J7);function Dc(e){return e.getClassName()}function hE(e,t={}){return Ex(e,zi.getMap().classNameMap,t,"activation")}function Oc(e){if(e==null){const t={};return t.className="linear",t.config={},hE(t)}if(typeof e=="string"){const t={};return t.className=e,t.config={},hE(t)}else return e instanceof $a?e:hE(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vke(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}class Z7 extends my{}class Q7 extends Z7{constructor(t){super(),Vke(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return Ee(()=>{let n=os([1]);return this.hasL1&&(n=Ge(n,St(me(this.l1,Us(t))))),this.hasL2&&(n=Ge(n,St(me(this.l2,Ax(t))))),we(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,n){return new t({l1:n.l1,l2:n.l2})}}Q7.className="L1L2";Ve(Q7);const HV={l1l2:"L1L2"};function En(e){return T3(e)}function qV(e,t={}){return Ex(e,zi.getMap().classNameMap,t,"regularizer")}function Jn(e){if(e==null)return null;if(typeof e=="string"){const n={className:e in HV?HV[e]:e,config:{}};return qV(n)}else return e instanceof Z7?e:qV(e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class eK extends qt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,n){t=$t(t);let r=bp(t);return this.maxValue!=null&&(r=wi(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},n=super.getConfig();return Object.assign(t,n),t}}eK.className="ReLU";Ve(eK);class tK extends qt{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=$t(t);return TF(r,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}}tK.className="LeakyReLU";Ve(tK);class nK extends qt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Xn(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Jn(t.alphaRegularizer),this.alphaConstraint=Gr(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new de(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=nn(t);const n=t.slice(1);if(this.sharedAxes!=null)for(const s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let s=1;s<t.length;++s)r[s]=t[s];this.inputSpec=[new Wr({ndim:t.length,axes:r})],this.built=!0}call(t,n){return t=$t(t),DF(t,this.alpha.read())}getConfig(){const t={alphaInitializer:ar(this.alphaInitializer),alphaRegularizer:En(this.alphaRegularizer),alphaConstraint:jr(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(t,n),t}}nK.className="PReLU";Ve(nK);let rK=class extends qt{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new Pt(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,n){const r=$t(t);return nN(r)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},n=super.getConfig();return Object.assign(t,n),t}};rK.className="ELU";Ve(rK);class sK extends qt{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,n){const r=$t(t);return me(r,at(Ti(r,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},n=super.getConfig();return Object.assign(t,n),t}}sK.className="ThresholdedReLU";Ve(sK);class aK extends qt{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new W3().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,n){return Ee(()=>{let r=$t(t);const s=n.mask;if(s!=null){const a=me(Tt(ld(r.shape),at(s,r.dtype)),un(-1e9));r=Ge(r,a)}return this.axis instanceof Array?this.axis.length>1?Rl(Tt(r,qq(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}aK.className="Softmax";Ve(aK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function eg(e,t,n){if(typeof e=="number")return Lh(e,t);if(e.length!==t)throw new de(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const s=e[r];if(!wwe(s))throw new de(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Ro(e,t,n,r,s=1){if(e==null)return e;const a=t+(t-1)*(s-1);let i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function ul(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+Rc([n-t,0]);else if(r==="same")e=e*t;else throw new de(`Unsupport padding mode: ${r}.`);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function V3(e,t){return Ee(()=>(xr(t),t==="channelsFirst"?Zt(e,[0,2,3,1]):e))}function iK(e,t){return Ee(()=>(xr(t),t==="channelsFirst"?Zt(e,[0,2,3,4,1]):e))}function Uke(e,t,n,r=1,s="valid",a,i=1){return Ee(()=>{if(a==null&&(a=Lo()),xr(a),e.shape.length!==3)throw new de(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new de(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new de(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(e=Zt(e,[0,2,1])),s==="causal")throw new Pt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=Pq(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=Go(o,n)),o})}function KV(e,t,n,r=[1,1],s="valid",a,i,o=null){return Ee(()=>{if(a==null&&(a=Lo()),xr(a),e.rank!==3&&e.rank!==4)throw new de(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new de(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=V3(e,a);if(s==="causal")throw new Pt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=jve({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=Zt(l,[0,3,1,2])),l})}function jke(e,t,n,r=[1,1,1],s="valid",a,i){return Ee(()=>{if(a==null&&(a=Lo()),xr(a),e.rank!==4&&e.rank!==5)throw new de(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new de(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=iK(e,a);if(s==="causal")throw new Pt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=Vge(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=Go(o,n)),a==="channelsFirst"&&(o=Zt(o,[0,4,1,2,3])),o})}class fN extends qt{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",fN.verifyArgs(n),this.rank=t,us(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Pt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=eg(n.kernelSize,t,"kernelSize"),this.strides=eg(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,$i(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,xr(this.dataFormat),this.activation=Oc(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=Xn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Gr(n.biasConstraint),this.biasRegularizer=Jn(n.biasRegularizer),this.activityRegularizer=Jn(n.activityRegularizer),this.dilationRate=eg(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new de(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new de(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new de(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(ll("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!$3(t.kernelSize,"number",1,3))throw new de(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Dc(this.activation),useBias:this.useBias,biasInitializer:ar(this.biasInitializer),biasRegularizer:En(this.biasRegularizer),activityRegularizer:En(this.activityRegularizer),biasConstraint:jr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}class gy extends fN{constructor(t,n){super(t,n),this.kernel=null,gy.verifyArgs(n),this.filters=n.filters,us(this.filters,"filters"),this.kernelInitializer=Xn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Gr(n.kernelConstraint),this.kernelRegularizer=Jn(n.kernelRegularizer)}build(t){t=nn(t);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new de(`The channel dimension of the input should be defined. Found ${t[n]}`);const r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return Ee(()=>{t=$t(t);let r;const s=this.bias==null?null:this.bias.read(),a=s7(this.activation.getClassName());if(a!=null&&this.rank===2)r=KV(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=Uke(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=KV(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=jke(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Pt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=nn(t);const n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<r.length;++a){const i=Ro(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){const t={filters:this.filters,kernelInitializer:ar(this.kernelInitializer),kernelRegularizer:En(this.kernelRegularizer),kernelConstraint:jr(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new de(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class Fx extends gy{constructor(t){super(2,t),Fx.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!$3(t.kernelSize,"number",1,2))throw new de(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}Fx.className="Conv2D";Ve(Fx);class Mx extends gy{constructor(t){super(3,t),Mx.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new de(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}Mx.className="Conv3D";Ve(Mx);class oK extends Fx{constructor(t){if(super(t),this.inputSpec=[new Wr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new de(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=nn(t),t.length!==4)throw new de("Input should have rank 4; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new de("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Wr({ndim:4,axes:{[n]:r}})],this.built=!0}call(t,n){return Ee(()=>{let r=$t(t);if(r.shape.length!==4)throw new de(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o;this.dataFormat==="channelsFirst"?(i=2,o=3):(i=1,o=2);const l=s[i],u=s[o],c=this.kernelSize[0],d=this.kernelSize[1],h=this.strides[0],p=this.strides[1],f=ul(l,h,c,this.padding),m=ul(u,p,d,this.padding),g=[a,f,m,this.filters];this.dataFormat!=="channelsLast"&&(r=Zt(r,[0,2,3,1]));let y=Lq(r,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=Zt(y,[0,3,1,2])),this.bias!=null&&(y=Go(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(t){t=nn(t);const n=t.slice();let r,s,a;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3):(r=3,s=1,a=2);const i=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],u=this.strides[1];return n[r]=this.filters,n[s]=ul(n[s],l,i,this.padding),n[a]=ul(n[a],u,o,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}oK.className="Conv2DTranspose";Ve(oK);class lK extends Mx{constructor(t){if(super(t),this.inputSpec=[new Wr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new de(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=nn(t),t.length!==5)throw new de("Input should have rank 5; Received input shape: "+JSON.stringify(t));const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new de("The channel dimension of the inputs should be defined. Found `None`.");const r=t[n],s=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Wr({ndim:5,axes:{[n]:r}})],this.built=!0}call(t,n){return Ee(()=>{let r=$t(t);if(r.shape.length!==5)throw new de(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const s=r.shape,a=s[0];let i,o,l;this.dataFormat==="channelsFirst"?(l=2,i=3,o=4):(l=1,i=2,o=3);const u=s[l],c=s[i],d=s[o],h=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],m=this.strides[0],g=this.strides[1],y=this.strides[2],b=ul(u,m,h,this.padding),x=ul(c,g,p,this.padding),v=ul(d,y,f,this.padding),w=[a,b,x,v,this.filters];this.dataFormat!=="channelsLast"&&(r=Zt(r,[0,2,3,4,1]));let k=Gge(r,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(k=Zt(k,[0,4,1,2,3])),this.bias!==null&&(k=Go(k,this.bias.read(),this.dataFormat)),this.activation!==null&&(k=this.activation.apply(k)),k})}computeOutputShape(t){t=nn(t);const n=t.slice();let r,s,a,i;this.dataFormat==="channelsFirst"?(r=1,s=2,a=3,i=4):(r=4,s=1,a=2,i=3);const o=this.kernelSize[0],l=this.kernelSize[1],u=this.kernelSize[2],c=this.strides[0],d=this.strides[1],h=this.strides[2];return n[r]=this.filters,n[s]=ul(n[s],c,o,this.padding),n[a]=ul(n[a],d,l,this.padding),n[i]=ul(n[i],h,u,this.padding),n}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}lK.className="Conv3DTranspose";Ve(lK);class uK extends gy{constructor(t,n){if(super(t,n),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,n.filters==null)throw new de("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new de("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new de(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=Xn(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Jn(n.depthwiseRegularizer),this.depthwiseConstraint=Gr(n.depthwiseConstraint),this.pointwiseInitializer=Xn(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Jn(n.pointwiseRegularizer),this.pointwiseConstraint=Gr(n.pointwiseConstraint)}build(t){if(t=nn(t),t.length<this.rank+2)throw new de(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null||t[n]<0)throw new de(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[n])}`);const r=t[n],s=this.kernelSize.concat([r,this.depthMultiplier]),a=[];for(let o=0;o<this.rank;++o)a.push(1);a.push(r*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Wr({ndim:this.rank+2,axes:{[n]:r}})],this.built=!0}call(t,n){return Ee(()=>{t=$t(t);let r;if(this.rank===1)throw new Pt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Zt(t,[0,2,3,1])),r=n9(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Go(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=Zt(r,[0,3,1,2])),r})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=ar(this.depthwiseInitializer),t.pointwiseInitializer=ar(this.pointwiseInitializer),t.depthwiseRegularizer=En(this.depthwiseRegularizer),t.pointwiseRegularizer=En(this.pointwiseRegularizer),t.depthwiseConstraint=jr(this.depthwiseConstraint),t.pointwiseConstraint=jr(this.pointwiseConstraint),t}}uK.className="SeparableConv";class cK extends uK{constructor(t){super(2,t)}}cK.className="SeparableConv2D";Ve(cK);class mN extends gy{constructor(t){super(1,t),mN.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!$3(t.kernelSize,"number",1,1))throw new de(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}mN.className="Conv1D";Ve(mN);class dK extends qt{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,n){return Ee(()=>{if(t=$t(t),this.dataFormat==="channelsLast"){const r=Nk(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Nk(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=Nk(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Nk(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}dK.className="Cropping2D";Ve(dK);class hK extends qt{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,xr(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,bwe(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const n=t[2]==null?null:this.size[0]*t[2],r=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],n,r]}else{const n=t[1]==null?null:this.size[0]*t[1],r=t[2]==null?null:this.size[1]*t[2];return[t[0],n,r,t[3]]}}call(t,n){return Ee(()=>{let r=$t(t);const s=r.shape;if(this.dataFormat==="channelsFirst"){r=Zt(r,[0,2,3,1]);const a=this.size[0]*s[2],i=this.size[1]*s[3],o=this.interpolation==="nearest"?ru.resizeNearestNeighbor(r,[a,i]):ru.resizeBilinear(r,[a,i]);return Zt(o,[0,3,1,2])}else{const a=this.size[0]*s[1],i=this.size[1]*s[2];return this.interpolation==="nearest"?ru.resizeNearestNeighbor(r,[a,i]):ru.resizeBilinear(r,[a,i])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}}hK.className="UpSampling2D";Ve(hK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gke(e,t,n=[1,1],r="valid",s,a){return Ee(()=>{s==null&&(s=Lo()),xr(s);let i=V3(e,s);if(e.rank!==4)throw new de(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new de(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=SF(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=Zt(i,[0,3,1,2])),i})}class pK extends fN{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Xn(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Gr(t.depthwiseConstraint),this.depthwiseRegularizer=Jn(t.depthwiseRegularizer)}build(t){if(t=nn(t),t.length<4)throw new de(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const n=this.dataFormat==="channelsFirst"?1:3;if(t[n]==null||t[n]<0)throw new de(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[n]}).`);const r=t[n],s=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Ee(()=>{t=$t(t);let r=Gke(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Go(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=nn(t);const n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,a=Ro(n,this.kernelSize[0],this.padding,this.strides[0]),i=Ro(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],s,a,i]:[t[0],a,i,s]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=ar(this.depthwiseInitializer),t.depthwiseRegularizer=En(this.depthwiseRegularizer),t.depthwiseConstraint=jr(this.depthwiseRegularizer),t}}pK.className="DepthwiseConv2D";Ve(pK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function fK(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new de("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function mK(e,t,n,r=!1,s,a,i=!1,o=!1){return Ee(()=>{const l=t.shape.length;if(l<3)throw new de(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(Po(2,l));if(t=Zt(t,u),a!=null)throw new Pt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=at(at(s,"bool"),"float32"),s.rank===l-1&&(s=da(s,-1)),s=Zt(s,u)),r&&(t=Mh(t,0),s!=null&&(s=Mh(s,0)));const c=[];let d,h=n;const p=t.shape[0],f=Ph(t);let m;s!=null&&(m=Ph(s));for(let y=0;y<p;++y){const b=f[y],x=Ee(()=>e(b,h));if(s==null)d=x[0],h=x[1];else{const v=Ee(()=>{const w=m[y],k=Tt(Qi(w),w),S=Ge(me(x[0],w),me(h[0],k)),I=h.map(($,C)=>Ge(me(x[1][C],w),me($,k)));return{output:S,newStates:I}});d=v.output,h=v.newStates}o&&c.push(d)}let g;return o&&(g=fu(c,1)),[d,g,h]})}class cd extends qt{constructor(t){super(t);let n;if(t.cell==null)throw new de("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new G3({cells:t.cell}):n=t.cell,n.stateSize==null)throw new de("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Wr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Po(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){DA(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);const r=n[0];let s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){const a=[];for(const i of n)a.push([t[0],i]);return[s].concat(a)}else return s}computeMask(t,n){return Ee(()=>{Array.isArray(n)&&(n=n[0]);const r=this.returnSequences?n:null;if(this.returnState){const s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Pt("Constants support is not implemented in RNN yet.");DA(t)&&(t=t[0]),t=t;const n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Wr({shape:[n,null,...r]});const s=[t[0]].concat(t.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!cn(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new de(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Wr({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){Ee(()=>{if(!this.stateful)throw new ol("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new de("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>os([r,s])):this.states_=[os([r,this.cell.stateSize])];else if(t==null)Vt(this.states_),this.keptStates!=null&&(Vt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>os([r,s])):this.states_[0]=os([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new de(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):Vt(this.states_);for(let s=0;s<this.states_.length;++s){const a=t[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!cn(a.shape,o))throw new de(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>wl(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=fK(t,r,s,this.numConstants);t=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(const u of r)this.stateSpec.push(new Wr({shape:u.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof Ol){const u=[t].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const h=super.apply(u,n);return this.inputSpec=d,h}else return super.apply(t,n)}call(t,n){return Ee(()=>{const r=n==null?null:n.mask,s=n==null?null:n.training;let a=n==null?null:n.initialState;t=$t(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new de(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:s},u=mK((f,m)=>{const g=this.cell.call([f].concat(m),o);return[g[0],g.slice(1)]},t,a,this.goBackwards,r,null,this.unroll,this.returnSequences),c=u[0],d=u[1],h=u[2];this.stateful&&this.resetStates(h,s);const p=this.returnSequences?d:c;return this.returnState?[p].concat(h):p})}getInitialState(t){return Ee(()=>{let n=os(t.shape);return n=St(n,[1,2]),n=_x(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?AA(n,[1,r]):n):this.cell.stateSize>1?[AA(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===cd.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){const s=n.cell,a=Cl(s,r);return new t(Object.assign(n,{cell:a}))}}cd.className="RNN";Ve(cd);class gN extends qt{}class U3 extends gN{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,us(this.units,"units"),this.activation=Oc(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Xn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jn(t.kernelRegularizer),this.recurrentRegularizer=Jn(t.recurrentRegularizer),this.biasRegularizer=Jn(t.biasRegularizer),this.kernelConstraint=Gr(t.kernelConstraint),this.recurrentConstraint=Gr(t.recurrentConstraint),this.biasConstraint=Gr(t.biasConstraint),this.dropout=Tg([1,Rc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Tg([1,Rc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=nn(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Ee(()=>{if(t=t,t.length!==2)throw new de(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let r=t[1];t=t[0];const s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Fc({ones:()=>Qi(t),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Fc({ones:()=>Qi(r),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let a;const i=this.dropoutMask,o=this.recurrentDropoutMask;i!=null?a=Il(me(t,i),this.kernel.read()):a=Il(t,this.kernel.read()),this.bias!=null&&(a=Go(a,this.bias.read())),o!=null&&(r=me(r,o));let l=Ge(a,Il(r,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Dc(this.activation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),recurrentInitializer:ar(this.recurrentInitializer),biasInitializer:ar(this.biasInitializer),kernelRegularizer:En(this.kernelRegularizer),recurrentRegularizer:En(this.recurrentRegularizer),biasRegularizer:En(this.biasRegularizer),activityRegularizer:En(this.activityRegularizer),kernelConstraint:jr(this.kernelConstraint),recurrentConstraint:jr(this.recurrentConstraint),biasConstraint:jr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),n)}}U3.className="SimpleRNNCell";Ve(U3);class gK extends cd{constructor(t){t.cell=new U3(t),super(t)}call(t,n){return Ee(()=>{this.cell.dropoutMask!=null&&(Vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return new t(n)}}gK.className="SimpleRNN";Ve(gK);class j3 extends gN{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new de("GRUCell does not support reset_after parameter set to true.");this.units=t.units,us(this.units,"units"),this.activation=Oc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Oc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Xn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Jn(t.kernelRegularizer),this.recurrentRegularizer=Jn(t.recurrentRegularizer),this.biasRegularizer=Jn(t.biasRegularizer),this.kernelConstraint=Gr(t.kernelConstraint),this.recurrentConstraint=Gr(t.recurrentConstraint),this.biasConstraint=Gr(t.biasConstraint),this.dropout=Tg([1,Rc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Tg([1,Rc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=nn(t);const n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,n){return Ee(()=>{if(t=t,t.length!==2)throw new de(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training==null?!1:n.training;let s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Fc({ones:()=>Qi(t),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Fc({ones:()=>Qi(s),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,i=this.recurrentDropoutMask;let o,l,u;0<this.dropout&&this.dropout<1&&(t=me(t,a[0]));let c=Il(t,this.kernel.read());this.useBias&&(c=Go(c,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=me(s,i[0]));const d=this.recurrentKernel.read(),[h,p]=yi(d,[2*this.units,this.units],d.rank-1),f=Il(s,h),[m,g,y]=yi(c,3,c.rank-1),[b,x]=yi(f,2,f.rank-1);o=this.recurrentActivation.apply(Ge(m,b)),l=this.recurrentActivation.apply(Ge(g,x));const v=Il(me(l,s),p);u=this.activation.apply(Ge(y,v));const w=Ge(me(o,s),me(Ge(1,yr(o)),u));return[w,w]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Dc(this.activation),recurrentActivation:Dc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),recurrentInitializer:ar(this.recurrentInitializer),biasInitializer:ar(this.biasInitializer),kernelRegularizer:En(this.kernelRegularizer),recurrentRegularizer:En(this.recurrentRegularizer),biasRegularizer:En(this.biasRegularizer),activityRegularizer:En(this.activityRegularizer),kernelConstraint:jr(this.kernelConstraint),recurrentConstraint:jr(this.recurrentConstraint),biasConstraint:jr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),n)}}j3.className="GRUCell";Ve(j3);class yK extends cd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new j3(t),super(t)}call(t,n){return Ee(()=>{this.cell.dropoutMask!=null&&(Vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}yK.className="GRU";Ve(yK);class yN extends gN{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,us(this.units,"units"),this.activation=Oc(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Oc(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Xn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Xn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Xn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Jn(t.kernelRegularizer),this.recurrentRegularizer=Jn(t.recurrentRegularizer),this.biasRegularizer=Jn(t.biasRegularizer),this.kernelConstraint=Gr(t.kernelConstraint),this.recurrentConstraint=Gr(t.recurrentConstraint),this.biasConstraint=Gr(t.biasConstraint),this.dropout=Tg([1,Rc([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Tg([1,Rc([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var n;t=nn(t);const r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,i=this.units;s=new(n=class extends ro{apply(l,u){const c=a.apply([i]),d=new _3().apply([i]),h=a.apply([i*2]);return AV(AV(c,d),h)}},n.className="CustomInit",n)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,n){return Ee(()=>{const r=n.training==null?!1:n.training;if(t=t,t.length!==3)throw new de(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1];const a=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Fc({ones:()=>Qi(t),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Fc({ones:()=>Qi(s),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,o=this.recurrentDropoutMask;let l,u,c,d;0<this.dropout&&this.dropout<1&&(t=me(t,i[0]));let h=Il(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=me(s,o[0])),h=Ge(h,Il(s,this.recurrentKernel.read())),this.useBias&&(h=Go(h,this.bias.read()));const[p,f,m,g]=yi(h,4,h.rank-1);l=this.recurrentActivation.apply(p),u=this.recurrentActivation.apply(f),c=Ge(me(u,a),me(l,this.activation.apply(m))),d=this.recurrentActivation.apply(g);const y=me(d,this.activation.apply(c));return[y,y,c]})}getConfig(){const t=super.getConfig(),n={units:this.units,activation:Dc(this.activation),recurrentActivation:Dc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),recurrentInitializer:ar(this.recurrentInitializer),biasInitializer:ar(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:En(this.kernelRegularizer),recurrentRegularizer:En(this.recurrentRegularizer),biasRegularizer:En(this.biasRegularizer),activityRegularizer:En(this.activityRegularizer),kernelConstraint:jr(this.kernelConstraint),recurrentConstraint:jr(this.recurrentConstraint),biasConstraint:jr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),n)}}yN.className="LSTMCell";Ve(yN);class bK extends cd{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new yN(t),super(t)}call(t,n){return Ee(()=>{this.cell.dropoutMask!=null&&(Vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}static fromConfig(t,n){return n.implmentation===0&&(n.implementation=1),new t(n)}}bK.className="LSTM";Ve(bK);class G3 extends gN{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const n of this.cells.slice().reverse())Array.isArray(n.stateSize)?t.push(...n.stateSize):t.push(n.stateSize);return t}call(t,n){return Ee(()=>{t=t;let r=t.slice(1);const s=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?s.push(r.splice(0,o.stateSize.length)):s.push(r.splice(0,1));s.reverse();const a=[];let i;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];r=s[o],o===0?i=[t[0]].concat(r):i=[i[0]].concat(r),i=l.call(i,n),a.push(i.slice(1))}r=[];for(const o of a.slice().reverse())r.push(...o);return[i[0]].concat(r)})}build(t){DA(t)&&(t=t[0]),t=t;let n;this.cells.forEach((r,s)=>{fh(`RNNCell_${s}`,()=>{r.build(t),Array.isArray(r.stateSize)?n=r.stateSize[0]:n=r.stateSize,t=[t[0],n]})}),this.built=!0}getConfig(){const t=super.getConfig(),n=a=>({className:a.getClassName(),config:a.getConfig()}),s={cells:this.cells.map(n)};return Object.assign(Object.assign({},t),s)}static fromConfig(t,n,r={}){const s=[];for(const a of n.cells)s.push(Cl(a,r));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const n of this.cells)t.push(...n.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const n of this.cells)t.push(...n.nonTrainableWeights);if(!this.trainable){const n=[];for(const r of this.cells)n.push(...r.trainableWeights);return n.concat(t)}return t}getWeights(){const t=[];for(const n of this.cells)t.push(...n.weights);return OA(t)}setWeights(t){const n=[];for(const r of this.cells){const s=r.weights.length,a=t.splice(s);for(let i=0;i<r.weights.length;++i)n.push([r.weights[i],a[i]])}P3(n)}}G3.className="StackedRNNCells";Ve(G3);function Fc(e){const{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):d7(t(),n),o=()=>Rx(i,t,r);return!s||s<=1?wl(o().clone()):Array(s).fill(void 0).map(o).map(u=>wl(u.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var Hke=globalThis&&globalThis.__rest||function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n};class vK extends cd{constructor(t){if(t.unroll)throw new Pt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new Pt("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new Wr({ndim:5})]}call(t,n){return Ee(()=>{if(this.cell.dropoutMask!=null&&(Vt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Vt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new de("ConvRNN2D cell does not support constants");const r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(t,{mask:r,training:s,initialState:a})})}computeOutputShape(t){let n=this.computeSingleOutputShape(t);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([t[0],...n.slice(-3)])]),n}getInitialState(t){return Ee(()=>{const{stateSize:n}=this.cell,r=t.shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)],i=os(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(t,n=!1){Ee(()=>{if(!this.stateful)throw new ol("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,s=this.computeSingleOutputShape(r),a=[s[0],...s.slice(2)];if(r[0]==null)throw new de("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>os(a)):this.states_=[os(a)];else if(t==null)Vt(this.states_),this.keptStates!=null&&(Vt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>os(a)):this.states_[0]=os(a);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new de(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n?this.keptStates.push(this.states_.slice()):Vt(this.states_);for(let o=0;o<this.states_.length;++o){const l=t[o],u=a;if(!cn(l.shape,u))throw new de(`State ${o} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${l.shape}`);this.states_[o]=l}}this.states_=this.states_.map(o=>wl(o.clone()))})}computeSingleOutputShape(t){const{dataFormat:n,filters:r,kernelSize:s,padding:a,strides:i,dilationRate:o}=this.cell,l=n==="channelsFirst",u=t[l?3:2],c=t[l?4:3],d=Ro(u,s[0],a,i[0],o[0]),h=Ro(c,s[1],a,i[1],o[1]);return[...t.slice(0,2),...l?[r,d,h]:[d,h,r]]}}vK.className="ConvRNN2D";class H3 extends yN{constructor(t){const{filters:n,kernelSize:r,strides:s,padding:a,dataFormat:i,dilationRate:o}=t;super(Object.assign(Object.assign({},t),{units:n})),this.filters=n,us(this.filters,"filters"),this.kernelSize=eg(r,2,"kernelSize"),this.kernelSize.forEach(l=>us(l,"kernelSize")),this.strides=eg(s||1,2,"strides"),this.strides.forEach(l=>us(l,"strides")),this.padding=a||"valid",$i(this.padding),this.dataFormat=i||"channelsLast",xr(this.dataFormat),this.dilationRate=eg(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>us(l,"dilationRate"))}build(t){var n;t=nn(t);const r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new de(`The channel dimension of the input should be defined. Found ${t[r]}`);const s=t[r],a=4,i=this.kernelSize.concat([s,this.filters*a]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const u=this.biasInitializer,c=this.filters;l=new(n=class extends ro{apply(h,p){const f=u.apply([c]),m=ld([c]),g=u.apply([c*2]);return E3([f,m,g])}},n.className="CustomInit",n)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,n){return Ee(()=>{if(t.length!==3)throw new de(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const r=n.training||!1,s=t[0],a=t[1],i=t[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Fc({ones:()=>Qi(s),rate:this.dropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,u=(O,D,B)=>!D||!D[B]?O:me(D[B],O);let c=u(s,l,0),d=u(s,l,1),h=u(s,l,2),p=u(s,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Fc({ones:()=>Qi(a),rate:this.recurrentDropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let m=u(a,f,0),g=u(a,f,1),y=u(a,f,2),b=u(a,f,3);const x=3,[v,w,k,S]=yi(this.kernel.read(),o,x),[I,$,C,T]=this.useBias?yi(this.bias.read(),o):[null,null,null,null];c=this.inputConv(c,v,I,this.padding),d=this.inputConv(d,w,$,this.padding),h=this.inputConv(h,k,C,this.padding),p=this.inputConv(p,S,T,this.padding);const[N,E,_,R]=yi(this.recurrentKernel.read(),o,x);m=this.recurrentConv(m,N),g=this.recurrentConv(g,E),y=this.recurrentConv(y,_),b=this.recurrentConv(b,R);const z=this.recurrentActivation.apply(Ge(c,m)),W=this.recurrentActivation.apply(Ge(d,g)),F=Ge(me(W,i),me(z,this.activation.apply(Ge(h,y)))),L=me(this.recurrentActivation.apply(Ge(p,b)),this.activation.apply(F));return[L,L,F]})}getConfig(){const t=super.getConfig(),n=Hke(t,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),r)}inputConv(t,n,r,s){const a=Fh(t,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Go(a,r,this.dataFormat):a}recurrentConv(t,n){return Fh(t,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}H3.className="ConvLSTM2DCell";Ve(H3);class xK extends vK{constructor(t){const n=new H3(t);super(Object.assign(Object.assign({},t),{cell:n}))}static fromConfig(t,n){return new t(n)}}xK.className="ConvLSTM2D";Ve(xK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class q3 extends qt{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const n=t.shape,r=[];for(let s=0;s<this.noiseShape.length;++s)r.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return r}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);const r=$t(t);if(0<this.rate&&this.rate<1){const s=n.training==null?!1:n.training,a=this.getNoiseShape(r);return Rx(()=>d7(r,this.rate,a,this.seed),()=>r,s)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(t,n),t}dispose(){return super.dispose()}}q3.className="Dropout";Ve(q3);class wK extends q3{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const n=t.shape;return[n[0],1,n[2]]}}wK.className="SpatialDropout1D";Ve(wK);class kK extends qt{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let n=null;t.batchSize!=null&&(n=t.batchSize),this.batchInputShape=[n,t.inputDim]}this.units=t.units,us(this.units,"units"),this.activation=Oc(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Xn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Xn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Gr(t.kernelConstraint),this.biasConstraint=Gr(t.biasConstraint),this.kernelRegularizer=Jn(t.kernelRegularizer),this.biasRegularizer=Jn(t.biasRegularizer),this.activityRegularizer=Jn(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=nn(t);const n=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(t){t=nn(t);const n=t.slice();return n[n.length-1]=this.units,n}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);const r=$t(t),s=s7(this.activation.getClassName());let a;return s!=null?a=Il(r,this.kernel.read(),s,this.bias?this.bias.read():null):(a=Il(r,this.kernel.read()),this.bias!=null&&(a=Go(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const t={units:this.units,activation:Dc(this.activation),useBias:this.useBias,kernelInitializer:ar(this.kernelInitializer),biasInitializer:ar(this.biasInitializer),kernelRegularizer:En(this.kernelRegularizer),biasRegularizer:En(this.biasRegularizer),activityRegularizer:En(this.activityRegularizer),kernelConstraint:jr(this.kernelConstraint),biasConstraint:jr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}}kK.className="Dense";Ve(kK);class SK extends qt{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=nn(t);for(const n of t.slice(1))if(n==null)throw new de(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],Sc(t,1)]}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);let r=$t(t);if(this.dataFormat==="channelsFirst"&&r.rank>1){const s=[0];for(let a=2;a<r.rank;++a)s.push(a);s.push(1),r=Zt(r,s)}return Iwe(r)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const n=super.getConfig();return Object.assign(t,n),t}}SK.className="Flatten";Ve(SK);class IK extends qt{constructor(t){super(t),this.supportsMasking=!0,this.activation=Oc(t.activation)}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);const r=$t(t);return this.activation.apply(r)})}getConfig(){const t={activation:Dc(this.activation)},n=super.getConfig();return Object.assign(t,n),t}}IK.className="Activation";Ve(IK);class CK extends qt{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,n){return Ee(()=>(t=$t(t),kwe(t,this.n)))}getConfig(){const t={n:this.n},n=super.getConfig();return Object.assign(t,n),t}}CK.className="RepeatVector";Ve(CK);class NK extends qt{constructor(t){super(t),this.targetShape=t.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,n){const r="Total size of new array must be unchanged.",s=n.slice();let a=1,i=null;for(let l=0;l<s.length;++l){const u=s[l];if(this.isUnknown(u))if(i===null)i=l;else throw new de("Can only specifiy one unknown dimension.");else a*=u}const o=Sc(t);if(i!==null){if(a===0||o%a!==0)throw new de(r);s[i]=o/a}else if(o!==a)throw new de(r);return s}computeOutputShape(t){let n=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){n=!0;break}return n?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);const r=$t(t),s=r.shape,a=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return we(r,a)})}getConfig(){const t={targetShape:this.targetShape},n=super.getConfig();return Object.assign(t,n),t}}NK.className="Reshape";Ve(NK);class TK extends qt{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const n=Po(1,t.dims.length+1);if(!cn(t.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Wr({ndim:this.dims.length+1})]}computeOutputShape(t){t=nn(t);const n=t.slice();return this.dims.forEach((r,s)=>{n[s+1]=t[r]}),n}call(t,n){return Zt($t(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},n=super.getConfig();return Object.assign(t,n),t}}TK.className="Permute";Ve(TK);class $K extends qt{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,t),n}computeMask(t,n){const r=$t(t),s=-1;return IA(yS(r,this.maskValue),s)}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);const r=$t(t),s=-1,a=!0,i=IA(yS(r,this.maskValue),s,a);return me(r,at(i,r.dtype))})}}$K.className="Masking";Ve($K);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class EK extends qt{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let n=null;t.batchSize!=null&&(n=t.batchSize),t.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(fn(t.inputLength))}this.inputDim=t.inputDim,us(this.inputDim,"inputDim"),this.outputDim=t.outputDim,us(this.outputDim,"outputDim"),this.embeddingsInitializer=Xn(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Jn(t.embeddingsRegularizer),this.activityRegularizer=Jn(t.activityRegularizer),this.embeddingsConstraint=Gr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,n){return Ee(()=>this.maskZero?(t=$t(t),yS(t,Qt(t))):null)}computeOutputShape(t){if(t=nn(t),this.inputLength==null)return[...t,this.outputDim];const n=fn(this.inputLength);if(n.length!==t.length-1)throw new de(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let s=0;s<n.length;++s){const a=n[s],i=t[s+1];if(a!=null&&i!=null&&a!==i)throw new de(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);a==null&&(n[r]=i),r++}}return[t[0],...n,this.outputDim]}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);let r=$t(t);r.dtype!=="int32"&&(r=Sl(r,"int32"));const s=c7(this.embeddings.read(),we(r,[r.size]));return we(s,nn(this.computeOutputShape(r.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ar(this.embeddingsInitializer),embeddingsRegularizer:En(this.embeddingsRegularizer),activityRegularizer:En(this.activityRegularizer),embeddingsConstraint:jr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(t,n),t}}EK.className="Embedding";Ve(EK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class wp extends qt{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new Pt}computeElementwiseOpOutputShape(t,n){if(t==null||n==null)return null;if(t.length<n.length)return this.computeElementwiseOpOutputShape(n,t);if(n.length===0)return t;const r=t.slice(0,t.length-n.length);for(let s=0;s<n.length;++s){const a=t[t.length-n.length+s],i=n[s];if(a==null||i==null||a<0||i<0)r.push(null);else if(a===1)r.push(i);else if(i===1)r.push(a);else{if(a!==i)throw new de("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(n));r.push(a)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[nn(t)]),t=t,t.length<2)throw new de(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let n=[];for(const a of t)a!=null&&a[0]!==null&&n.push(a[0]);if(n=kc(n),n.length>1)throw new de(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let a=1;a<t.length;++a){const i=t[a]==null?null:t[a].slice(1);r=this.computeElementwiseOpOutputShape(r,i)}const s=t.map(a=>a.length);t.indexOf(null)===-1&&kc(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,n){return Ee(()=>{if(t=t,this.reshapeRequired){const r=[],s=t.map(a=>a.rank);if(s.indexOf(null)===-1){const a=Rc(s);for(let i of t){const o=i.rank;for(let l=0;l<a-o;++l)i=_x(i,1);r.push(i)}return this.mergeFunction(r)}else{let a=!1;for(const l of t){const u=l.rank;if(u==null){const c=l.shape,d=c[0],h=c.slice(1).concat([d]);let p=we(l,[d].concat(Sc(c.slice(1))));p=Zt(p,[1,0]),p=we(p,h),r.push(p),a=!0}else if(u>1){const c=Po(1,u).concat([0]);r.push(Zt(l,c)),a=!0}else r.push(l)}let i=this.mergeFunction(r);const o=i.rank;if(a){if(o==null){const l=i.shape,u=l.length,c=l[u-1],d=[c].concat(l.slice(0,l.length-1));i=we(Zt(we(i,[-1,c]),[1,0]),d)}else if(o>1){const l=[o-1].concat(Po(0,o-1));i=Zt(i,l)}}return i}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let n;t[0]==null?n=null:n=t[0].slice(1);for(let s=1;s<t.length;++s){const a=t[s]==null?null:t[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=[];for(const s of t)s!=null&&s[0]!==null&&r.push(s[0]);return r=kc(r),r.length===1?n=r.concat(n):n=[null].concat(n),n}computeMask(t,n){return Ee(()=>{if(n==null)return null;if(!Array.isArray(n))throw new de("`mask` should be an Array");if(!Array.isArray(t))throw new de("`inputs` should be an Array");if(n.length!==t.length)throw new de(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:da(s,0));let r=n[0];for(let s=1;s<n.length-1;++s)r=pu(r,n[s]);return r})}}class _K extends wp{constructor(t){super(t)}mergeFunction(t){return Ee(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=Ge(n,t[r]);return n})}}_K.className="Add";Ve(_K);class AK extends wp{constructor(t){super(t)}mergeFunction(t){return Ee(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=me(n,t[r]);return n})}}AK.className="Multiply";Ve(AK);class RK extends wp{constructor(t){super(t)}mergeFunction(t){return Ee(()=>{let n=t[0].clone();for(let r=1;r<t.length;++r)n=Ge(n,t[r]);return me(1/t.length,n)})}}RK.className="Average";Ve(RK);class DK extends wp{constructor(t){super(t)}mergeFunction(t){return Ee(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=od(n,t[r]);return n})}}DK.className="Maximum";Ve(DK);class OK extends wp{constructor(t){super(t)}mergeFunction(t){return Ee(()=>{let n=t[0];for(let r=1;r<t.length;++r)n=L1(n,t[r]);return n})}}OK.className="Minimum";Ve(OK);class FK extends wp{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new de("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let n=!0;for(const s of t)if(s!=null){n=!1;break}if(n)return;const r=[];for(let s=0;s<t.length;++s){const a=t[s].slice();a.splice(this.axis,1);let i=!1;for(const o of r)if(cn(o,a)){i=!0;break}i||r.push(a)}if(r.length>1)throw new de("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return Ee(()=>E3(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new de("A `Concatenate` layer should be called on a list of inputs.");const n=t,r=n[0].slice(),s=this.axis<0?r.length+this.axis:this.axis;for(const a of n.slice(1)){if(r[s]==null||a[s]==null){r[s]=null;break}r[s]+=a[s]}return r}computeMask(t,n){if(n==null)return null;if(!Array.isArray(n))throw new de("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new de("`inputs` should be an array for Concatenate");if(n.length!==t.length)throw new de(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${t.length})`);return Ee(()=>{let r=!0;if(n.forEach(i=>{if(i!=null){r=!1;return}}),r)return null;const s=[];for(let i=0;i<t.length;++i)n[i]==null?s.push(at(Qi(t[i]),"bool")):n[i].rank<t[i].rank?s.push(da(n[i],-1)):s.push(n[i]);const a=ga(s,this.axis);return Mq(a,-1,!1)})}getConfig(){const t={axis:this.axis},n=super.getConfig();return Object.assign(t,n),t}}FK.className="Concatenate";Ve(FK);function yv(e,t){for(;e<0;)e+=t;return e}function qke(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Pt("batchDot is not implemented for tensors of 4D or higher rank yet");if(Y(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),Y(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Pt("batchDot is not implemented for complex64-type Tensors yet.");const r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);const a=n;return Ee(()=>{let i;if(r>s){i=r-s;const l=[];for(let u=0;u<i;++u)l.push(1);t=we(t,t.shape.concat(l))}else if(s>r){i=s-r;const l=[];for(let u=0;u<i;++u)l.push(1);e=we(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=St(me(e,t),a[0]):o=St(me(Zt(e,[1,0]),t),a[1]);else{const l=a[0]!==e.shape.length-1,u=a[1]===t.shape.length-1;o=ln(e,t,l,u)}if(i>0){let l;r>s?l=r+s-3:l=r-1;const u=[];for(let c=l;c<l+i;++c)u.push(c);o=Ix(o,u)}return o.shape.length===1&&(o=da(o,1)),o})}class MK extends wp{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){Y(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0],r=t[1];if(n.length>3||r.length>3)throw new Pt("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);if(n[s[0]]!==r[s[1]])throw new de(`Dimension incompatibility: ${n[s[0]]} !== ${r[s[1]]}`)}mergeFunction(t){if(t.length!==2)throw new de(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let n=t[0],r=t[1],s;return Array.isArray(this.axes)?s=this.axes.map((a,i)=>yv(a,t[i].shape.length)):s=[yv(this.axes,n.shape.length),yv(this.axes,r.shape.length)],this.normalize&&(n=IS(n,s[0]),r=IS(r,s[1])),qke(n,r,s)}interpretAxes(t,n){let r;return Array.isArray(this.axes)?r=this.axes:r=[yv(this.axes,t.length),yv(this.axes,n.length)],r}computeOutputShape(t){Y(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const n=t[0].slice(),r=t[1].slice();if(n.length>3||r.length>3)throw new Pt("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(n,r);n.splice(s[0],1),r.splice(s[1],1),r.splice(0,1);const a=n.concat(r);return a.length===1&&a.push(1),a}computeMask(t,n){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(t,n),t}}MK.className="Dot";Ve(MK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PK extends qt{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,t),n}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);const r=$t(t);return Rx(()=>Ge(cN(r.shape,0,this.stddev),r),()=>r,n.training||!1)})}}PK.className="GaussianNoise";Ve(PK);class LK extends qt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return Ee(()=>{this.invokeCallHook(t,n);const r=$t(t);return this.rate>0&&this.rate<1?Rx(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return me(r,cN(r.shape,1,a))},()=>r,n.training||!1):r})}}LK.className="GaussianDropout";Ve(LK);class zK extends qt{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||$t(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),n={rate:this.rate};return Object.assign(n,t),n}call(t,n){return Ee(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(t);return Rx(()=>{const a=$t(t),i=1.6732632423543772,o=1.0507009873554805,l=-i*o;let u=gp(Sx(r),this.rate);u=Sl(u,"float32");const c=((1-this.rate)*(1+this.rate*l**2))**-.5,d=-c*l*this.rate,h=Ge(me(a,u),me(Ge(u,-1),l));return Ge(me(h,c),d)},()=>$t(t),n.training||!1)}return t})}}zK.className="AlphaDropout";Ve(zK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function U1(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=bge(e,t,n,r,s,a);else if(e.rank===3)i=xge(e,t,n,r,s,a);else if(e.rank===4)i=kge(e,t,n,r,s,a);else throw new Pt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function Kke(e,t,n,r,s=.001){return Ee(()=>{const a=_F(e,r),i=a.mean,o=a.variance;return[U1(e,i,o,n,t,s),i,o]})}function Xke(e,t,n,r,s=.001){return Ee(()=>{const a=_F(e,r),i=a.mean,o=a.variance,l=[];for(const f of Po(0,e.rank))r.indexOf(f)!==-1?l.push(1):l.push(e.shape[f]);const u=we(i,l),c=we(o,l),d=t==null?null:we(t,l),h=n==null?null:we(n,l);return[U1(e,u,c,h,d,s),i,o]})}function Yke(e,t,n,r,s=.001){return cn(r.slice().sort(),Po(0,e.rank-1))?Kke(e,t,n,r,s):Xke(e,t,n,r,s)}class BK extends qt{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Xn(t.betaInitializer||"zeros"),this.gammaInitializer=Xn(t.gammaInitializer||"ones"),this.movingMeanInitializer=Xn(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Xn(t.movingVarianceInitializer||"ones"),this.betaConstraint=Gr(t.betaConstraint),this.gammaConstraint=Gr(t.gammaConstraint),this.betaRegularizer=Jn(t.betaRegularizer),this.gammaRegularizer=Jn(t.gammaRegularizer)}build(t){t=nn(t);const n=this.axis>=0?this.axis:this.axis+t.length,r=t[n];if(r==null)throw new de(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new Wr({ndim:t.length,axes:{[n]:r}})];const s=[r];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,n){return Ee(()=>{const r=n.training==null?!1:n.training,s=$t(t),a=s.shape,i=a.length,o=Po(0,i),l=this.axis>=0?this.axis:this.axis+i;o.splice(l,1);const u=Lh(1,i);u[l]=a[l];const c=o.slice();c.sort();const d=!cn(c,Po(0,i).slice(0,i-1)),h=()=>{if(d){const b=we(this.movingMean.read(),u),x=we(this.movingVariance.read(),u),v=this.center?we(this.beta.read(),u):null,w=this.scale?we(this.gamma.read(),u):null;return U1(s,b,x,v,w,this.epsilon)}else return U1(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return h();const[p,f,m]=Yke(s,this.gamma.read(),this.beta.read(),o,this.epsilon),g=(b,x,v)=>{Ee(()=>{const w=1-v,k=b.read(),S=me(Tt(k,x),w);b.write(Tt(k,S))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,m,this.momentum)})(),p})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ar(this.betaInitializer),gammaInitializer:ar(this.gammaInitializer),movingMeanInitializer:ar(this.movingMeanInitializer),movingVarianceInitializer:ar(this.movingVarianceInitializer),betaRegularizer:En(this.betaRegularizer),gammaRegularizer:En(this.gammaRegularizer),betaConstraint:jr(this.betaConstraint),gammaConstraint:jr(this.gammaConstraint)},n=super.getConfig();return Object.assign(t,n),t}}BK.className="BatchNormalization";Ve(BK);class WK extends qt{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Xn(t.betaInitializer||"zeros"),this.gammaInitializer=Xn(t.gammaInitializer||"ones"),this.betaRegularizer=Jn(t.betaRegularizer),this.gammaRegularizer=Jn(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=nn(t);const n=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(const a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==kc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(a=>t[a]),s=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(t,n){const r=$t(t),s=r.shape,a=s.length;return Ee(()=>{let{mean:o,variance:l}=_F(r,this.axis,!0);const u=Lh(1,a);for(const m of this.axis)u[m]=s[m];const c=m=>m!=null&&m.shape.length!==a?we(m,u):m;let d=this.scale?c(this.gamma.read()):null,h=this.center?c(this.beta.read()):null;const p=[],f=[];for(let m=0;m<a;++m)this.axis.indexOf(m)!==-1?(p.push(s[m]),f.push(1)):(p.push(1),f.push(s[m]));return o=No(o,p),l=No(l,p),d!=null&&(d=No(d,f)),h!=null&&(h=No(h,f)),U1(r,o,l,h,d,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ar(this.betaInitializer),gammaInitializer:ar(this.gammaInitializer),betaRegularizer:En(this.betaRegularizer),gammaRegularizer:En(this.gammaRegularizer)},n=super.getConfig();return Object.assign(t,n),t}}WK.className="LayerNormalization";Ve(WK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Jke(e,t,n){return Ee(()=>{if(e.rank!==4)throw new de(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new de("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Lo()),n!=="channelsLast"&&n!=="channelsFirst")throw new de(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],AF(e,r)})}class VK extends qt{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?Lo():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new de(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let n,r;if(typeof t.padding[0]=="number")n=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new de(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(n=t.padding[0],t.padding[1].length!==2)throw new de(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[n,r]}this.inputSpec=[new Wr({ndim:4})]}computeOutputShape(t){t=nn(t);let n,r;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?n=t[2]+this.padding[0][0]+this.padding[0][1]:n=null,t[3]!=null&&t[3]>=0?r=t[3]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],t[1],n,r]):(t[1]!=null&&t[1]>=0?n=t[1]+this.padding[0][0]+this.padding[0][1]:n=null,t[2]!=null&&t[2]>=0?r=t[2]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],n,r,t[3]])}call(t,n){return Ee(()=>Jke($t(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}VK.className="ZeroPadding2D";Ve(VK);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bN(e,t,n,r,s,a){return Ee(()=>{xr(s),i7(a),$i(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=Lo()),a==null&&(a="max"),e=V3(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=EF(e,t,n,o):i=bF(e,t,n,o),s==="channelsFirst"&&(i=Zt(i,[0,3,1,2])),i})}function UK(e,t,n,r,s,a){return Ee(()=>{xr(s),i7(a),$i(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Lo()),a==null&&(a="max"),e=iK(e,s);let i;const o=r==="same"?"same":"valid";return a==="max"?i=obe(e,t,n,o):i=lge(e,t,n,o),s==="channelsFirst"&&(i=Zt(i,[0,4,1,2,3])),i})}class jK extends qt{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new de(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(us(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new de(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);us(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,$i(this.padding),this.inputSpec=[new Wr({ndim:3})]}computeOutputShape(t){t=nn(t);const n=Ro(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],n,t[2]]}call(t,n){return Ee(()=>{this.invokeCallHook(t,n),t=_x($t(t),2);const r=this.poolingFunction($t(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ix(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(t,n),t}}class GK extends jK{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return xr(a),$i(s),bN(t,n,r,s,a,"max")}}GK.className="MaxPooling1D";Ve(GK);class HK extends jK{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return xr(a),$i(s),bN(t,n,r,s,a,"avg")}}HK.className="AveragePooling1D";Ve(HK);class qK extends qt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new de(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];us(this.poolSize,"poolSize"),us(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,xr(this.dataFormat),$i(this.padding),this.inputSpec=[new Wr({ndim:4})]}computeOutputShape(t){t=nn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return n=Ro(n,this.poolSize[0],this.padding,this.strides[0]),r=Ro(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r]:[t[0],n,r,t[3]]}call(t,n){return Ee(()=>(this.invokeCallHook(t,n),this.poolingFunction($t(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class KK extends qK{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return xr(a),$i(s),bN(t,n,r,s,a,"max")}}KK.className="MaxPooling2D";Ve(KK);class XK extends qK{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return xr(a),$i(s),bN(t,n,r,s,a,"avg")}}XK.className="AveragePooling2D";Ve(XK);class YK extends qt{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new de(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];us(this.poolSize,"poolSize"),us(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,xr(this.dataFormat),$i(this.padding),this.inputSpec=[new Wr({ndim:5})]}computeOutputShape(t){t=nn(t);let n=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[4]:t[3];return n=Ro(n,this.poolSize[0],this.padding,this.strides[0]),r=Ro(r,this.poolSize[1],this.padding,this.strides[1]),s=Ro(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],n,r,s]:[t[0],n,r,s,t[4]]}call(t,n){return Ee(()=>(this.invokeCallHook(t,n),this.poolingFunction($t(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class JK extends YK{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return xr(a),$i(s),UK(t,n,r,s,a,"max")}}JK.className="MaxPooling3D";Ve(JK);class ZK extends YK{constructor(t){super(t)}poolingFunction(t,n,r,s,a){return xr(a),$i(s),UK(t,n,r,s,a,"avg")}}ZK.className="AveragePooling3D";Ve(ZK);class QK extends qt{constructor(t){super(t),this.inputSpec=[new Wr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,n){throw new Pt}}class eX extends QK{constructor(t){super(t||{})}call(t,n){return Ee(()=>{const r=$t(t);return Nr(r,1)})}}eX.className="GlobalAveragePooling1D";Ve(eX);class tX extends QK{constructor(t){super(t||{})}call(t,n){return Ee(()=>{const r=$t(t);return Ao(r,1)})}}tX.className="GlobalMaxPooling1D";Ve(tX);class nX extends qt{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,xr(this.dataFormat),this.inputSpec=[new Wr({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,n){throw new Pt}getConfig(){const t={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(t,n),t}}class rX extends nX{call(t,n){return Ee(()=>{const r=$t(t);return this.dataFormat==="channelsLast"?Nr(r,[1,2]):Nr(r,[2,3])})}}rX.className="GlobalAveragePooling2D";Ve(rX);class sX extends nX{call(t,n){return Ee(()=>{const r=$t(t);return this.dataFormat==="channelsLast"?Ao(r,[1,2]):Ao(r,[2,3])})}}sX.className="GlobalMaxPooling2D";Ve(sX);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class aX extends qt{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(t,n),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,n,r={}){const s=n.layer,a=Cl(s,r);delete n.layer;const i={layer:a};return Object.assign(i,n),new t(i)}}class iX extends aX{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=nn(t),t.length<3)throw new de(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const n=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(n),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=nn(t);const n=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(n),s=t[1];return[r[0],s].concat(r.slice(1))}call(t,n){return Ee(()=>(t=$t(t),mK((i,o)=>[$t(this.layer.call(i,n)),[]],t,[],!1,null,null,!1,!0)[1]))}}iX.className="TimeDistributed";Ve(iX);function Zke(e){xp(ywe,"BidirectionalMergeMode",e)}const Qke="concat";class oX extends aX{constructor(t){super(t);const n=t.layer.getConfig(),r={};r.className=t.layer.getClassName(),r.config=n,this.forwardLayer=Cl(r),n.goBackwards=n.goBackwards!==!0;const s={};if(s.className=t.layer.getClassName(),s.config=n,this.backwardLayer=Cl(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?Qke:t.mergeMode,Zke(this.mergeMode),t.weights)throw new Pt("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const n=t.length,r=Math.floor(n/2);this.forwardLayer.setWeights(t.slice(0,r)),this.backwardLayer.setWeights(t.slice(r))}computeOutputShape(t){let n=this.forwardLayer.computeOutputShape(t);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let r,s,a;return this.returnState&&(a=n.slice(1)),r=n[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,s=[r]):this.mergeMode==null?s=[r,r.slice()]:s=[r],this.returnState?this.mergeMode==null?s.concat(a).concat(a.slice()):[r].concat(a).concat(a.slice()):ha(s)}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});const a=fK(t,r,s,this.numConstants);if(t=a.inputs,r=a.initialState,s=a.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(r==null||r.length===0)&&s==null)return super.apply(t,n);const i=[],o=[];if(r!=null){const u=r.length;if(u%2>0)throw new de("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=r,i.push(...r);const c=r.map(d=>new Wr({shape:d.shape}));this.forwardLayer.stateSpec=c.slice(0,u/2),this.backwardLayer.stateSpec=c.slice(u/2),o.push(...c)}if(s!=null)throw new Pt("Support for constants in Bidirectional layers is not implemented yet.");const l=i[0]instanceof Ol;for(const u of i)if(u instanceof Ol!==l)throw new de("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const u=[t].concat(i),c=this.inputSpec.concat(o),d=this.inputSpec;this.inputSpec=c;const h=super.apply(u,n);return this.inputSpec=d,h}else return super.apply(t,n)}call(t,n){return Ee(()=>{const r=n.initialState;let s,a;if(r==null)s=this.forwardLayer.call(t,n),a=this.backwardLayer.call(t,n);else{const l=r.slice(0,r.length/2),u=r.slice(r.length/2);s=this.forwardLayer.call(t,Object.assign(n,{initialState:l})),a=this.backwardLayer.call(t,Object.assign(n,{initialState:u}))}let i;this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(a.slice(1))),s=s[0],a=a[0]),this.returnSequences&&(a=Mh(a,1));let o;return this.mergeMode==="concat"?o=E3([s,a]):this.mergeMode==="sum"?o=Ge(s,a):this.mergeMode==="ave"?o=me(.5,Ge(s,a)):this.mergeMode==="mul"?o=me(s,a):this.mergeMode==null&&(o=[s,a]),this.returnState?this.mergeMode==null?o.concat(i):[o].concat(i):o})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){fh(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),fh(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,n){Array.isArray(n)&&(n=n[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[n,n]:r=n:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const a=this.forwardLayer.states.map(i=>null);return Array.isArray(r)?r.concat(a).concat(a):[r].concat(a).concat(a)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(t,n),t}static fromConfig(t,n){const r=Cl(n.layer);if(delete n.layer,n.numConstants!=null)throw new Pt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=n;return s.layer=r,new t(s)}}oX.className="Bidirectional";Ve(oX);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class lX extends qt{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return Ee(()=>(t=$t(t),t.dtype!=="float32"&&(t=Sl(t,"float32")),Ge(me(t,this.scale),this.offset)))}}lX.className="Rescaling";Ve(lX);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:e2e,cropAndResize:t2e}=ru;class uX extends qt{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,n,r,s,a,i,o,l){return Ee(()=>{let u,c=!1;const d=n/i,h=r/o,p=(s+n)/i,f=(a+r)/o,m=[d,h,p,f],g=[];t.rank===3?(c=!0,u=fu([t])):u=t;for(let w=0;w<u.shape[0];w++)g.push(m);const y=hh(g,[g.length,4]),b=z1(0,g.length,1,"int32"),v=t2e(u,y,b,[s,a],"nearest");return Sl(c?$t(Ph(v)):v,l)})}upsize(t,n,r,s){return Ee(()=>{const a=e2e(t,[n,r]);return Sl(a,s)})}call(t,n){return Ee(()=>{const r=$t(t),s=r.dtype,a=r.shape,i=a[a.length-3],o=a[a.length-2];let l=0;i!==this.height&&(l=Math.floor((i-this.height)/2));let u=0;return o!==this.width&&(u=Math.floor((o-this.width)/2),u===0&&(u=1)),l>=0&&u>=0?this.centerCrop(r,l,u,this.height,this.width,i,o,s):this.upsize(t,this.height,this.width,s)})}getConfig(){const t={height:this.height,width:this.width},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=nn(t);const n=t.length-3,r=t.length-2;return t[n]=this.height,t[r]=this.width,t}}uX.className="CenterCrop";Ve(uX);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function n2e(e,t,n,r){let s=$t(e);if(s.dtype!=="int32"&&(s=Sl(s,"int32")),t==="int")return s;const a=s.shape;if(s.rank===0&&(s=da(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=da(s,-1)),s.rank>2)throw new de(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);const i=["multiHot","oneHot"].includes(t),o=s;let l;if(typeof r<"u"&&t==="count"?l=fV(o,r,n,i):l=fV(o,[],n,i),t!=="tfIdf")return l;if(r)return me(l,r);throw new de("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cX extends qt{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){return t=nn(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,n){return Ee(()=>{t=$t(t),t.dtype!=="int32"&&(t=Sl(t,"int32"));let r;if(typeof n.countWeights<"u"){if(this.outputMode!=="count")throw new de(`countWeights is not used when outputMode !== count.
              Received countWeights=${n.countWeights}`);r=$t(n.countWeights)}const s=Ao(t),a=mS(t),i=Ti(this.numTokens,s).bufferSync().get(0),o=gp(a,0).bufferSync().get(0);if(!(i&&o))throw new de(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return n2e(t,this.outputMode,this.numTokens,r)})}}cX.className="CategoryEncoding";Ve(cX);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const r2e=["bilinear","nearest"],XV=new Set(r2e);class dX extends qt{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(XV.has(t.interpolation))this.interpolation=t.interpolation;else throw new de(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=nn(t);const n=t[2];return[this.height,this.width,n]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},n=super.getConfig();return Object.assign(t,n),t}call(t,n){return Ee(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return ru.resizeBilinear(t,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return ru.resizeNearestNeighbor(t,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...XV]} are supported`)})}}dX.className="Resizing";Ve(dX);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hX{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}hX.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class pX extends qt{constructor(t){super(t),this.randomGenerator=new hX(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},n=super.getConfig();return Object.assign(t,n),t}}pX.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const s2e=["bilinear","nearest"],YV=new Set(s2e);class fX extends pX{constructor(t){super(t);const{factor:n,interpolation:r="bilinear"}=t;if(this.factor=n,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new de(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new de(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new de(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(YV.has(r))this.interpolation=r;else throw new de(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},n=super.getConfig();return Object.assign(t,n),t}computeOutputShape(t){t=nn(t);const n=t[2];return[this.imgHeight,-1,n]}call(t,n){return Ee(()=>{const r=$t(t);this.imgHeight=r.shape[r.shape.length-3];const s=r.shape[r.shape.length-2];this.widthFactor=Sx([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*s;a=Math.round(a);const i=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return ru.resizeBilinear(t,i);case"nearest":return ru.resizeNearestNeighbor(t,i);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...YV]} are supported`)}})}}fX.className="RandomWidth";Ve(fX);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a2e=_e();a2e.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var JV;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(JV||(JV={}));var ZV;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(ZV||(ZV={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var QV;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(QV||(QV={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&Y(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2e=c9;class vN extends vO{nextDataId(){return vN.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new R8(this,rl())}write(t,n,r){this.firstUse&&(this.firstUse=!1,_e().get("IS_NODE")&&li(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&C0(r[0])){const a=r.map(i=>wc(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,r,s,a){this.data.set(t,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){const s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return mu(s,a)}return hfe(this.data.get(t).values,n)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>Ac(s));return Gt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Gt(t.shape,t.dtype,n)}makeOutput(t,n,r){return rl().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=ca();return t(),{kernelMs:ca()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){ht([t],"where");const n=this.readSync(t.dataId);return i2e(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}vN.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mX(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const o2e=e=>{const{x:t}=e.inputs,n=e.backend;ht(t,"abs");let r=new Float32Array(Me(t.shape));const s=n.data.get(t.dataId).values;return r=mX(s),n.makeOutput(r,t.shape,t.dtype)},l2e={kernelName:JI,backendName:"cpu",kernelFunc:o2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wr(e){return(t,n,r,s,a)=>{const i=Ot(t,n),o=i.length,l=kt(i),u=Me(i),c=Ds(a,u),d=t.length,h=n.length,p=kt(t),f=kt(n),m=Ig(t,i),g=Ig(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){const b=cy(y,o,l),x=b.slice(-d);m.forEach(S=>x[S]=0);const v=xl(x,d,p),w=b.slice(-h);g.forEach(S=>w[S]=0);const k=xl(w,h,f);c[y]=e(r[v],s[k])}return[c,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function La(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}const u2e={kernelName:RO,backendName:"cpu",kernelFunc:La};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(e,t,n="float32"){if(n==="complex64"){const s=AS(e,t,"float32"),a=AS(e,t,"float32");return La({inputs:{real:s,imag:a},backend:e})}const r=Os(Me(t),n);return e.makeTensorInfo(t,n,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fl(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const c2e={kernelName:H0,backendName:"cpu",kernelFunc:Fl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const d2e={kernelName:nF,backendName:"cpu",kernelFunc:zh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(e,t,n,r){if(r==="int32"){const s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){const s=mp([0],n),[a,i]=wr((o,l)=>o!==l?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Mc(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Fl({inputs:{x:s},backend:n});const c=AS(n,s.shape,s.dtype),d=Mc({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),h=La({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),h}if(s.dtype==="complex64"){const c=zh({inputs:{input:s},backend:n}),d=Mc({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),d}if(!F8(s.dtype,a)){const c=Fl({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}const i=n.data.get(s.dataId).values,[o,l,u]=gX(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}const h2e={kernelName:D0,backendName:"cpu",kernelFunc:Mc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yr(e,t,n,r){return n==null?({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;ht([i,o],e);const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=i.dtype==="string"?gu(u):u,h=i.dtype==="string"?gu(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:({inputs:s,backend:a})=>{const{a:i,b:o}=s,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){const u=Mc({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,p=l.data.get(d.dataId).values,f=l.data.get(h.dataId).values,m=Mc({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,v=l.data.get(b.dataId).values,[w,k,S]=n(i.shape,o.shape,p,f,x,v),I=l.makeTensorInfo(S,"float32",w),$=l.makeTensorInfo(S,"float32",k),C=La({inputs:{real:I,imag:$},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo($),C}else{const u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=r||i.dtype,[h,p]=t(i.shape,o.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function K3(e){return(t,n,r,s,a,i)=>{const o=Ot(t,n),l=Me(o),u=o.length,c=kt(o),d=Ds("float32",l),h=Ds("float32",l),p=Ig(t,o),f=Ig(n,o),m=mu(r,s),g=mu(a,i),y=t.length,b=kt(t),x=n.length,v=kt(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){const k=w%m.length,S=w%g.length,I=e(m[k*2],m[k*2+1],g[S*2],g[S*2+1]);d[w]=I.real,h[w]=I.imag}else for(let w=0;w<d.length;w++){const k=cy(w,u,c),S=k.slice(-y);p.forEach(N=>S[N]=0);const I=xl(S,y,b),$=k.slice(-x);f.forEach(N=>$[N]=0);const C=xl($,x,v),T=e(m[I*2],m[I*2+1],g[C*2],g[C*2+1]);d[w]=T.real,h[w]=T.imag}return[d,h,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yX=wr((e,t)=>e+t),p2e=K3((e,t,n,r)=>({real:e+n,imag:t+r})),$g=Yr(dy,yX,p2e),f2e={kernelName:dy,backendName:"cpu",kernelFunc:$g};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X3(e,t,n,r,s){const a=Me(r),i=Os(s,n);for(let o=0;o<e.length;o++){const l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(a>0?i[l]+=t[o]:i[l]+=1)}return i}function bX(e,t,n,r=!1){const s=e.shape[0],a=e.shape[1],i=Gt([s,n],t.dtype);for(let o=0;o<s;o++)for(let l=0;l<a;l++){const u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vX=wr((e,t)=>e&t),m2e=Yr(AO,vX),g2e={kernelName:AO,backendName:"cpu",kernelFunc:m2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zl(e){return(t,n,r)=>{const s=gr(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bn(e,t,n){const r=zl(t);return dd(e,r,n)}function dd(e,t,n){return({inputs:r,attrs:s,backend:a})=>{const{x:i}=r;ht(i,e);const o=a,l=o.data.get(i.dataId).values;let u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=gu(l)}else u=l;const c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xX=zl(e=>Math.ceil(e)),y2e=dd(O0,xX),b2e={kernelName:O0,backendName:"cpu",kernelFunc:y2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wX(e,t,n,r){const s=gr(n,Me(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{const o=Me(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{const o=n==="string"?gu(i.vals):i.vals;let l=0;for(let u=0;u<i.shape[0];++u){const c=u*t[1]+a;for(let d=0;d<i.shape[1];++d)s[c+d]=o[l++]}a+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kX=wr((e,t)=>e===t?1:0),SX=Yr(hC,kX,null,"bool"),v2e={kernelName:hC,backendName:"cpu",kernelFunc:SX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IX=zl(e=>Math.exp(e)),CX=dd(W0,IX,"float32"),x2e={kernelName:W0,backendName:"cpu",kernelFunc:CX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NX=zl(e=>Math.expm1(e)),w2e=dd(V0,NX),k2e={kernelName:V0,backendName:"cpu",kernelFunc:w2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TX=zl(e=>Math.floor(e)),S2e=dd(U0,TX),I2e={kernelName:U0,backendName:"cpu",kernelFunc:S2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $X=wr((e,t)=>Math.floor(e/t)),C2e=Yr(j0,$X,null,"int32"),N2e={kernelName:j0,backendName:"cpu",kernelFunc:C2e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(e,t,n,r,s,a,i,o,l){const u=Gt([r,a],n);for(let c=0;c<r;c++){const d=[];let h=0;for(let p=0;p<s;p++){const f=e[c*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<a;p++)u.values[c*a+p]=t.get(...t.indexToLoc(h*a+p))}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _X(e,t,n){const r=Gt(n,e.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),o=i[0],l=i[2],u=t.locToIndex([o,l]);i[2]=t.values[u];const c=e.locToIndex(i);0<=c&&c<e.values.length&&(r.values[s]=e.values[c])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AX=wr((e,t)=>e>t?1:0),T2e=Yr(gC,AX,null,"bool"),$2e={kernelName:gC,backendName:"cpu",kernelFunc:T2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RX=wr((e,t)=>e>=t?1:0),E2e=Yr(G0,RX,null,"bool"),_2e={kernelName:G0,backendName:"cpu",kernelFunc:E2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DX=wr((e,t)=>e<t?1:0),A2e=Yr(bC,DX,null,"bool"),R2e={kernelName:bC,backendName:"cpu",kernelFunc:A2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OX=wr((e,t)=>e<=t?1:0),D2e=Yr(vC,OX,null,"bool"),O2e={kernelName:vC,backendName:"cpu",kernelFunc:D2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FX(e,t,n){const r=(t-e)/(n-1),s=Os(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MX=zl(e=>Math.log(e)),F2e=dd(Y0,MX),M2e={kernelName:Y0,backendName:"cpu",kernelFunc:F2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(e,t,n,r){const s=Ds(r,Me(n));for(let a=0;a<s.length;++a){const i=a*t;let o=e[i];for(let l=0;l<t;++l){const u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}s[a]=o}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LX=wr((e,t)=>Math.max(e,t)),P2e=Yr(Z0,LX),L2e={kernelName:Z0,backendName:"cpu",kernelFunc:P2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zX=wr((e,t)=>Math.min(e,t)),z2e=Yr(Q0,zX),B2e={kernelName:Q0,backendName:"cpu",kernelFunc:z2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y3=wr((e,t)=>e*t),W2e=K3((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),xN=Yr(tx,Y3,W2e),V2e={kernelName:tx,backendName:"cpu",kernelFunc:xN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BX(e,t,n){const r=rd(-1,n);return Y3([],t,r,e,n)}function U2e(e){const{inputs:t,backend:n}=e,{x:r}=t;ht(r,"neg");const s=n.data.get(r.dataId).values,[a,i]=BX(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}const j2e={kernelName:_C,backendName:"cpu",kernelFunc:U2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WX=wr((e,t)=>e!==t?1:0),G2e=Yr(AC,WX,null,"bool"),H2e={kernelName:AC,backendName:"cpu",kernelFunc:G2e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J3(e,t,n,r,s){const a=t.length,i=Me(t),o=kt(t),l=kt(s),u=Ds(n,Me(s));for(let c=0;c<i;++c){const d=cy(c,a,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];const p=xl(h,a,l);u[p]=e[c]}return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(e){const{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;ht(s,"transpose");const i=s.shape.length,o=new Array(i);for(let d=0;d<o.length;d++)o[d]=s.shape[a[d]];const l=r.data.get(s.dataId).values,u=J3(l,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}const q2e={kernelName:Xm,backendName:"cpu",kernelFunc:xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VX(e,t,n,r){const[s,a]=ps(e,r),i=Xa(t,"int32"),o=Os(Me(s),i),l=Me(a);for(let u=0;u<o.length;++u){const c=u*l;let d=1;for(let h=0;h<l;++h)d*=n[c+h];o[u]=d}return{outVals:o,outShape:s,outDtype:i}}function K2e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ht(s,"prod");const o=s.shape.length,l=Ht(a,s.shape),u=lr(l,o);let c=l,d=s;const h=[];u!=null&&(d=xa({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(d),c=vr(c.length,o));const p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=VX(d.shape,d.dtype,p,c);let y=m;return i&&(y=Ar(m,l)),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}const X2e={kernelName:PC,backendName:"cpu",kernelFunc:K2e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y2e(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){const a=cy(s,t.length,kt(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function J2e(e,t){for(let n=0;n<e.length;++n){const r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function Z2e(e,t,n,r){const s=[];let a=0;const i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);J2e(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const c=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*c)}for(let u=0;u<e.length;++u){let c=e[u],d=e[u]+1;for(let h=0;h<n.length;++h){const p=n[h],f=h+t.length-1;if(f>=0){const m=o[f],g=m[m.length-1]-p[c];for(let y=c;y<d;++y)o[f].push(p[y+1]+g)}c=p[c],d=p[d]}d!==c&&(s.push([c,d]),a+=d-c)}return{outSplits:o,valueSlices:s,numValues:a}}function Q2e(e){const t=[];for(let n=0;n<e.length;++n){const r=e[n].length,s=gr("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function eU(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function eSe(e,t,n,r,s,a){const i=eU(t,2)[1],o=eU(a,2)[1];let l=0;for(const u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*o+d]=e[c*i+d];++l}}function tSe(e,t,n,r,s){const a=t.slice();a[0]=s;const i=gr(n,Me(a)),o=e.length,l=o===0?0:o/t[0];return eSe(e,t,r,l,i,a),[i,a]}function UX(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const l=t[0][0]-1;if(Y2e(a,i,l),r.length===0)throw new Error("params.rank must be nonzero");const u=r[0],{outSplits:c,valueSlices:d,numValues:h}=Z2e(a,i,e,u),p=Q2e(c),f=tSe(n,r,s,d,h);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tU=2147483647;function jX(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const o=t.length===0,l=s.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const d=c.length===0?1:c[0],h=gr("int32",d+1);h[0]=0;for(let g=0;g<d;++g){const y=o?e[0]:e[g],b=l?r[0]:r[g],x=u?a[0]:a[g];if(x===0)throw new Error("Requires delta != 0");let v;if(x>0&&b<y||x<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/x)),v>tU)throw new Error(`Requires ((limit - start) / delta) <= ${tU}`);h[g+1]=h[g]+v}const p=h[d],f=gr(n,p);let m=0;for(let g=0;g<d;++g){const y=h[g+1]-h[g];let b=o?e[0]:e[g];const x=u?a[0]:a[g];for(let v=0;v<y;++v)f[m++]=b,b+=x}return[h,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ai=Io;class RS{constructor(t,n,r,s,a,i,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=A9(c),this.raggedRank=R9(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Ai.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Ai.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Ai.VALUE_ROWIDS:return RS.getMaxWidthValueRowID(n);case Ai.ROW_SPLITS:return RS.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Ai[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){const a=t[s+1]-t[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(t){const n=t.length;if(n===0)return 0;let r=0,s=t[0],a=0;for(let i=1;i<n;++i){const o=t[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return rU(t,r)}calculateOutputSize(t){const n=this.valuesShape,r=this.defaultValueShape;D9(r,n);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=_9(this.raggedRank,s,n);i[0]<0&&(i[0]=t);for(let o=1;o<=this.raggedRank;++o)i[o]<0&&(i[o]=this.getMaxWidth(o));return i}calculateFirstParentOutputIndex(t,n,r){const s=Math.min(t,r),a=[];let i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<t;++o)a.push(-1);return Y(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,r,s){const a=t.length,i=[];for(let o=0;o<a-1;++o){const l=t[o+1]-t[o];let u=Math.min(s,l),c=n[o];c===-1&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,s){const a=t.length,i=[];if(a===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<a;++c){const d=t[c];if(d===l)u>=0&&(++o,o<s?u+=r:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,s){const a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Ai.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case Ai.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${Ai[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case Ai.FIRST_DIM_SIZE:return t[0];case Ai.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Ai.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Ai[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let l=s.length-2;l>=0;--l)s[l]=s[l+1]*r[l+1];const a=rU(r,!1),i=gr(this.valuesDType,Me(a));if(s[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,s[0],r[0]);for(let u=1;u<=this.raggedRank;++u)l=this.calculateOutputIndex(u-1,l,s[u],r[u]);this.setOutput(this.raggedRank,l,i,a)}return[a,i]}setOutput(t,n,r,s){if(r.length===0)return;const a=this.values,i=r;let o=s.slice();o=o.slice(t+1);const l=Me(o),u=n.length;let c=this.defaultValue;if(c.length!==l&&c.length!==1){const f=this.defaultValueShape;Ee(()=>{const m=we(c,f);c=a1(m,o).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let m=f<u?n[f]:-1;if(m===p){++p;continue}if(h<p){const g=a.subarray(d*l),y=i.subarray(h*l),b=(p-h)*l;nU(y,g,b)}if(f>=u){const g=r.length;m=Math.floor(g/l)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){const g=i.slice(p*l);nU(g,c,l),++p}m<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}}function nU(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function rU(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function GX(e,t,n,r,s,a,i,o,l,u){return new RS(e,t,n,r,s,a,i,o,l,u).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HX(e,t,n,r){const s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return Os(0,r);const o=Math.abs(Math.ceil((t-e)/n)),l=Os(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qX=zl(e=>1/Math.sqrt(e)),nSe=dd(ox,qX),rSe={kernelName:ox,backendName:"cpu",kernelFunc:nSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sh(e,t,n,r,s,a,i,o,l,u){const c=[r/s,s],d=e.values,h=t.values;if(r===0)return Gt(n,t.dtype);const p=l instanceof Ss?l:Gt(c,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<a;f++){const m=[];let g=0;for(let y=0;y<i;y++){const b=d[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<s;y++)u?p.values[g*s+y]+=h[f*s+y]:p.values[g*s+y]=t.rank===0?h[0]:h[f*s+y]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sSe=zl(e=>1/(1+Math.exp(-e))),KX=bn(hx,e=>1/(1+Math.exp(-e))),aSe={kernelName:hx,backendName:"cpu",kernelFunc:KX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XX(e,t,n,r,s){const a=s3(r,t,n),i=Me(n),o=kt(r);if(a){const d=a3(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}const l=s==="string"?gu(e):e,u=Gt(r,s,l),c=Gt(n,s);for(let d=0;d<c.size;++d){const h=c.indexToLoc(d),p=h.map((f,m)=>f+t[m]);c.set(u.get(...p),...h)}return s==="string"?Q9(c.values):c.values}function Bh(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;ht(s,"slice");const[o,l]=aN(s,a,i);n3(s,o,l);const u=n.data.get(s.dataId).values,c=XX(u,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}const iSe={kernelName:UC,backendName:"cpu",kernelFunc:Bh};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YX(e,t,n,r,s,a,i){const o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(B9(o));const g=gr(n,0),y=gr(s,0);return[g,[0,d],y,u,c]}let h=!0,p=0;const f=new Array(l).fill(0);for(let g=0;g<o;++g){const y=e[g*d];if(y<0)throw new Error(W9(g,y));if(y>=l)throw new Error(V9(g,y,l));++f[y],h=h&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){const y=f[g]===0;u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){const g=e,y=r;for(let b=0;b<o;++b)c[b]=b;return[g,[o,d],y,u,c]}else{const g=f[l-1],y=gr(n,g*d),b=gr(s,g),x=new Array(l).fill(0);for(let v=0;v<o;++v){const w=e[v*d],k=x[w],S=(w===0?0:f[w-1])+k;x[w]++;for(let I=0;I<d;++I)y[S*d+I]=e[v*d+I];b[S]=r[v],c[v]=S}for(let v=0;v<l;++v)if(x[v]===0){const k=v===0?0:f[v-1];y[k*d+0]=v;for(let S=1;S<d;++S)y[k*d+S]=0;b[k]=i}return[y,[g,d],b,u,c]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JX(e,t,n,r,s){const a=Me(r),i=t[0],o=s.length,l=[];let u=1,c=-1;for(let g=0;g<o;++g){const y=s[g];if(y===-1){if(c!==-1)throw new Error(U9(c,g));c=g,l.push(1)}else{if(y<0)throw new Error(j9(g,y));u*=y,l.push(y)}}if(c!==-1){if(u<=0)throw new Error(G9());const g=Math.trunc(a/u);if(u*g!==a)throw new Error(H9(r,l));l[c]=g}if(Me(l)!==a)throw new Error(q9(r,l));const h=r.length,p=[];if(h>0){p[h-1]=1;for(let g=h-2;g>=0;--g)p[g]=p[g+1]*r[g+1]}const f=[];if(o>0){f[o-1]=1;for(let g=o-2;g>=0;--g)f[g]=f[g+1]*l[g+1]}const m=gr(n,i*o);for(let g=0;g<i;++g){let y=0;for(let b=0;b<h;++b)y+=e[g*h+b]*p[b];for(let b=0;b<o;++b)m[g*o+b]=Math.trunc(y/f[b]),y%=f[b]}return[m,[i,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3(e,t,n,r,s,a=!1,i=0){const o=r.length,l=[t[0],e.length/t[0]],u=l[1],d=o>0?s[o-1]+1:0;if(d<0)throw new Error(EA());const h=t.slice();h[0]=d;const p=h.reduce((x,v)=>x*v,1),f=gr(n,p);if(o===0)return d>0&&f.fill(i),[f,h];if(d<=0)throw new Error(EA());let m=0,g=1,y=0,b=s[m];for(;;){let x=0;if(g<o){if(x=s[g],b===x){++g;continue}if(b>=x)throw new Error(K9())}if(b<0||b>=d)throw new Error(X9(b,d));b>y&&f.fill(i,y*u,b*u);for(let v=m;v<g;++v){const w=r[v];if(w<0||w>=l[0])throw new Error(Y9(v,r[v],l[0]));for(let k=0;k<u;k++)f[b*u+k]+=e[w*u+k]}if(a)for(let v=0;v<u;v++)f[b*u+v]/=g-m;if(m=g,++g,y=b+1,b=x,g>o)break}return y<d&&f.fill(i,y*u,d*u),[f,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oSe=zl(e=>Math.sqrt(e)),lSe=bn(fx,e=>Math.sqrt(e)),uSe={kernelName:fx,backendName:"cpu",kernelFunc:lSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZX=wr((e,t)=>{const n=e-t;return n*n}),cSe=Yr(mx,ZX),dSe={kernelName:mx,backendName:"cpu",kernelFunc:cSe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QX=zl((e,t)=>{const{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),hSe=dd(iF,QX),pSe={kernelName:iF,backendName:"cpu",kernelFunc:hSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eY(e,t,n,r){const s=Gt(e,t.dtype);for(let a=0;a<s.size;a++){const i=s.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];s.set(t.get(...o),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fSe{constructor(t,n,r,s,a,i){this.separator=wc(t),this.nGramWidths=n,this.leftPad=wc(r),this.rightPad=wc(s),this.padWidth=a,this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const r=this.getPadWidth(n);return Math.max(0,t+2*r-n+1)}createNGrams(t,n,r,s,a,i){for(let o=0;o<a;++o){const l=this.getPadWidth(i),u=Math.max(0,l-o),c=Math.max(0,l-(a-(o+1))),d=i-(u+c),h=n+(u>0?0:o-l);let p=0;p+=u*this.leftPad.length;for(let b=0;b<d;++b)p+=t[h+b].length;p+=c*this.rightPad.length;const f=u+c+d-1;p+=f*this.separator.length,r[s+o]=new Uint8Array(p);const m=r[s+o];let g=0;const y=b=>b.forEach(x=>m[g++]=x);for(let b=0;b<u;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(t[h+b]),y(this.separator);if(d>0){y(t[h+d-1]);for(let b=0;b<c;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<c-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(t,n){const r=t.length,s=n.length;if(s>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let u=1;u<s;++u){let c=n[u]>=l;if(c=c&&n[u]<=r,!c)throw new Error(`Invalid split value ${n[u]}, must be in [${l}, ${r}]`);l=n[u]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const a=s-1,i=gr("int32",s);if(r===0||s===0){const l=new Array(r);for(let u=0;u<=a;++u)i[u]=0;return[l,i]}i[0]=0;for(let l=1;l<=a;++l){const u=n[l]-n[l-1];let c=0;this.nGramWidths.forEach(d=>{c+=this.getNumNGrams(u,d)}),this.preserveShort&&u>0&&c===0&&(c=1),i[l]=i[l-1]+c}const o=new Array(i[a]);for(let l=0;l<a;++l){const u=n[l];let c=i[l];if(this.nGramWidths.forEach(d=>{const h=n[l+1]-n[l],p=this.getNumNGrams(h,d);this.createNGrams(t,u,o,c,p,d),c+=p}),this.preserveShort&&c===i[l]){const d=n[l+1]-n[l];if(d===0)continue;const h=d+2*this.padWidth,p=1;this.createNGrams(t,u,o,c,p,h)}}return[o,i]}}function tY(e,t,n,r,s,a,i,o){return new fSe(n,r,s,a,i,o).compute(e,t)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mSe(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){const a=t[0];let i=e.indexOf(a);for(;i!==-1;){const o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){const i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function nY(e,t,n){const r=e.length,s=[];let a=0,i=0;const o=new Array(r);for(let h=0;h<r;++h){const p=s.length;mSe(e[h],t,n,s);const f=s.length-p;o[h]=f,a+=f,i=Math.max(i,f)}const l=gr("int32",a*2),u=new Array(a),c=[r,i];let d=0;for(let h=0;h<r;++h)for(let p=0;p<o[h];++p)l[d*2]=h,l[d*2+1]=p,u[d]=s[d],++d;return[l,u,c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rY(e,t){const n=gr("int32",e.length);for(let r=0;r<e.length;++r)n[r]=Afe(e[r]).modulo(t).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sY=wr((e,t)=>e-t),gSe=K3((e,t,n,r)=>({real:e-n,imag:t-r})),Q3=Yr(gx,sY,gSe),ySe={kernelName:gx,backendName:"cpu",kernelFunc:Q3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aY(e,t){const n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];const r=Gt(n,e.dtype);for(let s=0;s<r.values.length;++s){const a=r.indexToLoc(s),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%e.shape[l];const o=e.locToIndex(i);r.values[s]=e.values[o]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mv=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function iY(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){const o=r-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),h=Math.max(n,Math.floor(t-l*c/o+d)),p=Math.min(r,Math.floor(t+(o-l)*c/o+d));iY(e,t,h,p)}const s=e[t];let a=n,i=r;for(vm(e,n,t),Mv(e[r],s)>0&&vm(e,n,r);a<i;){for(vm(e,a,i),a++,i--;Mv(e[a],s)<0;)a=a+1;for(;Mv(e[i],s)>0;)i=i-1}Mv(e[n],s)===0?vm(e,n,i):(i=i+1,vm(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function oY(e,t,n,r,s){const a=t[t.length-1],[i,o]=[e.length/a,a],l=Ds(n,i*r),u=Ds("int32",i*r);for(let d=0;d<i;d++){const h=d*o,p=e.subarray(h,h+o);let f=new Array(p.length);p.forEach((b,x)=>f[x]={value:b,index:x}),r<f.length&&(iY(f,r),f=f.slice(0,r)),s&&f.sort(Mv);const m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}const c=t.slice();return c[c.length-1]=r,[Gt(c,n,l),Gt(c,"int32",u)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lY(e,t,n,r){const s=Ht(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];const i=new Map,o=new Int32Array(n[s]),l=new Ss(a,r,e),u=[],c=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(c)m=e[f].toString();else{const y=[];for(let b=0;b<a[0];b++)for(let x=0;x<a[2];x++)y.push(l.get(b,f,x));m=y.join(",")}const g=i.get(m);if(g!=null)o[f]=g;else{const y=i.size;i.set(m,y),o[f]=y,u.push(f)}}const d=a.slice();d[1]=i.size;const h=new Ss(d,r);u.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let y=0;y<a[2];y++)h.set(l.get(g,f,y),g,m,y)});const p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bSe=Object.freeze(Object.defineProperty({__proto__:null,addImpl:yX,bincountImpl:X3,bincountReduceImpl:bX,bitwiseAndImpl:vX,castImpl:gX,ceilImpl:xX,concatImpl:wX,equalImpl:kX,expImpl:IX,expm1Impl:NX,floorDivImpl:$X,floorImpl:TX,gatherNdImpl:EX,gatherV2Impl:_X,greaterEqualImpl:RX,greaterImpl:AX,lessEqualImpl:OX,lessImpl:DX,linSpaceImpl:FX,logImpl:MX,maxImpl:PX,maximumImpl:LX,minimumImpl:zX,multiplyImpl:Y3,negImpl:BX,notEqualImpl:WX,prodImpl:VX,raggedGatherImpl:UX,raggedRangeImpl:jX,raggedTensorToTensorImpl:GX,rangeImpl:HX,rsqrtImpl:qX,scatterImpl:sh,sigmoidImpl:sSe,simpleAbsImpl:mX,sliceImpl:XX,sparseFillEmptyRowsImpl:YX,sparseReshapeImpl:JX,sparseSegmentReductionImpl:Z3,sqrtImpl:oSe,squaredDifferenceImpl:ZX,staticRegexReplaceImpl:QX,stridedSliceImpl:eY,stringNGramsImpl:tY,stringSplitImpl:nY,stringToHashBucketFastImpl:rY,subImpl:sY,tileImpl:aY,topKImpl:oY,transposeImpl:J3,uniqueImpl:lY},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */$q("cpu",()=>new vN,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uY=bn(z0,e=>e>=0?e:Math.exp(e)-1),vSe={kernelName:z0,backendName:"cpu",kernelFunc:uY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;ht([s],"leakyRelu");const i=Me(s.shape),o=n.data.get(s.dataId).values,l=Ds("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}const xSe={kernelName:yC,backendName:"cpu",kernelFunc:cY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wSe=wr((e,t)=>e<0?t*e:e);function dY(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t;ht([r,s],"prelu");const a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=wSe(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}const kSe={kernelName:MC,backendName:"cpu",kernelFunc:dY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hY=bn(sx,e=>Math.max(0,e)),SSe={kernelName:sx,backendName:"cpu",kernelFunc:hY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pY=bn(ax,e=>Math.min(Math.max(0,e),6)),ISe={kernelName:ax,backendName:"cpu",kernelFunc:pY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DS(e,t,n,r,s){if(n==="linear")return Fl({inputs:{x:t},backend:e});if(n==="relu")return hY({inputs:{x:t},backend:e});if(n==="elu")return uY({inputs:{x:t},backend:e});if(n==="relu6")return pY({inputs:{x:t},backend:e});if(n==="prelu")return dY({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return cY({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return KX({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mn(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=Me(s.shape),o=O8(a,i),l=Me(o);Y(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);const u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){const c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}const CSe={kernelName:LC,backendName:"cpu",kernelFunc:Mn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fY(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;ht([s,a],"matMul");const l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=Me(f),y=Me(m),x=Ot(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);Y(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);const v=i?[g,c,h]:[g,h,c],w=o?[y,p,d]:[y,d,p],k=Mn({inputs:{x:s},backend:n,attrs:{shape:v}}),S=Mn({inputs:{x:a},backend:n,attrs:{shape:w}}),I=i?k.shape[1]:k.shape[2],$=i?k.shape[2]:k.shape[1],C=o?S.shape[1]:S.shape[2],T=Math.max(g,y),N=n.data.get(k.dataId).values,E=n.data.get(S.dataId).values,_=kt(k.shape),R=kt(S.shape),[z,W,F]=i?[_[0],1,_[1]]:[_[0],_[1],1],[L,O,D]=o?[1,R[1],R[0]]:[R[1],1,R[0]],B=$*C,V=Gt([T,$,C],k.dtype),K=V.values,G=n.blockSize;for(let U=0;U<T;U++){const q=U%g,Q=U%y;for(let ee=0;ee<$;ee+=G){const ae=Math.min(ee+G,$);for(let ye=0;ye<C;ye+=G){const j=Math.min(ye+G,C);for(let ce=0;ce<I;ce+=G){const be=Math.min(ce+G,I);for(let ke=ee;ke<ae;ke++)for(let Ae=ye;Ae<j;Ae++){let Pe=0;for(let ie=ce;ie<be;ie++){const Te=N[q*z+ke*W+ie*F],Le=E[ie*L+Ae*O+Q*D];Pe+=Te*Le}K[U*B+(ke*C+Ae)]+=Pe}}}}}return n.disposeIntermediateTensorInfo(k),n.disposeIntermediateTensorInfo(S),n.makeTensorInfo(x,V.dtype,V.values)}const NSe={kernelName:nC,backendName:"cpu",kernelFunc:fY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TSe(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;let h,p,f;const m=[];h=fY({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=$g({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=DS(n,h,c,o,d),m.push(h),h=f);for(const y of m)n.disposeIntermediateTensorInfo(y);return h}const $Se={kernelName:uS,backendName:"cpu",kernelFunc:TSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ESe=bn(N0,e=>Math.acos(e)),_Se={kernelName:N0,backendName:"cpu",kernelFunc:ESe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ASe=bn(T0,e=>Math.acosh(e)),RSe={kernelName:T0,backendName:"cpu",kernelFunc:ASe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DSe(e){const{inputs:t,backend:n}=e,r=t;ht(t,"addN");const s=r.map(o=>n.data.get(o.dataId).values),a=Gt(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){const l=s[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}const OSe={kernelName:CO,backendName:"cpu",kernelFunc:DSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ht(s,"all");const o=Ht(a,s.shape);let l=o;const u=lr(l,s.shape.length);let c=s;u!=null&&(c=xa({inputs:{x:s},backend:n,attrs:{perm:u}}),l=vr(l.length,s.shape.length)),Ns("all",l,c.shape.length);const[d,h]=ps(c.shape,l),p=Me(h),f=Os(Me(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let x=m[b];for(let v=0;v<p;++v){const w=m[b+v];x=x&&w}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=Ar(d,o),b=Mn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const MSe={kernelName:NO,backendName:"cpu",kernelFunc:FSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ht(s,"any");const o=Ht(a,s.shape);let l=o;const u=lr(l,s.shape.length);let c=s;u!=null&&(c=xa({inputs:{x:s},backend:n,attrs:{perm:u}}),l=vr(l.length,s.shape.length)),Ns("any",l,c.shape.length);const[d,h]=ps(c.shape,l),p=Me(h),f=Os(Me(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let x=m[b];for(let v=0;v<p;++v){const w=m[b+v];x=x||w}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=Ar(d,o),b=Mn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const LSe={kernelName:TO,backendName:"cpu",kernelFunc:PSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;ht(s,"argMax");let i=Ht(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=xa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=vr(i.length,l.shape.length)),i=[i[0]],Ns("argMax",i,l.shape.length);const[c,d]=ps(l.shape,i),h=Me(c),p=Os(h,"int32"),f=Me(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],x=0;for(let v=0;v<f;++v){const w=m[y+v];w>b&&(b=w,x=v)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}const BSe={kernelName:ZI,backendName:"cpu",kernelFunc:zSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WSe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;ht(s,"argMin");let i=Ht(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=xa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=vr(i.length,l.shape.length)),i=[i[0]],Ns("argMin",i,l.shape.length);const[c,d]=ps(l.shape,i),h=Me(c),p=Os(h,"int32"),f=Me(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){const y=g*f;let b=m[y],x=0;for(let v=0;v<f;++v){const w=m[y+v];w<b&&(b=w,x=v)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}const VSe={kernelName:QI,backendName:"cpu",kernelFunc:WSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const USe=bn($0,e=>Math.asin(e)),jSe={kernelName:$0,backendName:"cpu",kernelFunc:USe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GSe=bn(E0,e=>Math.asinh(e)),HSe={kernelName:E0,backendName:"cpu",kernelFunc:GSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qSe=bn(_0,e=>Math.atan(e)),KSe={kernelName:_0,backendName:"cpu",kernelFunc:qSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XSe=wr((e,t)=>Math.atan2(e,t)),YSe=Yr(R0,XSe),JSe={kernelName:R0,backendName:"cpu",kernelFunc:YSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZSe=bn(A0,e=>Math.atanh(e)),QSe={kernelName:A0,backendName:"cpu",kernelFunc:ZSe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eM(e,t,n,r,s,a){const i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=Gt(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let v=0;v<s.batchSize;++v){const w=v*y,k=v*r[0];for(let S=0;S<s.inChannels;++S)for(let I=0;I<s.outHeight;++I){const $=I*i-h,C=Math.max(0,$),T=Math.min(s.inHeight,c+$),N=w+I*b;for(let E=0;E<s.outWidth;++E){const _=E*o-p,R=Math.max(0,_),z=Math.min(s.inWidth,d+_);let W=f,F=0,L=0;for(let D=C;D<T;D+=l){const B=k+D*r[1];for(let V=R;V<z;V+=u){const K=B+V*r[2],G=e[K+S];a==="max"&&G>W?W=G:a==="avg"&&(F+=G,L++)}if(isNaN(W))break}const O=N+E*x+S;g[O]=a==="avg"?F/L:W}}}return m}function mY(e,t,n,r,s=!1,a=!1){const i=Gt(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=Gt(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){const x=b*o-p;let v=x;for(;v<0;)v+=u;const w=Math.min(r.inHeight,d+x);for(let k=0;k<r.outWidth;++k){const S=k*l-f;let I=S;for(;I<0;)I+=c;const $=Math.min(r.inWidth,h+S);let C=Number.NEGATIVE_INFINITY,T=-1;for(let N=v;N<w;N+=u){const E=N-x;for(let _=I;_<$;_+=c){const R=_-S,z=m.get(g,N,_,y);z>C&&(C=z,s?T=a?((g*r.inHeight+N)*r.inWidth+_)*r.inChannels+y:(N*r.inWidth+_)*r.inChannels+y:T=E*h+R)}}i.set(T,g,b,k,y)}}return i}function gY(e,t,n,r,s,a){const i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Gt(s.outShape,n),v=x.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let $=0;$<s.batchSize;++$){const C=$*w,T=$*r[0];for(let N=0;N<s.inChannels;++N)for(let E=0;E<s.outDepth;++E){const _=E*i-m;let R=_;for(;R<0;)R+=u;const z=Math.min(s.inDepth,h+_),W=C+E*k;for(let F=0;F<s.outHeight;++F){const L=F*o-g;let O=L;for(;O<0;)O+=c;const D=Math.min(s.inHeight,p+L),B=W+F*S;for(let V=0;V<s.outWidth;++V){const K=V*l-y;let G=K;for(;G<0;)G+=d;const U=Math.min(s.inWidth,f+K),q=B+V*I;let Q=b,ee=0,ae=0;for(let j=R;j<z;j+=u){const ce=T+j*r[1];for(let be=O;be<D;be+=c){const ke=ce+be*r[2];for(let Ae=G;Ae<U;Ae+=d){const Pe=ke+Ae*r[3],ie=e[Pe+N];if(a==="max"&&ie>Q?Q=ie:a==="avg"&&(ee+=ie,ae++),isNaN(Q))break}if(isNaN(Q))break}if(isNaN(Q))break}const ye=q+N;v[ye]=a==="avg"?ee/Math.max(ae,1):Q}}}}return x}function eIe(e,t){const n=Gt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*r-h;let x=b;for(;x<0;)x+=i;const v=Math.min(t.inDepth,u+b);for(let w=0;w<t.outHeight;++w){const k=w*s-p;let S=k;for(;S<0;)S+=o;const I=Math.min(t.inHeight,c+k);for(let $=0;$<t.outWidth;++$){const C=$*a-f;let T=C;for(;T<0;)T+=l;const N=Math.min(t.inWidth,d+C);let E=Number.NEGATIVE_INFINITY,_=-1;for(let R=x;R<v;R+=i){const z=R-b;for(let W=S;W<I;W+=o){const F=W-k;for(let L=T;L<N;L+=l){const O=L-C,D=e.get(m,R,W,L,g);D>=E&&(E=D,_=z*c*d+F*c+O)}}}n.set(_,m,y,w,$,g)}}}return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;ht(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(Ps(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=no(s.shape,a,i,u,o,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&cn(c.inShape,c.outShape))d=Fl({inputs:{x:s},backend:n});else{const h=n.data.get(s.dataId).values,p=kt(s.shape),f=eM(h,s.shape,s.dtype,p,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}const nIe={kernelName:eC,backendName:"cpu",kernelFunc:tIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;ht(s,"avgPool3d");const c=Iu(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=gY(d,s.shape,s.dtype,kt(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}const sIe={kernelName:tC,backendName:"cpu",kernelFunc:rIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;ht([s,a],"avgPool3DGrad");const c=Iu(a.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=v-1-c.padInfo.front,I=k-1-c.padInfo.left,$=w-1-c.padInfo.top,C=Gt(a.shape,"float32"),T=1/(f*m*g),N=n.bufferSync(s);for(let E=0;E<c.batchSize;++E)for(let _=0;_<c.inChannels;++_)for(let R=0;R<c.inDepth;++R)for(let z=0;z<c.inHeight;++z)for(let W=0;W<c.inWidth;++W){const F=R-S,L=z-$,O=W-I;let D=0;for(let B=0;B<v;B+=y){const V=(F+B)/d;if(!(V<0||V>=c.outDepth||Math.floor(V)!==V))for(let K=0;K<w;K+=b){const G=(L+K)/h;if(!(G<0||G>=c.outHeight||Math.floor(G)!==G))for(let U=0;U<k;U+=x){const q=(O+U)/p;if(q<0||q>=c.outWidth||Math.floor(q)!==q)continue;const Q=N.get(E,V,G,q,_);D+=Q}}}C.set(D*T,E,R,z,W,_)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}const iIe={kernelName:EO,backendName:"cpu",kernelFunc:aIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;ht([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=no(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,x=b-1-c.padInfo.left,v=y-1-c.padInfo.top,w=Gt(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,I=Gt(s.shape,"float32",S);for(let $=0;$<c.batchSize;++$)for(let C=0;C<c.inChannels;++C)for(let T=0;T<c.inHeight;++T)for(let N=0;N<c.inWidth;++N){const E=T-v,_=N-x;let R=0;for(let z=0;z<y;z+=m){const W=(E+z)/d;if(!(W<0||W>=c.outHeight||Math.floor(W)!==W))for(let F=0;F<b;F+=g){const L=(_+F)/h;if(L<0||L>=c.outWidth||Math.floor(L)!==L)continue;const O=I.get($,W,L,C);R+=O}}w.set(R*k,$,T,N,C)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const lIe={kernelName:$O,backendName:"cpu",kernelFunc:oIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;Y(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ht([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);const c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,x=d.length;let v=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[v++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),v>=g&&(v=0),w>=x&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}const cIe={kernelName:fC,backendName:"cpu",kernelFunc:uIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;ht([s],"batchToSpaceND");const o=a.reduce((y,b)=>y*b),l=Nx(s.shape,a,o),u=Tx(l.length,a.length),c=$x(s.shape,a,o),d=c3(i,a.length),h=d3(c,i,a.length),p=Mn({inputs:{x:s},backend:n,attrs:{shape:l}}),f=xa({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Mn({inputs:{x:f},backend:n,attrs:{shape:c}}),g=Bh({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const hIe={kernelName:rC,backendName:"cpu",kernelFunc:dIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=X3(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const fIe={kernelName:_O,backendName:"cpu",kernelFunc:pIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mIe(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=Ot(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const gIe={kernelName:B8,backendName:"cpu",kernelFunc:mIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yIe=bn(F0,(e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),bIe={kernelName:F0,backendName:"cpu",kernelFunc:yIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vIe=e=>{const{x:t}=e.inputs,n=e.backend,r=new Float32Array(Me(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){const c=o[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,t.shape,"float32")},xIe={kernelName:sC,backendName:"cpu",kernelFunc:vIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eg(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}const wIe={kernelName:KO,backendName:"cpu",kernelFunc:Eg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _g(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Ht(s,t[0].shape)[0],i=t.map(m=>m.shape);o3(i,a);let o=kl(t.map(m=>m.shape),a);if(Me(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(m=>Me(m.shape)>0);if(l.length===1)return Fl({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){const m=l.map(v=>zh({inputs:{input:v},backend:n})),g=l.map(v=>Eg({inputs:{input:v},backend:n})),y=_g({inputs:m,backend:n,attrs:{axis:a}}),b=_g({inputs:g,backend:n,attrs:{axis:a}}),x=La({inputs:{real:y,imag:b},backend:n});return m.forEach(v=>n.disposeIntermediateTensorInfo(v)),g.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}const u=l.map(m=>{const y=[-1,Me(m.shape.slice(a))];return Mn({inputs:{x:m},backend:n,attrs:{shape:y}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=kl(u.map(m=>m.shape),1);const d=u[0].shape[0]===1,h=wX(c,o,t[0].dtype,d),p=kl(l.map(m=>m.shape),a),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const kIe={kernelName:aC,backendName:"cpu",kernelFunc:_g};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;ht([s,a],"conv2d");const d=Cu(l),h=Cs(s.shape,a.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,x=h.dataFormat==="channelsLast",v=new Ss(h.outShape,s.dtype),w=kt(s.shape),k=kt(a.shape),S=w[0],I=x?w[1]:w[2],$=x?w[2]:1,C=x?1:w[1],T=v.strides[0],N=x?v.strides[1]:v.strides[2],E=x?v.strides[2]:1,_=x?1:v.strides[1],R=n.data.get(s.dataId).values,z=n.data.get(a.dataId).values,W=v.values;for(let F=0;F<h.batchSize;++F){const L=F*S,O=F*T;for(let D=0;D<h.outHeight;++D){const B=O+D*N,V=D*h.strideHeight-b;for(let K=0;K<p;++K){const G=V+K*m;if(G<0||G>=h.inHeight)continue;const U=K*k[0],q=L+G*I;for(let Q=0;Q<h.outWidth;++Q){const ee=B+Q*E,ae=Q*h.strideWidth-y;for(let ye=0;ye<f;++ye){const j=ae+ye*g;if(j<0||j>=h.inWidth)continue;const ce=U+ye*k[1],be=q+j*$;let ke=ce;for(let Ae=0;Ae<h.inChannels;++Ae){const Pe=R[be+Ae*C];for(let ie=0;ie<h.outChannels;++ie)W[ee+ie*_]+=Pe*z[ke+ie];ke+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,W)}const SIe={kernelName:iC,backendName:"cpu",kernelFunc:yY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;ht([s,a],"conv2dBackpropFilter");const d=Cu(l),h=Cs(s.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=h.dataFormat==="channelsLast",b=new Ss(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=new Ss(s.shape,s.dtype,w),I=new Ss(a.shape,a.dtype,k);for(let $=0;$<m;++$){const C=Math.max(0,Math.ceil((v-$)/p)),T=Math.min(h.outHeight,(h.inHeight+v-$)/p);for(let N=0;N<g;++N){const E=Math.max(0,Math.ceil((x-N)/f)),_=Math.min(h.outWidth,(h.inWidth+x-N)/f);for(let R=0;R<h.inChannels;++R)for(let z=0;z<h.outChannels;++z){let W=0;for(let F=0;F<h.batchSize;++F)for(let L=C;L<T;++L){const O=$+L*p-v;for(let D=E;D<_;++D){const B=N+D*f-x;y?W+=S.get(F,O,B,R)*I.get(F,L,D,z):W+=S.get(F,R,O,B)*I.get(F,z,L,D)}}b.set(W,$,N,R,z)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const CIe={kernelName:DO,backendName:"cpu",kernelFunc:IIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;ht([s,a],"conv2dBackpropInput");const d=kt(a.shape),h=kt(s.shape);let p=Cu(u);const f=Cs(i,a.shape,o,1,l,c,!1,p),m=new Ss(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[x,v,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:$,inHeight:C,inWidth:T,outChannels:N,outHeight:E,outWidth:_,strideHeight:R,strideWidth:z}=f;p=f.dataFormat;const W=S-1-f.padInfo.top,F=I-1-f.padInfo.left,L=p==="channelsLast",O=m.strides[0],D=L?m.strides[1]:m.strides[2],B=L?m.strides[2]:1,V=L?1:m.strides[1],K=h[0],G=L?h[1]:h[2],U=L?h[2]:1,q=L?1:h[1];for(let Q=0;Q<k;++Q)for(let ee=0;ee<$;++ee)for(let ae=0;ae<C;++ae){const ye=ae-W,j=Math.max(0,Math.ceil(ye/R)),ce=Math.min(E,(S+ye)/R);for(let be=0;be<T;++be){const ke=be-F,Ae=Math.max(0,Math.ceil(ke/z)),Pe=Math.min(_,(I+ke)/z);let ie=0;for(let Le=j;Le<ce;++Le){const $e=Le*R-ye;for(let ge=Ae;ge<Pe;++ge){const ve=ge*z-ke,pe=K*Q+G*Le+U*ge,Ie=x*(S-1-$e)+v*(I-1-ve)+w*ee;for(let ze=0;ze<N;++ze){const Ye=y[pe+q*ze],Je=b[Ie+ze];ie+=Ye*Je}}}const Te=O*Q+D*ae+B*be+V*ee;g[Te]=ie}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const TIe={kernelName:oC,backendName:"cpu",kernelFunc:NIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ie(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;ht([s,a],"conv3d");const u=ad(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,v=new Ss(u.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=v.values,I=kt(s.shape),$=kt(a.shape);for(let C=0;C<u.batchSize;++C){const T=C*I[0],N=C*v.strides[0];for(let E=0;E<u.outDepth;++E){const _=N+E*v.strides[1],R=E*u.strideDepth-y;for(let z=0;z<c;++z){const W=R+z*p;if(W<0||W>=u.inDepth)continue;const F=z*$[0],L=T+W*I[1];for(let O=0;O<u.outHeight;++O){const D=_+O*v.strides[2],B=O*u.strideHeight-x;for(let V=0;V<d;++V){const K=B+V*f;if(K<0||K>=u.inHeight)continue;const G=F+V*$[1],U=L+K*I[2];for(let q=0;q<u.outWidth;++q){const Q=D+q*u.outChannels,ee=q*u.strideWidth-b;for(let ae=0;ae<h;++ae){const ye=ee+ae*m;if(ye<0||ye>=u.inWidth)continue;const j=G+ae*$[2],ce=U+ye*u.inChannels;let be=j;for(let ke=0;ke<u.inChannels;++ke){const Ae=w[ce+ke];for(let Pe=0;Pe<u.outChannels;++Pe)S[Q+Pe]+=Ae*k[be+Pe];be+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}const EIe={kernelName:lC,backendName:"cpu",kernelFunc:$Ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Ie(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;ht([s,a],"conv3dBackpropFilterV2");const u=kt(s.shape),c=kt(a.shape),d=ad(s.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Ss(d.filterShape,"float32"),x=b.values,[v,w,k,S]=b.strides,I=n.data.get(a.dataId).values,[$,C,T,N]=c,E=n.data.get(s.dataId).values,[_,R,z,W]=u,F=d.padInfo.front,L=d.padInfo.left,O=d.padInfo.top;for(let D=0;D<m;++D){const B=Math.max(0,Math.ceil((F-D)/h)),V=Math.min(d.outDepth,(d.inDepth+F-D)/h),K=D*v;for(let G=0;G<g;++G){const U=Math.max(0,Math.ceil((O-G)/p)),q=Math.min(d.outHeight,(d.inHeight+O-G)/p),Q=G*w+K;for(let ee=0;ee<y;++ee){const ae=Math.max(0,Math.ceil((L-ee)/f)),ye=Math.min(d.outWidth,(d.inWidth+L-ee)/f),j=ee*k+Q;for(let ce=0;ce<d.inChannels;++ce){const be=ce*S+j;for(let ke=0;ke<d.outChannels;++ke){let Ae=0;for(let Pe=0;Pe<d.batchSize;++Pe){const ie=Pe*_,Te=Pe*$;for(let Le=B;Le<V;++Le){const ge=(D+Le*h-F)*R+ie,ve=Le*C+Te;for(let pe=U;pe<q;++pe){const ze=(G+pe*p-O)*z+ge,Ye=pe*T+ve;for(let Je=ae;Je<ye;++Je){const Ue=(ee+Je*f-L)*W+ze,Xe=Je*N+Ye;Ae+=E[Ue+ce]*I[Xe+ke]}}}}x[be+ke]=Ae}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const AIe={kernelName:OO,backendName:"cpu",kernelFunc:_Ie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;ht([s],"conv3dBackpropInputV2");const u=kt(s.shape),c=kt(a.shape),d=ad(l,a.shape,o,1,i),h=new Ss(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(s.dataId).values,[x,v,w,k]=u,S=n.data.get(a.dataId).values,[I,$,C,T]=c,{batchSize:N,filterDepth:E,filterHeight:_,filterWidth:R,inChannels:z,inDepth:W,inHeight:F,inWidth:L,outChannels:O,outDepth:D,outHeight:B,outWidth:V,strideDepth:K,strideHeight:G,strideWidth:U}=d,q=E-1-d.padInfo.front,Q=_-1-d.padInfo.top,ee=R-1-d.padInfo.left;for(let ae=0;ae<N;++ae)for(let ye=0;ye<z;++ye)for(let j=0;j<W;++j){const ce=j-q,be=Math.max(0,Math.ceil(ce/K)),ke=Math.min(D,(E+ce)/K);for(let Ae=0;Ae<F;++Ae){const Pe=Ae-Q,ie=Math.max(0,Math.ceil(Pe/G)),Te=Math.min(B,(_+Pe)/G);for(let Le=0;Le<L;++Le){const $e=Le-ee,ge=Math.max(0,Math.ceil($e/U)),ve=Math.min(V,(R+$e)/U);let pe=0;for(let Ie=be;Ie<ke;++Ie){const ze=Ie*K-ce;for(let Ye=ie;Ye<Te;++Ye){const Je=Ye*G-Pe;for(let Ke=ge;Ke<ve;++Ke){const Ue=Ke*U-$e,Xe=x*ae+v*Ie+w*Ye+k*Ke,ut=I*(E-1-ze)+$*(_-1-Je)+C*(R-1-Ue)+T*ye;for(let vt=0;vt<O;++vt){const An=b[Xe+vt],Rt=S[ut+vt];pe+=An*Rt}}}}p[f*ae+m*j+g*Ae+y*Le+ye]=pe}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}const DIe={kernelName:FO,backendName:"cpu",kernelFunc:RIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OIe=bn(M0,e=>Math.cos(e)),FIe={kernelName:M0,backendName:"cpu",kernelFunc:OIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MIe=bn(P0,e=>Math.cosh(e)),PIe={kernelName:P0,backendName:"cpu",kernelFunc:MIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LIe(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,y=Gt([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,w=kt(s.shape),k=kt(y.shape);for(let S=0;S<f;S++){const I=S*4,$=b[I],C=b[I+1],T=b[I+2],N=b[I+3],E=x[S];if(E>=c)continue;const _=m>1?(T-$)*(d-1)/(m-1):0,R=g>1?(N-C)*(h-1)/(g-1):0;for(let z=0;z<m;z++){const W=m>1?$*(d-1)+z*_:.5*($+T)*(d-1);if(W<0||W>d-1){for(let F=0;F<g;F++)for(let L=0;L<p;L++){const O=L+F*k[2]+z*k[1]+S*k[0];y.values[O]=u}continue}if(l==="bilinear"){const F=Math.floor(W),L=Math.ceil(W),O=W-F;for(let D=0;D<g;D++){const B=g>1?C*(h-1)+D*R:.5*(C+N)*(h-1);if(B<0||B>h-1){for(let U=0;U<p;U++){const q=U+D*k[2]+z*k[1]+S*k[0];y.values[q]=u}continue}const V=Math.floor(B),K=Math.ceil(B),G=B-V;for(let U=0;U<p;U++){let q=U+V*w[2]+F*w[1]+E*w[0];const Q=v[q];q=U+K*w[2]+F*w[1]+E*w[0];const ee=v[q];q=U+V*w[2]+L*w[1]+E*w[0];const ae=v[q];q=U+K*w[2]+L*w[1]+E*w[0];const ye=v[q],j=Q+(ee-Q)*G,ce=ae+(ye-ae)*G;q=U+D*k[2]+z*k[1]+S*k[0],y.values[q]=j+(ce-j)*O}}}else for(let F=0;F<g;++F){const L=g>1?C*(h-1)+F*R:.5*(C+N)*(h-1);if(L<0||L>h-1){for(let B=0;B<p;B++){const V=B+F*k[2]+z*k[1]+S*k[0];y.values[V]=u}continue}const O=Math.round(L),D=Math.round(W);for(let B=0;B<p;B++){const V=B+O*w[2]+D*w[1]+E*w[0],K=B+F*k[2]+z*k[1]+S*k[0];y.values[K]=v[V]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}const zIe={kernelName:PO,backendName:"cpu",kernelFunc:LIe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;ht(s,"cumprod");const l=lr([a],s.shape.length);let u=s;l!=null&&(u=xa({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=vr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Xa(u.dtype,"int32"),h=kO(Me(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const x=m(y,b);if(b===0)h[x]=i?1:p[x];else{const v=m(y,b-1);h[x]=i?p[v]*h[v]:p[x]*h[v]}}const g=n.makeTensorInfo(u.shape,d,h);if(l!=null){const y=id(l),b=xa({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}const WIe={kernelName:MO,backendName:"cpu",kernelFunc:BIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;ht(s,"cumsum");const l=lr([a],s.shape.length);let u=s;l!=null&&(u=xa({inputs:{x:s},backend:n,attrs:{perm:l}}));const c=vr(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const d=Xa(u.dtype,"int32"),h=Os(Me(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){const x=m(y,b);if(b===0)h[x]=i?0:p[x];else{const v=m(y,b-1);h[x]=i?p[v]+h[v]:p[x]+h[v]}}const g=n.makeTensorInfo(u.shape,d,h);if(l!=null){const y=id(l),b=xa({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}const UIe={kernelName:uC,backendName:"cpu",kernelFunc:VIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=X3(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=bX(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const GIe={kernelName:LO,backendName:"cpu",kernelFunc:jIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;Y(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,h=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p);let g=0;for(let y=0;y<o;++y)for(let b=0;b<d;++b){const x=Math.floor(b/a),v=b%a;for(let w=0;w<h;++w){const k=Math.floor(w/a),S=w%a,I=(v*a+S)*p;for(let $=0;$<p;++$){const T=$+I+c*(k+u*(x+l*y));m[g++]=f[T]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}const qIe={kernelName:zO,backendName:"cpu",kernelFunc:HIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;ht([s,a],"depthwiseConv2DNative");const c=kt(s.shape),d=kt(a.shape);let h=l;h==null&&(h=[1,1]),Y(Ps(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=Cs(s.shape,a.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,x=b.left,v=b.top,w=p.outChannels/p.inChannels,k=new Ss(p.outShape,s.dtype),S=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,$=k.values;for(let C=0;C<p.batchSize;++C){const T=C*c[0],N=C*k.strides[0];for(let E=0;E<p.outHeight;++E){const _=N+E*k.strides[1],R=E*p.strideHeight-v;for(let z=0;z<f;++z){const W=R+z*g;if(W<0||W>=p.inHeight)continue;const F=z*d[0],L=T+W*c[1];for(let O=0;O<p.outWidth;++O){const D=_+O*k.strides[2],B=O*p.strideWidth-x;for(let V=0;V<m;++V){const K=B+V*y;if(K<0||K>=p.inWidth)continue;const G=F+V*d[1],U=L+K*p.inChannels;let q=D,Q=G;for(let ee=0;ee<p.inChannels;++ee){const ae=S[U+ee];for(let ye=0;ye<w;++ye)$[q+ye]+=ae*I[Q+ye];q+=w,Q+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const KIe={kernelName:cC,backendName:"cpu",kernelFunc:bY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XIe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;ht([s,a],"depthwiseConv2dNativeBackpropFilter");const d=Cs(s.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new Ss(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(s.dataId).values,w=new Ss(s.shape,s.dtype,v),k=n.data.get(a.dataId).values,S=new Ss(a.shape,a.dtype,k);for(let I=0;I<f;++I){const $=Math.max(0,Math.ceil((b-I)/h)),C=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let T=0;T<m;++T){const N=Math.max(0,Math.ceil((y-T)/p)),E=Math.min(d.outWidth,(d.inWidth+y-T)/p);for(let _=0;_<d.outChannels;++_){const R=Math.trunc(_/x),z=_%x;let W=0;for(let F=0;F<d.batchSize;++F)for(let L=$;L<C;++L){const O=I+L*h-b;for(let D=N;D<E;++D){const B=T+D*p-y;W+=w.get(F,O,B,R)*S.get(F,L,D,_)}}g.set(W,I,T,R,z)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const YIe={kernelName:BO,backendName:"cpu",kernelFunc:XIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JIe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;ht([s,a],"depthwiseConv2DNativeBackpropInput");const d=kt(s.shape),h=kt(a.shape),p=Cs(c,a.shape,i,o,l,u,!0),f=new Ss(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[v,w,k]=d,S=n.data.get(a.dataId).values,[I,$,C]=h,{batchSize:T,filterHeight:N,filterWidth:E,inChannels:_,inHeight:R,inWidth:z,outChannels:W,outHeight:F,outWidth:L,strideHeight:O,strideWidth:D}=p,B=N-1-p.padInfo.top,V=E-1-p.padInfo.left,K=W/_;for(let G=0;G<T;++G)for(let U=0;U<_;++U)for(let q=0;q<R;++q){const Q=q-B,ee=Math.max(0,Math.ceil(Q/O)),ae=Math.min(F,(N+Q)/O);for(let ye=0;ye<z;++ye){const j=ye-V,ce=Math.max(0,Math.ceil(j/D)),be=Math.min(L,(E+j)/D);let ke=0;for(let Ae=ee;Ae<ae;++Ae){const Pe=Ae*O-Q;for(let ie=ce;ie<be;++ie){const Te=ie*D-j,Le=v*G+w*Ae+k*ie,$e=I*(N-1-Pe)+$*(E-1-Te)+C*U;for(let ge=0;ge<K;++ge){const ve=U*K+ge,pe=x[Le+ve],Ie=S[$e+ge];ke+=pe*Ie}}}m[g*G+y*q+b*ye+U]=ke}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}const ZIe={kernelName:WO,backendName:"cpu",kernelFunc:JIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QIe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=Me(r.shape),a=n.data.get(r.dataId).values,i=Gt([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];const l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}const eCe={kernelName:W8,backendName:"cpu",kernelFunc:QIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tCe={kernelName:dC,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:$,outShape:C}=wx(r.shape,s.shape,a,i,"NHWC",o),T=Me(C),N=C.length,E=gr(r.dtype,T);for(let R=0;R<p;++R)for(let z=0;z<y;++z){const W=z*v-x.top;for(let F=0;F<b;++F){const L=F*w-x.left;for(let O=0;O<g;++O){let D=Number.MIN_SAFE_INTEGER;for(let V=0;V<k;++V){const K=W+V*I;if(K>=0&&K<f)for(let G=0;G<S;++G){const U=L+G*$;if(U>=0&&U<m){const q=xl([R,K,U,O],c,kt(r.shape)),Q=xl([V,G,O],h,kt(s.shape)),ee=u[q]+d[Q];ee>D&&(D=ee)}}}const B=xl([R,z,F,O],N,kt(C));E[B]=D}}}return{dataId:l.write(mp(E,r.dtype),C,r.dtype),shape:C,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nCe={kernelName:hA,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=_o(r.shape,u.data.get(r.dataId).values),d=_o(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:$}=wx(r.shape,s.shape,i,o,"NHWC",l);Y(a.rank===$.length,()=>`Error in ${hA}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);const C=_o($,u.data.get(a.dataId).values),T=P8(s.shape,s.dtype);for(let E=0;E<h;++E)for(let _=0;_<g;++_){const R=_*x-b.top;for(let z=0;z<y;++z){const W=z*v-b.left;for(let F=0;F<m;++F){let L=Number.MIN_SAFE_INTEGER,O=0,D=0;for(let B=0;B<w;++B){const V=R+B*S;if(V>=0&&V<p)for(let K=0;K<k;++K){const G=W+K*I;if(G>=0&&G<f){const U=c[E][V][G][F]+d[B][K][F];U>L&&(L=U,O=B,D=K)}}}T[O][D][F]+=C[E][_][z][F]}}}return{dataId:u.write(mp(T,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rCe={kernelName:dA,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=_o(r.shape,u.data.get(r.dataId).values),d=_o(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:$}=wx(r.shape,s.shape,i,o,"NHWC",l);Y(a.rank===$.length,()=>`Error in ${dA}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);const C=_o($,u.data.get(a.dataId).values),T=P8(r.shape,r.dtype);for(let E=0;E<h;++E)for(let _=0;_<g;++_){const R=_*x-b.top;for(let z=0;z<y;++z){const W=z*v-b.left;for(let F=0;F<m;++F){let L=Number.MIN_SAFE_INTEGER,O=R<0?0:R,D=W<0?0:W;for(let B=0;B<w;++B){const V=R+B*S;if(V>=0&&V<p)for(let K=0;K<k;++K){const G=W+K*I;if(G>=0&&G<f){const U=c[E][V][G][F]+d[B][K][F];U>L&&(L=U,O=V,D=G)}}}T[E][O][D][F]+=C[E][_][z][F]}}}return{dataId:u.write(mp(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sCe(e){const{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const d=a.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${c} type.`);const[h,p]=s.shape.slice(0,2),f=s.shape.length===2?1:s.shape[2],m=n.data.get(s.dataId).values,g=s.dtype==="float32"?255:1,y=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){const v=[0,0,0,255*u];for(let k=0;k<f;k++){const S=m[x*f+k];if(s.dtype==="float32"){if(S<0||S>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${S}.`)}else if(s.dtype==="int32"&&(S<0||S>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${S}.`);f===1?(v[0]=S*g,v[1]=S*g,v[2]=S*g):v[k]=S*g}const w=x*4;y[w+0]=Math.round(v[0]),y[w+1]=Math.round(v[1]),y[w+2]=Math.round(v[2]),y[w+3]=Math.round(v[3])}a.width=p,a.height=h;const b=new ImageData(y,p,h);return d.putImageData(b,0,0),s}const aCe={kernelName:xfe,backendName:"cpu",kernelFunc:sCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Px(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ht(s,"sum");let o;s.dtype==="bool"?o=Mc({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=Fl({inputs:{x:s},backend:n});const l=o.shape.length,u=Ht(a,o.shape),c=lr(u,l);let d=u,h=o;c!=null&&(h=xa({inputs:{x:o},backend:n,attrs:{perm:c}}),d=vr(d.length,l)),Ns("sum",d,h.shape.length);const[p,f]=ps(h.shape,d),m=Xa(h.dtype,"int32");let g=AS(n,p,m);const y=Me(f),b=n.data.get(g.dataId).values,x=n.data.get(h.dataId).values;for(let v=0;v<b.length;++v){const w=v*y;let k=0;for(let S=0;S<y;++S)k+=x[w+S];b[v]=k}if(i){const v=Ar(g.shape,u),w=g;g=Mn({inputs:{x:g},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(w)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(h),g}const iCe={kernelName:jC,backendName:"cpu",kernelFunc:Px};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oCe(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=v3(s,a.length);w3(i.length,l,a);const{path:u,steps:c}=k3(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=x3(p,l[g]);let x;S3(y)?x=a[g]:(x=xa({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));const v=x.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);cn(x.shape,v)||(x=Mn({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),h===null?h=x:(h=xN({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=Px({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const lCe={kernelName:VO,backendName:"cpu",kernelFunc:oCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uCe(e){const{inputs:t,backend:n}=e,{dy:r,y:s}=t;ht([r,s],"eluGrad");const a=new Float32Array(Me(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){const u=i[l];u>=0?a[l]=o[l]:a[l]=o[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",a)}const cCe={kernelName:UO,backendName:"cpu",kernelFunc:uCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dCe=h3,hCe=p3,pCe=f3,fCe=m3,mCe=g3,gCe=y3,yCe=bn(B0,e=>{const t=Math.sign(e),n=Math.abs(e),r=1/(1+dCe*n);return t*(1-((((gCe*r+mCe)*r+fCe)*r+pCe)*r+hCe)*r*Math.exp(-n*n))}),bCe={kernelName:B0,backendName:"cpu",kernelFunc:yCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(e){const{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice();let l=a;return a<0&&(Y(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),Mn({inputs:{x:s},backend:n,attrs:{shape:o}})}const vCe={kernelName:pC,backendName:"cpu",kernelFunc:OS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xCe=wr((e,t)=>e/t),tM=Yr(L0,xCe),zA={kernelName:L0,backendName:"cpu",kernelFunc:tM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vY(e,t,n){const r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=Me(u),d=Ds("float32",c),h=Ds("float32",c);for(let g=0;g<s;g++){const y=Bh({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),b=Bh({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),x=La({inputs:{real:y,imag:b},backend:n}),{real:v,imag:w}=wCe(x,t,n),k=mu(v,w);for(let S=0;S<a;S++){const I=b3(k,S);d[g*a+S]=I.real,h[g*a+S]=I.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x)}const p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=La({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function wCe(e,t,n){const r=Me(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(kCe(r)){const o=BA(a,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){const u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",rd(r,"float32")),h=Fl({inputs:{x:d},backend:n}),p=zA.kernelFunc({inputs:{a:u,b:d},backend:n}),f=zA.kernelFunc({inputs:{a:c,b:h},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{const o=mu(a,i),l=SCe(o,r,t);return O9(l)}}function kCe(e){return(e&e-1)===0}function BA(e,t,n,r,s){if(n===1)return{real:e,imag:t};const a=mu(e,t),i=n/2,o=F9(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=La({inputs:{real:d,imag:h},backend:s}),f=M9(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),v=La({inputs:{real:b,imag:x},backend:s}),w=BA(l,u,i,r,s),k=w.real,S=w.imag,I=[k.length],$=s.makeTensorInfo(I,"float32",k),C=s.makeTensorInfo(I,"float32",S),T=La({inputs:{real:$,imag:C},backend:s}),N=BA(m,g,i,r,s),E=N.real,_=N.imag,R=[E.length],z=s.makeTensorInfo(R,"float32",E),W=s.makeTensorInfo(R,"float32",_),F=La({inputs:{real:z,imag:W},backend:s}),L=L9(n,r),O=[L.real.length],D=s.makeTensorInfo(O,"float32",L.real),B=s.makeTensorInfo(O,"float32",L.imag),V=La({inputs:{real:D,imag:B},backend:s}),K=xN({inputs:{a:V,b:F},backend:s}),G=$g({inputs:{a:T,b:K},backend:s}),U=Q3({inputs:{a:T,b:K},backend:s}),q=zh({inputs:{input:G},backend:s}),Q=zh({inputs:{input:U},backend:s}),ee=Eg({inputs:{input:G},backend:s}),ae=Eg({inputs:{input:U},backend:s}),ye=_g({inputs:[q,Q],backend:s,attrs:{axis:0}}),j=_g({inputs:[ee,ae],backend:s,attrs:{axis:0}}),ce=s.data.get(ye.dataId).values,be=s.data.get(j.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(ae),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(j),{real:ce,imag:be}}function SCe(e,t,n){const r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){const l=z9(s*o,t,n),u=b3(e,o);a+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(a/=t,i/=t),P9(r,a,i,s)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ICe(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Me(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Mn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=vY(o,!1,n),u=Mn({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const CCe={kernelName:jO,backendName:"cpu",kernelFunc:ICe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nM(e){const{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||uy(s),o=gr(i,Me(r));return TCe(o,s,i),t.makeTensorInfo(r,i,o)}const NCe={kernelName:GO,backendName:"cpu",kernelFunc:nM};function TCe(e,t,n){e.fill(t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ce={kernelName:HO,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,s=n,a=Ds(r.dtype,Me(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let h=0;h<i;h++){const p=h*l*o*u;for(let f=0;f<o;f++){const m=f*(l*u);for(let g=0;g<l;g++){const y=g*u;for(let b=0;b<u;b++){const x=Math.round(l-g-1),v=p+m+y+b;let w=c[v];if(x>=0&&x<l){const k=x*u,S=p+m+k+b;w=c[S]}a[v]=w}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ECe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=yY({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const y=Mn({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=$g({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=$g({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){const g=m;if(c==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const y=Mn({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=DS(n,m,p,y,f),n.disposeIntermediateTensorInfo(y)}else m=DS(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}const _Ce={kernelName:cS,backendName:"cpu",kernelFunc:ECe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ACe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r;let m=bY({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){const g=m;m=$g({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){const g=m;m=DS(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}const RCe={kernelName:iq,backendName:"cpu",kernelFunc:ACe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DCe(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=Me(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=t3(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);const h=n.data.get(s.dataId).values,p=n.bufferSync(r),f=EX(h,p,r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,f.values)}const OCe={kernelName:V8,backendName:"cpu",kernelFunc:DCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FCe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;ht([s,a],"gatherV2");const l=Ht(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let v=0;v<u.length;++v){const w=u[v];Y(w<=c-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);const h=Me(a.shape),p=C3(s,a,l,d),f=Mn({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Mn({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=_X(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}const MCe={kernelName:mC,backendName:"cpu",kernelFunc:FCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PCe(e){const{inputs:t,backend:n}=e,{input:r}=t,s=Me(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Mn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=vY(o,!0,n),u=Mn({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}const LCe={kernelName:qO,backendName:"cpu",kernelFunc:PCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zCe=bn(q0,e=>Number.isFinite(e)?1:0,"bool"),BCe={kernelName:q0,backendName:"cpu",kernelFunc:zCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WCe=bn(K0,e=>Math.abs(e)===1/0?1:0,"bool"),VCe={kernelName:K0,backendName:"cpu",kernelFunc:WCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UCe=bn(X0,e=>Number.isNaN(e)?1:0,"bool"),jCe={kernelName:X0,backendName:"cpu",kernelFunc:UCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GCe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=FX(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const HCe={kernelName:U8,backendName:"cpu",kernelFunc:GCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qCe=bn(J0,e=>Math.log1p(e)),KCe={kernelName:J0,backendName:"cpu",kernelFunc:qCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XCe=wr((e,t)=>e&&t),YCe=Yr(xC,XCe,null,"bool"),JCe={kernelName:xC,backendName:"cpu",kernelFunc:YCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZCe=bn(wC,e=>e?0:1,"bool"),QCe={kernelName:wC,backendName:"cpu",kernelFunc:ZCe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eNe=wr((e,t)=>e||t),tNe=Yr(kC,eNe,null,"bool"),nNe={kernelName:kC,backendName:"cpu",kernelFunc:tNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;ht(s,"LRN");const u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,h=Me(s.shape),p=new Float32Array(h);function f(m){const g=m%u;let y=m-g+Math.max(0,g-a);const b=m-g+Math.min(g+a,c);let x=0;for(;y<=b;y++){const v=d[y];x+=v*v}return x}for(let m=0;m<h;m++){const g=f(m),y=d[m]*Math.pow(i+o*g,-l);p[m]=y}return n.makeTensorInfo(s.shape,s.dtype,p)}const sNe={kernelName:SC,backendName:"cpu",kernelFunc:rNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;ht(i,"LRNGrad");const d=Me(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){const x=b%h,v=b-x+Math.max(0,x-o),w=b-x+Math.min(h,x+o+1);let k=0;for(let S=v;S<w;S++)k+=Math.pow(f[S],2);k=u*k+l;for(let S=v;S<w;S++){let I=-2*u*c*f[S]*m[b]/k;b===S&&(I+=Math.pow(k,-c)),I*=p[b],g[S]+=I}}return n.makeTensorInfo(i.shape,s.dtype,g)}const iNe={kernelName:XO,backendName:"cpu",kernelFunc:aNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xY(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n;let l=s.shape;const u=l.length,c=Ht(a,l);let d=c;const h=lr(d,u);let p=o.data.get(s.dataId).values;if(h!=null){const v=new Array(u);for(let w=0;w<v.length;w++)v[w]=l[h[w]];p=J3(p,l,s.dtype,h,v),d=vr(d.length,u),l=v}ht(s,"max"),Ns("max",d,u);const[f,m]=ps(l,d),g=Me(m),y=PX(p,g,f,s.dtype),b=o.write(y,f,s.dtype);let x=f;return i&&(x=Ar(f,c)),{dataId:b,shape:x,dtype:s.dtype}}const oNe={kernelName:IC,backendName:"cpu",kernelFunc:xY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;ht(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(Ps(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=no(s.shape,a,i,u,o,l);let d;if(c.filterWidth===1&&c.filterHeight===1&&cn(c.inShape,c.outShape))d=Fl({inputs:{x:s},backend:n});else{const h=n.data.get(s.dataId).values,p=kt(s.shape),f=eM(h,s.shape,s.dtype,p,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}const uNe={kernelName:CC,backendName:"cpu",kernelFunc:lNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;ht(s,"maxPool3d");const c=Iu(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=gY(d,s.shape,s.dtype,kt(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}const dNe={kernelName:NC,backendName:"cpu",kernelFunc:cNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hNe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;ht([s,a],"maxPool3DGrad");const c=Iu(a.shape,i,o,1,l,u),d=n.bufferSync(a),h=eIe(d,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=x-1-c.padInfo.front,S=w-1-c.padInfo.left,I=v-1-c.padInfo.top,$=Gt(a.shape,"float32"),C=n.bufferSync(s);for(let T=0;T<c.batchSize;++T)for(let N=0;N<c.inChannels;++N)for(let E=0;E<c.inDepth;++E)for(let _=0;_<c.inHeight;++_)for(let R=0;R<c.inWidth;++R){const z=E-k,W=_-I,F=R-S;let L=0;for(let O=0;O<x;O+=g){const D=(z+O)/p;if(!(D<0||D>=c.outDepth||Math.floor(D)!==D))for(let B=0;B<v;B+=y){const V=(W+B)/f;if(!(V<0||V>=c.outHeight||Math.floor(V)!==V))for(let K=0;K<w;K+=b){const G=(F+K)/m;if(G<0||G>=c.outWidth||Math.floor(G)!==G)continue;const U=x*v*w-1-h.get(T,D,V,G,N),q=O*v*w+B*w+K,Q=U===q?1:0;if(Q===0)continue;const ee=C.get(T,D,V,G,N);L+=ee*Q}}}$.set(L,T,E,_,R,N)}return n.makeTensorInfo($.shape,$.dtype,$.values)}const pNe={kernelName:JO,backendName:"cpu",kernelFunc:hNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fNe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;ht([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=no(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=Gt(h.outShape,o.dtype,mY(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,k=x-1-h.padInfo.top,S=Gt(o.shape,"float32"),I=n.data.get(s.dataId).values,$=Gt(s.shape,"float32",I);for(let C=0;C<h.batchSize;++C)for(let T=0;T<h.inChannels;++T)for(let N=0;N<h.inHeight;++N)for(let E=0;E<h.inWidth;++E){const _=N-k,R=E-w;let z=0;for(let W=0;W<x;W+=y){const F=(_+W)/m;if(!(F<0||F>=h.outHeight||Math.floor(F)!==F))for(let L=0;L<v;L+=b){const O=(R+L)/g;if(O<0||O>=h.outWidth||Math.floor(O)!==O)continue;const D=x*v-1-f.get(C,F,O,T),B=W*v+L,V=D===B?1:0;if(V===0)continue;const K=$.get(C,F,O,T);z+=K*V}}S.set(z,C,N,E,T)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const mNe={kernelName:YO,backendName:"cpu",kernelFunc:fNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gNe(e,t,n,r,s){const a=kt(t),i=eM(e,t,n,a,s,"max"),o=mY(e,t,n,s,!0,r);return[i.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yNe={kernelName:j8,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;ht(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,c=no(r.shape,s,a,[1,1],i),[d,h]=gNe(u,r.shape,r.dtype,o,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=Ht(a,s.shape),u=ps(s.shape,o)[1],c=Me(u),d=[],h=n.makeTensorInfo([],"float32",new Float32Array([c]));d.push(h);const p=Mc({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});d.push(p);const f=tM({inputs:{a:p,b:h},backend:n});d.push(f);const m=Px({inputs:{x:f},backend:n,attrs:{axis:a,keepDims:i}});return d.forEach(g=>n.disposeIntermediateTensorInfo(g)),m}const vNe={kernelName:TC,backendName:"cpu",kernelFunc:bNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;ht(s,"min");const o=Ht(a,s.shape);let l=o;const u=lr(l,s.shape.length);let c=s;u!=null&&(c=xa({inputs:{x:s},backend:n,attrs:{perm:u}}),l=vr(l.length,s.shape.length)),Ns("min",l,c.shape.length);const[d,h]=ps(c.shape,l),p=Me(h),f=Os(Me(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){const b=y*p;let x=m[b];for(let v=0;v<p;++v){const w=m[b+v];(Number.isNaN(w)||w<x)&&(x=w)}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);const g=n.makeTensorInfo(d,c.dtype,f);if(i){const y=Ar(d,o),b=Mn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}const wNe={kernelName:$C,backendName:"cpu",kernelFunc:xNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;ht(s,"mirrorPad");const o=a.map((x,v)=>x[0]+s.shape[v]+x[1]),l=a.map(x=>x[0]),u=a.map((x,v)=>x[0]+s.shape[v]),c=i==="reflect"?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=kt(s.shape),f=Me(o),m=o.length,g=kt(o),y=Ds(s.dtype,f);for(let x=0;x<f;x++){let v=cy(x,m,g);for(let k=0;k<m;k++)v[k]<l[k]?v[k]=l[k]*2-v[k]-c:v[k]>=u[k]&&(v[k]=(u[k]-1)*2-v[k]+c);v=v.map((k,S)=>k-l[S]);const w=xl(v,h,p);y[x]=d[w]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}const SNe={kernelName:EC,backendName:"cpu",kernelFunc:kNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const INe=wr((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),CNe=Yr(ex,INe),NNe={kernelName:ex,backendName:"cpu",kernelFunc:CNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wY(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length;let o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);const l=Ht([o],s.shape),u=xY({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Ar(u.shape,l),d=Mn({inputs:{x:u},backend:n,attrs:{shape:c}}),h=Q3({inputs:{a:s,b:d},backend:n}),p=CX({inputs:{x:h},backend:n}),f=Px({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Mn({inputs:{x:f},backend:n,attrs:{shape:c}}),g=tM({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const TNe={kernelName:qC,backendName:"cpu",kernelFunc:wY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Ne(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;ht(s,"multinomial");const l=o?s:wY({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,a],p=Os(Me(h),"int32");for(let f=0;f<u;++f){const m=f*c,g=new Float32Array(c-1);g[0]=d[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[m+x];const y=BF.alea(i.toString()),b=f*a;for(let x=0;x<a;++x){const v=y();p[b+x]=g.length;for(let w=0;w<g.length;w++)if(v<g[w]){p[b+x]=w;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}const ENe={kernelName:G8,backendName:"cpu",kernelFunc:$Ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Ne=XF;function ANe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;ht(s,"NonMaxSuppression");const u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=_Ne(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const RNe={kernelName:ZO,backendName:"cpu",kernelFunc:ANe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DNe=YF;function ONe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;ht(s,"NonMaxSuppressionPadded");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=DNe(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const FNe={kernelName:QO,backendName:"cpu",kernelFunc:ONe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MNe=JF;function PNe(e){const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;ht(s,"NonMaxSuppressionWithScore");const c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=MNe(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const LNe={kernelName:eF,backendName:"cpu",kernelFunc:PNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zNe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;ht(s,"oneHot");const u=Me(s.shape),c=new Float32Array(u*i);c.fill(l);const d=n.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}const BNe={kernelName:DC,backendName:"cpu",kernelFunc:zNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const s=zh({inputs:{input:r},backend:n}),a=FS({inputs:{x:s},backend:n}),i=Eg({inputs:{input:r},backend:n}),o=FS({inputs:{x:i},backend:n}),l=La({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return nM({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const WNe={kernelName:YC,backendName:"cpu",kernelFunc:FS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kY(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const s=zh({inputs:{input:r},backend:n}),a=kY({inputs:{x:s},backend:n}),i=Eg({inputs:{input:r},backend:n}),o=FS({inputs:{x:i},backend:n}),l=La({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return nM({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const VNe={kernelName:RC,backendName:"cpu",kernelFunc:kY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SY(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return OS({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(c=>{wO(a,c.shape,"All tensors passed to stack must have matching shapes"),Y(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const d=OS({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=_g({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const UNe={kernelName:OC,backendName:"cpu",kernelFunc:SY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jNe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;ht(s,"pad");const o=a.map((b,x)=>b[0]+s.shape[x]+b[1]),l=a.map(b=>b[0]),u=n.data.get(s.dataId).values,c=Me(s.shape),d=s.shape.length,h=kt(s.shape),p=Me(o),f=o.length,m=kt(o),g=Ds(s.dtype,p);i!==0&&g.fill(i);for(let b=0;b<c;b++){const v=cy(b,d,h).map((k,S)=>k+l[S]),w=xl(v,f,m);g[w]=u[b]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}const IY={kernelName:FC,backendName:"cpu",kernelFunc:jNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GNe=wr((e,t)=>Math.pow(e,t)),HNe=Yr(nx,GNe),qNe={kernelName:nx,backendName:"cpu",kernelFunc:HNe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KNe(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,o=s.map(g=>n.data.get(g.dataId).values),l=s.map(g=>g.shape),u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h,p]=UX(o,l,u,a.shape,a.dtype,c,i.shape),f=d.map(g=>n.makeTensorInfo([g.length],"int32",g)),m=n.makeTensorInfo(p,a.dtype,h);return f.concat([m])}const XNe={kernelName:H8,backendName:"cpu",kernelFunc:KNe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YNe(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=jX(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}const JNe={kernelName:q8,backendName:"cpu",kernelFunc:YNe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZNe(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=GX(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}const QNe={kernelName:K8,backendName:"cpu",kernelFunc:ZNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eTe(e){const{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=HX(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}const tTe={kernelName:tF,backendName:"cpu",kernelFunc:eTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nTe=bn(rx,e=>1/e),rTe={kernelName:rx,backendName:"cpu",kernelFunc:nTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sTe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;ht(s,"resizeBilinear");const l=kt(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(Me([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c];let x=0;const v=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let S=0;S<u;S++){let I;i?I=v*(S+.5)-.5:I=v*S;const $=Math.max(0,Math.floor(I)),C=I-$,T=Math.min(h-1,Math.ceil(I)),N=k*l[0]+$*l[1],E=k*l[0]+T*l[1];for(let _=0;_<c;_++){let R;i?R=w*(_+.5)-.5:R=w*_;const z=Math.max(0,Math.floor(R)),W=R-z,F=Math.min(p-1,Math.ceil(R)),L=N+z*l[2],O=E+z*l[2],D=N+F*l[2],B=E+F*l[2];for(let V=0;V<f;V++){const K=m[L+V],G=m[O+V],U=m[D+V],q=m[B+V],Q=K+(U-K)*W,ee=G+(q-G)*W,ae=Q+(ee-Q)*C;g[x++]=ae}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}const aTe={kernelName:BC,backendName:"cpu",kernelFunc:sTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iTe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;ht([a,s],"resizeBilinearGrad");const o=kt(s.shape),[l,u,c,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(a.dataId).values;let v=0;for(let w=0;w<l;w++){const k=w*o[0];for(let S=0;S<h;S++){const I=S*y,$=Math.floor(I),C=Math.min(Math.ceil(I),u-1),T=k+$*o[1],N=k+C*o[1],E=I-$,_=1-E;for(let R=0;R<p;R++){const z=R*b,W=Math.floor(z),F=Math.min(Math.ceil(z),c-1),L=z-W,O=1-L,D=T+W*o[2],B=T+F*o[2],V=N+W*o[2],K=N+F*o[2],G=_*O,U=_*L,q=E*O,Q=E*L;for(let ee=0;ee<d;ee++){const ae=x[v++];f[D+ee]+=ae*G,f[B+ee]+=ae*U,f[V+ee]+=ae*q,f[K+ee]+=ae*Q}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}const oTe={kernelName:sF,backendName:"cpu",kernelFunc:iTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lTe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;ht(s,"resizeNearestNeighbor");const l=kt(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=y[0]/b[0],v=y[1]/b[1];let w=0;for(let k=0;k<d;k++){const S=k*l[0];for(let I=0;I<u;I++){const $=i?x*(I+.5):x*I;let C=Math.min(h-1,a?Math.round($):Math.floor($));i&&(C=Math.max(0,C));const T=S+C*l[1];for(let N=0;N<c;N++){const E=i?v*(N+.5):v*N;let _=Math.min(p-1,a?Math.round(E):Math.floor(E));i&&(_=Math.max(0,_));const R=T+_*l[2];for(let z=0;z<f;z++){const W=m[R+z];g[w++]=W}}}}return n.makeTensorInfo([d,u,c,f],s.dtype,g)}const uTe={kernelName:zC,backendName:"cpu",kernelFunc:lTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cTe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;ht([a,s],"resizeNearestNeighborGrad");const o=kt(s.shape),l=kt(a.shape),[u,c,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],w=1/x,k=1/v,S=Math.ceil(w)*2+2,I=Math.ceil(k)*2+2;for(let $=0;$<u;$++){const C=$*o[0];for(let T=0;T<c;T++){const N=C+T*o[1],E=Math.floor(T*w),_=Math.floor(E-S/2);for(let R=0;R<d;R++){const z=N+R*o[2],W=Math.floor(R*k),F=Math.floor(W-I/2);for(let L=0;L<h;L++){let O=0;for(let D=0;D<S;D++){const B=D+_;if(B<0||B>=p)continue;const V=C+B*l[1],K=B*x,G=Math.min(c-1,i?Math.round(K):Math.floor(K));if(T===G)for(let U=0;U<I;U++){const q=U+F;if(q<0||q>=f)continue;const Q=V+q*l[2],ee=q*v,ae=Math.min(d-1,i?Math.round(ee):Math.floor(ee));R===ae&&(O+=g[Q+L])}}m[z+L]=O}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}const dTe={kernelName:rF,backendName:"cpu",kernelFunc:cTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hTe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;ht(s,"reverse");const i=s.shape.length,o=Ht(a,s.shape);if(i===0)return Fl({inputs:{x:s},backend:n});const l=new Ss(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){const d=l.indexToLoc(c),h=d.slice();o.forEach(p=>h[p]=s.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const pTe={kernelName:WC,backendName:"cpu",kernelFunc:hTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fTe={kernelName:dF,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=Ds(r.dtype,Me(r.shape)),[u,c,d,h]=r.shape,[p,f]=u3(i,c,d),m=255,g=Math.sin(s),y=Math.cos(s),b=o.data.get(r.dataId).values;for(let v=0;v<u;v++){const w=v*d*c*h;for(let k=0;k<c;k++){const S=k*(d*h);for(let I=0;I<d;I++){const $=I*h;for(let C=0;C<h;C++){const T=[u,k,I,C],N=T[2],E=T[1];let _=(N-p)*y-(E-f)*g,R=(N-p)*g+(E-f)*y;_=Math.round(_+p),R=Math.round(R+f);let z=a;if(typeof a!="number"&&(C===3?z=m:z=a[C]),_>=0&&_<d&&R>=0&&R<c){const F=R*(d*h),L=_*h,O=w+F+L+C;z=b[O]}const W=w+S+$+C;l[W]=z}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mTe=bn(ix,e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),gTe={kernelName:ix,backendName:"cpu",kernelFunc:mTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yTe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=vp(a,s,i),h=!0,p=n.bufferSync(s),f=n.bufferSync(a),m=sh(p,f,i,d,u,l,o,c,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}const bTe={kernelName:X8,backendName:"cpu",kernelFunc:yTe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vTe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function xTe(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function wTe(e,t,n,r,s,a){const i=gr("int32",n*s);for(let o=0;o<n;++o){const l=e.slice(o*r,(o+1)*r),u=o*s;for(let c=0;c<s;++c)i[u+c]=a==="left"?vTe(l,t[c+u]):xTe(l,t[c+u])}return i}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kTe(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=wTe(o,l,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",u)}const STe={kernelName:J8,backendName:"cpu",kernelFunc:kTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ITe(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;ht([r,s,a],"select");const i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=Xa(s.dtype,a.dtype),d=Os(Me(s.shape),c);let h=0;const p=i===0||i>1||s.shape.length===1?1:Me(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(s.shape,c,d)}const CTe={kernelName:VC,backendName:"cpu",kernelFunc:ITe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NTe=oN,TTe=lN,$Te=bn(lx,e=>e>=0?TTe*e:NTe*(Math.exp(e)-1)),ETe={kernelName:lx,backendName:"cpu",kernelFunc:$Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Te=bn(dx,e=>e<0?-1:e>0?1:0),ATe={kernelName:dx,backendName:"cpu",kernelFunc:_Te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RTe=bn(ux,e=>Math.sin(e)),DTe={kernelName:ux,backendName:"cpu",kernelFunc:RTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OTe=bn(cx,e=>Math.sinh(e)),FTe={kernelName:cx,backendName:"cpu",kernelFunc:OTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MTe=11920928955078125e-23,sU=Math.log(MTe)+2,PTe=bn(px,e=>{const t=e>-sU,n=e<sU,r=Math.exp(e);let s;return n?s=r:t?s=e:s=Math.log(1+r),s}),LTe={kernelName:px,backendName:"cpu",kernelFunc:PTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zTe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;ht([s],"spaceToBatchND");const o=Me(a),l=[[0,0]];l.push(...i);for(let k=1+a.length;k<s.shape.length;++k)l.push([0,0]);const u=IY.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=Nx(u.shape,a,o,!1),d=Tx(c.length,a.length,!1),h=$x(u.shape,a,o,!1),m=Mn({inputs:{x:u},backend:n,attrs:{shape:c}}),b=xa({inputs:{x:m},backend:n,attrs:{perm:d}}),w=Mn({inputs:{x:b},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(b),w}const BTe={kernelName:GC,backendName:"cpu",kernelFunc:zTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WTe(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=YX(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const VTe={kernelName:Z8,backendName:"cpu",kernelFunc:WTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UTe(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=JX(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const jTe={kernelName:Q8,backendName:"cpu",kernelFunc:UTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GTe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=Z3(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const HTe={kernelName:eq,backendName:"cpu",kernelFunc:GTe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qTe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");const i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=Z3(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const KTe={kernelName:tq,backendName:"cpu",kernelFunc:qTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XTe(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=vp(a,s,o),p=!1,f=n.bufferSync(s);let m;switch(a.dtype){case"bool":{const g=n.bufferSync(a),y=!!n.data.get(i.dataId).values[0];m=sh(f,g,o,h,c,u,l,d,y,p);break}case"float32":{const g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=sh(f,g,o,h,c,u,l,d,y,p);break}case"int32":{const g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=sh(f,g,o,h,c,u,l,d,y,p);break}case"string":{const g=n.bufferSync(a),y=Ac(n.data.get(i.dataId).values[0]);m=sh(f,g,o,h,c,u,l,d,y,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}const YTe={kernelName:nq,backendName:"cpu",kernelFunc:XTe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JTe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Ht(i,s.shape)[0],l=I3(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{const h=[...c];h[o]=d;const p=Bh({inputs:{x:s},backend:n,attrs:{begin:u,size:h}});return u[o]+=d,p})}const ZTe={kernelName:HC,backendName:"cpu",kernelFunc:JTe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QTe={kernelName:aF,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t;ht(n,"square");const s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let o=0;o<s.length;++o){const l=s[o];a[o]=l*l}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$e=bn(xx,(e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),t$e={kernelName:xx,backendName:"cpu",kernelFunc:e$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;ht(s,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=i3(s.shape,a,i,o,l,u,c,d,h);let w;if(m)w=Mn({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Y(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const k=r3(b,x,v),S=Bh({inputs:{x:s},backend:n,attrs:{begin:b,size:k}});w=Mn({inputs:{x:S},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(S)}else{const k=n.bufferSync(s),S=eY(p,k,v,b);w=n.makeTensorInfo(f,S.dtype,S.values)}return w}const r$e={kernelName:oF,backendName:"cpu",kernelFunc:n$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$e(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=tY(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const a$e={kernelName:rq,backendName:"cpu",kernelFunc:s$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$e(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=nY(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const o$e={kernelName:sq,backendName:"cpu",kernelFunc:i$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$e(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.data.get(a.dataId).values,o=rY(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const u$e={kernelName:aq,backendName:"cpu",kernelFunc:l$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c$e=bn(yx,e=>Math.tan(e)),d$e={kernelName:yx,backendName:"cpu",kernelFunc:c$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h$e=bn(bx,e=>Math.tanh(e)),p$e={kernelName:bx,backendName:"cpu",kernelFunc:h$e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$e(e){const{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=vp(a,s,r.shape),d=!1,h=n.bufferSync(s),p=n.bufferSync(a),f=n.bufferSync(r),m=sh(h,p,r.shape,c,l,o,i,u,f,d);return n.makeTensorInfo(r.shape,m.dtype,m.values)}const m$e={kernelName:Y8,backendName:"cpu",kernelFunc:f$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;ht(s,"tile");const i=aY(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const y$e={kernelName:vx,backendName:"cpu",kernelFunc:g$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;ht(s,"topk");const o=n.data.get(s.dataId).values,[l,u]=oY(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}const v$e={kernelName:lF,backendName:"cpu",kernelFunc:b$e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$e(e){const{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=kt(s.shape),b=y[0],x=y[1],v=y[2],w=kt(g),k=w[0],S=w[1],I=w[2],$=Ds(s.dtype,Me(g));$.fill(l);const C=r.data.get(s.dataId).values,T=r.data.get(a.dataId).values;for(let E=0;E<c;++E){const _=a.shape[0]===1?T:T.subarray(E*8,E*8+8);for(let R=0;R<f;++R)for(let z=0;z<m;++z)for(let W=0;W<p;++W){let F;const L=_[6]*z+_[7]*R+1;if(L===0)continue;const O=(_[0]*z+_[1]*R+_[2])/L,D=(_[3]*z+_[4]*R+_[5])/L,B=aU(O,h,o),V=aU(D,d,o);switch(i){case"nearest":F=N$e(C,d,h,b,x,v,E,V,B,W,l);break;case"bilinear":F=T$e(C,d,h,b,x,v,E,V,B,W,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const K=E*k+R*S+z*I+W;$[K]=F}return r.makeTensorInfo(g,s.dtype,$)}return{dataId:r.write($,g,s.dtype),shape:s.shape,dtype:s.dtype}}const w$e={kernelName:uF,backendName:"cpu",kernelFunc:x$e};function aU(e,t,n){switch(n){case"reflect":return k$e(e,t);case"wrap":return S$e(e,t);case"nearest":return C$e(e,t);case"constant":default:return I$e(e)}}function k$e(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{const r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return $h(0,n,t-1)}function S$e(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{const r=t-1;n-=t*Math.trunc(n/r)}return $h(0,n,t-1)}function I$e(e,t){return e}function C$e(e,t){return $h(0,e,t-1)}function Pv(e,t,n,r,s,a,i,o,l,u,c){const d=i*r+o*s+l*a+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:c}function N$e(e,t,n,r,s,a,i,o,l,u,c){const d=Math.round(o),h=Math.round(l);return Pv(e,t,n,r,s,a,i,d,h,u,c)}function T$e(e,t,n,r,s,a,i,o,l,u,c){const d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1,m=(f-l)*Pv(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*Pv(e,t,n,r,s,a,i,d,f,u,c),g=(f-l)*Pv(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*Pv(e,t,n,r,s,a,i,p,f,u,c);return(p-o)*m+(o-d)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$e(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;ht(a,"unique");const i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=lY(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const E$e={kernelName:cF,backendName:"cpu",kernelFunc:$$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$e(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s.shape.length,o=s.shape[a],l=new Array(i-1);let u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);const c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;const h=new Array(o);for(let p=0;p<h.length;p++){c[a]=p;const f=Bh({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[p]=Mn({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return h}const A$e={kernelName:KC,backendName:"cpu",kernelFunc:_$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;ht(s,"unsortedSegmentSum");const o=s.shape.length,l=a.shape.length,u=[],c=[],d=o-l;let h=a;for(let f=0;f<d;++f){const m=OS({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,c.push(m)}for(let f=0;f<i;++f){const m=rd(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=SX({inputs:{a:g,b:h},backend:n}),b=Mc({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=xN({inputs:{a:b,b:s},backend:n}),v=Px({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});u.push(v),c.push(g),c.push(y),c.push(b),c.push(x),c.push(v)}const p=SY({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const D$e={kernelName:XC,backendName:"cpu",kernelFunc:R$e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O$e=[$Se,l2e,_Se,RSe,f2e,OSe,MSe,LSe,BSe,VSe,jSe,HSe,KSe,JSe,QSe,nIe,sIe,iIe,lIe,NSe,cIe,hIe,fIe,g2e,gIe,h2e,b2e,bIe,u2e,xIe,kIe,SIe,CIe,TIe,EIe,AIe,DIe,FIe,PIe,zIe,WIe,UIe,GIe,qIe,KIe,YIe,ZIe,eCe,tCe,nCe,rCe,aCe,lCe,vSe,cCe,v2e,bCe,x2e,vCe,k2e,CCe,NCe,$Ce,I2e,N2e,_Ce,RCe,OCe,MCe,$2e,_2e,c2e,LCe,wIe,BCe,VCe,jCe,xSe,R2e,O2e,HCe,M2e,KCe,JCe,QCe,nNe,sNe,iNe,oNe,L2e,uNe,dNe,pNe,mNe,yNe,vNe,wNe,B2e,SNe,NNe,ENe,V2e,j2e,RNe,FNe,LNe,H2e,BNe,VNe,UNe,IY,qNe,kSe,X2e,XNe,JNe,QNe,tTe,d2e,zA,rTe,SSe,ISe,CSe,aTe,oTe,uTe,dTe,pTe,fTe,gTe,rSe,bTe,STe,CTe,ETe,aSe,ATe,DTe,FTe,iSe,TNe,LTe,BTe,VTe,jTe,HTe,KTe,YTe,ZTe,uSe,QTe,dSe,pSe,t$e,r$e,a$e,o$e,u$e,ySe,iCe,d$e,p$e,m$e,y$e,v$e,w$e,q2e,E$e,A$e,D$e,WNe];for(const e of O$e)oq(e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hd={},$k={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function F$e(e,t){Hd[e]=t}function zo(e,t){if(!(e in Hd)||t!=null){const r=P$e(e,t);if(r!==null)Hd[e]=r;else return console.log("Could not get context for WebGL version",e),null}const n=Hd[e];return n==null||n.isContextLost()?(delete Hd[e],zo(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Hd[e])}function M$e(e){if(!_e().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function P$e(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=t??M$e(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Hd[e]},!1),_e().getBool("SOFTWARE_WEBGL_ENABLED")&&($k.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",$k)||n.getContext("experimental-webgl",$k):n.getContext("webgl2",$k)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var j1;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(j1||(j1={}));var ci;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(ci||(ci={}));var bs;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(bs||(bs={}));function Lx(e,t){return[t,e]}function L$e(e,t){return e*t}function Ek(e){const t=Me(e),n=Math.ceil(t/4);return oA(n)}function yy(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function z$e(e,t){const[n,r]=yy(e,t);return n*r*4}function rM(e,t){const n=e;let r,s,a,i,o,l,u,c,d,h;return _e().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=t!=null?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function st(e,t){const n=t();return _e().getBool("DEBUG")&&B$e(e),n}function B$e(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+j$e(e,t))}const W$e=596e-10,V$e=65504;function U$e(e){return!!(_e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||W$e<Math.abs(e)&&Math.abs(e)<V$e)}function j$e(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function _k(e,t){return Nu(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function G$e(e,t){const n=Nu(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(st(e,()=>e.shaderSource(n,t)),st(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function H$e(e,t){const n=Nu(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(st(e,()=>e.shaderSource(n,t)),st(e,()=>e.compileShader(n)),_e().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw CY(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const q$e=/ERROR: [0-9]+:([0-9]+):/g;function CY(e,t){const n=q$e.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}const r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,h)=>Km((h+1).toString(),a)+d);let o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);const l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${Km(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function K$e(e){return Nu(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function X$e(e,t){if(st(e,()=>e.linkProgram(t)),!_e().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function pE(e,t){if(st(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Y$e(e,t){const n=Nu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),st(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function J$e(e,t){const n=Nu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return st(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),st(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Z$e(e){return Nu(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function Q$e(e,t){const n=_e().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){const r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function eEe(e){return Nu(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function iU(e,t,n,r,s,a,i){const o=e.getAttribLocation(t,n);return o===-1?!1:(st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),st(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),st(e,()=>e.enableVertexAttribArray(o)),!0)}function tEe(e,t,n){iEe(e,n),st(e,()=>e.activeTexture(e.TEXTURE0+n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function nEe(e,t,n){return Nu(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function rEe(e,t,n){return e.getUniformLocation(t,n)}function sEe(e,t,n,r){st(e,()=>tEe(e,t,r)),st(e,()=>e.uniform1i(n,r))}function fE(e,t,n){st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),st(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function oU(e,t){st(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),st(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Ak(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+aEe(e,t))}function aEe(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Nu(e,t,n){const r=st(e,()=>t());if(r==null)throw new Error(n);return r}function iEe(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){const s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Ag(e,t=2){return Me(e.slice(0,e.length-t))}function Rg(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Rk(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[Ag(e),...Rg(e)]),t}function oEe(e,t=!1){let n=_e().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=_e().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&_e().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?xO(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=nd(e).newShape);let s=Me(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);const i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){const o=Ag(e);let l=2,u=2;e.length&&([l,u]=Rg(e)),s=o*(l/2)*(u/2),a=oA(s).map(c=>c*2)}else a=oA(s);return a}function Dk(e){return e%2===0}function MS(e,t){if(e=e.slice(-2),t=t.slice(-2),cn(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){const n=e[e.length-1],r=t[t.length-1];if(n===r||Dk(n)&&Dk(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Dk(e[0])&&Dk(t[0])}let mE,gE;function lEe(e){if(mE==null){const t=zo(e);mE=t.getParameter(t.MAX_TEXTURE_SIZE)}return mE}function uEe(e){if(gE==null){const t=zo(e);gE=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,gE)}function cEe(e){if(e===0)return 0;let t;const n=zo(e);return Gi(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:Gi(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function Gi(e,t){return e.getExtension(t)!=null}function lU(e){try{if(zo(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function dEe(e){if(e===0)return!1;const t=zo(e);if(e===1){if(!Gi(t,"OES_texture_float"))return!1}else if(!Gi(t,"EXT_color_buffer_float"))return!1;return WA(t)}function hEe(e){if(e===0)return!1;const t=zo(e);if(e===1){if(!Gi(t,"OES_texture_float")||!Gi(t,"WEBGL_color_buffer_float"))return!1}else{if(Gi(t,"EXT_color_buffer_float"))return WA(t);const r="EXT_color_buffer_half_float";if(Gi(t,r)){const s=t.getExtension(r);return pEe(t,s)}return!1}return WA(t)}function WA(e){const t=rM(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);const r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,r,s,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),i}function pEe(e,t){const n=rM(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r);const s=1,a=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,s,a,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const i=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(i),o}function fEe(e){return e!==2?!1:zo(e).fenceSync!=null}function zx(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&Y(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ft=_e();ft.registerFlag("HAS_WEBGL",()=>ft.getNumber("WEBGL_VERSION")>0);ft.registerFlag("WEBGL_VERSION",()=>lU(2)?2:lU(1)?1:0);ft.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ft.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ft.get("WEBGL_VERSION")===2);ft.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ft.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ft.registerFlag("WEBGL_PACK",()=>ft.getBool("HAS_WEBGL"));ft.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_CLIP",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_REDUCE",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_LAZILY_UNPACK",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_CONV_IM2COL",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>ft.getBool("WEBGL_PACK"));ft.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>lEe(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>uEe(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const e=ft.getNumber("WEBGL_VERSION");return e===0?0:cEe(e)});ft.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ft.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Iq());ft.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>dEe(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ft.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ft.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ft.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>hEe(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_FENCE_API_ENABLED",()=>fEe(ft.getNumber("WEBGL_VERSION")));ft.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ft.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ft.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});ft.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Iq()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});ft.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ft.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ft.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ft.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);ft.registerFlag("WEBGL_EXP_CONV",()=>!1);ft.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>ft.getBool("IS_TEST"));ft.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);ft.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);ft.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);ft.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sa(){let e,t,n,r,s,a,i,o,l,u;return _e().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=_e().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(e,t,n="index"){const r=kt(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function wN(e,t,n="index"){const r=kt(t);return r.map((s,a)=>{const i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function mEe(e,t){const n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function gEe(e,t,n="index"){const r=e.map((a,i)=>i),s=mEe(r,t);return s.map((a,i)=>{const o=`int ${e[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${l};`}).join("")}function sM(e){const t=kt(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function aM(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const NY=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:TY}=s0e;function yEe(e,t,n){const r=[];if(e.forEach(p=>{const f=Me(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?r.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(r.push(`uniform sampler2D ${p.name};`),r.push(`uniform int offset${p.name};`)),n.enableShapeUniforms){const{uniformShape:m}=iM(n.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:r.push(`uniform int ${p.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${p.name}Shape;`);break}r.push(`uniform ivec2 ${p.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(p=>{r.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const s=r.join(`
`),a=e.map(p=>bEe(p,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=sa(),l=wEe(o);let u,c,d=IEe(o);return t.isPacked?(u=vEe(t.logicalShape,i,n.enableShapeUniforms),c=SEe(o)):(u=xEe(t.logicalShape,i,n.enableShapeUniforms),c=kEe(o)),n.packedInputs&&(d+=$Ee),[d,l,c,s,u,a,n.userCode].join(`
`)}function by(e,t=!1){const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return BEe(e,t);case 1:return VEe(e,t);case 2:return jEe(e,t);case 3:return HEe(e,t);case 4:return KEe(e,t);case 5:return XEe(e);case 6:return YEe(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function $Y(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return zEe(e);case 1:return WEe(e,t);case 2:return UEe(e,t);case 3:return GEe(e,t);default:return qEe(e,t)}}function bEe(e,t,n=!1,r){let s="";n?s+=$Y(e,r):s+=by(e,r);const a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=JEe(e,t):s+=ZEe(e,t)),s}function vEe(e,t,n){switch(e.length){case 0:return EY();case 1:return EEe(e,t,n);case 2:return PEe(e,t,n);case 3:return AEe(e,t,n);default:return DEe(e,t,n)}}function xEe(e,t,n){switch(e.length){case 0:return EY();case 1:return _Ee(e,t,n);case 2:return LEe(e,t,n);case 3:return REe(e,t,n);case 4:return OEe(e,t,n);case 5:return FEe(e,t);case 6:return MEe(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function wEe(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function kEe(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function SEe(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function IEe(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${CEe}
    ${NEe}
    ${TEe}
  `}const CEe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,NEe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,TEe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,$Ee=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function EY(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function EEe(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function _Ee(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function AEe(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function REe(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${wN(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;const r=kp(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function DEe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2);let i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function OEe(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${wN(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;const r=kp(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function FEe(e,t){const n=kp(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function MEe(e,t){const n=kp(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function PEe(e,t,n){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(cn(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function LEe(e,t,n){return cn(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function Sp(e){return`offset${e}`}function zEe(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=sa();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function BEe(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const i=Sp(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;const[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function WEe(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=sa();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;const i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function VEe(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${vy(e)}
      }
    `;const s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=Sp(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function UEe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=sa();if(a!=null&&cn(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function jEe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&cn(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const h=a[0],p=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:i,keptDims:o}=nd(n),l=i;if(l.length<n.length){const h=xy(e,l),p=["row","col"];return`
      ${by(h,t)}
      float ${s}(int row, int col) {
        return ${s}(${wy(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${vy(e)}
      }
    `;const u=a[0],c=a[1],d=Sp(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function GEe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){const h=n.slice(1),p=[1,2],f=xy(e,h),m=["b","row","col"];return`
        ${$Y(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${wy(m,p)});
        }
      `}const o=sa();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;const l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function HEe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=nd(n),u=o;if(u.length<n.length){const m=xy(e,u),g=["row","col","depth"];return`
        ${by(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${wy(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${vy(e)}
      }
    `;const c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===a&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===i&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const f=Sp(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function qEe(e,t){const n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=sa();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;const a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2);let h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function KEe(e,t){const n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=nd(n);if(l.length<n.length){const b=xy(e,l),x=["row","col","depth","depth2"];return`
      ${by(b,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${wy(x,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${vy(e)}
      }
    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=Sp(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function XEe(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=nd(t);if(l.length<t.length){const m=xy(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${by(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${wy(g,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${vy(e)}
      }
    `;const c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const f=Sp(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function YEe(e){const t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=nd(t);if(s.length<t.length){const g=xy(e,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${by(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${wy(y,a)});
      }
    `}const i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${vy(e)}
      }
    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;const m=Sp(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function vy(e){const t=e.name,n=Me(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function JEe(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=TY(e.shapeInfo.logicalShape,t.logicalShape),l=Cn(i),u=i-a;let c;const d=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(b=>`coords.${d[b+u]} = 0;`).join(`
`);let h="";i<2&&a>0?h="coords":h=e.shapeInfo.logicalShape.map((b,x)=>`coords.${d[x+u]}`).join(", ");let p="return outputValue;";const m=Me(e.shapeInfo.logicalShape)===1,y=Me(t.logicalShape)===1;if(a===1&&!m&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){const b=a-2,x=a-1;o.indexOf(b)>-1&&o.indexOf(x)>-1?p="return vec4(outputValue.x);":o.indexOf(b)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(x)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${h});
      ${p}
    }
  `}function ZEe(e,t){const n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&cn(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const u=Cn(l),c=TY(e.shapeInfo.logicalShape,t.logicalShape),d=l-o;let h;const p=["x","y","z","w","u","v"];o===0?h="":l<2&&c.length>=1?h="coords = 0;":h=c.map(m=>`coords.${p[m+d]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function Cn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function iM(e,t,n){const{newShape:r,keptDims:s}=nd(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&a>1&&!cn(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function xy(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function wy(e,t){return t.map(n=>e[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QEe(e,t,n,r){const s=n.map((c,d)=>{const h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),a=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=yEe(s,i,t),l=H$e(e.gl,o),u=e.createProgram(l);return _e().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},_Y(e,t,u)))}function _Y(e,t,n){const r=[],s=[];let a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),_e().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const d of t.variableNames){const h={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(h.shape=e.getUniformLocation(n,`${d}Shape`,c),h.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(h)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function uU(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{const s=n.logicalShape,a=t[r],i=a.shape;if(!cn(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;const o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!cn(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function e_e(e,t,n,r,s){t.program.enableShapeUniforms||(uU(t.inShapeInfos,n),uU([t.outShapeInfo],[r]));const a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),_e().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const u=n[l],{uniform:c,offset:d,shape:h,texShape:p}=t.variablesLocations[l];if(h){const{uniformShape:f}=iM(t.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(h,new Int32Array(f));break;case 2:e.gl.uniform2iv(h,new Int32Array(f));break;case 3:e.gl.uniform3iv(h,new Int32Array(f));break;case 4:e.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(Me(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}const o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){const l=kt(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){const u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=s[l];if(u.type==="float")e.gl.uniform1fv(c,d);else if(u.type==="vec2")e.gl.uniform2fv(c,d);else if(u.type==="vec3")e.gl.uniform3fv(c,d);else if(u.type==="vec4")e.gl.uniform4fv(c,d);else if(u.type==="int")e.gl.uniform1iv(c,d);else if(u.type==="ivec2")e.gl.uniform2iv(c,d);else if(u.type==="ivec3")e.gl.uniform3iv(c,d);else if(u.type==="ivec4")e.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function t_e(e,t,n){let r="";t.concat(n).forEach(i=>{const o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){const l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=iM(e.packedInputs,i.shape,l);let h="",p="",f="";if(c.length===1&&e.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(c.length===2&&!e.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){const w=kt(c);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}const m=i.shape.length,g=c.length===2&&cn(i.shape,l),y=Me(i.shape)===1,b=Ig(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&cn(l,n.texData.texShape),v=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${u?d:""}_${c.length}_${y}_${b}_${g}_${h}_${p}_${f}_${v}_${o}`}else{const l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});const s=e.userCode;let a=e.constructor.name;return a+="_"+r+"_"+s+`${_e().getNumber("WEBGL_VERSION")}`,a}function Ls(e){return _e().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n_e{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=j1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=sa();this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wN(["r","c","d"],t):kp(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class r_e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=j1.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=sa();this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?wN(["r","c","d"],t):kp(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s_e{constructor(t){this.variableNames=["A"],this.outTexUsage=ci.DOWNLOAD;const n=sa();this.outputShape=t,this.userCode=`
      ${NY}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a_e{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ci.DOWNLOAD;const n=sa();this.outputShape=t,this.userCode=`
      ${NY}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i_e={R:0,G:1,B:2,A:3};class cU{constructor(t,n=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=sa();this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length);let a="result";n&&(a="floor(result * 255. + 0.5)");let i="";for(let o=0;o<r.length;o++){const l=r[o];i+=`
          if(offset == ${o}) {
            result = values[${i_e[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?aM():sM(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${s.texture2D}(A, uv);
          ${i}
        }
        ${s.output} = vec4(${a}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o_e{constructor(t,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=sa();this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length);let s="",a="result";n&&(a="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let o=0;o<=1;o++){const l=i*2+o;s+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?aM():sM(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${s}

          ${r.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_e(e){const t=sa(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return G$e(e,n)}function u_e(e){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Y$e(e,t)}function c_e(e){const t=new Uint16Array([0,1,2,2,1,3]);return J$e(e,t)}function Bx(e,t,n,r,s,a){Q$e(t,n);const i=Z$e(e),o=e.TEXTURE_2D;return st(e,()=>e.bindTexture(o,i)),st(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),st(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),st(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),st(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),_e().getNumber("WEBGL_VERSION")===1?st(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):st(e,()=>e.texStorage2D(o,1,r,t,n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function AY(e){return e.internalFormatFloat}function d_e(e,t,n,r){const[s,a]=Lx(t,n);return Bx(e,s,a,AY(r),r.textureFormatFloat,e.FLOAT)}function RY(e){return e.internalFormatHalfFloat}function h_e(e,t,n,r){const[s,a]=Lx(t,n);return Bx(e,s,a,RY(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function DY(e){return e.downloadTextureFormat}function p_e(e,t,n,r){const[s,a]=Lx(t,n);return Bx(e,s,a,DY(r),e.RGBA,e.UNSIGNED_BYTE)}function OY(e){return e.internalFormatPackedFloat}function f_e(e,t,n,r){const[s,a]=yy(t,n);return Bx(e,s,a,OY(r),e.RGBA,e.FLOAT)}function FY(e){return e.internalFormatPackedHalfFloat}function m_e(e,t,n,r){const[s,a]=yy(t,n);return Bx(e,s,a,FY(r),e.RGBA,r.textureTypeHalfFloat)}function g_e(e,t,n){return st(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),iU(e,t,"clipSpacePos",n,3,20,0)&&iU(e,t,"uv",n,2,20,12)}function y_e(e,t,n,r,s,a){st(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),_e().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function b_e(e,t,n){st(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?_e().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):_e().getNumber("WEBGL_VERSION")===2?st(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):st(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),st(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function v_e(e,t,n,r){const s=e.createBuffer();st(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));const o=4*4*t*n;return st(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,o,e.STREAM_READ)),st(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),st(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function x_e(e,t,n){const r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function w_e(e,t,n,r){const[s,a]=Lx(t,n),i=4,o=new Uint8Array(L$e(t*n,i));return st(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function k_e(e,t,n,r,s,a,i,o){const l=e,u=new Float32Array(z$e(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function S_e(e,t,n){const r=new Float32Array(t*n*4);return st(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yE{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const n=_e().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,F$e(n,t)):this.gl=zo(n),t=this.gl,_e().getNumber("WEBGL_VERSION")===2){const a=t;this.createVertexArray=()=>st(a,()=>a.createVertexArray()),this.bindVertexArray=i=>st(a,()=>a.bindVertexArray(i)),this.deleteVertexArray=i=>st(a,()=>a.deleteVertexArray(i)),this.getVertexArray=()=>st(a,()=>a.getParameter(a.VERTEX_ARRAY_BINDING))}else if(t!=null){const a=t.getExtension("OES_vertex_array_object");if(a==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>st(t,()=>a.createVertexArrayOES()),this.bindVertexArray=i=>st(t,()=>a.bindVertexArrayOES(i)),this.deleteVertexArray=i=>st(t,()=>a.deleteVertexArrayOES(i)),this.getVertexArray=()=>st(t,()=>t.getParameter(a.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),_e().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=_k(this.gl,a),Gi(this.gl,i))this.textureHalfFloatExtension=_k(this.gl,i);else if(_e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Gi(this.gl,s))this.colorBufferHalfFloatExtension=_k(this.gl,s);else if(_e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Gi(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Gi(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=u_e(this.gl),this.indexBuffer=c_e(this.gl),this.framebuffer=eEe(this.gl),this.textureConfig=rM(this.gl,this.textureHalfFloatExtension)}get debug(){return _e().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;st(t,()=>t.finish()),st(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),st(t,()=>t.deleteFramebuffer(this.framebuffer)),st(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),st(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),st(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,n){return this.throwIfDisposed(),d_e(this.gl,t,n,this.textureConfig)}createFloat16MatrixTexture(t,n){return this.throwIfDisposed(),h_e(this.gl,t,n,this.textureConfig)}createUnsignedBytesMatrixTexture(t,n){return this.throwIfDisposed(),p_e(this.gl,t,n,this.textureConfig)}uploadPixelDataToTexture(t,n){this.throwIfDisposed(),b_e(this.gl,t,n)}uploadDenseMatrixToTexture(t,n,r,s){this.throwIfDisposed(),y_e(this.gl,t,n,r,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,n){return this.throwIfDisposed(),m_e(this.gl,t,n,this.textureConfig)}createPackedMatrixTexture(t,n){return this.throwIfDisposed(),f_e(this.gl,t,n,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(oU(this.gl,this.framebuffer),this.outputTexture=null),st(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,n,r){return this.downloadMatrixDriver(t,()=>w_e(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,n,r,s,a,i){return k_e(this.gl,t,n,r,s,a,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,n){return x_e(this.gl,t,n)}createBufferFromTexture(t,n,r){this.bindTextureToFrameBuffer(t);const s=v_e(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let n,r;if(_e().getBool("WEBGL_FENCE_API_ENABLED")){const s=t,a=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const i=s.clientWaitSync(a,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},n=a}else _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(t,n,r){return this.downloadMatrixDriver(t,()=>S_e(this.gl,n,r))}createProgram(t){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=l_e(n));const r=K$e(n);st(n,()=>n.attachShader(r,this.vertexShader)),st(n,()=>n.attachShader(r,t)),X$e(n,r);const s=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&pE(n,s),s}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const n=this.gl;st(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),g_e(n,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(st(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&pE(this.gl,this.program),st(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,n,r=!0){return this.throwIfDisposed(),r?nEe(this.gl,t,n):rEe(this.gl,t,n)}getAttributeLocation(t,n){return this.throwIfDisposed(),st(this.gl,()=>this.gl.getAttribLocation(t,n))}getUniformLocationNoThrow(t,n){return this.throwIfDisposed(),this.gl.getUniformLocation(t,n)}setInputMatrixTexture(t,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),sEe(this.gl,t,n,r)}setOutputMatrixTexture(t,n,r){this.setOutputMatrixTextureDriver(t,r,n)}setOutputPackedMatrixTexture(t,n,r){this.throwIfDisposed();const[s,a]=yy(n,r);this.setOutputMatrixTextureDriver(t,s,a)}setOutputMatrixWriteRegion(t,n,r,s){this.setOutputMatrixWriteRegionDriver(r,t,s,n)}setOutputPackedMatrixWriteRegion(t,n,r,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&pE(this.gl,this.program),Ak(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const n=this.getVertexArray();console.assert(n===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}st(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),st(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=_k(this.gl,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.createQuery();return r.beginQuery(s.TIME_ELAPSED_EXT,a),a}const t=this.getQueryTimerExtensionWebGL1(),n=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,n),n}endQuery(){if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await XW(()=>this.disposed||this.isQueryAvailable(t,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,n){if(n===0)return!0;if(n===2){const r=this.gl,s=this.getQueryTimerExtensionWebGL2(),a=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),s=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(n=>{this.addItemToPoll(()=>t.isFencePassed(),()=>n())})}pollItems(){const t=I_e(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=t;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,n){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in _e().platform&&(r=_e().platform.setTimeoutCustom.bind(_e().platform)),XW(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),fE(this.gl,t,this.framebuffer),this.debug&&Ak(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(fE(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ak(this.gl)):oU(this.gl,this.framebuffer)}downloadMatrixDriver(t,n){this.bindTextureToFrameBuffer(t);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,n,r){this.throwIfDisposed();const s=this.gl;fE(s,t,this.framebuffer),this.debug&&Ak(s),this.outputTexture=t,st(s,()=>s.viewport(0,0,n,r)),st(s,()=>s.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(t,n,r,s){this.throwIfDisposed(),st(this.gl,()=>this.gl.scissor(t,n,r,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function I_e(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:C_e,bincountImpl:MY,bincountReduceImpl:N_e,bitwiseAndImpl:T_e,castImpl:$_e,ceilImpl:E_e,concatImpl:__e,equalImpl:A_e,expImpl:R_e,expm1Impl:D_e,floorImpl:O_e,gatherNdImpl:F_e,gatherV2Impl:M_e,greaterImpl:P_e,greaterEqualImpl:L_e,lessImpl:z_e,lessEqualImpl:B_e,linSpaceImpl:W_e,logImpl:V_e,maxImpl:U_e,maximumImpl:j_e,minimumImpl:G_e,multiplyImpl:H_e,negImpl:q_e,notEqualImpl:K_e,prodImpl:X_e,raggedGatherImpl:Y_e,raggedRangeImpl:J_e,raggedTensorToTensorImpl:Z_e,rangeImpl:Q_e,rsqrtImpl:eAe,scatterImpl:tAe,sigmoidImpl:nAe,simpleAbsImpl:PY,sliceImpl:rAe,sparseFillEmptyRowsImpl:sAe,sparseReshapeImpl:aAe,sparseSegmentReductionImpl:LY,sqrtImpl:iAe,staticRegexReplaceImpl:oAe,stridedSliceImpl:lAe,stringNGramsImpl:uAe,stringSplitImpl:cAe,stringToHashBucketFastImpl:dAe,subImpl:hAe,tileImpl:pAe,topKImpl:fAe,transposeImpl:oM,uniqueImpl:mAe}=bSe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zY(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function qs(e,t){return t===1?[e]:zY(e,t)}function gAe(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yAe{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Ls(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=qs("rc",this.rank),r=Cn(this.rank),s=this.getOutOfBoundsCondition(n),a=this.getSetup(n),i=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(t){const n=[];for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){let a=`${r===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)a=`${t[t.length-1-i]},`+a;n.push(a)}return n}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(t){if(this.rank===1)return"";const n=t.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${s};
    `}getOutput(t){const n=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BY{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length);let r="";for(let s=0;s<4;s++){let a="thisRC = rc;";s%2===1&&(a+="thisRC.z += 1;"),s>1&&(a+="thisRC.y += 1;"),r+=`
        ${a}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${bAe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?aM():sM(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${r}

        setOutput(result);
      }
    `}}function bAe(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?gEe(["r","c","d"],"inputShape"):kp(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vAe{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,n,r){const s=hU(n,r),a=pU(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const i=dU(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const l=this.freeTextures[a].pop();return this.usedTextures[a].push(l),l}let o;return s===bs.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===bs.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===bs.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===bs.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===bs.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[a].push(o),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),o}releaseTexture(t,n,r,s){if(this.freeTextures==null)return;const a=hU(r,s),i=pU(n,a,s);i in this.freeTextures||(this.freeTextures[i]=[]);const o=dU(n,a,this.gpgpu.gl,this.gpgpu.textureConfig,s),l=_e().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=o):(this.freeTextures[i].push(t),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const u=this.usedTextures[i],c=u&&u.indexOf(t);if(c==null||c<0)throw new Error("Cannot release a texture that was never provided by this texture manager");u[c]=u[u.length-1],u.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function xAe(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function dU(e,t,n,r,s){const a=wAe(t,r);let i;if(s){const[l,u]=yy(e[0],e[1]);i=l*u}else{const[l,u]=Lx(e[0],e[1]);i=l*u}const o=xAe(n,a);return i*o}function wAe(e,t){switch(e){case bs.PACKED_2X2_FLOAT32:return OY(t);case bs.PACKED_2X2_FLOAT16:return FY(t);case bs.UNPACKED_FLOAT32:return AY(t);case bs.UNPACKED_FLOAT16:return RY(t);case bs.PACKED_4X1_UNSIGNED_BYTE:return DY(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function kAe(e){return _e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?bs.PACKED_2X2_FLOAT32:bs.UNPACKED_FLOAT32:e?bs.PACKED_2X2_FLOAT16:bs.UNPACKED_FLOAT16}function hU(e,t){if(e===ci.UPLOAD)return bs.PACKED_2X2_FLOAT32;if(e===ci.RENDER||e==null)return kAe(t);if(e===ci.DOWNLOAD||e===ci.PIXELS)return bs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function pU(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fl{constructor(t,n){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const so="if (isnan(x)) return x;",SAe="return x;",fU="return abs(x);",IAe="return (x >= 0.0) ? x : (exp(x) - 1.0);",CAe=so+`
  return (x < 0.0) ? 0.0 : x;
`,NAe=so+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,qu="return x;",TAe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ae="return x;",EAe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,_Ae=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,AAe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,RAe="return 1.0 / (1.0 + exp(-1.0 * x));";class sc{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DAe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length);const n=t.length,r=qs("rc",n),s=Cn(n),a=gAe(n,r),i=r.slice(-2),o=n<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OAe=c9,FAe=1e-7,MAe=1e-4,Ok={};function PAe(e){return e in Ok||(Ok[e]={}),Ok[e]}const LAe=_e().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),zAe=600;function BAe(){return _e().global.screen==null?1024:_e().global.screen.height*_e().global.screen.width*window.devicePixelRatio*zAe/1024/1024}class kN extends vO{nextDataId(){return kN.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!_e().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof yE)n=t;else{const r=zo(_e().getNumber("WEBGL_VERSION"),t);n=new yE(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=zo(_e().getNumber("WEBGL_VERSION"));n=new yE(r),this.binaryCache=PAe(_e().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new vAe(this.gpgpu),this.numMBBeforeWarning=BAe(),this.texData=new R8(this,rl())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,s,a,i){const o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[s,a]},l.texShape=[s,a];const u=Rk(n),c=new cU(u,!1,i),d=this.runWebGLProgram(c,[o],r,[[s,a]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if((_e().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||_e().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:ci.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){const n=this.texData.get(t);n.refCount--}}move(t,n,r,s,a){if(_e().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:ci.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=n;if(i!=null){let h;l?h=new sc(o,qu):h=new fl(o,qu);const p=this.runWebGLProgram(h,[{dataId:t,shape:o,dtype:s}],s),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;const u=this.activeTimers!=null;let c;u&&(c=ca());let d;if(s==="complex64"){const h=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);d=mu(h,p)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=ca()-c),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}const n=this.texData.get(t),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(a!=null){let f;l?f=new sc(s,qu):f=new fl(s,qu);const m=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(_e().getBool("DEBUG")&&!_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&_e().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&_e().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);const f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...Ek(s))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){const f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];d=mu(m,g)}else if(u==null)d=this.getValuesFromTexture(t);else{const f=Me(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){const f=this.gpgpu.gl;st(f,()=>f.deleteBuffer(u))}const h=this.convertAndCacheOnCPU(t,d),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(h)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&rl().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,n={}){const r=this.texData.get(t),{values:s,shape:a,slice:i,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new sc(a,qu):p=new fl(a,qu);const f=this.runWebGLProgram(p,[{dataId:t,shape:a,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const c=this.decode(t,n.customTexShape),d=rl().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string")try{const r=n.map(s=>Ac(s));return Gt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Gt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){const r=t[n];if(!U$e(r))throw _e().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:n,dtype:r,isPacked:s}=this.texData.get(t),a=Me(n);if(_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const h=this.decode(t),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Ek(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(h),f}const i=_e().getBool("WEBGL_PACK")&&s===!0,o=i?Rk(n):n,l=i?new a_e(o):new s_e(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const n=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();const a=Eh(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Eh(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(a);o.kernelMs=ofe(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ca(),endMs:null}}endTimer(t){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=ca(),t)}async getQueryTime(t){if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));const c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=LAe){return _e().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&Me(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){li("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=t.dataSync();return OAe(t.shape,n)}packedUnaryOp(t,n,r){const s=new sc(t.shape,n),a=this.compileAndRun(s,[t],r);return rl().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const s=PY(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(_e().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,fU,t.dtype);const n=new fl(t.shape,fU),r=this.compileAndRun(n,[t]);return rl().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&C0(r[0])){const a=r.map(i=>wc(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){return rl().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){const n=new DAe(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){const n=new yAe(t.shape),r=!0;return this.runWebGLProgram(n,[t],t.dtype,null,r)}packedReshape(t,n){const r=[Ag(t.shape),...Rg(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[Ag(n),...Rg(n)],i=new BY(a,r),o=!0,l=[r],u=this.runWebGLProgram(i,[s],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){const r=this.texData.get(t),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){const h=Me(a),p=n[0]*n[1]*4;Y(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=Rk(a);let l;s?l=new r_e(o):l=new n_e(o);const u=!0,c=[n??Ek(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,c,u,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,r,s,a=!1,i){const o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===j1.DENSE){const y=i??Ek(t.outputShape);l.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),Me(o.shape)===0)return l.values=Ds(o.dtype,0),o;const u=[],c=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&Me(y.shape)<=_e().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!MS(b.shape,y.shape)){const x=y,v=y.shape;y.shape=b.shape,y=this.packedReshape(y,v),u.push(y),b=this.texData.get(y.dataId),x.shape=v}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);const d={shape:o.shape,texData:l,isUniform:!1},h=t_e(t,c,d),p=this.getAndSaveBinary(h,()=>QEe(this.gpgpu,t,c,d)),f=this.activeTimers!=null;let m;f&&(m=this.startTimer()),_e().get("ENGINE_COMPILE_ONLY")||e_e(this.gpgpu,p,c,d,s),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));const g=_e().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const y=ca();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!_e().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){const y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(t,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(_e().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Ee(()=>{if(!_e().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=_e().getBool("DEBUG");_e().set("DEBUG",!1);const n=this.abs(un(1e-8)).dataSync()[0];if(_e().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?FAe:MAe}uploadToGPU(t){const n=this.texData.get(t),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;const u=this.activeTimers!=null;let c;u&&(c=ca());let d=n.texShape;if(d==null&&(d=oEe(r,l),n.texShape=d),a!=null){const h=Rk(r);let p,f=d[1],m=d[0];const g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!g)&&([f,m]=yy(d[0],d[1])),l?p=new o_e(h,g):p=new cU(h,g);const y=g?[m,f]:d,b=this.makeTensorInfo(y,s),x=this.texData.get(b.dataId);g?x.usage=ci.PIXELS:x.usage=ci.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,a);const v=[[m,f]],w=!0,k=this.runWebGLProgram(p,[b],s,v,w),S=this.texData.get(k.dataId);n.texShape=S.texShape,n.isPacked=S.isPacked,n.usage=S.usage,_e().get("ENGINE_COMPILE_ONLY")?this.disposeData(k.dataId):(n.texture=S.texture,n.values=null,this.texData.delete(k.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=ca()-c)}else{const h=this.acquireTexture(d,o,s,l);n.texture=h}}convertAndCacheOnCPU(t,n){const r=this.texData.get(t),{dtype:s}=r;return n!=null&&(r.values=WAe(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*lS(n)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await E9(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(CY(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=_Y(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=s,t.nanLoc=a,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";const{texture:s,height:a,width:i,channels:o}=t,l=rl().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const u=l.writeTexture(s,n,r,a,i,o);return rl().makeTensorFromDataId(u,n,r,l)}}kN.nextDataId=0;function WAe(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){const n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Cq()&&$q("webgl",()=>new kN,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lM=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Wh{constructor(t,n,r){this.variableNames=["A","B"],this.outputShape=Ot(n,r),this.enableShapeUniforms=Ls(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ip=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class ky{constructor(t,n,r,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ot(n,r);const a=this.outputShape.length;this.enableShapeUniforms=Ls(a);let i="";if(s)if(a===0||Me(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${Cn(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=qs("coords",a);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${l[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${l[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ja(e){const{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const VAe={kernelName:H0,backendName:"webgl",kernelFunc:Ja};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hd(e){const{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=Ja({inputs:{x:r},backend:n}),l=Ja({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}const UAe={kernelName:RO,backendName:"webgl",kernelFunc:hd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WY="return (a < 0.) ? b * a : a;",VY=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function jAe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",rd(a,"float32")),o=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ky(VY,s.shape,i.shape):new Wh(WY,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}const GAe={kernelName:yC,backendName:"webgl",kernelFunc:jAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UY="return (a < 0.) ? b * a : a;",jY=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function HAe(e){const{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ky(jY,r.shape,s.shape):new Wh(UY,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}const qAe={kernelName:MC,backendName:"webgl",kernelFunc:HAe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sy="if (isnan(x)) return x;";function en({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{const{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){const d=o.texData.get(i.dataId),h=n(d.values,l);return o.makeTensorInfo(i.shape,l,h)}const u=_e().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let c;return u?c=new sc(i.shape,t):c=new fl(i.shape,e),o.runWebGLProgram(c,[i],l)}}function Ts({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{const{a:l,b:u}=i,c=o;if(r&&l.dtype==="complex64"){const f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{const[v,w]=x,k={dataId:v.dataId,dtype:v.dtype,shape:l.shape},S={dataId:w.dataId,dtype:w.dtype,shape:u.shape},I=new Wh(e,l.shape,u.shape);return c.runWebGLProgram(I,[k,S],Xa(v.dtype,w.dtype))}),b=hd({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}const d=a||Xa(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){const f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?gu(f):f,y=l.dtype==="string"?gu(m):m,[b,x]=s(l.shape,u.shape,g,y,d),v=c.makeTensorInfo(x,d),w=c.texData.get(v.dataId);return w.values=b,v}const h=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let p;return h?p=new ky(t,l.shape,u.shape,n):p=new Wh(e,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function G1(e,t=!1){if(e==="linear")return t?$Ae:SAe;if(e==="relu")return t?_Ae:CAe;if(e==="elu")return t?EAe:IAe;if(e==="relu6")return t?AAe:NAe;if(e==="prelu")return t?jY:UY;if(e==="leakyrelu")return t?VY:WY;if(e==="sigmoid")return t?RAe:TAe;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GY{constructor(t,n,r,s=!1,a=!1,i=!1,o=null,l=!1,u=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Ls(this.outputShape.length);const c=s?t[1]:t[2],d=Math.ceil(c/2),h=s?"i * 2, rc.y":"rc.y, i * 2",p=a?"rc.z, i * 2":"i * 2, rc.z",f=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";o&&(l?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:u?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:g=`vec4 activation(vec4 x) {
          ${o}
        }`,y="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),u&&this.variableNames.push("leakyreluAlpha");let x="rc.x",v="rc.x";t[0]<n[0]?x=`imod(rc.x, ${t[0]})`:n[0]<t[0]&&(v=`imod(rc.x, ${n[0]})`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${v};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${h});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mU={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class gU{constructor(t,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ot(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yU="return a * b;";function uM(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=Xa(r.dtype,s.dtype);if(r.dtype==="complex64"){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new gU(mU.REAL,r.shape,s.shape),c=new gU(mU.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=hd({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,s])){const o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=H_e(r.shape,s.shape,o.values,l.values,a),d=n.makeTensorInfo(c,a),h=n.texData.get(d.dataId);return h.values=u,d}let i;return _e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new ky(yU,r.shape,s.shape):i=new Wh(yU,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}const KAe={kernelName:tx,backendName:"webgl",kernelFunc:uM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XAe(e,t,n){const r=[Ag(e.shape),...Rg(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[Ag(t),...Rg(t)],i=new BY(a,r),o=!0,l=[r],u=n.runWebGLProgram(i,[s],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ze(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=Me(s.shape),l=O8(a,o),u=Me(l);Y(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const c=i.texData.get(s.dataId);return c.isPacked&&!MS(s.shape,l)&&!(c.texture!==null&&MS(c.shape,l))?XAe(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}const YAe={kernelName:LC,backendName:"webgl",kernelFunc:Ze};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bU{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];const o=Math.floor(r/4)*4,l=r%4;let u="sumValue += dot(values, ones);";if(n!=null){const d=1/n;u=`sumValue += dot(values * ${xg(d)?d.toPrecision(2):d}, ones);`}let c="";a%r>0&&(c=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${c}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${u}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${u}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${u}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${u}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JAe{constructor(t,n){this.variableNames=["x"];const{windowSize:r,batchSize:s,inSize:a,outSize:i}=t;this.outputShape=[s,i];let o="0.0",l="";n==="prod"?o="1.0":n==="min"?(o="1.0 / 1e-20",l="min"):n==="max"&&(o="-1.0 / 1e-20",l="max");let u=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?u="sumValue":n==="prod"?u="prodValue":n==="all"?u="allValue":n==="any"&&(u="anyValue");const c=Math.floor(r/4)*4,d=r%4;let h=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";n==="all"?(o="1.0",h=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):n==="any"&&(o="0.0",h=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${h}
        } else if (${d===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${h}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZAe(e){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const n=t.length?t[t.length-1].outSize:e[1],r=iN(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function Cp(e,t,n,r){const s=ZAe(e.shape);let a=e;for(let i=0;i<s.length;i++){const{inSize:o,windowSize:l,outSize:u}=s[i];let c,d;n==="mean"?c=i===0?new bU({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new bU({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new JAe({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QAe{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[n[i]];this.outputShape=r,this.rank=r.length;const s=Cn(this.rank),a=eRe(n);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function eRe(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tRe{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let c=0;c<r.length;c++)r[c]=t[n[c]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=Cn(this.rank),a=zY("rc",this.rank),i=new Array(this.rank);for(let c=0;c<n.length;c++)i[n[c]]=a[c];const o=`vec2(${i.slice(-2).join()})`,l=`++${a[this.rank-1]} < ${r[this.rank-1]}`,u=`getChannel(getA(${i.join()}), ${o})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${u};
      if(${l}) {
        result[1] = ${u};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${u};
        if(${l}) {
          result[3] = ${u};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(e,t,n){const r=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tRe(e.shape,t):new QAe(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nRe(e,t,n,r){const s=t,a=e.shape.length,i=Ht(s,e.shape);let o=i;const l=lr(o,a),u=l!=null;let c=e;u&&(c=SN(e,l,r),o=vr(o.length,a)),Ns("sum",o,a);const[d,h]=ps(c.shape,o);let p=d;n&&(p=Ar(d,i));const f=Me(h),g=Me(e.shape)/f,y=Ze({inputs:{x:c},attrs:{shape:[g,f]},backend:r}),b=pF(e.dtype),x=Cp(y,b,"sum",r),v=Ze({inputs:{x},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(x),u&&r.disposeIntermediateTensorInfo(c),v}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return nRe(s,a,i,n)}const rRe={kernelName:jC,backendName:"webgl",kernelFunc:IN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ea(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){const d=i.texData.get(s.dataId).values,h=oM(d,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);const p=i.texData.get(u.dataId);p.values=h}else u=SN(s,a,i);return u}const sRe={kernelName:Xm,backendName:"webgl",kernelFunc:ea};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HY=1e3;function PS({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){const u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=Me(m),b=Me(g),v=Ot(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);Y(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);const w=n?[y,d,p]:[y,p,d],k=r?[b,f,h]:[b,h,f],S=Ze({inputs:{x:e},backend:s,attrs:{shape:w}}),I=Ze({inputs:{x:t},backend:s,attrs:{shape:k}}),$=[S,I],C=Math.max(y,b),T=n?S.shape[1]:S.shape[2],N=a!=null,E=i!=null,_=l==="leakyrelu",R=l!=null?G1(l,!0):null,z=N||E||_||R!=null;let W;if((p===1||f===1)&&T>HY&&z===!1){let L=S,O=I;n&&(L=ea({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),$.push(L)),r&&(O=ea({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),$.push(O));const D=f!==1,B=f===1;let V=L;D&&(V=Ze({inputs:{x:L},backend:s,attrs:{shape:[C,T,1]}}),$.push(V));const K=f===1?2:1;let G=O;B&&(G=Ze({inputs:{x:O},backend:s,attrs:{shape:[C,1,T]}}),$.push(G));const U=uM({inputs:{a:V,b:G},backend:s});W=IN({inputs:{x:U},backend:s,attrs:{axis:K,keepDims:!0}}),$.push(U)}else{const L=Xa(e.dtype,t.dtype),O=new GY(w,k,[C,p,f],n,r,N,R,E,_),D=[S,I];if(a!=null&&D.push(a),E&&D.push(i),_){const B=s.makeTensorInfo([],"float32",rd(o,"float32"));D.push(B),$.push(B)}W=s.runWebGLProgram(O,D,L)}const F=Ze({inputs:{x:W},backend:s,attrs:{shape:v}});$.push(W);for(const L of $)s.disposeIntermediateTensorInfo(L);return F}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aRe(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return PS({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}const iRe={kernelName:uS,backendName:"webgl",kernelFunc:aRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vU="return abs(x);";function oRe(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const a=n.texData.get(r.dataId),i=PY(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return _e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new sc(r.shape,vU):s=new fl(r.shape,vU),n.runWebGLProgram(s,[r],r.dtype)}const lRe={kernelName:JI,backendName:"webgl",kernelFunc:oRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uRe=so+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,cRe=en({opSnippet:uRe}),dRe={kernelName:N0,backendName:"webgl",kernelFunc:cRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hRe=so+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,pRe=en({opSnippet:hRe}),fRe={kernelName:T0,backendName:"webgl",kernelFunc:pRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xU="return a + b;",mRe=Ts({opSnippet:xU,packedOpSnippet:xU,supportsComplex:!0,cpuKernelImpl:C_e}),gRe={kernelName:dy,backendName:"webgl",kernelFunc:mRe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yRe{constructor(t,n){this.outputShape=[],this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`float v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bRe{constructor(t,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=n.map((a,i)=>`T${i}`);const r=[];this.variableNames.forEach(a=>{r.push(`vec4 v${a} = get${a}AtOutCoords();`)});const s=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2(e){const{inputs:t,backend:n}=e,r=t;if(r.length===1)return Ja({inputs:{x:r[0]},backend:n});if(r.length>_e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),u=x2({inputs:r.slice(0,l),backend:n}),c=x2({inputs:r.slice(l),backend:n});return x2({inputs:[u,c],backend:n})}const s=r.map(l=>l.dtype).reduce((l,u)=>Xa(l,u)),a=r.map(l=>l.shape),o=_e().getBool("WEBGL_PACK")?new bRe(r[0].shape,a):new yRe(r[0].shape,a);return n.runWebGLProgram(o,r,s)}const vRe={kernelName:CO,backendName:"webgl",kernelFunc:x2};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ht(a,s.shape);let u=l;const c=lr(u,o);let d=s;c!=null&&(d=ea({inputs:{x:s},backend:n,attrs:{perm:c}}),u=vr(u.length,o)),Ns("all",u,o);const[h,p]=ps(d.shape,u),f=Me(p),m=Ze({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=Cp(m,m.dtype,"all",n);let y;if(i){const b=Ar(h,l);y=Ze({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Ze({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const wRe={kernelName:NO,backendName:"webgl",kernelFunc:xRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ht(a,s.shape);let u=l;const c=lr(u,o);let d=s;c!=null&&(d=ea({inputs:{x:s},backend:n,attrs:{perm:c}}),u=vr(u.length,o)),Ns("any",u,o);const[h,p]=ps(d.shape,u),f=Me(p),m=Ze({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=Cp(m,m.dtype,"any",n);let y;if(i){const b=Ar(h,l);y=Ze({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Ze({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const SRe={kernelName:TO,backendName:"webgl",kernelFunc:kRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IRe{constructor(t,n,r){this.variableNames=["A"];const{windowSize:s,batchSize:a,outSize:i}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[a,i];const o=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CRe{constructor(t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Y(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const a=t[t.length-1],i=Math.ceil(a/n);this.outputShape=t.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,u=Cn(l),c=qs("coords",l);let d,h;if(i===1){h=l+1;const I=Cn(h);d=`
        ${I} sourceLocR = ${I}(${c.join()}, 0);
        ++${c[l-1]};
        ${I} sourceLocG = ${I}(${c.join()}, 0);
        ++${c[l-2]};
        ${I} sourceLocA = ${I}(${c.join()}, 0);
        --${c[l-1]};
        ${I} sourceLocB = ${I}(${c.join()}, 0);
        --${c[l-2]};`}else h=l,d=`
        ${u} sourceLocR = coords;
        ++${c[l-1]};
        ${u} sourceLocG = coords;
        ++${c[l-2]};
        ${u} sourceLocA = coords;
        --${c[l-1]};
        ${u} sourceLocB = coords;
        --${c[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,h),f="."+p[h-1],m=p.map(I=>"int "+I),g=qs("sourceLocR",h-1).concat("inIdx.r"),y=qs("sourceLocG",h-1).concat("inIdx.g"),b=qs("sourceLocB",h-1).concat("inIdx.b"),x=qs("sourceLocA",h-1).concat("inIdx.a"),v=r==="max"?"greaterThan":"lessThan",w=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()})));`,k=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,S=s?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${S}
      void main() {
        ${u} coords = getOutputCoords();
        bool hasNextCol = ${c[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${c[l-2]} < ${o[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qY(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);const i=iN(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new IRe(o,n,r==null),u=[t];r!=null&&u.push(r);const c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;const d=qY(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function KY(e,t,n,r=null){const s=r!=null?r.shape:t.shape,a=s[s.length-1],i=iN(a),o=new CRe(s,i,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){const c=KY(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function XY(e,t,n,r){const s=[n];if(Ns("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!_e().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked;let l=t;o&&(l=e.unpackTensor(t),a.push(l));const[u,c]=ps(l.shape,s),d=Me(c),h=Ze({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});a.push(h);const p=qY(e,h,r);a.push(p);const f=Ze({inputs:{x:p},backend:e,attrs:{shape:u}});return a.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return KY(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Ht(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=ea({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=vr(i.length,l.shape.length)),Ns("argMax",[i[0]],l.shape.length);const c=XY(n,l,i[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const TRe={kernelName:ZI,backendName:"webgl",kernelFunc:NRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Re(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;let i=Ht(a,s.shape);const o=lr(i,s.shape.length);let l=s;const u=[];o!=null&&(l=ea({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=vr(i.length,l.shape.length)),Ns("argMin",[i[0]],l.shape.length);const c=XY(n,l,i[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}const ERe={kernelName:QI,backendName:"webgl",kernelFunc:$Re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Re=so+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ARe=en({opSnippet:_Re}),RRe={kernelName:$0,backendName:"webgl",kernelFunc:ARe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DRe=so+"return log(x + sqrt(x * x + 1.0));",ORe=en({opSnippet:DRe}),FRe={kernelName:E0,backendName:"webgl",kernelFunc:ORe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MRe=so+`
  return atan(x);
`,PRe=en({opSnippet:MRe}),LRe={kernelName:_0,backendName:"webgl",kernelFunc:PRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zRe=lM+`
  return atan(a, b);
`,BRe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ip+`
  return result;
`,WRe=Ts({opSnippet:zRe,packedOpSnippet:BRe}),VRe={kernelName:R0,backendName:"webgl",kernelFunc:WRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const URe=so+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,jRe=en({opSnippet:URe}),GRe={kernelName:A0,backendName:"webgl",kernelFunc:jRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H1{constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideHeight,l=t.strideWidth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterHeight,h=t.effectiveFilterWidth,p=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;const m=n==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,y=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let b="0.0";if(m||(b="-1.0 / 1e-20"),r){const I=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${u}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h};
                wC += ${c}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?a?g:y:`wR * ${h} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const x="max";let v=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(v="avgValue / max(count, 1.0)");const w=Math.floor(i/4)*4,k=i%4,S=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${u}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${c};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              getValue(batch, xR, xC + 3 * ${c}, d)
            );

            ${S}
          }

          int xC = xCCorner + ${w};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${c}, d),
              getValue(batch, xR, xC + 2 * ${c}, d),
              initializationValue
            );

            ${S}
          }
        }
        setOutput(${v});
      }
    `}}class cM{constructor(t,n,r,s=!1,a=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const i=t.filterWidth,o=t.strideDepth,l=t.strideHeight,u=t.strideWidth,c=t.dilationDepth,d=t.dilationHeight,h=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,g=t.padInfo.front,y=t.padInfo.top,b=t.padInfo.left;this.outputShape=t.outShape;const x=n==="avg";let v="0.0";if(x||(v="-1.0 / 1e-20"),r){const C=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${u});
        const ivec3 pads = ivec3(${g}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${c}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${h}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${C} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?a?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let k=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(k="avgValue / max(count, 1.0)");const S=Math.floor(i/4)*4,I=i%4,$=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${u});
      const ivec3 pads = ivec3(${g}, ${y}, ${b});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${c}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${S}; wC += 4) {
              int xC = xCCorner + wC * ${h};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                getValue(batch, xD, xR, xC + 3 * ${h}, ch)
              );

              ${$}
            }

            int xC = xCCorner + ${S};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${h}, ch),
                getValue(batch, xD, xR, xC + 2 * ${h}, ch),
                initializationValue
              );

              ${$}
            }
          }
        }
        setOutput(${k});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;zx(s,"avgPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(Ps(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=no(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&cn(c.inShape,c.outShape))return Ja({inputs:{x:s},backend:n});const d=new H1(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}const qRe={kernelName:eC,backendName:"webgl",kernelFunc:HRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KRe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=Iu(s.shape,a,i,c,o,l,u),h=new cM(d,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}const XRe={kernelName:tC,backendName:"webgl",kernelFunc:KRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YRe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterHeight,u=t.effectiveFilterWidth,c=l-1-t.padInfo.top,d=u-1-t.padInfo.left,h=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${c}, ${d});
      const float avgMultiplier = float(${h});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${u};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class JRe{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterDepth,h=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=d-1-t.padInfo.front,m=h-1-t.padInfo.top,g=p-1-t.padInfo.left,y=1/(n*r*s);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${h};
              wR += ${u}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${c}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZRe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=Iu(i.shape,o,l,d,u,c),p=new JRe(h);return n.runWebGLProgram(p,[s],i.dtype)}const QRe={kernelName:EO,backendName:"webgl",kernelFunc:ZRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eDe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;zx([s,a],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=r,c=no(i.shape,o,l,1,u),d=new YRe(c);return n.runWebGLProgram(d,[s],i.dtype)}const tDe={kernelName:$O,backendName:"webgl",kernelFunc:eDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nDe(e){const{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return PS({a:s,b:a,transposeA:i,transposeB:o,backend:n})}const rDe={kernelName:nC,backendName:"webgl",kernelFunc:nDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sDe{constructor(t,n,r,s,a,i){this.outputShape=[],this.variableNames=["x","mean","variance"],Ot(t,n),Ot(t,r);let o="0.0";s!=null&&(Ot(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";a!=null&&(Ot(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aDe{constructor(t,n,r,s,a,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ot(t,n),Ot(t,r);let o="vec4(0.0)";s!=null&&(Ot(t,s),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";a!=null&&(Ot(t,a),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iDe=({inputs:e,backend:t,attrs:n})=>{const{x:r,mean:s,variance:a,offset:i,scale:o}=e;Y(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const u=[r,s,a];let c=null;i!=null&&(c=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));const h=_e().getBool("WEBGL_PACK_NORMALIZATION")?new aDe(r.shape,s.shape,a.shape,c,d,l):new sDe(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)},oDe={kernelName:fC,backendName:"webgl",kernelFunc:iDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lDe{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const n=Cn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=uDe(this.rank);let s;const a=t.map((i,o)=>`sourceLoc.${VA[o]} = start[${o}] + coords.${VA[o]};`);s=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${s}
        setOutput(getSource(${r}));
      }
    `}}const VA=["x","y","z","w","u","v"];function uDe(e){if(e===1)return"sourceLoc";if(e<=6)return VA.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cDe{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=Cn(this.rank),r=qs("coords",this.rank),s=qs("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${a})`,o=`
      result.x = ${i};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${i};
        --${s[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${i};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${i};
        }
      }
    `,u=this.rank<=4?`sourceLoc = coords +
            ${n}(${t.map((c,d)=>`start[${d}]`).join()});`:t.map((c,d)=>`${s[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${u}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dDe(e,t,n,r){const s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=a3(t,kt(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};const l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}function Iy(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=aN(s,a,i);if(n3(s,o,l),Me(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){const d=n.texData.get(s.dataId),h=rAe(d.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,h)}const{isPacked:u}=n.texData.get(s.dataId),c=s3(s.shape,o,l);if(u||!c){const d=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cDe(l):new lDe(l),h=[o];return n.runWebGLProgram(d,[s],s.dtype,h)}return n.uploadToGPU(s.dataId),dDe(s,o,l,n)}const hDe={kernelName:UC,backendName:"webgl",kernelFunc:Iy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pDe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;Y(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((b,x)=>b*x),l=Nx(s.shape,a,o),u=Tx(l.length,a.length),c=$x(s.shape,a,o),d=c3(i,a.length),h=d3(c,i,a.length),p=[],f=Ze({inputs:{x:s},backend:n,attrs:{shape:l}}),m=ea({inputs:{x:f},backend:n,attrs:{perm:u}}),g=Ze({inputs:{x:m},backend:n,attrs:{shape:c}}),y=Iy({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},fDe={kernelName:rC,backendName:"webgl",kernelFunc:pDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=MY(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}const gDe={kernelName:_O,backendName:"webgl",kernelFunc:mDe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yDe=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,bDe=`
  return float(int(a.r) & int(b.r));
`;function vDe(e){const{inputs:t,backend:n}=e,{a:r,b:s}=t,a=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=_e().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){const l=n.texData.get(r.dataId).values,u=n.texData.get(s.dataId).values,[c,d]=T_e(r.shape,s.shape,l,u,r.dtype),h=n.makeTensorInfo(d,r.dtype),p=n.texData.get(h.dataId);return p.values=c,h}let o;return a?o=new ky(yDe,r.shape,s.shape,!1):o=new Wh(bDe,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}const xDe={kernelName:AO,backendName:"webgl",kernelFunc:vDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wDe(e){const{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=Ot(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const kDe={kernelName:B8,backendName:"webgl",kernelFunc:wDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SDe="return float(a != b);",YY=Ts({opSnippet:SDe,cpuKernelImpl:K_e,dtype:"bool"}),IDe={kernelName:AC,backendName:"webgl",kernelFunc:YY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wx(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Ja({inputs:{x:s.complexTensorInfos.real},backend:n})}const CDe={kernelName:nF,backendName:"webgl",kernelFunc:Wx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NDe="return float(int(x));";function TDe(e,t){const n=new fl(e.shape,NDe),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UA(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Ja({inputs:{x:s},backend:n});const i=os(s.shape),o=UA({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=hd({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(s.dtype==="complex64"){const i=Wx({inputs:{input:s},backend:n}),o=UA({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!F8(s.dtype,a)){const i=Ja({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){const i=n.texData.get(s.dataId).values,[o,l,u]=$_e(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return TDe(s,n);if(a==="bool"){const i=n.makeTensorInfo([],"bool",Ds("bool",1)),l=YY({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),l}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}const $De={kernelName:D0,backendName:"webgl",kernelFunc:UA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wU="return ceil(x);",EDe=en({opSnippet:wU,packedOpSnippet:wU,cpuKernelImpl:E_e}),_De={kernelName:O0,backendName:"webgl",kernelFunc:EDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ADe{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RDe{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r;let o;_e().getBool("WEBGL_PACK_CLIP")?o=new RDe(s.shape):o=new ADe(s.shape);const l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}const ODe={kernelName:F0,backendName:"webgl",kernelFunc:DDe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FDe{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kU(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function MDe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new FDe(r.shape),i=[kU(r,s.complexTensorInfos.real),kU(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}const PDe={kernelName:sC,backendName:"webgl",kernelFunc:MDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LDe{constructor(t){this.outputShape=[],this.outputShape=kl(t,1),this.variableNames=t.map((i,o)=>`T${o}`);const n=new Array(t.length-1);n[0]=t[0][1];for(let i=1;i<n.length;i++)n[i]=n[i-1]+t[i][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<n.length;i++){const o=n[i-1];r.push(`else if (yC < ${n[i]}) setOutput(getT${i}(yR, yC-${o}));`)}const s=n.length,a=n[n.length-1];r.push(`else setOutput(getT${s}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zDe{constructor(t,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=kl(t,n);const r=this.outputShape,s=r.length,a=Cn(s),i=qs("coords",s),o=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((m,g)=>`T${g}`);const l=new Array(t.length-1);l[0]=t[0][n];for(let m=1;m<l.length;m++)l[m]=l[m-1]+t[m][n];const u=o[n],c=o.slice(-2),d=o.join();let h=`if (${u} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${c.join()}));
        }`;for(let m=1;m<l.length;m++){const g=l[m-1];h+=`
        if (${u} < ${l[m]}  && ${u} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Fk(o,u,g)}),
            vec2(${Fk(c,u,g)}));
        }`}const p=l.length,f=l[l.length-1];h+=`
        return getChannel(
          getT${p}(${Fk(o,u,f)}),
          vec2(${Fk(c,u,f)}));`,this.userCode=`
      float getValue(${o.map(m=>"int "+m)}) {
        ${h}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[s-1]} = ${i[s-1]} + 1;
        if (${i[s-1]} < ${r[s-1]}) {
          result.g = getValue(${i});
        }

        ${i[s-2]} = ${i[s-2]} + 1;
        if (${i[s-2]} < ${r[s-2]}) {
          result.a = getValue(${i});
        }

        ${i[s-1]} = ${i[s-1]} - 1;
        if (${i[s-2]} < ${r[s-2]} &&
            ${i[s-1]} < ${r[s-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}}function Fk(e,t,n){const r=e.indexOf(t);return e.map((a,i)=>i===r?`${a} - ${n}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(e){const{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return Ja({inputs:{x:s.complexTensorInfos.imag},backend:n})}const BDe={kernelName:KO,backendName:"webgl",kernelFunc:CN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(e,t,n){const r=e[0].dtype;if(r==="complex64"){const p=e.map(b=>Wx({inputs:{input:b},backend:n})),f=e.map(b=>CN({inputs:{input:b},backend:n})),m=Lv(p,t,n),g=Lv(f,t,n),y=hd({inputs:{real:m,imag:g},backend:n});return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){const p=e.map(v=>{const k=[-1,Me(v.shape.slice(t))];return Ze({inputs:{x:v},backend:n,attrs:{shape:k}})}),f=p.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),m=kl(p.map(v=>v.shape),1),g=p[0].shape[0]===1,y=__e(f,m,r,g),b=kl(e.map(v=>v.shape),t),x=n.makeTensorInfo(b,r,y);return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}const a=e.filter(p=>Me(p.shape)>0),i=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){const p=i?new fl(e[0].shape,qu):new sc(e[0].shape,qu);return n.runWebGLProgram(p,e,r)}const o=_e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){const p=[];for(let m=0;m<a.length;m+=o){const g=a.slice(m,m+o);p.push(Lv(g,t,n))}const f=Lv(p,t,n);for(const m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){const p=new zDe(a.map(f=>f.shape),t);return n.runWebGLProgram(p,a,r)}const{tensors2D:l,outShape:u}=WDe(a,t,n),c=new LDe(l.map(p=>p.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));const h=Ze({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function WDe(e,t,n){const r=kl(e.map(a=>a.shape),t);return{tensors2D:e.map(a=>Ze({inputs:{x:a},attrs:{shape:[-1,Me(a.shape.slice(t))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JY(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=Ht(s,t[0].shape)[0],i=t.map(u=>u.shape);o3(i,a);const o=kl(t.map(u=>u.shape),a);if(Me(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);const l=t.filter(u=>Me(u.shape)>0);return l.length===1?Ja({inputs:{x:l[0]},backend:n}):Lv(l,a,n)}const VDe={kernelName:aC,backendName:"webgl",kernelFunc:JY};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZY{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const i=t.padInfo.top,o=t.padInfo.left,l=t.strideHeight,u=t.strideWidth,c=t.dilationHeight,d=t.dilationWidth,h=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4,g=t.dataFormat==="channelsLast",y=g?1:2,b=g?2:3,x=g?3:1;let v="",w="";r&&(s?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:v=`
          float activation(float x) {
            ${r}
          }
        `,w="result = activation(result);");const k=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${h}; wR++) {
          int xR = xRCorner + wR * ${c};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${w}
        setOutput(result);
      }
    `}}class UDe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const n=t.padInfo.front,r=t.padInfo.top,s=t.padInfo.left,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=t.dilationDepth,u=t.dilationHeight,c=t.dilationWidth,d=t.filterDepth,h=t.filterHeight,p=t.filterWidth,f=Math.floor(t.inChannels/4)*4,m=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${i}, ${o});
      const ivec3 pads = ivec3(${n}, ${r}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${h}; wR++) {
            int xR = xRCorner + wR * ${u};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${c};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QY{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Ls(this.outputShape.length);const i=t.padInfo.left,o=t.strideWidth,l=t.dilationWidth,u=t.filterHeight,c=t.filterWidth,d=c;let h=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)h+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;h+=`
     for (int r = 0; r < ${u}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<c;g++)h+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;h+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(d+1)/2;g++){const y=g*2;if(h+=`
           xC = xCCorner + ${y*l};
           `,o===1){if(y<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?h+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:h+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):h+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<c)){const b=i%2===0?xO(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?h+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:h+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?h+=`
                     xC${y+1} = xTexelC${y};
                     `:h+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<c&&(i%2===1?(h+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<c&&(h+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(h+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<c&&(h+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<c&&(h+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<c&&(h+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}h+=`
     }
   `,h+=`
     }
   `,h+=`
     }
   `;let p="",f="";r&&(s?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:a?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:p=`vec4 activation(vec4 x) {
           ${r}
         }`,f="result = activation(result);");const m=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${h}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${m}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jDe{constructor(t,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=Ls(this.outputShape.length);const{dataFormat:r}=n,s=sa(),a=r==="channelsLast",i=a?1:2,o=a?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let u="";for(let c=0;c<=1;c++)for(let d=0;d<=1;d++)u+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${c};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${c*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${u}

        ${s.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LS(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function eJ({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(a!=null){const v=LS(a.shape,p);v!=null&&(a=Ze({inputs:{x:a},backend:r,attrs:{shape:v}}),y.push(a))}if(s!=null){const v=LS(s.shape,p);v!=null&&(s=Ze({inputs:{x:s},backend:r,attrs:{shape:v}}),y.push(s))}if(!((d===1||h===1)&&c>HY)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&cn(u.shape.slice(-3),l.slice(-3))){const v=l[0]*l[1]*(l[2]+1),w={dataId:e.dataId,shape:[1,v,n.inChannels],dtype:e.dtype},k=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,Y(MS(u.shape,w.shape),()=>`packed reshape ${u.shape} to ${w.shape} isn't free`);const S=Ze({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(S);const I=PS({a:w,b:S,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),$=r.texData.get(I.dataId);Y($.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=k,$.shape=n.outShape,g=Ja({inputs:{x:I},backend:r}),g.shape=n.outShape,y.push(I)}else{const v=n.outHeight*n.outWidth,w=Ze({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,v,n.inChannels]:[n.batchSize,n.inChannels,v]}}),k=Ze({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),S=PS({a:p?w:k,b:p?k:w,transposeA:!p,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=Ze({inputs:{x:S},backend:r,attrs:{shape:n.outShape}}),y.push(w),y.push(k),y.push(S)}for(const v of y)r.disposeIntermediateTensorInfo(v);return g}function tJ({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){const{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",m=l*u*c,g=h*d,y=[n.batchSize,m,g],b=!0,x=!1,v=[];if(a!=null){const F=LS(a.shape,f);F!=null&&(a=Ze({inputs:{x:a},backend:r,attrs:{shape:F}}),v.push(a))}if(s!=null){const F=LS(s.shape,f);F!=null&&(s=Ze({inputs:{x:s},backend:r,attrs:{shape:F}}),v.push(s))}const w=Ze({inputs:{x:t},backend:r,attrs:{shape:[1,m,Me(t.shape)/m]}});v.push(w);const k=new jDe(y,n),S=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],I=r.runWebGLProgram(k,[e],"float32",S),$=Ze({inputs:{x:I},backend:r,attrs:{shape:y}});v.push(I),v.push($);const C=s!=null,T=a!=null,N=o==="leakyrelu",E=o?G1(o,!0):null,_=new GY(f?$.shape:w.shape,f?w.shape:$.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,C,E,T,N),R=f?[$,w]:[w,$];if(s&&R.push(s),T&&R.push(a),N){const F=r.makeTensorInfo([],"float32",rd(i,"float32"));R.push(F),v.push(F)}const z=r.runWebGLProgram(_,R,"float32"),W=Ze({inputs:{x:z},backend:r,attrs:{shape:n.outShape}});v.push(z);for(const F of v)r.disposeIntermediateTensorInfo(F);return W}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=Cu(l),h=Cs(s.shape,a.shape,i,u,o,c,!1,d);let p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=eJ({x:s,filter:a,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&_e().getBool("WEBGL_EXP_CONV")){const m=new QY(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(m,[s,a],"float32",g)}else if(_e().getBool("WEBGL_CONV_IM2COL"))p=tJ({x:s,filter:a,convInfo:h,backend:n});else{const m=new ZY(h);p=n.runWebGLProgram(m,[s,a],"float32")}const f=Ze({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}const HDe={kernelName:iC,backendName:"webgl",kernelFunc:GDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qDe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${i?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class KDe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=t.dataFormat==="channelsLast",o=n-1-t.padInfo.top,l=r-1-t.padInfo.left,u=i?1:2,c=i?2:3,d=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${u}], coords[${c}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class XDe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.padInfo.front,i=t.padInfo.top,o=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${a};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${i};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${o};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class YDe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterDepth,r=t.filterHeight,s=t.filterWidth,a=t.strideDepth,i=t.strideHeight,o=t.strideWidth,l=n-1-t.padInfo.front,u=r-1-t.padInfo.top,c=s-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${u}, ${c});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JDe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=Cu(l),h=Cs(s.shape,c,i,1,o,u,!1,d),p=new qDe(h);return n.runWebGLProgram(p,[s,a],"float32")}const ZDe={kernelName:DO,backendName:"webgl",kernelFunc:JDe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QDe{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=Ls(this.outputShape.length);const n=t.filterHeight,r=t.filterWidth,s=n-1-t.padInfo.top,a=r-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${s}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eOe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=Cu(u),h=Cs(i,a.shape,o,1,l,c,!1,d);if(_e().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const p=[[h.strideHeight,h.strideWidth]],f=new QDe(h);return n.runWebGLProgram(f,[s,a],"float32",p)}else{const p=new KDe(h);return n.runWebGLProgram(p,[s,a],"float32")}}const tOe={kernelName:oC,backendName:"webgl",kernelFunc:eOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=ad(s.shape,a.shape,i,l,o),c=new UDe(u);return n.runWebGLProgram(c,[s,a],"float32")}const rOe={kernelName:lC,backendName:"webgl",kernelFunc:nOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=ad(s.shape,l,i,1,o),c=new XDe(u);return n.runWebGLProgram(c,[s,a],"float32")}const aOe={kernelName:OO,backendName:"webgl",kernelFunc:sOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iOe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=ad(l,a.shape,o,1,i),c=new YDe(u);return n.runWebGLProgram(c,[s,a],"float32")}const oOe={kernelName:FO,backendName:"webgl",kernelFunc:iOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lOe=Sy+`
  return cos(x);
`,uOe=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Ip}
  return result;
`,cOe=en({opSnippet:lOe,packedOpSnippet:uOe}),dOe={kernelName:M0,backendName:"webgl",kernelFunc:cOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hOe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,pOe=en({opSnippet:hOe}),fOe={kernelName:P0,backendName:"webgl",kernelFunc:pOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mOe{constructor(t,n,r,s,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,o,l,u]=t,[c]=n,[d,h]=r;this.outputShape=[c,d,h,u];const p=s==="bilinear"?1:0,[f,m]=[`${o-1}.0`,`${l-1}.0`],[g,y,b]=d>1?[`${(o-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,v,w]=h>1?[`${(l-1)/(h-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${v};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gOe=e=>{const{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new mOe(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")},yOe={kernelName:PO,backendName:"webgl",kernelFunc:gOe};var q1;(function(e){e.Prod="*",e.Sum="+"})(q1||(q1={}));class SU{constructor(t,n,r,s){this.op=t,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const a=this.outputShape.length,i=this.op===q1.Prod?"1.0":"0.0",o=r?i:`getX(${IU(a,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let u="",c="";r?(u=s?`end != ${l-1}`:"end != 0",c=s?"end + 1":"end - 1"):(u=s?`end + pow2 < ${l}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Cn(a)} coords = getOutputCoords();
        int end = ${CU(a,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${u}) {
          int idx = ${c};
          ${CU(a,"coords",this.op)} = idx;
          val ${this.op}= getX(${IU(a,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function IU(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function CU(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(e,t,n,r,s,a){const i=t.shape.length,o=lr([r],i);let l=t;o!=null&&(l=ea({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=vr(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const c=l.shape[u];let d=Ja({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){const p=new SU(e,l.shape,!1,a),f=[[h]],m=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(s){const h=new SU(e,l.shape,s,a),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){const h=id(o),p=ea({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),p}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return nJ(q1.Prod,s,n,a,i,o)}const vOe={kernelName:MO,backendName:"webgl",kernelFunc:bOe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return nJ(q1.Sum,s,n,a,i,o)}const wOe={kernelName:uC,backendName:"webgl",kernelFunc:xOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){const l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=MY(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){const l=n.bufferSync(s),u=n.bufferSync(a),c=N_e(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}const SOe={kernelName:LO,backendName:"webgl",kernelFunc:kOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IOe{constructor(t,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function COe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,h=u*a,p=c/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=new IOe(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}const NOe={kernelName:zO,backendName:"webgl",kernelFunc:COe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rJ{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Ls(this.outputShape.length);const i=t.filterHeight,o=t.filterWidth,l=t.outChannels/t.inChannels;let u="",c="";r&&(s?u=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?u=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:u=`
          float activation(float x) {
            ${r}
          }
        `,c="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${u}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sJ{constructor(t,n=!1,r=null,s=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=Ls(this.outputShape.length);const i=t.outChannels/t.inChannels,o=t.padInfo.left,l=t.strideWidth,u=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,h=d;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<d;y++)p+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;p+=`
    for (int r = 0; r < ${c}; r++) {
      `;for(let y=0;y<d;y++)p+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(h+1)/2;y++){const b=y*2;if(p+=`
          xC = xCCorner + ${b*u};
          `,l===1){if(b<d&&(o%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,u===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<d)){const x=o%2===0?xO(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,u>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):x===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<d&&(o%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<d&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<d&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<d&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<d&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";r&&(s?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:f=`vec4 activation(vec4 x) {
          ${r}
        }`,m="result = activation(result);");const g=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;let c=l;c==null&&(c=[1,1]),Y(Ps(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const d=Cs(s.shape,a.shape,i,c,o,u,!0);let h;_e().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new sJ(d):h=new rJ(d);const p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}const $Oe={kernelName:cC,backendName:"webgl",kernelFunc:TOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EOe{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const n=t.strideHeight,r=t.strideWidth,s=t.padInfo.top,a=t.padInfo.left,i=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${a};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class _Oe{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const n=t.filterHeight,r=t.filterWidth,s=t.strideHeight,a=t.strideWidth,i=n-1-t.padInfo.top,o=r-1-t.padInfo.left,l=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=Cs(s.shape,c,i,o,l,u,!0),h=new EOe(d);return n.runWebGLProgram(h,[s,a],"float32")}const ROe={kernelName:BO,backendName:"webgl",kernelFunc:AOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DOe(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=Cs(c,a.shape,i,o,l,u,!0),h=new _Oe(d);return n.runWebGLProgram(h,[s,a],"float32")}const OOe={kernelName:WO,backendName:"webgl",kernelFunc:DOe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FOe{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MOe(e){const{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=Me(r.shape),i=Ze({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new FOe(a),l=n.runWebGLProgram(o,[i],i.dtype),u=Ze({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}const POe={kernelName:W8,backendName:"webgl",kernelFunc:MOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LOe{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:n,inWidth:r,padInfo:s,strideHeight:a,strideWidth:i,filterHeight:o,filterWidth:l,dilationHeight:u,dilationWidth:c}=t,{top:d,left:h}=s;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${i});
      const ivec2 pads = ivec2(${d}, ${h});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${u};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${c};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zOe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=wx(s.shape,a.shape,i,o,"NHWC",l);let c;const d=new LOe(u);c=n.runWebGLProgram(d,[s,a],"float32");const h=Ze({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}const BOe={kernelName:dC,backendName:"webgl",kernelFunc:zOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WOe(e){const{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=v3(s,a.length);w3(i.length,l,a);const{path:u,steps:c}=k3(o,l),d=c.length;let h=null,p=i.length;const f=[];for(let m=0;m<d;++m){for(const g of c[m]){const{permutationIndices:y,expandDims:b}=x3(p,l[g]);let x;S3(y)?x=a[g]:(x=ea({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));const v=x.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);cn(x.shape,v)||(x=Ze({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),h===null?h=x:(h=uM({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=IN({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(const m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}const VOe={kernelName:VO,backendName:"webgl",kernelFunc:WOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UOe="return (x >= 0.0) ? x : (exp(x) - 1.0);",jOe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,GOe=en({opSnippet:UOe,packedOpSnippet:jOe}),HOe={kernelName:z0,backendName:"webgl",kernelFunc:GOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qOe="return (b >= 0.0) ? a : a * (b + 1.0);",KOe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,XOe=e=>{const{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ky(KOe,r.shape,s.shape):new Wh(qOe,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},YOe={kernelName:UO,backendName:"webgl",kernelFunc:XOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JOe=`
  return vec4(equal(a, b));
`,ZOe="return float(a == b);",QOe=Ts({opSnippet:ZOe,packedOpSnippet:JOe,dtype:"bool",cpuKernelImpl:A_e}),eFe={kernelName:hC,backendName:"webgl",kernelFunc:QOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tFe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${h3};
  float a1 = ${p3};
  float a2 = ${f3};
  float a3 = ${m3};
  float a4 = ${g3};
  float a5 = ${y3};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,nFe=en({opSnippet:tFe}),rFe={kernelName:B0,backendName:"webgl",kernelFunc:nFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sFe=Sy+`
  return exp(x);
`,aFe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,aJ=en({opSnippet:sFe,packedOpSnippet:aFe,cpuKernelImpl:R_e,dtype:"float32"}),iFe={kernelName:W0,backendName:"webgl",kernelFunc:aJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(e){const{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice();let l=s;return s<0&&(Y(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),Ze({inputs:{x:a},backend:r,attrs:{shape:o}})}const oFe={kernelName:pC,backendName:"webgl",kernelFunc:jA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NU="return exp(x) - 1.0;",lFe=en({opSnippet:NU,packedOpSnippet:NU,cpuKernelImpl:D_e}),uFe={kernelName:V0,backendName:"webgl",kernelFunc:lFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TU{constructor(t,n,r){this.variableNames=["real","imag"];const s=n[1];this.outputShape=n;const a=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=r?`${s}.0`:"1.0";let o;if(t==="real")o="return real * expR - imag * expI;";else if(t==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iJ(e,t,n){const r=n.texData.get(e.dataId),s=Me(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=Ze({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),l=o.shape,u=new TU("real",l,t),c=new TU("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=hd({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);const m=Ze({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cFe(e){const{inputs:t,backend:n}=e,{input:r}=t;return iJ(r,!1,n)}const dFe={kernelName:jO,backendName:"webgl",kernelFunc:cFe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hFe{constructor(t,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vx(e){const{backend:t,attrs:n}=e,{shape:r,value:s}=n;let{dtype:a}=n;if(a=a||uy(s),a==="string"){const i=gr(a,Me(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{const i=new hFe(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}const pFe={kernelName:GO,backendName:"webgl",kernelFunc:Vx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fFe{constructor(t){this.variableNames=["Image"],this.outputShape=[];const n=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mFe={kernelName:HO,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,s=new fFe(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $U="return floor(x);",gFe=en({opSnippet:$U,packedOpSnippet:$U,cpuKernelImpl:O_e}),yFe={kernelName:U0,backendName:"webgl",kernelFunc:gFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bFe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,vFe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,xFe=Ts({opSnippet:bFe,packedOpSnippet:vFe,dtype:"int32"}),wFe={kernelName:j0,backendName:"webgl",kernelFunc:xFe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kFe{constructor(t){this.variableNames=["A"];const n=sa(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SFe{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=sa(),[r,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IFe={kernelName:kfe,backendName:"webgl",kernelFunc:CFe};let fm,bE=_e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function CFe(e){const{inputs:t,backend:n,attrs:r}=e;let{pixels:s}=t;const{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){const m=_e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(fm==null||m!==bE)&&(bE=m,fm=document.createElement("canvas").getContext("2d",{willReadFrequently:bE})),fm.canvas.width=l,fm.canvas.height=u,fm.drawImage(s,0,0,l,u),s=fm.canvas}const h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=ci.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);const p=_e().getBool("WEBGL_PACK")?new SFe(d):new kFe(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NFe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=Cu(c),g=Cs(s.shape,a.shape,l,d,u,h,!1,m);let y;const b=[],x=i!=null,v=o!=null,w=p==="leakyrelu",k=()=>{const I=[s,a],$=(C,T)=>{if(T==="NCHW"&&C.shape.length===1&&C.shape[0]!==1){const N=Ze({inputs:{x:C},backend:n,attrs:{shape:[C.shape[0],1,1]}});return b.push(N),N}return C};if(x&&I.push($(i,c)),v&&I.push($(o,c)),w){const C=n.makeTensorInfo([],"float32",rd(f,"float32"));I.push(C),b.push(C)}return I};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=eJ({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&_e().getBool("WEBGL_EXP_CONV")){const I=p?G1(p,!0):null,$=new QY(g,x,I,v,w),C=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=k();y=n.runWebGLProgram($,T,"float32",C)}else if(_e().getBool("WEBGL_CONV_IM2COL"))y=tJ({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const I=p?G1(p,!1):null,$=new ZY(g,x,I,v,w),C=k();y=n.runWebGLProgram($,C,"float32")}const S=Ze({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(I=>n.disposeIntermediateTensorInfo(I)),S}const TFe={kernelName:cS,backendName:"webgl",kernelFunc:NFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Fe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[];let m=c;m==null&&(m=[1,1]),Y(Ps(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const g=Cs(s.shape,a.shape,l,m,u,d,!0),y=_e().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?G1(h,y):null,x=[s,a],v=i!=null,w=o!=null,k=h==="leakyrelu";if(v&&x.push(i),w&&x.push(o),k){const C=n.makeTensorInfo([],"float32",rd(p,"float32"));x.push(C),f.push(C)}let S;y?S=new sJ(g,v,b,w,k):S=new rJ(g,v,b,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=n.runWebGLProgram(S,x,"float32",I);return f.forEach(C=>n.disposeIntermediateTensorInfo(C)),$}const EFe={kernelName:iq,backendName:"webgl",kernelFunc:$Fe};class _Fe{constructor(t,n,r,s){this.sliceDim=t,this.strides=n,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=r;const a=Cn(r.length);let i=`
    int index;`;for(let o=0;o<this.sliceDim;o++)i+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${i}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AFe(e){const{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=Me(r.shape),[l,u,c,d]=t3(r,s),h=Ze({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=Ze({inputs:{x:r},backend:n,attrs:{shape:[Me(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const y=n.readSync(s.dataId),b=n.bufferSync(r),x=F_e(y,b,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,x.values)}const f=new _Fe(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=Ze({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}const RFe={kernelName:V8,backendName:"webgl",kernelFunc:AFe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DFe{constructor(t,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=Cn(this.rank),s=OFe(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${s}));
      }
    `}}function OFe(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=Ht(i,s.shape)[0];if(_e().get("DEBUG")){const b=n.readSync(a.dataId),x=s.shape[l];for(let v=0;v<b.length;++v){const w=b[v];Y(w<=x-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${x-1}]`)}}const u=C3(s,a,l,o),c=Me(a.shape),d=[],h=Ze({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Ze({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){const b=n.bufferSync(p),x=n.bufferSync(h),v=M_e(x,b,f);return d.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(u.outputShape,v.dtype,v.values)}const m=new DFe(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);const y=Ze({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const FFe={kernelName:mC,backendName:"webgl",kernelFunc:oJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MFe="return float(a > b);",PFe=`
  return vec4(greaterThan(a, b));
`,LFe=Ts({opSnippet:MFe,packedOpSnippet:PFe,cpuKernelImpl:P_e,dtype:"bool"}),zFe={kernelName:gC,backendName:"webgl",kernelFunc:LFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BFe="return float(a >= b);",WFe=`
  return vec4(greaterThanEqual(a, b));
`,VFe=Ts({opSnippet:BFe,packedOpSnippet:WFe,dtype:"bool",cpuKernelImpl:L_e}),UFe={kernelName:G0,backendName:"webgl",kernelFunc:VFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jFe(e){const{inputs:t,backend:n}=e,{input:r}=t;return iJ(r,!0,n)}const GFe={kernelName:qO,backendName:"webgl",kernelFunc:jFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HFe="return float(!isnan(x) && !isinf(x));",qFe=en({opSnippet:HFe,dtype:"bool"}),KFe={kernelName:q0,backendName:"webgl",kernelFunc:qFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XFe="return float(isinf(x));",YFe=en({opSnippet:XFe,dtype:"bool"}),JFe={kernelName:K0,backendName:"webgl",kernelFunc:YFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZFe="return float(isnan(x));",QFe=en({opSnippet:ZFe,dtype:"bool"}),e3e={kernelName:X0,backendName:"webgl",kernelFunc:QFe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t3e="return float(a < b);",n3e=`
  return vec4(lessThan(a, b));
`,r3e=Ts({opSnippet:t3e,packedOpSnippet:n3e,cpuKernelImpl:z_e,dtype:"bool"}),s3e={kernelName:bC,backendName:"webgl",kernelFunc:r3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3e="return float(a <= b);",i3e=`
  return vec4(lessThanEqual(a, b));
`,o3e=Ts({opSnippet:a3e,packedOpSnippet:i3e,cpuKernelImpl:B_e,dtype:"bool"}),l3e={kernelName:vC,backendName:"webgl",kernelFunc:o3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u3e(e){const{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=W_e(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}const c3e={kernelName:U8,backendName:"webgl",kernelFunc:u3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d3e=Sy+`
  return x < 0.0 ? 0./0. : log(x);
`,h3e=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,p3e=en({opSnippet:d3e,packedOpSnippet:h3e,cpuKernelImpl:V_e}),f3e={kernelName:Y0,backendName:"webgl",kernelFunc:p3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m3e=Sy+`
  return log(1.0 + x);
`,g3e=en({opSnippet:m3e}),y3e={kernelName:J0,backendName:"webgl",kernelFunc:g3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3e="return float(a >= 1.0 && b >= 1.0);",v3e=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,x3e=Ts({opSnippet:b3e,packedOpSnippet:v3e,dtype:"bool"}),w3e={kernelName:xC,backendName:"webgl",kernelFunc:x3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k3e="return float(!(x >= 1.0));",S3e=en({opSnippet:k3e}),I3e={kernelName:wC,backendName:"webgl",kernelFunc:S3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C3e="return float(a >= 1.0 || b >= 1.0);",N3e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,T3e=Ts({opSnippet:C3e,packedOpSnippet:N3e,dtype:"bool"}),$3e={kernelName:kC,backendName:"webgl",kernelFunc:T3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class E3e{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[];const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${r}) + float(${s}) * sum`;a===.5?l=`inversesqrt(${u})`:a===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _3e{constructor(t,n,r,s,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=n,o=t[3]-1;this.outputShape=t;let l;const u=`float(${r}) + float(${s}) * sum`;a===.5?l=`inversesqrt(${u})`:a===1?l=`1.0/(${u})`:l=`exp(log(${u}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const A3e=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=_e().getBool("WEBGL_PACK_NORMALIZATION")?new _3e(s.shape,a,i,o,l):new E3e(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)},R3e={kernelName:SC,backendName:"webgl",kernelFunc:A3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class D3e{constructor(t,n,r,s,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=n,this.bias=r,this.alpha=s,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${a})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O3e=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new D3e(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)},F3e={kernelName:XO,backendName:"webgl",kernelFunc:O3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M3e(e,t,n,r){const s=Me(t),i=Me(e.shape)/s,o=Ze({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),l=Cp(o,e.dtype,"max",r),u=Ze({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=Ht(a,s.shape);let u=l;const c=lr(u,o),d=c!=null,h=n.shouldExecuteOnCPU([s]);let p=s;if(d){if(h){const x=n.texData.get(p.dataId).values,v=new Array(o);for(let S=0;S<v.length;S++)v[S]=s.shape[c[S]];const w=oM(x,s.shape,s.dtype,c,v);p=n.makeTensorInfo(v,s.dtype);const k=n.texData.get(p.dataId);k.values=w}else p=SN(s,c,n);u=vr(u.length,o)}Ns("max",u,o);const[f,m]=ps(p.shape,u);let g=f;i&&(g=Ar(f,l));let y;if(h){const x=n.texData.get(p.dataId).values,v=U_e(x,Me(m),g,s.dtype);y=n.makeTensorInfo(g,s.dtype);const w=n.texData.get(y.dataId);w.values=v}else y=M3e(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),y}const P3e={kernelName:IC,backendName:"webgl",kernelFunc:lJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L3e=lM+`
  return max(a, b);
`,z3e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ip+`
  return result;
`,B3e=Ts({opSnippet:L3e,packedOpSnippet:z3e,cpuKernelImpl:j_e}),W3e={kernelName:Z0,backendName:"webgl",kernelFunc:B3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;zx(s,"maxPool");const{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;Y(Ps(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);const c=no(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&cn(c.inShape,c.outShape))return Ja({inputs:{x:s},backend:n});const d=new H1(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}const U3e={kernelName:CC,backendName:"webgl",kernelFunc:V3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=Iu(s.shape,a,i,c,o,u,l),h=new cM(d,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}const G3e={kernelName:NC,backendName:"webgl",kernelFunc:j3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H3e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideHeight,r=t.strideWidth,s=t.dilationHeight,a=t.effectiveFilterHeight,i=t.effectiveFilterWidth,o=a-1-t.padInfo.top,l=i-1-t.padInfo.left,u=a*i-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${u} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class q3e{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const n=t.strideDepth,r=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,o=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,c=t.effectiveFilterWidth,d=l-1-t.padInfo.front,h=u-1-t.padInfo.top,p=c-1-t.padInfo.left,f=l*u*c-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${u};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${c};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${u} * ${c} +
                  wR * ${c} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K3e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=Iu(i.shape,o,l,d,u,c),p=new cM(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new q3e(h),g=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}const X3e={kernelName:JO,backendName:"webgl",kernelFunc:K3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3e(e){const{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;zx([a,i],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=no(o.shape,l,u,1,c,d),p=!0,f=new H1(h,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new H3e(h),y=n.runWebGLProgram(g,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}const J3e={kernelName:YO,backendName:"webgl",kernelFunc:Y3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3e(e,t,n,r){let s=new H1(n,"max",!1);const a=r.runWebGLProgram(s,[e],"float32");s=new H1(n,"max",!0,!0,t);const i=r.runWebGLProgram(s,[e],"float32");return[a,i]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q3e={kernelName:j8,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;Y(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const u=[1,1];Y(Ps(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const c=no(r.shape,s,a,u,i),[d,h]=Z3e(r,o,c,l);return[d,h]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eMe(e,t,n,r){const s=Me(t),i=Me(e.shape)/s,o=Ze({inputs:{x:e},attrs:{shape:[i,s]},backend:r}),l=Cp(o,"float32","mean",r),u=Ze({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(l),u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tMe={kernelName:TC,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=Ht(a,r.shape);let u=l;const c=lr(u,o),d=c!=null,h=i.shouldExecuteOnCPU([r]),p=[];let f=r;if(d){if(h){const v=i.texData.get(f.dataId).values,w=new Array(o);for(let I=0;I<w.length;I++)w[I]=r.shape[c[I]];const k=oM(v,r.shape,r.dtype,c,w);f=i.makeTensorInfo(w,r.dtype);const S=i.texData.get(f.dataId);S.values=k}else f=SN(r,c,i);p.push(f),u=vr(u.length,o)}Ns("sum",u,o);const[m,g]=ps(f.shape,u);let y=m;s&&(y=Ar(m,l));const b=eMe(f,g,y,i);for(const x of p)i.disposeIntermediateTensorInfo(x);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nMe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=Ht(a,s.shape);let u=l;const c=lr(u,o);let d=s;c!=null&&(d=ea({inputs:{x:s},backend:n,attrs:{perm:c}}),u=vr(u.length,s.shape.length)),Ns("min",u,o);const[h,p]=ps(d.shape,u),f=Me(p),m=Ze({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=Cp(m,m.dtype,"min",n);let y;if(i){const b=Ar(h,l);y=Ze({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Ze({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}const rMe={kernelName:$C,backendName:"webgl",kernelFunc:nMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sMe=lM+`
  return min(a, b);
`,aMe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Ip+`
  return result;
`,iMe=Ts({opSnippet:sMe,packedOpSnippet:aMe,cpuKernelImpl:G_e}),oMe={kernelName:Q0,backendName:"webgl",kernelFunc:iMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lMe{constructor(t,n,r){this.variableNames=["x"],this.outputShape=n.map((c,d)=>c[0]+t[d]+c[1]);const s=t.length,a=Cn(s),i=n.map(c=>c[0]).join(","),o=n.map((c,d)=>c[0]+t[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),u=r==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${u};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${u};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${u};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${u};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uMe{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((f,m)=>f[0]+t[m]+f[1]);const s=t.length,a=Cn(s),i=n.map(f=>f[0]).join(","),o=n.map((f,m)=>f[0]+t[m]).join(","),l=qs("rc",s),u=qs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,h=r==="reflect"?0:1;let p="";if(s===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${h};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${h};
        }
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${h}) +
                gte * ((end - 1) * 2 - source + ${h});
        source -= start;
      `;p=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${u.join()}), ${d});
        ${l[s-1]} += 1;
        if(${c}) {
          ${f}
          result[1] = getChannel(getX(${u.join()}), ${d});
        }
        rc = outputLoc;
        ${l[s-2]} += 1;
        if(${l[s-2]} < ${this.outputShape[s-2]}) {
          ${f}
          result[2] = getChannel(getX(${u.join()}), ${d});
          ${l[s-1]} += 1;
          if(${c}) {
            ${f}
            result[3] = getChannel(getX(${u.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cMe=({inputs:e,backend:t,attrs:n})=>{const{x:r}=e,{paddings:s,mode:a}=n,i=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uMe(r.shape,s,a):new lMe(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},dMe={kernelName:EC,backendName:"webgl",kernelFunc:cMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hMe=`if (b == 0.0) return NAN;
  return mod(a, b);`,pMe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Ip+`
  return result;
`,fMe=Ts({opSnippet:hMe,packedOpSnippet:pMe}),mMe={kernelName:ex,backendName:"webgl",kernelFunc:fMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gMe{constructor(t,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yMe=`
if (a == b) {
  return 1.0;
};
return a / b;`,bMe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,uJ=Ts({opSnippet:yMe,packedOpSnippet:bMe,checkOutOfBounds:!0}),vMe={kernelName:L0,backendName:"webgl",kernelFunc:uJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EU="return a - b;",cJ=Ts({opSnippet:EU,packedOpSnippet:EU,supportsComplex:!0,cpuKernelImpl:hAe}),xMe={kernelName:gx,backendName:"webgl",kernelFunc:cJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dJ(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=Ht([a],s.shape),o=lJ({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=Ar(o.shape,i),u=Ze({inputs:{x:o},backend:n,attrs:{shape:l}}),c=cJ({inputs:{a:s,b:u},backend:n}),d=aJ({inputs:{x:c},backend:n}),h=IN({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=Ze({inputs:{x:h},backend:n,attrs:{shape:l}}),f=uJ({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}const wMe={kernelName:qC,backendName:"webgl",kernelFunc:dJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kMe(e){const{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:dJ({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new gMe(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}const SMe={kernelName:G8,backendName:"webgl",kernelFunc:kMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IMe=so+`
  return -x;
`,CMe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function NMe(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const a=n.texData.get(r.dataId),[i,o]=q_e(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return _e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new sc(r.shape,CMe):s=new fl(r.shape,IMe),n.runWebGLProgram(s,[r],r.dtype)}const TMe={kernelName:_C,backendName:"webgl",kernelFunc:NMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Me=XF;function EMe(e){li("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=$Me(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const _Me={kernelName:ZO,backendName:"webgl",kernelFunc:EMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AMe=YF;function RMe(e){li("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=AMe(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const DMe={kernelName:QO,backendName:"webgl",kernelFunc:RMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OMe=JF;function FMe(e){li("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=OMe(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const MMe={kernelName:eF,backendName:"webgl",kernelFunc:FMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PMe{constructor(t,n,r,s){this.variableNames=["indices"],this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LMe=e=>{const{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=Me(s.shape),c=new PMe(u,i,o,l),d=Ze({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);const p=[...s.shape,i],f=Ze({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},zMe={kernelName:DC,backendName:"webgl",kernelFunc:LMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){const s=Wx({inputs:{input:r},backend:n}),a=zS({inputs:{x:s},backend:n}),i=CN({inputs:{input:r},backend:n}),o=zS({inputs:{x:i},backend:n}),l=hd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Vx({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const BMe={kernelName:YC,backendName:"webgl",kernelFunc:zS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hJ(e){const{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=Wx({inputs:{input:r},backend:n}),a=hJ({inputs:{x:s},backend:n}),i=CN({inputs:{input:r},backend:n}),o=zS({inputs:{x:i},backend:n}),l=hd({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Vx({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const WMe={kernelName:RC,backendName:"webgl",kernelFunc:hJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VMe(e){const{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return jA({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const a=t[0].shape,i=t[0].dtype;t.forEach(c=>{wO(a,c.shape,"All tensors passed to stack must have matching shapes"),Y(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=t.map(c=>{const d=jA({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=JY({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}const UMe={kernelName:OC,backendName:"webgl",kernelFunc:VMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jMe{constructor(t,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((u,c)=>u[0]+t[c]+u[1]);const s=t.length,a=Cn(s),i=n.map(u=>u[0]).join(","),o=n.map((u,c)=>u[0]+t[c]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${i};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${i});
      ${a} end = ${a}(${o});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GMe{constructor(t,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((m,g)=>m[0]+t[g]+m[1]);const s=t.length,a=Cn(s),i=n.map(m=>m[0]).join(","),o=n.map((m,g)=>m[0]+t[g]).join(","),l=qs("rc",s),u=qs("source",s),c=`${l[s-1]} < ${this.outputShape[s-1]}`,d=s===1?"source":`vec2(${u.slice(-2).join()})`,h=[`${a} rc = outputLoc;`,`${l[s-1]} += 1;
       if(${c}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${l[s-2]} += 1;
       if(${l[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${l[s-1]} += 1;
         if(${c}) {`],p=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=s===1?2:4;m<g;m++)f+=`
        ${h[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${u.join()}), ${d});
        }
      `;f+=s===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${i});
      const ${a} end = ${a}(${o});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pJ=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(Me(s.shape)===0){const u=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return Vx({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}const o=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new GMe(s.shape,a,i):new jMe(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},HMe={kernelName:FC,backendName:"webgl",kernelFunc:pJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qMe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,KMe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Ip+`
  return result;
`,XMe=Ts({opSnippet:qMe,packedOpSnippet:KMe}),YMe={kernelName:nx,backendName:"webgl",kernelFunc:XMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JMe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=Ht(a,s.shape);let c=u;const d=lr(c,o);let h=s;d!=null&&(h=ea({inputs:{x:s},backend:n,attrs:{perm:d}}),c=vr(c.length,o),l.push(h)),Ns("prod",c,o);let p;if(n.shouldExecuteOnCPU([h])){const f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=X_e(h.shape,h.dtype,f,c);p=n.makeTensorInfo(g,y,m)}else{const[f,m]=ps(h.shape,c),g=Me(m),y=Ze({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=pF(s.dtype),x=Cp(y,b,"prod",n);p=Ze({inputs:{x},backend:n,attrs:{shape:f}}),l.push(y),l.push(x)}if(i){l.push(p);const f=Ar(p.shape,u);p=Ze({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}const ZMe={kernelName:PC,backendName:"webgl",kernelFunc:JMe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QMe(e){const{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(y=>n.readSync(y.dataId)),u=s.map(y=>y.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=Y_e(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}const ePe={kernelName:H8,backendName:"webgl",kernelFunc:QMe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tPe(e){const{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=J_e(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}const nPe={kernelName:q8,backendName:"webgl",kernelFunc:tPe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rPe(e){const{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=Z_e(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}const sPe={kernelName:K8,backendName:"webgl",kernelFunc:rPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fJ=e=>{const{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=Q_e(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},aPe={kernelName:tF,backendName:"webgl",kernelFunc:fJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iPe="return 1.0 / x;",oPe=en({opSnippet:iPe}),lPe={kernelName:rx,backendName:"webgl",kernelFunc:oPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uPe=so+`
  return (x < 0.0) ? 0.0 : x;
`,cPe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dPe=en({opSnippet:uPe,packedOpSnippet:cPe}),hPe={kernelName:sx,backendName:"webgl",kernelFunc:dPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pPe=so+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,fPe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mPe=en({opSnippet:pPe,packedOpSnippet:fPe}),gPe={kernelName:ax,backendName:"webgl",kernelFunc:mPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yPe{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let h;a?h="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bPe{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r];let h;a?h="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vPe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=_e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bPe(s.shape,l,u,a,i):new yPe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}const xPe={kernelName:BC,backendName:"webgl",kernelFunc:vPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wPe{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,l=[r&&i>1?s-1:s,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kPe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new wPe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const SPe={kernelName:sF,backendName:"webgl",kernelFunc:kPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IPe{constructor(t,n,r,s,a){this.variableNames=["A"],this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],h=s?"0.5":"0.0";let p;a?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${c[0]/d[0]},
          ${c[1]/d[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CPe{constructor(t,n,r,s,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,o,l,u]=t;this.outputShape=[i,n,r,u];const c=[s&&n>1?o-1:o,s&&r>1?l-1:l],d=[s&&n>1?n-1:n,s&&r>1?r-1:r],h=s?"0.5":"0.0";let p;a?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${c[0]/d[0]},
          ${c[1]/d[1]},
          ${c[1]/d[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${u-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NPe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=_e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new CPe(s.shape,l,u,a,i):new IPe(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}const TPe={kernelName:zC,backendName:"webgl",kernelFunc:NPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Pe{constructor(t,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,s,a]=n,[,i,o]=t,l=[r&&i>1?s-1:s,r&&o>1?a-1:a],u=[r&&i>1?i-1:i,r&&o>1?o-1:o],c=l[0]/u[0],d=l[1]/u[1],h=1/c,p=1/d,f=Math.ceil(h)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${c});
        const float widthScale = float(${d});

        const float invHeightScale = float(${h});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${u[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${u[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EPe(e){const{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new $Pe(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}const _Pe={kernelName:rF,backendName:"webgl",kernelFunc:EPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class APe{constructor(t,n){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const s=o=>n.indexOf(o)!==-1&&t[o]!==1?`${t[o]} - coords[${o}] - 1`:`coords[${o}]`,a=t.map((o,l)=>s(l)).join(","),i=Cn(r);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RPe{constructor(t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const s=qs("rc",r),a=`${s[r-1]} + 1 < ${this.outputShape[r-1]}`,i=`${s[r-2]} + 1 < ${this.outputShape[r-2]}`,o=Cn(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(s.slice())};
          if(${a}){
            result.g = ${u(s.slice())};
          }
          if(${i}) {
            result.b = ${c(s.slice())};
            if(${a}) {
              result.a = ${d(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return h(f)}function u(f){return f[r-1]="("+f[r-1]+" + 1)",h(f)}function c(f){return f[r-2]="("+f[r-2]+" + 1)",h(f)}function d(f){return f[r-1]="("+f[r-1]+" + 1)",f[r-2]="("+f[r-2]+" + 1)",h(f)}function h(f){const m=t.map((b,x)=>p(x,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function p(f,m){return n.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DPe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=Ht(a,s.shape);if(i===0)return Ja({inputs:{x:s},backend:n});const l=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new RPe(s.shape,o):new APe(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}const OPe={kernelName:WC,backendName:"webgl",kernelFunc:DPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FPe{constructor(t,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],s=t[2];this.outputShape=t;let a="";typeof n=="number"?a=`float outputValue = ${n.toFixed(2)};`:a=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MPe={kernelName:dF,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new FPe(r.shape,a),[u,c]=u3(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PPe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,LPe=en({opSnippet:PPe}),zPe={kernelName:ix,backendName:"webgl",kernelFunc:LPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BPe="return inversesqrt(x);",WPe=en({opSnippet:BPe,cpuKernelImpl:eAe}),VPe={kernelName:ox,backendName:"webgl",kernelFunc:WPe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dM{constructor(t,n,r,s,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const u=Cn(a.length),c=Cn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const h=`getIndices(${d})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=n>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${y};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(${g}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UPe{constructor(t,n,r,s,a,i,o=!0,l=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const u=Cn(a.length),c=Cn(i.length);let d="";r===1?d="i":r===2&&(d="i, j");const h=`getIndices(${d})`;let p="";s===1?p="i":s===2&&(p="i, coords[1]");const f=`getUpdates(${p})`;let m="";l&&(m="coords[0], coords[1]");const g=`getDefaultValue(${m})`,y=n>1?"strides[j]":"strides",b=n>1?"strides[j + 1]":"strides";this.userCode=`
        ${u} strides = ${u}(${a});

        void main() {
          ${c} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${n}; j+=2) {
              ivec4 index = round(${h});
              flattenedIndex += index.xz * ${y};
              if (j + 1 < ${n}) {
                flattenedIndex += index.yw * ${b};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${f};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${g}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jPe(e){const{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=vp(a,s,i),h=[d/u,u];if(d===0)return n.makeTensorInfo(i,s.dtype);const p=Ze({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=Ze({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;_e().getBool("WEBGL_PACK")?g=new UPe(l,o,p.shape.length,f.shape.length,c,h):g=new dM(l,o,p.shape.length,f.shape.length,c,h);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=Ze({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}const GPe={kernelName:X8,backendName:"webgl",kernelFunc:jPe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HPe{constructor(t,n,r,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const a="while (left < right) {",i=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,o=_e().getNumber("WEBGL_VERSION")===2?a:i,l=s==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qPe(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new HPe(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}const KPe={kernelName:J8,backendName:"webgl",kernelFunc:qPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XPe{constructor(t,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let s,a;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)a="resRC",s="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],u=[];for(let c=0;c<n.length;c++)u.push(`${o[c]}`),c<t&&l.push(`${o[c]}`);s=l.join(),a=u.join()}const i=Cn(r);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YPe(e){const{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new XPe(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],Xa(s.dtype,a.dtype))}const JPe={kernelName:VC,backendName:"webgl",kernelFunc:YPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZPe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${oN};
  float scale = ${lN};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,QPe=en({opSnippet:ZPe}),eLe={kernelName:lx,backendName:"webgl",kernelFunc:QPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tLe=Sy+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,nLe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,rLe=en({opSnippet:tLe,packedOpSnippet:nLe,cpuKernelImpl:nAe}),sLe={kernelName:hx,backendName:"webgl",kernelFunc:rLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aLe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,iLe=en({opSnippet:aLe}),oLe={kernelName:dx,backendName:"webgl",kernelFunc:iLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lLe=Sy+`
  return sin(x);
`,uLe=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Ip}
  return result;
`,cLe=en({opSnippet:lLe,packedOpSnippet:uLe}),dLe={kernelName:ux,backendName:"webgl",kernelFunc:cLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hLe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,pLe=en({opSnippet:hLe}),fLe={kernelName:cx,backendName:"webgl",kernelFunc:pLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mLe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,gLe=en({opSnippet:mLe}),yLe={kernelName:px,backendName:"webgl",kernelFunc:gLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bLe=e=>{const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;Y(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=a.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);const u=[],c=pJ({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=Nx(c.shape,a,o,!1),h=Tx(d.length,a.length,!1),p=$x(c.shape,a,o,!1),f=Ze({inputs:{x:c},backend:n,attrs:{shape:d}}),m=ea({inputs:{x:f},backend:n,attrs:{perm:h}}),g=Ze({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},vLe={kernelName:GC,backendName:"webgl",kernelFunc:bLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xLe(e){const{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);const o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=sAe(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}const wLe={kernelName:Z8,backendName:"webgl",kernelFunc:xLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kLe(e){const{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=aAe(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const SLe={kernelName:Q8,backendName:"webgl",kernelFunc:kLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ILe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=LY(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}const CLe={kernelName:eq,backendName:"webgl",kernelFunc:ILe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NLe(e){const{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=LY(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}const TLe={kernelName:tq,backendName:"webgl",kernelFunc:NLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Le(e){const{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=vp(a,s,o),p=!1;if(a.dtype==="string"){const y=n.bufferSync(s),b=n.bufferSync(a),x=Ac(n.readSync(i.dataId)[0]),v=tAe(y,b,o,h,c,u,l,d,x,p);return n.makeTensorInfo(o,v.dtype,v.values)}const f=new dM(u,l,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=Ze({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}const ELe={kernelName:nq,backendName:"webgl",kernelFunc:$Le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Le(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=Ht(i,s.shape)[0],l=I3(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(h=>{const p=[...d];p[o]=h;const f=Iy({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});return c[o]+=h,f})}const ALe={kernelName:HC,backendName:"webgl",kernelFunc:_Le};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _U="return sqrt(x);",RLe=en({opSnippet:_U,packedOpSnippet:_U,cpuKernelImpl:iAe}),DLe={kernelName:fx,backendName:"webgl",kernelFunc:RLe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OLe="return x * x;",FLe=en({opSnippet:OLe}),MLe={kernelName:aF,backendName:"webgl",kernelFunc:FLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AU="return (a - b) * (a - b);",PLe=Ts({opSnippet:AU,packedOpSnippet:AU}),LLe={kernelName:mx,backendName:"webgl",kernelFunc:PLe};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zLe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");const a=n.readSync(s.dataId),i=gu(a),o=oAe(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}const BLe={kernelName:iF,backendName:"webgl",kernelFunc:zLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WLe({inputs:e,attrs:t,backend:n}){const{x:r}=e,s=so+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new fl(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}const VLe={kernelName:xx,backendName:"webgl",kernelFunc:WLe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ULe{constructor(t,n,r){this.variableNames=["x"],this.outputShape=r;const s=r.length,a=Cn(r.length),i=Cn(r.length);let o="";if(s===1)o="coords * strides + begin";else{let l=0;o=r.map((u,c)=>(l++,r.length===1?`coords * strides[${c}] + begin[${c}]`:`coords[${l-1}] * strides[${c}] + begin[${c}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${t});
      ${a} strides = ${a}(${n});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jLe(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=i3(s.shape,a,i,o,l,u,c,d,h);let w;if(m)w=Ze({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){Y(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const S=r3(b,x,v),I=Iy({inputs:{x:s},backend:n,attrs:{begin:b,size:S}});w=Ze({inputs:{x:I},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(I)}else if(n.shouldExecuteOnCPU([s])){const I=n.readSync(s.dataId),$=Gt(s.shape,s.dtype,I),C=lAe(p,$,v,b);w=n.makeTensorInfo(f,s.dtype,C.values)}else{const I=new ULe(b,v,p);w=n.runWebGLProgram(I,[s],s.dtype)}const k=Ze({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}const GLe={kernelName:oF,backendName:"webgl",kernelFunc:jLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HLe(e){const{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=uAe(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}const qLe={kernelName:rq,backendName:"webgl",kernelFunc:HLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KLe(e){const{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);const o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=cAe(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const XLe={kernelName:sq,backendName:"webgl",kernelFunc:KLe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YLe(e){const{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");const i=n.readSync(a.dataId),o=dAe(i,s);return n.makeTensorInfo(a.shape,"int32",o)}const JLe={kernelName:aq,backendName:"webgl",kernelFunc:YLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZLe="return tan(x);",QLe=en({opSnippet:ZLe}),e4e={kernelName:yx,backendName:"webgl",kernelFunc:QLe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t4e=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,n4e=en({opSnippet:t4e}),r4e={kernelName:bx,backendName:"webgl",kernelFunc:n4e};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s4e(e){const{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=vp(i,a,s.shape),h=[d/u,u];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);const p=Ze({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=Ze({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=Ze({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new dM(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=Ze({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}const a4e={kernelName:Y8,backendName:"webgl",kernelFunc:s4e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i4e{constructor(t,n){this.variableNames=["A"];const r=new Array(t.length);for(let i=0;i<r.length;i++)r[i]=t[i]*n[i];this.outputShape=r,this.rank=r.length;const s=Cn(this.rank),a=o4e(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function o4e(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mJ(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){const l=n.readSync(s.dataId),u=s.dtype==="string"?l.map(h=>Ac(h)):l,c=Gt(s.shape,s.dtype,u),d=pAe(c,a);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const i=new i4e(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}const l4e={kernelName:vx,backendName:"webgl",kernelFunc:mJ};class u4e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class c4e{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rd(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function RU(e){let t=1;for(;t<e;)t*=2;return t}function d4e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=_e().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=_e().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){const C=n.readSync(s.dataId),[T,N]=fAe(C,u,s.dtype,a,i);return[n.makeTensorInfo(T.shape,T.dtype,T.values),n.makeTensorInfo(N.shape,N.dtype,N.values)]}if(a===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,Vx({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const d=n.texData.get(s.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(s):s,m=Me(u)/c,g=Ze({inputs:{x:p},attrs:{shape:[m,c]},backend:n});h&&Rd(n,p);const y=RU(a),b=RU(c);let x=null;const v=()=>x===null?[g,g]:[g,x],w=(C,T,N)=>{const E=v(),_=new u4e(N),z=[[c],[x===null?1:0],[Number.NEGATIVE_INFINITY],[C],[T]],W=x;x=n.runWebGLProgram(_,E,"int32",z),Rd(n,W)};for(let C=1;C<y;C*=2){const T=C*2;for(let N=C;N>=1;N/=2)w(T,N,[m,b])}for(let C=b;C>y;C/=2){const T=v(),N=new c4e([m,C/2]),_=[[c],[x===null?1:0],[y]],R=x;x=n.runWebGLProgram(N,T,"int32",_),Rd(n,R);const z=y/2,W=z*2;for(let F=z;F>=1;F/=2)w(W,F,x.shape)}let k=x;x=Iy({inputs:{x},backend:n,attrs:{begin:0,size:[m,a]}}),Rd(n,k);let S=oJ({inputs:{x:g,indices:x},backend:n,attrs:{axis:1,batchDims:1}});Rd(n,g);const I=u.slice(0,-1);I.push(a),k=x,x=Ze({inputs:{x},attrs:{shape:I},backend:n}),Rd(n,k);const $=S;return S=Ze({inputs:{x:S},attrs:{shape:I},backend:n}),Rd(n,$),[S,x]}const h4e={kernelName:lF,backendName:"webgl",kernelFunc:d4e};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p4e{constructor(t,n,r,s,a,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const o=r==="nearest"?1:2;let l;switch(s){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${t}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f4e(e){const{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=new p4e(d,h,i,o,l,g);return n.runWebGLProgram(y,[s,a],"float32")}const m4e={kernelName:uF,backendName:"webgl",kernelFunc:f4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g4e(e){const{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;zx(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=mAe(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}const y4e={kernelName:cF,backendName:"webgl",kernelFunc:g4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4e(e){const{inputs:t,backend:n,attrs:r}=e,{value:s}=t;let{axis:a}=r;a<0&&(a+=s.shape.length);const i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1);let c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);const d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;const f=new Array(l);for(let m=0;m<f.length;m++){h[a]=m;const g=Iy({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),y=Ze({inputs:{x:g},backend:n,attrs:{shape:u}});f[m]=y,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}const v4e={kernelName:KC,backendName:"webgl",kernelFunc:b4e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x4e{constructor(t,n){this.variableNames=["x","segmentIds"];const r=t.windowSize,s=t.batchSize,a=t.inSize,i=t.numSegments,o=i*Math.ceil(a/r);this.outputShape=[s,o];const l="0.0",u="sumValue",c=Math.floor(r/4)*4,d=r%4,h=`
        sumValue += dot(values, segFilter);
    `;let p="";a%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%r>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${c}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${h}
        }

        int inIdx = inOffset + ${c};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${h}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${h}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${h}
        }
        setOutput(${u});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w4e(e){const{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[];let u=0;const c=lr([u],o);let d=s;c!=null&&(d=ea({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=vr(1,o)[0]);const h=Z9(d.shape,u,i),p=Me([d.shape[u]]),f=Ze({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);const m=pF(s.dtype),g=(v,w,k,S,I)=>{const $=v.shape[0],C=v.shape[1],T=J9(C,I),N={windowSize:T,inSize:C,batchSize:$,numSegments:I},E=new x4e(N,w),_=n.compileAndRun(E,[v,k],S);if(l.push(_),_.shape[1]===I)return _;const R=fJ({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),z=mJ({inputs:{x:R},backend:n,attrs:{reps:[C/T]}});return l.push(R),l.push(z),g(_,w,z,S,I)},y=g(f,"unsortedSegmentSum",a,m,i),b=Ze({inputs:{x:y},backend:n,attrs:{shape:h}});let x=b;if(c!=null){l.push(b);const v=id(c);x=ea({inputs:{x},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}const k4e={kernelName:XC,backendName:"webgl",kernelFunc:w4e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S4e=[iRe,lRe,dRe,fRe,gRe,vRe,wRe,SRe,TRe,ERe,RRe,FRe,LRe,VRe,GRe,qRe,XRe,QRe,tDe,rDe,oDe,fDe,gDe,xDe,kDe,$De,_De,ODe,UAe,PDe,VDe,HDe,ZDe,tOe,rOe,aOe,oOe,dOe,fOe,yOe,vOe,wOe,SOe,NOe,$Oe,ROe,OOe,POe,BOe,VOe,HOe,YOe,eFe,rFe,iFe,oFe,uFe,dFe,pFe,mFe,yFe,wFe,IFe,TFe,EFe,RFe,FFe,zFe,UFe,VAe,GFe,BDe,KFe,JFe,e3e,GAe,s3e,l3e,c3e,f3e,y3e,w3e,I3e,$3e,R3e,F3e,P3e,W3e,U3e,G3e,X3e,J3e,Q3e,tMe,rMe,oMe,dMe,mMe,SMe,KAe,TMe,_Me,DMe,MMe,IDe,zMe,WMe,UMe,HMe,YMe,qAe,ZMe,ePe,nPe,sPe,aPe,CDe,vMe,lPe,hPe,gPe,YAe,xPe,SPe,TPe,_Pe,OPe,MPe,zPe,VPe,GPe,KPe,JPe,eLe,sLe,oLe,dLe,fLe,hDe,wMe,yLe,vLe,wLe,SLe,CLe,TLe,ELe,ALe,DLe,MLe,LLe,BLe,VLe,GLe,qLe,XLe,JLe,xMe,rRe,e4e,r4e,a4e,l4e,h4e,m4e,sRe,y4e,v4e,k4e,BMe];for(const e of S4e)oq(e);const I4e=()=>{const[e,t]=Z.useState(!0),[n,r]=Z.useState(""),[s,a]=Z.useState(""),[i,o]=Z.useState(!0),[l,u]=Z.useState(),[c,d]=Z.useState(!1);let h,p;const f=Z.useRef(null),m=Z.useRef(null),g=Z.useRef(null),y=WI();Z.useEffect(()=>{if(l!=null&&l.tfjsCompatible==="not tested"){async function I(){if(await v()===!1){b(!1);return}if(console.log("setBackend test passed"),await w()===!1){b(!1);return}if(console.log("loadModels test passed"),await x()===!1){b(!1);return}console.log("testTFJSPrediction test passed"),b(!0)}d(!0),I()}else l!=null&&l.tfjsCompatible!="not tested"&&y("/dashboardPage",{replace:!0})},[l]);async function b(I){l!=null&&(await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/user/${l._id}`,{method:"PATCH",credentials:"include",headers:{"Content-Type":"application/json"},body:JSON.stringify({tfjsCompatible:I.toString()})}),I===!0?console.log("This device supports tfjs"):I===!1&&console.log("This device does not support tfjs. Instead a backend version will be used."),d(!1),y("/dashboardPage",{replace:!0}))}async function x(){try{const $=await(await fetch("/processedSelfieTensor.json")).json(),C=hh($),N=p.predict(C).arraySync()[0];console.log("Selfie CNN Prediction Scores ="),console.log(N);const _=await(await fetch("/processedJournalTensor.json")).json(),R=hh(_),W=h.predict(R).arraySync()[0];return console.log("Journal BNNC Prediction Scores ="),console.log(W),!0}catch(I){return console.log(I),!1}}async function v(){try{return Ym("webgl"),await Jm(),console.log("WebGL backend is compatible"),!0}catch(I){console.log("WebGL backend is not compatible:",I)}try{return Ym("wasm"),await Jm(),console.log("WASM backend is compatible"),!0}catch(I){console.log("WASM backend is not compatible:",I)}try{return Ym("cpu"),await Jm(),console.log("CPU backend is compatible"),!0}catch(I){console.log("CPU backend is not compatible:",I)}return!1}async function w(){try{return h=await _S("https://tpd20seu.projects.cmp.uea.ac.uk/journal/models/TFJSBinaryNeuralNetworkClassifier/model.json"),p=await _S("https://tpd20seu.projects.cmp.uea.ac.uk/selfie/models/tfjsCNNV3-OS-Epoch-100/model.json"),h&&p?(console.log("Fetch of BNNC and CNN models completed :)"),!0):!1}catch(I){return console.log("Error while loading BNNC and CNN models:",I),!1}}async function k(){const $=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/user/",{method:"GET",credentials:"include"})).json();u($)}async function S(I){I.preventDefault(),await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/user/login",{method:"POST",headers:{"Content-Type":"application/json"},credentials:"include",body:JSON.stringify({username:n,password:s})})).status===200?(o(!0),k()):o(!1)}return Z.useEffect(()=>{f.current!=null&&m.current!=null&&i===!1&&(f.current.style.color="red",f.current.style.border="1px solid red",m.current.style.color="red",m.current.style.border="1px solid red",f.current.value="",m.current.value="")},[i]),A.jsxs(A.Fragment,{children:[c&&A.jsxs("div",{id:"loadingSpinnerContainer",children:[A.jsx(ly,{visible:!0,height:"80",width:"80",color:"#FED362",ariaLabel:"tail-spin-loading",radius:"1",wrapperStyle:{},wrapperClass:""}),A.jsx("h2",{children:"Testing device compatibility with website...."})]}),!c&&A.jsxs("div",{id:"loginScreenContainer",children:[A.jsx(nr,{id:"usernameEmptyTooltip",place:"top",content:"You must enter a username"}),A.jsx(nr,{id:"passwordEmptyTooltip",place:"top",content:"You must enter a password"}),A.jsx(nr,{id:"consentWarningTooltip",place:"top",content:"You must read through the 'Important Information' section and check the consent checkbox"}),A.jsxs("form",{id:"loginForm",onSubmit:I=>{S(I)},children:[A.jsx("h2",{children:'Welcome to the "You Are Not Your Thoughts" website!'}),A.jsx("h3",{children:"Please enter the login details provided by the researcher Dawid Klos in the instructions email sent to you."}),A.jsxs("div",{id:"notesContainer",children:[A.jsx("p",{children:"*Important Information:"}),A.jsxs("ul",{children:[A.jsx("li",{children:"It is important that you understand that both the Journal and Selfie features will store your inputted entries/selfies on a secure database if you click the submit button."}),A.jsx("li",{children:"It is up to you if you wish to submit your entries/selfies. You will still be able to test both of the feature's machine learning models without submission."}),A.jsx("li",{children:"This login will keep the data you input during testing safe and only accessible by the researcher Dawid Klos."}),A.jsx("li",{children:"All of your data will be deleted and will not be used in the project report in any capacity."}),A.jsx("li",{children:"The sole goal of getting individuals to test the website is to collect feedback on features, get recommendations from testers, and to find any bugs missed during development."})]})]}),!i&&A.jsx("p",{id:"invalidLoginDetailsP",children:"*Incorrect Login Details - Please try again"}),A.jsxs("div",{id:"usernameContainer",className:"loginFieldContainer",children:[A.jsx("label",{htmlFor:"username",id:"usernameLbl",className:"loginFieldLbl",children:"Username:"}),A.jsx("input",{type:"text",id:"usernameTxt",className:"loginTxt",ref:f,placeholder:"Enter your username...",onChange:I=>{r(I.target.value)}})]}),A.jsxs("div",{id:"passwordContainer",className:"loginFieldContainer",children:[A.jsx("label",{htmlFor:"password",id:"passwordLbl",className:"loginFieldLbl",children:"Password:"}),A.jsx("input",{type:"text",id:"passwordTxt",className:"loginTxt",ref:m,placeholder:"Enter your password...",onChange:I=>{a(I.target.value)}})]}),A.jsxs("div",{id:"checkBoxContainer",className:"loginFieldContainer",children:[A.jsxs("label",{htmlFor:"checkbox",children:["I have read through and understood the ",A.jsx("u",{children:"'Important Information'"})," section and I consent to testing the website"]}),A.jsx("input",{type:"checkbox",id:"consentCBX",ref:g,onChange:()=>{t(!e)}})]}),A.jsx("button",{type:"submit",id:"loginBtn",disabled:n===""||s===""?!0:e,"data-tooltip-id":n===""?"usernameEmptyTooltip":s===""?"passwordEmptyTooltip":e?"consentWarningTooltip":"",children:"Login"})]})]})]})},C4e=()=>A.jsxs(A.Fragment,{children:[A.jsx("h1",{children:"Home Page"}),A.jsx("h2",{children:"Stress Probability 60%"})]});function N4e(){this.__data__=[],this.size=0}var T4e=N4e;function $4e(e,t){return e===t||e!==e&&t!==t}var gJ=$4e,E4e=gJ;function _4e(e,t){for(var n=e.length;n--;)if(E4e(e[n][0],t))return n;return-1}var NN=_4e,A4e=NN,R4e=Array.prototype,D4e=R4e.splice;function O4e(e){var t=this.__data__,n=A4e(t,e);if(n<0)return!1;var r=t.length-1;return n==r?t.pop():D4e.call(t,n,1),--this.size,!0}var F4e=O4e,M4e=NN;function P4e(e){var t=this.__data__,n=M4e(t,e);return n<0?void 0:t[n][1]}var L4e=P4e,z4e=NN;function B4e(e){return z4e(this.__data__,e)>-1}var W4e=B4e,V4e=NN;function U4e(e,t){var n=this.__data__,r=V4e(n,e);return r<0?(++this.size,n.push([e,t])):n[r][1]=t,this}var j4e=U4e,G4e=T4e,H4e=F4e,q4e=L4e,K4e=W4e,X4e=j4e;function Cy(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Cy.prototype.clear=G4e;Cy.prototype.delete=H4e;Cy.prototype.get=q4e;Cy.prototype.has=K4e;Cy.prototype.set=X4e;var TN=Cy,Y4e=TN;function J4e(){this.__data__=new Y4e,this.size=0}var Z4e=J4e;function Q4e(e){var t=this.__data__,n=t.delete(e);return this.size=t.size,n}var eze=Q4e;function tze(e){return this.__data__.get(e)}var nze=tze;function rze(e){return this.__data__.has(e)}var sze=rze,aze=typeof mr=="object"&&mr&&mr.Object===Object&&mr,yJ=aze,ize=yJ,oze=typeof self=="object"&&self&&self.Object===Object&&self,lze=ize||oze||Function("return this")(),Tu=lze,uze=Tu,cze=uze.Symbol,hM=cze,DU=hM,bJ=Object.prototype,dze=bJ.hasOwnProperty,hze=bJ.toString,bv=DU?DU.toStringTag:void 0;function pze(e){var t=dze.call(e,bv),n=e[bv];try{e[bv]=void 0;var r=!0}catch{}var s=hze.call(e);return r&&(t?e[bv]=n:delete e[bv]),s}var fze=pze,mze=Object.prototype,gze=mze.toString;function yze(e){return gze.call(e)}var bze=yze,OU=hM,vze=fze,xze=bze,wze="[object Null]",kze="[object Undefined]",FU=OU?OU.toStringTag:void 0;function Sze(e){return e==null?e===void 0?kze:wze:FU&&FU in Object(e)?vze(e):xze(e)}var $N=Sze;function Ize(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}var vJ=Ize,Cze=$N,Nze=vJ,Tze="[object AsyncFunction]",$ze="[object Function]",Eze="[object GeneratorFunction]",_ze="[object Proxy]";function Aze(e){if(!Nze(e))return!1;var t=Cze(e);return t==$ze||t==Eze||t==Tze||t==_ze}var xJ=Aze,Rze=Tu,Dze=Rze["__core-js_shared__"],Oze=Dze,vE=Oze,MU=function(){var e=/[^.]+$/.exec(vE&&vE.keys&&vE.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();function Fze(e){return!!MU&&MU in e}var Mze=Fze,Pze=Function.prototype,Lze=Pze.toString;function zze(e){if(e!=null){try{return Lze.call(e)}catch{}try{return e+""}catch{}}return""}var wJ=zze,Bze=xJ,Wze=Mze,Vze=vJ,Uze=wJ,jze=/[\\^$.*+?()[\]{}|]/g,Gze=/^\[object .+?Constructor\]$/,Hze=Function.prototype,qze=Object.prototype,Kze=Hze.toString,Xze=qze.hasOwnProperty,Yze=RegExp("^"+Kze.call(Xze).replace(jze,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function Jze(e){if(!Vze(e)||Wze(e))return!1;var t=Bze(e)?Yze:Gze;return t.test(Uze(e))}var Zze=Jze;function Qze(e,t){return e==null?void 0:e[t]}var eBe=Qze,tBe=Zze,nBe=eBe;function rBe(e,t){var n=nBe(e,t);return tBe(n)?n:void 0}var Ny=rBe,sBe=Ny,aBe=Tu,iBe=sBe(aBe,"Map"),pM=iBe,oBe=Ny,lBe=oBe(Object,"create"),EN=lBe,PU=EN;function uBe(){this.__data__=PU?PU(null):{},this.size=0}var cBe=uBe;function dBe(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}var hBe=dBe,pBe=EN,fBe="__lodash_hash_undefined__",mBe=Object.prototype,gBe=mBe.hasOwnProperty;function yBe(e){var t=this.__data__;if(pBe){var n=t[e];return n===fBe?void 0:n}return gBe.call(t,e)?t[e]:void 0}var bBe=yBe,vBe=EN,xBe=Object.prototype,wBe=xBe.hasOwnProperty;function kBe(e){var t=this.__data__;return vBe?t[e]!==void 0:wBe.call(t,e)}var SBe=kBe,IBe=EN,CBe="__lodash_hash_undefined__";function NBe(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=IBe&&t===void 0?CBe:t,this}var TBe=NBe,$Be=cBe,EBe=hBe,_Be=bBe,ABe=SBe,RBe=TBe;function Ty(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Ty.prototype.clear=$Be;Ty.prototype.delete=EBe;Ty.prototype.get=_Be;Ty.prototype.has=ABe;Ty.prototype.set=RBe;var DBe=Ty,LU=DBe,OBe=TN,FBe=pM;function MBe(){this.size=0,this.__data__={hash:new LU,map:new(FBe||OBe),string:new LU}}var PBe=MBe;function LBe(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}var zBe=LBe,BBe=zBe;function WBe(e,t){var n=e.__data__;return BBe(t)?n[typeof t=="string"?"string":"hash"]:n.map}var _N=WBe,VBe=_N;function UBe(e){var t=VBe(this,e).delete(e);return this.size-=t?1:0,t}var jBe=UBe,GBe=_N;function HBe(e){return GBe(this,e).get(e)}var qBe=HBe,KBe=_N;function XBe(e){return KBe(this,e).has(e)}var YBe=XBe,JBe=_N;function ZBe(e,t){var n=JBe(this,e),r=n.size;return n.set(e,t),this.size+=n.size==r?0:1,this}var QBe=ZBe,eWe=PBe,tWe=jBe,nWe=qBe,rWe=YBe,sWe=QBe;function $y(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}$y.prototype.clear=eWe;$y.prototype.delete=tWe;$y.prototype.get=nWe;$y.prototype.has=rWe;$y.prototype.set=sWe;var kJ=$y,aWe=TN,iWe=pM,oWe=kJ,lWe=200;function uWe(e,t){var n=this.__data__;if(n instanceof aWe){var r=n.__data__;if(!iWe||r.length<lWe-1)return r.push([e,t]),this.size=++n.size,this;n=this.__data__=new oWe(r)}return n.set(e,t),this.size=n.size,this}var cWe=uWe,dWe=TN,hWe=Z4e,pWe=eze,fWe=nze,mWe=sze,gWe=cWe;function Ey(e){var t=this.__data__=new dWe(e);this.size=t.size}Ey.prototype.clear=hWe;Ey.prototype.delete=pWe;Ey.prototype.get=fWe;Ey.prototype.has=mWe;Ey.prototype.set=gWe;var yWe=Ey,bWe="__lodash_hash_undefined__";function vWe(e){return this.__data__.set(e,bWe),this}var xWe=vWe;function wWe(e){return this.__data__.has(e)}var kWe=wWe,SWe=kJ,IWe=xWe,CWe=kWe;function BS(e){var t=-1,n=e==null?0:e.length;for(this.__data__=new SWe;++t<n;)this.add(e[t])}BS.prototype.add=BS.prototype.push=IWe;BS.prototype.has=CWe;var NWe=BS;function TWe(e,t){for(var n=-1,r=e==null?0:e.length;++n<r;)if(t(e[n],n,e))return!0;return!1}var $We=TWe;function EWe(e,t){return e.has(t)}var _We=EWe,AWe=NWe,RWe=$We,DWe=_We,OWe=1,FWe=2;function MWe(e,t,n,r,s,a){var i=n&OWe,o=e.length,l=t.length;if(o!=l&&!(i&&l>o))return!1;var u=a.get(e),c=a.get(t);if(u&&c)return u==t&&c==e;var d=-1,h=!0,p=n&FWe?new AWe:void 0;for(a.set(e,t),a.set(t,e);++d<o;){var f=e[d],m=t[d];if(r)var g=i?r(m,f,d,t,e,a):r(f,m,d,e,t,a);if(g!==void 0){if(g)continue;h=!1;break}if(p){if(!RWe(t,function(y,b){if(!DWe(p,b)&&(f===y||s(f,y,n,r,a)))return p.push(b)})){h=!1;break}}else if(!(f===m||s(f,m,n,r,a))){h=!1;break}}return a.delete(e),a.delete(t),h}var SJ=MWe,PWe=Tu,LWe=PWe.Uint8Array,zWe=LWe;function BWe(e){var t=-1,n=Array(e.size);return e.forEach(function(r,s){n[++t]=[s,r]}),n}var WWe=BWe;function VWe(e){var t=-1,n=Array(e.size);return e.forEach(function(r){n[++t]=r}),n}var UWe=VWe,zU=hM,BU=zWe,jWe=gJ,GWe=SJ,HWe=WWe,qWe=UWe,KWe=1,XWe=2,YWe="[object Boolean]",JWe="[object Date]",ZWe="[object Error]",QWe="[object Map]",eVe="[object Number]",tVe="[object RegExp]",nVe="[object Set]",rVe="[object String]",sVe="[object Symbol]",aVe="[object ArrayBuffer]",iVe="[object DataView]",WU=zU?zU.prototype:void 0,xE=WU?WU.valueOf:void 0;function oVe(e,t,n,r,s,a,i){switch(n){case iVe:if(e.byteLength!=t.byteLength||e.byteOffset!=t.byteOffset)return!1;e=e.buffer,t=t.buffer;case aVe:return!(e.byteLength!=t.byteLength||!a(new BU(e),new BU(t)));case YWe:case JWe:case eVe:return jWe(+e,+t);case ZWe:return e.name==t.name&&e.message==t.message;case tVe:case rVe:return e==t+"";case QWe:var o=HWe;case nVe:var l=r&KWe;if(o||(o=qWe),e.size!=t.size&&!l)return!1;var u=i.get(e);if(u)return u==t;r|=XWe,i.set(e,t);var c=GWe(o(e),o(t),r,s,a,i);return i.delete(e),c;case sVe:if(xE)return xE.call(e)==xE.call(t)}return!1}var lVe=oVe;function uVe(e,t){for(var n=-1,r=t.length,s=e.length;++n<r;)e[s+n]=t[n];return e}var cVe=uVe,dVe=Array.isArray,fM=dVe,hVe=cVe,pVe=fM;function fVe(e,t,n){var r=t(e);return pVe(e)?r:hVe(r,n(e))}var mVe=fVe;function gVe(e,t){for(var n=-1,r=e==null?0:e.length,s=0,a=[];++n<r;){var i=e[n];t(i,n,e)&&(a[s++]=i)}return a}var yVe=gVe;function bVe(){return[]}var vVe=bVe,xVe=yVe,wVe=vVe,kVe=Object.prototype,SVe=kVe.propertyIsEnumerable,VU=Object.getOwnPropertySymbols,IVe=VU?function(e){return e==null?[]:(e=Object(e),xVe(VU(e),function(t){return SVe.call(e,t)}))}:wVe,CVe=IVe;function NVe(e,t){for(var n=-1,r=Array(e);++n<e;)r[n]=t(n);return r}var TVe=NVe;function $Ve(e){return e!=null&&typeof e=="object"}var AN=$Ve,EVe=$N,_Ve=AN,AVe="[object Arguments]";function RVe(e){return _Ve(e)&&EVe(e)==AVe}var DVe=RVe,UU=DVe,OVe=AN,IJ=Object.prototype,FVe=IJ.hasOwnProperty,MVe=IJ.propertyIsEnumerable,PVe=UU(function(){return arguments}())?UU:function(e){return OVe(e)&&FVe.call(e,"callee")&&!MVe.call(e,"callee")},LVe=PVe,WS={exports:{}};function zVe(){return!1}var BVe=zVe;WS.exports;(function(e,t){var n=Tu,r=BVe,s=t&&!t.nodeType&&t,a=s&&!0&&e&&!e.nodeType&&e,i=a&&a.exports===s,o=i?n.Buffer:void 0,l=o?o.isBuffer:void 0,u=l||r;e.exports=u})(WS,WS.exports);var CJ=WS.exports,WVe=9007199254740991,VVe=/^(?:0|[1-9]\d*)$/;function UVe(e,t){var n=typeof e;return t=t??WVe,!!t&&(n=="number"||n!="symbol"&&VVe.test(e))&&e>-1&&e%1==0&&e<t}var jVe=UVe,GVe=9007199254740991;function HVe(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=GVe}var NJ=HVe,qVe=$N,KVe=NJ,XVe=AN,YVe="[object Arguments]",JVe="[object Array]",ZVe="[object Boolean]",QVe="[object Date]",eUe="[object Error]",tUe="[object Function]",nUe="[object Map]",rUe="[object Number]",sUe="[object Object]",aUe="[object RegExp]",iUe="[object Set]",oUe="[object String]",lUe="[object WeakMap]",uUe="[object ArrayBuffer]",cUe="[object DataView]",dUe="[object Float32Array]",hUe="[object Float64Array]",pUe="[object Int8Array]",fUe="[object Int16Array]",mUe="[object Int32Array]",gUe="[object Uint8Array]",yUe="[object Uint8ClampedArray]",bUe="[object Uint16Array]",vUe="[object Uint32Array]",qn={};qn[dUe]=qn[hUe]=qn[pUe]=qn[fUe]=qn[mUe]=qn[gUe]=qn[yUe]=qn[bUe]=qn[vUe]=!0;qn[YVe]=qn[JVe]=qn[uUe]=qn[ZVe]=qn[cUe]=qn[QVe]=qn[eUe]=qn[tUe]=qn[nUe]=qn[rUe]=qn[sUe]=qn[aUe]=qn[iUe]=qn[oUe]=qn[lUe]=!1;function xUe(e){return XVe(e)&&KVe(e.length)&&!!qn[qVe(e)]}var wUe=xUe;function kUe(e){return function(t){return e(t)}}var SUe=kUe,VS={exports:{}};VS.exports;(function(e,t){var n=yJ,r=t&&!t.nodeType&&t,s=r&&!0&&e&&!e.nodeType&&e,a=s&&s.exports===r,i=a&&n.process,o=function(){try{var l=s&&s.require&&s.require("util").types;return l||i&&i.binding&&i.binding("util")}catch{}}();e.exports=o})(VS,VS.exports);var IUe=VS.exports,CUe=wUe,NUe=SUe,jU=IUe,GU=jU&&jU.isTypedArray,TUe=GU?NUe(GU):CUe,TJ=TUe,$Ue=TVe,EUe=LVe,_Ue=fM,AUe=CJ,RUe=jVe,DUe=TJ,OUe=Object.prototype,FUe=OUe.hasOwnProperty;function MUe(e,t){var n=_Ue(e),r=!n&&EUe(e),s=!n&&!r&&AUe(e),a=!n&&!r&&!s&&DUe(e),i=n||r||s||a,o=i?$Ue(e.length,String):[],l=o.length;for(var u in e)(t||FUe.call(e,u))&&!(i&&(u=="length"||s&&(u=="offset"||u=="parent")||a&&(u=="buffer"||u=="byteLength"||u=="byteOffset")||RUe(u,l)))&&o.push(u);return o}var PUe=MUe,LUe=Object.prototype;function zUe(e){var t=e&&e.constructor,n=typeof t=="function"&&t.prototype||LUe;return e===n}var BUe=zUe;function WUe(e,t){return function(n){return e(t(n))}}var VUe=WUe,UUe=VUe,jUe=UUe(Object.keys,Object),GUe=jUe,HUe=BUe,qUe=GUe,KUe=Object.prototype,XUe=KUe.hasOwnProperty;function YUe(e){if(!HUe(e))return qUe(e);var t=[];for(var n in Object(e))XUe.call(e,n)&&n!="constructor"&&t.push(n);return t}var JUe=YUe,ZUe=xJ,QUe=NJ;function eje(e){return e!=null&&QUe(e.length)&&!ZUe(e)}var tje=eje,nje=PUe,rje=JUe,sje=tje;function aje(e){return sje(e)?nje(e):rje(e)}var ije=aje,oje=mVe,lje=CVe,uje=ije;function cje(e){return oje(e,uje,lje)}var dje=cje,HU=dje,hje=1,pje=Object.prototype,fje=pje.hasOwnProperty;function mje(e,t,n,r,s,a){var i=n&hje,o=HU(e),l=o.length,u=HU(t),c=u.length;if(l!=c&&!i)return!1;for(var d=l;d--;){var h=o[d];if(!(i?h in t:fje.call(t,h)))return!1}var p=a.get(e),f=a.get(t);if(p&&f)return p==t&&f==e;var m=!0;a.set(e,t),a.set(t,e);for(var g=i;++d<l;){h=o[d];var y=e[h],b=t[h];if(r)var x=i?r(b,y,h,t,e,a):r(y,b,h,e,t,a);if(!(x===void 0?y===b||s(y,b,n,r,a):x)){m=!1;break}g||(g=h=="constructor")}if(m&&!g){var v=e.constructor,w=t.constructor;v!=w&&"constructor"in e&&"constructor"in t&&!(typeof v=="function"&&v instanceof v&&typeof w=="function"&&w instanceof w)&&(m=!1)}return a.delete(e),a.delete(t),m}var gje=mje,yje=Ny,bje=Tu,vje=yje(bje,"DataView"),xje=vje,wje=Ny,kje=Tu,Sje=wje(kje,"Promise"),Ije=Sje,Cje=Ny,Nje=Tu,Tje=Cje(Nje,"Set"),$je=Tje,Eje=Ny,_je=Tu,Aje=Eje(_je,"WeakMap"),Rje=Aje,GA=xje,HA=pM,qA=Ije,KA=$je,XA=Rje,$J=$N,_y=wJ,qU="[object Map]",Dje="[object Object]",KU="[object Promise]",XU="[object Set]",YU="[object WeakMap]",JU="[object DataView]",Oje=_y(GA),Fje=_y(HA),Mje=_y(qA),Pje=_y(KA),Lje=_y(XA),Bd=$J;(GA&&Bd(new GA(new ArrayBuffer(1)))!=JU||HA&&Bd(new HA)!=qU||qA&&Bd(qA.resolve())!=KU||KA&&Bd(new KA)!=XU||XA&&Bd(new XA)!=YU)&&(Bd=function(e){var t=$J(e),n=t==Dje?e.constructor:void 0,r=n?_y(n):"";if(r)switch(r){case Oje:return JU;case Fje:return qU;case Mje:return KU;case Pje:return XU;case Lje:return YU}return t});var zje=Bd,wE=yWe,Bje=SJ,Wje=lVe,Vje=gje,ZU=zje,QU=fM,ej=CJ,Uje=TJ,jje=1,tj="[object Arguments]",nj="[object Array]",Mk="[object Object]",Gje=Object.prototype,rj=Gje.hasOwnProperty;function Hje(e,t,n,r,s,a){var i=QU(e),o=QU(t),l=i?nj:ZU(e),u=o?nj:ZU(t);l=l==tj?Mk:l,u=u==tj?Mk:u;var c=l==Mk,d=u==Mk,h=l==u;if(h&&ej(e)){if(!ej(t))return!1;i=!0,c=!1}if(h&&!c)return a||(a=new wE),i||Uje(e)?Bje(e,t,n,r,s,a):Wje(e,t,l,n,r,s,a);if(!(n&jje)){var p=c&&rj.call(e,"__wrapped__"),f=d&&rj.call(t,"__wrapped__");if(p||f){var m=p?e.value():e,g=f?t.value():t;return a||(a=new wE),s(m,g,n,r,a)}}return h?(a||(a=new wE),Vje(e,t,n,r,s,a)):!1}var qje=Hje,Kje=qje,sj=AN;function EJ(e,t,n,r,s){return e===t?!0:e==null||t==null||!sj(e)&&!sj(t)?e!==e&&t!==t:Kje(e,t,n,r,EJ,s)}var Xje=EJ,Yje=Xje;function Jje(e,t){return Yje(e,t)}var Zje=Jje,_J={exports:{}};/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */(function(e,t){(function(r,s){e.exports=s()})(typeof self<"u"?self:mr,function(){return function(n){var r={};function s(a){if(r[a])return r[a].exports;var i=r[a]={i:a,l:!1,exports:{}};return n[a].call(i.exports,i,i.exports,s),i.l=!0,i.exports}return s.m=n,s.c=r,s.d=function(a,i,o){s.o(a,i)||Object.defineProperty(a,i,{configurable:!1,enumerable:!0,get:o})},s.n=function(a){var i=a&&a.__esModule?function(){return a.default}:function(){return a};return s.d(i,"a",i),i},s.o=function(a,i){return Object.prototype.hasOwnProperty.call(a,i)},s.p="",s(s.s=109)}([function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(17),i=s(18),o=s(19),l=s(45),u=s(46),c=s(47),d=s(48),h=s(49),p=s(12),f=s(32),m=s(33),g=s(31),y=s(1),b={Scope:y.Scope,create:y.create,find:y.find,query:y.query,register:y.register,Container:a.default,Format:i.default,Leaf:o.default,Embed:d.default,Scroll:l.default,Block:c.default,Inline:u.default,Text:h.default,Attributor:{Attribute:p.default,Class:f.default,Style:m.default,Store:g.default}};r.default=b},function(n,r,s){var a=this&&this.__extends||function(){var g=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(y,b){y.__proto__=b}||function(y,b){for(var x in b)b.hasOwnProperty(x)&&(y[x]=b[x])};return function(y,b){g(y,b);function x(){this.constructor=y}y.prototype=b===null?Object.create(b):(x.prototype=b.prototype,new x)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=function(g){a(y,g);function y(b){var x=this;return b="[Parchment] "+b,x=g.call(this,b)||this,x.message=b,x.name=x.constructor.name,x}return y}(Error);r.ParchmentError=i;var o={},l={},u={},c={};r.DATA_KEY="__blot";var d;(function(g){g[g.TYPE=3]="TYPE",g[g.LEVEL=12]="LEVEL",g[g.ATTRIBUTE=13]="ATTRIBUTE",g[g.BLOT=14]="BLOT",g[g.INLINE=7]="INLINE",g[g.BLOCK=11]="BLOCK",g[g.BLOCK_BLOT=10]="BLOCK_BLOT",g[g.INLINE_BLOT=6]="INLINE_BLOT",g[g.BLOCK_ATTRIBUTE=9]="BLOCK_ATTRIBUTE",g[g.INLINE_ATTRIBUTE=5]="INLINE_ATTRIBUTE",g[g.ANY=15]="ANY"})(d=r.Scope||(r.Scope={}));function h(g,y){var b=f(g);if(b==null)throw new i("Unable to create "+g+" blot");var x=b,v=g instanceof Node||g.nodeType===Node.TEXT_NODE?g:x.create(y);return new x(v,y)}r.create=h;function p(g,y){return y===void 0&&(y=!1),g==null?null:g[r.DATA_KEY]!=null?g[r.DATA_KEY].blot:y?p(g.parentNode,y):null}r.find=p;function f(g,y){y===void 0&&(y=d.ANY);var b;if(typeof g=="string")b=c[g]||o[g];else if(g instanceof Text||g.nodeType===Node.TEXT_NODE)b=c.text;else if(typeof g=="number")g&d.LEVEL&d.BLOCK?b=c.block:g&d.LEVEL&d.INLINE&&(b=c.inline);else if(g instanceof HTMLElement){var x=(g.getAttribute("class")||"").split(/\s+/);for(var v in x)if(b=l[x[v]],b)break;b=b||u[g.tagName]}return b==null?null:y&d.LEVEL&b.scope&&y&d.TYPE&b.scope?b:null}r.query=f;function m(){for(var g=[],y=0;y<arguments.length;y++)g[y]=arguments[y];if(g.length>1)return g.map(function(v){return m(v)});var b=g[0];if(typeof b.blotName!="string"&&typeof b.attrName!="string")throw new i("Invalid definition");if(b.blotName==="abstract")throw new i("Cannot register abstract class");if(c[b.blotName||b.attrName]=b,typeof b.keyName=="string")o[b.keyName]=b;else if(b.className!=null&&(l[b.className]=b),b.tagName!=null){Array.isArray(b.tagName)?b.tagName=b.tagName.map(function(v){return v.toUpperCase()}):b.tagName=b.tagName.toUpperCase();var x=Array.isArray(b.tagName)?b.tagName:[b.tagName];x.forEach(function(v){(u[v]==null||b.className==null)&&(u[v]=b)})}return b}r.register=m},function(n,r,s){var a=s(51),i=s(11),o=s(3),l=s(20),u=String.fromCharCode(0),c=function(d){Array.isArray(d)?this.ops=d:d!=null&&Array.isArray(d.ops)?this.ops=d.ops:this.ops=[]};c.prototype.insert=function(d,h){var p={};return d.length===0?this:(p.insert=d,h!=null&&typeof h=="object"&&Object.keys(h).length>0&&(p.attributes=h),this.push(p))},c.prototype.delete=function(d){return d<=0?this:this.push({delete:d})},c.prototype.retain=function(d,h){if(d<=0)return this;var p={retain:d};return h!=null&&typeof h=="object"&&Object.keys(h).length>0&&(p.attributes=h),this.push(p)},c.prototype.push=function(d){var h=this.ops.length,p=this.ops[h-1];if(d=o(!0,{},d),typeof p=="object"){if(typeof d.delete=="number"&&typeof p.delete=="number")return this.ops[h-1]={delete:p.delete+d.delete},this;if(typeof p.delete=="number"&&d.insert!=null&&(h-=1,p=this.ops[h-1],typeof p!="object"))return this.ops.unshift(d),this;if(i(d.attributes,p.attributes)){if(typeof d.insert=="string"&&typeof p.insert=="string")return this.ops[h-1]={insert:p.insert+d.insert},typeof d.attributes=="object"&&(this.ops[h-1].attributes=d.attributes),this;if(typeof d.retain=="number"&&typeof p.retain=="number")return this.ops[h-1]={retain:p.retain+d.retain},typeof d.attributes=="object"&&(this.ops[h-1].attributes=d.attributes),this}}return h===this.ops.length?this.ops.push(d):this.ops.splice(h,0,d),this},c.prototype.chop=function(){var d=this.ops[this.ops.length-1];return d&&d.retain&&!d.attributes&&this.ops.pop(),this},c.prototype.filter=function(d){return this.ops.filter(d)},c.prototype.forEach=function(d){this.ops.forEach(d)},c.prototype.map=function(d){return this.ops.map(d)},c.prototype.partition=function(d){var h=[],p=[];return this.forEach(function(f){var m=d(f)?h:p;m.push(f)}),[h,p]},c.prototype.reduce=function(d,h){return this.ops.reduce(d,h)},c.prototype.changeLength=function(){return this.reduce(function(d,h){return h.insert?d+l.length(h):h.delete?d-h.delete:d},0)},c.prototype.length=function(){return this.reduce(function(d,h){return d+l.length(h)},0)},c.prototype.slice=function(d,h){d=d||0,typeof h!="number"&&(h=1/0);for(var p=[],f=l.iterator(this.ops),m=0;m<h&&f.hasNext();){var g;m<d?g=f.next(d-m):(g=f.next(h-m),p.push(g)),m+=l.length(g)}return new c(p)},c.prototype.compose=function(d){var h=l.iterator(this.ops),p=l.iterator(d.ops),f=[],m=p.peek();if(m!=null&&typeof m.retain=="number"&&m.attributes==null){for(var g=m.retain;h.peekType()==="insert"&&h.peekLength()<=g;)g-=h.peekLength(),f.push(h.next());m.retain-g>0&&p.next(m.retain-g)}for(var y=new c(f);h.hasNext()||p.hasNext();)if(p.peekType()==="insert")y.push(p.next());else if(h.peekType()==="delete")y.push(h.next());else{var b=Math.min(h.peekLength(),p.peekLength()),x=h.next(b),v=p.next(b);if(typeof v.retain=="number"){var w={};typeof x.retain=="number"?w.retain=b:w.insert=x.insert;var k=l.attributes.compose(x.attributes,v.attributes,typeof x.retain=="number");if(k&&(w.attributes=k),y.push(w),!p.hasNext()&&i(y.ops[y.ops.length-1],w)){var S=new c(h.rest());return y.concat(S).chop()}}else typeof v.delete=="number"&&typeof x.retain=="number"&&y.push(v)}return y.chop()},c.prototype.concat=function(d){var h=new c(this.ops.slice());return d.ops.length>0&&(h.push(d.ops[0]),h.ops=h.ops.concat(d.ops.slice(1))),h},c.prototype.diff=function(d,h){if(this.ops===d.ops)return new c;var p=[this,d].map(function(b){return b.map(function(x){if(x.insert!=null)return typeof x.insert=="string"?x.insert:u;var v=b===d?"on":"with";throw new Error("diff() called "+v+" non-document")}).join("")}),f=new c,m=a(p[0],p[1],h),g=l.iterator(this.ops),y=l.iterator(d.ops);return m.forEach(function(b){for(var x=b[1].length;x>0;){var v=0;switch(b[0]){case a.INSERT:v=Math.min(y.peekLength(),x),f.push(y.next(v));break;case a.DELETE:v=Math.min(x,g.peekLength()),g.next(v),f.delete(v);break;case a.EQUAL:v=Math.min(g.peekLength(),y.peekLength(),x);var w=g.next(v),k=y.next(v);i(w.insert,k.insert)?f.retain(v,l.attributes.diff(w.attributes,k.attributes)):f.push(k).delete(v);break}x-=v}}),f.chop()},c.prototype.eachLine=function(d,h){h=h||`
`;for(var p=l.iterator(this.ops),f=new c,m=0;p.hasNext();){if(p.peekType()!=="insert")return;var g=p.peek(),y=l.length(g)-p.peekLength(),b=typeof g.insert=="string"?g.insert.indexOf(h,y)-y:-1;if(b<0)f.push(p.next());else if(b>0)f.push(p.next(b));else{if(d(f,p.next(1).attributes||{},m)===!1)return;m+=1,f=new c}}f.length()>0&&d(f,{},m)},c.prototype.transform=function(d,h){if(h=!!h,typeof d=="number")return this.transformPosition(d,h);for(var p=l.iterator(this.ops),f=l.iterator(d.ops),m=new c;p.hasNext()||f.hasNext();)if(p.peekType()==="insert"&&(h||f.peekType()!=="insert"))m.retain(l.length(p.next()));else if(f.peekType()==="insert")m.push(f.next());else{var g=Math.min(p.peekLength(),f.peekLength()),y=p.next(g),b=f.next(g);if(y.delete)continue;b.delete?m.push(b):m.retain(g,l.attributes.transform(y.attributes,b.attributes,h))}return m.chop()},c.prototype.transformPosition=function(d,h){h=!!h;for(var p=l.iterator(this.ops),f=0;p.hasNext()&&f<=d;){var m=p.peekLength(),g=p.peekType();if(p.next(),g==="delete"){d-=Math.min(m,d-f);continue}else g==="insert"&&(f<d||!h)&&(d+=m);f+=m}return d},n.exports=c},function(n,r){var s=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=Object.defineProperty,o=Object.getOwnPropertyDescriptor,l=function(p){return typeof Array.isArray=="function"?Array.isArray(p):a.call(p)==="[object Array]"},u=function(p){if(!p||a.call(p)!=="[object Object]")return!1;var f=s.call(p,"constructor"),m=p.constructor&&p.constructor.prototype&&s.call(p.constructor.prototype,"isPrototypeOf");if(p.constructor&&!f&&!m)return!1;var g;for(g in p);return typeof g>"u"||s.call(p,g)},c=function(p,f){i&&f.name==="__proto__"?i(p,f.name,{enumerable:!0,configurable:!0,value:f.newValue,writable:!0}):p[f.name]=f.newValue},d=function(p,f){if(f==="__proto__")if(s.call(p,f)){if(o)return o(p,f).value}else return;return p[f]};n.exports=function h(){var p,f,m,g,y,b,x=arguments[0],v=1,w=arguments.length,k=!1;for(typeof x=="boolean"&&(k=x,x=arguments[1]||{},v=2),(x==null||typeof x!="object"&&typeof x!="function")&&(x={});v<w;++v)if(p=arguments[v],p!=null)for(f in p)m=d(x,f),g=d(p,f),x!==g&&(k&&g&&(u(g)||(y=l(g)))?(y?(y=!1,b=m&&l(m)?m:[]):b=m&&u(m)?m:{},c(x,{name:f,newValue:h(k,b,g)})):typeof g<"u"&&c(x,{name:f,newValue:g}));return x}},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.BlockEmbed=r.bubbleFormats=void 0;var a=function(){function T(N,E){for(var _=0;_<E.length;_++){var R=E[_];R.enumerable=R.enumerable||!1,R.configurable=!0,"value"in R&&(R.writable=!0),Object.defineProperty(N,R.key,R)}}return function(N,E,_){return E&&T(N.prototype,E),_&&T(N,_),N}}(),i=function T(N,E,_){N===null&&(N=Function.prototype);var R=Object.getOwnPropertyDescriptor(N,E);if(R===void 0){var z=Object.getPrototypeOf(N);return z===null?void 0:T(z,E,_)}else{if("value"in R)return R.value;var W=R.get;return W===void 0?void 0:W.call(_)}},o=s(3),l=x(o),u=s(2),c=x(u),d=s(0),h=x(d),p=s(16),f=x(p),m=s(6),g=x(m),y=s(7),b=x(y);function x(T){return T&&T.__esModule?T:{default:T}}function v(T,N){if(!(T instanceof N))throw new TypeError("Cannot call a class as a function")}function w(T,N){if(!T)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return N&&(typeof N=="object"||typeof N=="function")?N:T}function k(T,N){if(typeof N!="function"&&N!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof N);T.prototype=Object.create(N&&N.prototype,{constructor:{value:T,enumerable:!1,writable:!0,configurable:!0}}),N&&(Object.setPrototypeOf?Object.setPrototypeOf(T,N):T.__proto__=N)}var S=1,I=function(T){k(N,T);function N(){return v(this,N),w(this,(N.__proto__||Object.getPrototypeOf(N)).apply(this,arguments))}return a(N,[{key:"attach",value:function(){i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"attach",this).call(this),this.attributes=new h.default.Attributor.Store(this.domNode)}},{key:"delta",value:function(){return new c.default().insert(this.value(),(0,l.default)(this.formats(),this.attributes.values()))}},{key:"format",value:function(_,R){var z=h.default.query(_,h.default.Scope.BLOCK_ATTRIBUTE);z!=null&&this.attributes.attribute(z,R)}},{key:"formatAt",value:function(_,R,z,W){this.format(z,W)}},{key:"insertAt",value:function(_,R,z){if(typeof R=="string"&&R.endsWith(`
`)){var W=h.default.create($.blotName);this.parent.insertBefore(W,_===0?this:this.next),W.insertAt(0,R.slice(0,-1))}else i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"insertAt",this).call(this,_,R,z)}}]),N}(h.default.Embed);I.scope=h.default.Scope.BLOCK_BLOT;var $=function(T){k(N,T);function N(E){v(this,N);var _=w(this,(N.__proto__||Object.getPrototypeOf(N)).call(this,E));return _.cache={},_}return a(N,[{key:"delta",value:function(){return this.cache.delta==null&&(this.cache.delta=this.descendants(h.default.Leaf).reduce(function(_,R){return R.length()===0?_:_.insert(R.value(),C(R))},new c.default).insert(`
`,C(this))),this.cache.delta}},{key:"deleteAt",value:function(_,R){i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"deleteAt",this).call(this,_,R),this.cache={}}},{key:"formatAt",value:function(_,R,z,W){R<=0||(h.default.query(z,h.default.Scope.BLOCK)?_+R===this.length()&&this.format(z,W):i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"formatAt",this).call(this,_,Math.min(R,this.length()-_-1),z,W),this.cache={})}},{key:"insertAt",value:function(_,R,z){if(z!=null)return i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"insertAt",this).call(this,_,R,z);if(R.length!==0){var W=R.split(`
`),F=W.shift();F.length>0&&(_<this.length()-1||this.children.tail==null?i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"insertAt",this).call(this,Math.min(_,this.length()-1),F):this.children.tail.insertAt(this.children.tail.length(),F),this.cache={});var L=this;W.reduce(function(O,D){return L=L.split(O,!0),L.insertAt(0,D),D.length},_+F.length)}}},{key:"insertBefore",value:function(_,R){var z=this.children.head;i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"insertBefore",this).call(this,_,R),z instanceof f.default&&z.remove(),this.cache={}}},{key:"length",value:function(){return this.cache.length==null&&(this.cache.length=i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"length",this).call(this)+S),this.cache.length}},{key:"moveChildren",value:function(_,R){i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"moveChildren",this).call(this,_,R),this.cache={}}},{key:"optimize",value:function(_){i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"optimize",this).call(this,_),this.cache={}}},{key:"path",value:function(_){return i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"path",this).call(this,_,!0)}},{key:"removeChild",value:function(_){i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"removeChild",this).call(this,_),this.cache={}}},{key:"split",value:function(_){var R=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(R&&(_===0||_>=this.length()-S)){var z=this.clone();return _===0?(this.parent.insertBefore(z,this),this):(this.parent.insertBefore(z,this.next),z)}else{var W=i(N.prototype.__proto__||Object.getPrototypeOf(N.prototype),"split",this).call(this,_,R);return this.cache={},W}}}]),N}(h.default.Block);$.blotName="block",$.tagName="P",$.defaultChild="break",$.allowedChildren=[g.default,h.default.Embed,b.default];function C(T){var N=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return T==null||(typeof T.formats=="function"&&(N=(0,l.default)(N,T.formats())),T.parent==null||T.parent.blotName=="scroll"||T.parent.statics.scope!==T.statics.scope)?N:C(T.parent,N)}r.bubbleFormats=C,r.BlockEmbed=I,r.default=$},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.overload=r.expandConfig=void 0;var a=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(L){return typeof L}:function(L){return L&&typeof Symbol=="function"&&L.constructor===Symbol&&L!==Symbol.prototype?"symbol":typeof L},i=function(){function L(O,D){var B=[],V=!0,K=!1,G=void 0;try{for(var U=O[Symbol.iterator](),q;!(V=(q=U.next()).done)&&(B.push(q.value),!(D&&B.length===D));V=!0);}catch(Q){K=!0,G=Q}finally{try{!V&&U.return&&U.return()}finally{if(K)throw G}}return B}return function(O,D){if(Array.isArray(O))return O;if(Symbol.iterator in Object(O))return L(O,D);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),o=function(){function L(O,D){for(var B=0;B<D.length;B++){var V=D[B];V.enumerable=V.enumerable||!1,V.configurable=!0,"value"in V&&(V.writable=!0),Object.defineProperty(O,V.key,V)}}return function(O,D,B){return D&&L(O.prototype,D),B&&L(O,B),O}}();s(50);var l=s(2),u=C(l),c=s(14),d=C(c),h=s(8),p=C(h),f=s(9),m=C(f),g=s(0),y=C(g),b=s(15),x=C(b),v=s(3),w=C(v),k=s(10),S=C(k),I=s(34),$=C(I);function C(L){return L&&L.__esModule?L:{default:L}}function T(L,O,D){return O in L?Object.defineProperty(L,O,{value:D,enumerable:!0,configurable:!0,writable:!0}):L[O]=D,L}function N(L,O){if(!(L instanceof O))throw new TypeError("Cannot call a class as a function")}var E=(0,S.default)("quill"),_=function(){o(L,null,[{key:"debug",value:function(D){D===!0&&(D="log"),S.default.level(D)}},{key:"find",value:function(D){return D.__quill||y.default.find(D)}},{key:"import",value:function(D){return this.imports[D]==null&&E.error("Cannot import "+D+". Are you sure it was registered?"),this.imports[D]}},{key:"register",value:function(D,B){var V=this,K=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;if(typeof D!="string"){var G=D.attrName||D.blotName;typeof G=="string"?this.register("formats/"+G,D,B):Object.keys(D).forEach(function(U){V.register(U,D[U],B)})}else this.imports[D]!=null&&!K&&E.warn("Overwriting "+D+" with",B),this.imports[D]=B,(D.startsWith("blots/")||D.startsWith("formats/"))&&B.blotName!=="abstract"?y.default.register(B):D.startsWith("modules")&&typeof B.register=="function"&&B.register()}}]);function L(O){var D=this,B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(N(this,L),this.options=R(O,B),this.container=this.options.container,this.container==null)return E.error("Invalid Quill container",O);this.options.debug&&L.debug(this.options.debug);var V=this.container.innerHTML.trim();this.container.classList.add("ql-container"),this.container.innerHTML="",this.container.__quill=this,this.root=this.addContainer("ql-editor"),this.root.classList.add("ql-blank"),this.root.setAttribute("data-gramm",!1),this.scrollingContainer=this.options.scrollingContainer||this.root,this.emitter=new p.default,this.scroll=y.default.create(this.root,{emitter:this.emitter,whitelist:this.options.formats}),this.editor=new d.default(this.scroll),this.selection=new x.default(this.scroll,this.emitter),this.theme=new this.options.theme(this,this.options),this.keyboard=this.theme.addModule("keyboard"),this.clipboard=this.theme.addModule("clipboard"),this.history=this.theme.addModule("history"),this.theme.init(),this.emitter.on(p.default.events.EDITOR_CHANGE,function(G){G===p.default.events.TEXT_CHANGE&&D.root.classList.toggle("ql-blank",D.editor.isBlank())}),this.emitter.on(p.default.events.SCROLL_UPDATE,function(G,U){var q=D.selection.lastRange,Q=q&&q.length===0?q.index:void 0;z.call(D,function(){return D.editor.update(null,U,Q)},G)});var K=this.clipboard.convert(`<div class='ql-editor' style="white-space: normal;">`+V+"<p><br></p></div>");this.setContents(K),this.history.clear(),this.options.placeholder&&this.root.setAttribute("data-placeholder",this.options.placeholder),this.options.readOnly&&this.disable()}return o(L,[{key:"addContainer",value:function(D){var B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;if(typeof D=="string"){var V=D;D=document.createElement("div"),D.classList.add(V)}return this.container.insertBefore(D,B),D}},{key:"blur",value:function(){this.selection.setRange(null)}},{key:"deleteText",value:function(D,B,V){var K=this,G=W(D,B,V),U=i(G,4);return D=U[0],B=U[1],V=U[3],z.call(this,function(){return K.editor.deleteText(D,B)},V,D,-1*B)}},{key:"disable",value:function(){this.enable(!1)}},{key:"enable",value:function(){var D=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!0;this.scroll.enable(D),this.container.classList.toggle("ql-disabled",!D)}},{key:"focus",value:function(){var D=this.scrollingContainer.scrollTop;this.selection.focus(),this.scrollingContainer.scrollTop=D,this.scrollIntoView()}},{key:"format",value:function(D,B){var V=this,K=arguments.length>2&&arguments[2]!==void 0?arguments[2]:p.default.sources.API;return z.call(this,function(){var G=V.getSelection(!0),U=new u.default;if(G==null)return U;if(y.default.query(D,y.default.Scope.BLOCK))U=V.editor.formatLine(G.index,G.length,T({},D,B));else{if(G.length===0)return V.selection.format(D,B),U;U=V.editor.formatText(G.index,G.length,T({},D,B))}return V.setSelection(G,p.default.sources.SILENT),U},K)}},{key:"formatLine",value:function(D,B,V,K,G){var U=this,q=void 0,Q=W(D,B,V,K,G),ee=i(Q,4);return D=ee[0],B=ee[1],q=ee[2],G=ee[3],z.call(this,function(){return U.editor.formatLine(D,B,q)},G,D,0)}},{key:"formatText",value:function(D,B,V,K,G){var U=this,q=void 0,Q=W(D,B,V,K,G),ee=i(Q,4);return D=ee[0],B=ee[1],q=ee[2],G=ee[3],z.call(this,function(){return U.editor.formatText(D,B,q)},G,D,0)}},{key:"getBounds",value:function(D){var B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,V=void 0;typeof D=="number"?V=this.selection.getBounds(D,B):V=this.selection.getBounds(D.index,D.length);var K=this.container.getBoundingClientRect();return{bottom:V.bottom-K.top,height:V.height,left:V.left-K.left,right:V.right-K.left,top:V.top-K.top,width:V.width}}},{key:"getContents",value:function(){var D=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this.getLength()-D,V=W(D,B),K=i(V,2);return D=K[0],B=K[1],this.editor.getContents(D,B)}},{key:"getFormat",value:function(){var D=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.getSelection(!0),B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;return typeof D=="number"?this.editor.getFormat(D,B):this.editor.getFormat(D.index,D.length)}},{key:"getIndex",value:function(D){return D.offset(this.scroll)}},{key:"getLength",value:function(){return this.scroll.length()}},{key:"getLeaf",value:function(D){return this.scroll.leaf(D)}},{key:"getLine",value:function(D){return this.scroll.line(D)}},{key:"getLines",value:function(){var D=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Number.MAX_VALUE;return typeof D!="number"?this.scroll.lines(D.index,D.length):this.scroll.lines(D,B)}},{key:"getModule",value:function(D){return this.theme.modules[D]}},{key:"getSelection",value:function(){var D=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!1;return D&&this.focus(),this.update(),this.selection.getRange()[0]}},{key:"getText",value:function(){var D=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:this.getLength()-D,V=W(D,B),K=i(V,2);return D=K[0],B=K[1],this.editor.getText(D,B)}},{key:"hasFocus",value:function(){return this.selection.hasFocus()}},{key:"insertEmbed",value:function(D,B,V){var K=this,G=arguments.length>3&&arguments[3]!==void 0?arguments[3]:L.sources.API;return z.call(this,function(){return K.editor.insertEmbed(D,B,V)},G,D)}},{key:"insertText",value:function(D,B,V,K,G){var U=this,q=void 0,Q=W(D,0,V,K,G),ee=i(Q,4);return D=ee[0],q=ee[2],G=ee[3],z.call(this,function(){return U.editor.insertText(D,B,q)},G,D,B.length)}},{key:"isEnabled",value:function(){return!this.container.classList.contains("ql-disabled")}},{key:"off",value:function(){return this.emitter.off.apply(this.emitter,arguments)}},{key:"on",value:function(){return this.emitter.on.apply(this.emitter,arguments)}},{key:"once",value:function(){return this.emitter.once.apply(this.emitter,arguments)}},{key:"pasteHTML",value:function(D,B,V){this.clipboard.dangerouslyPasteHTML(D,B,V)}},{key:"removeFormat",value:function(D,B,V){var K=this,G=W(D,B,V),U=i(G,4);return D=U[0],B=U[1],V=U[3],z.call(this,function(){return K.editor.removeFormat(D,B)},V,D)}},{key:"scrollIntoView",value:function(){this.selection.scrollIntoView(this.scrollingContainer)}},{key:"setContents",value:function(D){var B=this,V=arguments.length>1&&arguments[1]!==void 0?arguments[1]:p.default.sources.API;return z.call(this,function(){D=new u.default(D);var K=B.getLength(),G=B.editor.deleteText(0,K),U=B.editor.applyDelta(D),q=U.ops[U.ops.length-1];q!=null&&typeof q.insert=="string"&&q.insert[q.insert.length-1]===`
`&&(B.editor.deleteText(B.getLength()-1,1),U.delete(1));var Q=G.compose(U);return Q},V)}},{key:"setSelection",value:function(D,B,V){if(D==null)this.selection.setRange(null,B||L.sources.API);else{var K=W(D,B,V),G=i(K,4);D=G[0],B=G[1],V=G[3],this.selection.setRange(new b.Range(D,B),V),V!==p.default.sources.SILENT&&this.selection.scrollIntoView(this.scrollingContainer)}}},{key:"setText",value:function(D){var B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:p.default.sources.API,V=new u.default().insert(D);return this.setContents(V,B)}},{key:"update",value:function(){var D=arguments.length>0&&arguments[0]!==void 0?arguments[0]:p.default.sources.USER,B=this.scroll.update(D);return this.selection.update(D),B}},{key:"updateContents",value:function(D){var B=this,V=arguments.length>1&&arguments[1]!==void 0?arguments[1]:p.default.sources.API;return z.call(this,function(){return D=new u.default(D),B.editor.applyDelta(D,V)},V,!0)}}]),L}();_.DEFAULTS={bounds:null,formats:null,modules:{},placeholder:"",readOnly:!1,scrollingContainer:null,strict:!0,theme:"default"},_.events=p.default.events,_.sources=p.default.sources,_.version="1.3.7",_.imports={delta:u.default,parchment:y.default,"core/module":m.default,"core/theme":$.default};function R(L,O){if(O=(0,w.default)(!0,{container:L,modules:{clipboard:!0,keyboard:!0,history:!0}},O),!O.theme||O.theme===_.DEFAULTS.theme)O.theme=$.default;else if(O.theme=_.import("themes/"+O.theme),O.theme==null)throw new Error("Invalid theme "+O.theme+". Did you register it?");var D=(0,w.default)(!0,{},O.theme.DEFAULTS);[D,O].forEach(function(K){K.modules=K.modules||{},Object.keys(K.modules).forEach(function(G){K.modules[G]===!0&&(K.modules[G]={})})});var B=Object.keys(D.modules).concat(Object.keys(O.modules)),V=B.reduce(function(K,G){var U=_.import("modules/"+G);return U==null?E.error("Cannot load "+G+" module. Are you sure you registered it?"):K[G]=U.DEFAULTS||{},K},{});return O.modules!=null&&O.modules.toolbar&&O.modules.toolbar.constructor!==Object&&(O.modules.toolbar={container:O.modules.toolbar}),O=(0,w.default)(!0,{},_.DEFAULTS,{modules:V},D,O),["bounds","container","scrollingContainer"].forEach(function(K){typeof O[K]=="string"&&(O[K]=document.querySelector(O[K]))}),O.modules=Object.keys(O.modules).reduce(function(K,G){return O.modules[G]&&(K[G]=O.modules[G]),K},{}),O}function z(L,O,D,B){if(this.options.strict&&!this.isEnabled()&&O===p.default.sources.USER)return new u.default;var V=D==null?null:this.getSelection(),K=this.editor.delta,G=L();if(V!=null&&(D===!0&&(D=V.index),B==null?V=F(V,G,O):B!==0&&(V=F(V,D,B,O)),this.setSelection(V,p.default.sources.SILENT)),G.length()>0){var U,q=[p.default.events.TEXT_CHANGE,G,K,O];if((U=this.emitter).emit.apply(U,[p.default.events.EDITOR_CHANGE].concat(q)),O!==p.default.sources.SILENT){var Q;(Q=this.emitter).emit.apply(Q,q)}}return G}function W(L,O,D,B,V){var K={};return typeof L.index=="number"&&typeof L.length=="number"?typeof O!="number"?(V=B,B=D,D=O,O=L.length,L=L.index):(O=L.length,L=L.index):typeof O!="number"&&(V=B,B=D,D=O,O=0),(typeof D>"u"?"undefined":a(D))==="object"?(K=D,V=B):typeof D=="string"&&(B!=null?K[D]=B:V=D),V=V||p.default.sources.API,[L,O,K,V]}function F(L,O,D,B){if(L==null)return null;var V=void 0,K=void 0;if(O instanceof u.default){var G=[L.index,L.index+L.length].map(function(ee){return O.transformPosition(ee,B!==p.default.sources.USER)}),U=i(G,2);V=U[0],K=U[1]}else{var q=[L.index,L.index+L.length].map(function(ee){return ee<O||ee===O&&B===p.default.sources.USER?ee:D>=0?ee+D:Math.max(O,ee+D)}),Q=i(q,2);V=Q[0],K=Q[1]}return new b.Range(V,K-V)}r.expandConfig=R,r.overload=W,r.default=_},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function g(y,b){for(var x=0;x<b.length;x++){var v=b[x];v.enumerable=v.enumerable||!1,v.configurable=!0,"value"in v&&(v.writable=!0),Object.defineProperty(y,v.key,v)}}return function(y,b,x){return b&&g(y.prototype,b),x&&g(y,x),y}}(),i=function g(y,b,x){y===null&&(y=Function.prototype);var v=Object.getOwnPropertyDescriptor(y,b);if(v===void 0){var w=Object.getPrototypeOf(y);return w===null?void 0:g(w,b,x)}else{if("value"in v)return v.value;var k=v.get;return k===void 0?void 0:k.call(x)}},o=s(7),l=d(o),u=s(0),c=d(u);function d(g){return g&&g.__esModule?g:{default:g}}function h(g,y){if(!(g instanceof y))throw new TypeError("Cannot call a class as a function")}function p(g,y){if(!g)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return y&&(typeof y=="object"||typeof y=="function")?y:g}function f(g,y){if(typeof y!="function"&&y!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof y);g.prototype=Object.create(y&&y.prototype,{constructor:{value:g,enumerable:!1,writable:!0,configurable:!0}}),y&&(Object.setPrototypeOf?Object.setPrototypeOf(g,y):g.__proto__=y)}var m=function(g){f(y,g);function y(){return h(this,y),p(this,(y.__proto__||Object.getPrototypeOf(y)).apply(this,arguments))}return a(y,[{key:"formatAt",value:function(x,v,w,k){if(y.compare(this.statics.blotName,w)<0&&c.default.query(w,c.default.Scope.BLOT)){var S=this.isolate(x,v);k&&S.wrap(w,k)}else i(y.prototype.__proto__||Object.getPrototypeOf(y.prototype),"formatAt",this).call(this,x,v,w,k)}},{key:"optimize",value:function(x){if(i(y.prototype.__proto__||Object.getPrototypeOf(y.prototype),"optimize",this).call(this,x),this.parent instanceof y&&y.compare(this.statics.blotName,this.parent.statics.blotName)>0){var v=this.parent.isolate(this.offset(),this.length());this.moveChildren(v),v.wrap(this)}}}],[{key:"compare",value:function(x,v){var w=y.order.indexOf(x),k=y.order.indexOf(v);return w>=0||k>=0?w-k:x===v?0:x<v?-1:1}}]),y}(c.default.Inline);m.allowedChildren=[m,c.default.Embed,l.default],m.order=["cursor","inline","underline","strike","italic","bold","script","link","code"],r.default=m},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(0),i=o(a);function o(h){return h&&h.__esModule?h:{default:h}}function l(h,p){if(!(h instanceof p))throw new TypeError("Cannot call a class as a function")}function u(h,p){if(!h)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return p&&(typeof p=="object"||typeof p=="function")?p:h}function c(h,p){if(typeof p!="function"&&p!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof p);h.prototype=Object.create(p&&p.prototype,{constructor:{value:h,enumerable:!1,writable:!0,configurable:!0}}),p&&(Object.setPrototypeOf?Object.setPrototypeOf(h,p):h.__proto__=p)}var d=function(h){c(p,h);function p(){return l(this,p),u(this,(p.__proto__||Object.getPrototypeOf(p)).apply(this,arguments))}return p}(i.default.Text);r.default=d},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function b(x,v){for(var w=0;w<v.length;w++){var k=v[w];k.enumerable=k.enumerable||!1,k.configurable=!0,"value"in k&&(k.writable=!0),Object.defineProperty(x,k.key,k)}}return function(x,v,w){return v&&b(x.prototype,v),w&&b(x,w),x}}(),i=function b(x,v,w){x===null&&(x=Function.prototype);var k=Object.getOwnPropertyDescriptor(x,v);if(k===void 0){var S=Object.getPrototypeOf(x);return S===null?void 0:b(S,v,w)}else{if("value"in k)return k.value;var I=k.get;return I===void 0?void 0:I.call(w)}},o=s(54),l=d(o),u=s(10),c=d(u);function d(b){return b&&b.__esModule?b:{default:b}}function h(b,x){if(!(b instanceof x))throw new TypeError("Cannot call a class as a function")}function p(b,x){if(!b)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return x&&(typeof x=="object"||typeof x=="function")?x:b}function f(b,x){if(typeof x!="function"&&x!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof x);b.prototype=Object.create(x&&x.prototype,{constructor:{value:b,enumerable:!1,writable:!0,configurable:!0}}),x&&(Object.setPrototypeOf?Object.setPrototypeOf(b,x):b.__proto__=x)}var m=(0,c.default)("quill:events"),g=["selectionchange","mousedown","mouseup","click"];g.forEach(function(b){document.addEventListener(b,function(){for(var x=arguments.length,v=Array(x),w=0;w<x;w++)v[w]=arguments[w];[].slice.call(document.querySelectorAll(".ql-container")).forEach(function(k){if(k.__quill&&k.__quill.emitter){var S;(S=k.__quill.emitter).handleDOM.apply(S,v)}})})});var y=function(b){f(x,b);function x(){h(this,x);var v=p(this,(x.__proto__||Object.getPrototypeOf(x)).call(this));return v.listeners={},v.on("error",m.error),v}return a(x,[{key:"emit",value:function(){m.log.apply(m,arguments),i(x.prototype.__proto__||Object.getPrototypeOf(x.prototype),"emit",this).apply(this,arguments)}},{key:"handleDOM",value:function(w){for(var k=arguments.length,S=Array(k>1?k-1:0),I=1;I<k;I++)S[I-1]=arguments[I];(this.listeners[w.type]||[]).forEach(function($){var C=$.node,T=$.handler;(w.target===C||C.contains(w.target))&&T.apply(void 0,[w].concat(S))})}},{key:"listenDOM",value:function(w,k,S){this.listeners[w]||(this.listeners[w]=[]),this.listeners[w].push({node:k,handler:S})}}]),x}(l.default);y.events={EDITOR_CHANGE:"editor-change",SCROLL_BEFORE_UPDATE:"scroll-before-update",SCROLL_OPTIMIZE:"scroll-optimize",SCROLL_UPDATE:"scroll-update",SELECTION_CHANGE:"selection-change",TEXT_CHANGE:"text-change"},y.sources={API:"api",SILENT:"silent",USER:"user"},r.default=y},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});function a(o,l){if(!(o instanceof l))throw new TypeError("Cannot call a class as a function")}var i=function o(l){var u=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};a(this,o),this.quill=l,this.options=u};i.DEFAULTS={},r.default=i},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=["error","warn","log","info"],i="warn";function o(u){if(a.indexOf(u)<=a.indexOf(i)){for(var c,d=arguments.length,h=Array(d>1?d-1:0),p=1;p<d;p++)h[p-1]=arguments[p];(c=console)[u].apply(c,h)}}function l(u){return a.reduce(function(c,d){return c[d]=o.bind(console,d,u),c},{})}o.level=l.level=function(u){i=u},r.default=l},function(n,r,s){var a=Array.prototype.slice,i=s(52),o=s(53),l=n.exports=function(h,p,f){return f||(f={}),h===p?!0:h instanceof Date&&p instanceof Date?h.getTime()===p.getTime():!h||!p||typeof h!="object"&&typeof p!="object"?f.strict?h===p:h==p:d(h,p,f)};function u(h){return h==null}function c(h){return!(!h||typeof h!="object"||typeof h.length!="number"||typeof h.copy!="function"||typeof h.slice!="function"||h.length>0&&typeof h[0]!="number")}function d(h,p,f){var m,g;if(u(h)||u(p)||h.prototype!==p.prototype)return!1;if(o(h))return o(p)?(h=a.call(h),p=a.call(p),l(h,p,f)):!1;if(c(h)){if(!c(p)||h.length!==p.length)return!1;for(m=0;m<h.length;m++)if(h[m]!==p[m])return!1;return!0}try{var y=i(h),b=i(p)}catch{return!1}if(y.length!=b.length)return!1;for(y.sort(),b.sort(),m=y.length-1;m>=0;m--)if(y[m]!=b[m])return!1;for(m=y.length-1;m>=0;m--)if(g=y[m],!l(h[g],p[g],f))return!1;return typeof h==typeof p}},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(1),i=function(){function o(l,u,c){c===void 0&&(c={}),this.attrName=l,this.keyName=u;var d=a.Scope.TYPE&a.Scope.ATTRIBUTE;c.scope!=null?this.scope=c.scope&a.Scope.LEVEL|d:this.scope=a.Scope.ATTRIBUTE,c.whitelist!=null&&(this.whitelist=c.whitelist)}return o.keys=function(l){return[].map.call(l.attributes,function(u){return u.name})},o.prototype.add=function(l,u){return this.canAdd(l,u)?(l.setAttribute(this.keyName,u),!0):!1},o.prototype.canAdd=function(l,u){var c=a.query(l,a.Scope.BLOT&(this.scope|a.Scope.TYPE));return c==null?!1:this.whitelist==null?!0:typeof u=="string"?this.whitelist.indexOf(u.replace(/["']/g,""))>-1:this.whitelist.indexOf(u)>-1},o.prototype.remove=function(l){l.removeAttribute(this.keyName)},o.prototype.value=function(l){var u=l.getAttribute(this.keyName);return this.canAdd(l,u)&&u?u:""},o}();r.default=i},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.Code=void 0;var a=function(){function I($,C){var T=[],N=!0,E=!1,_=void 0;try{for(var R=$[Symbol.iterator](),z;!(N=(z=R.next()).done)&&(T.push(z.value),!(C&&T.length===C));N=!0);}catch(W){E=!0,_=W}finally{try{!N&&R.return&&R.return()}finally{if(E)throw _}}return T}return function($,C){if(Array.isArray($))return $;if(Symbol.iterator in Object($))return I($,C);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function(){function I($,C){for(var T=0;T<C.length;T++){var N=C[T];N.enumerable=N.enumerable||!1,N.configurable=!0,"value"in N&&(N.writable=!0),Object.defineProperty($,N.key,N)}}return function($,C,T){return C&&I($.prototype,C),T&&I($,T),$}}(),o=function I($,C,T){$===null&&($=Function.prototype);var N=Object.getOwnPropertyDescriptor($,C);if(N===void 0){var E=Object.getPrototypeOf($);return E===null?void 0:I(E,C,T)}else{if("value"in N)return N.value;var _=N.get;return _===void 0?void 0:_.call(T)}},l=s(2),u=b(l),c=s(0),d=b(c),h=s(4),p=b(h),f=s(6),m=b(f),g=s(7),y=b(g);function b(I){return I&&I.__esModule?I:{default:I}}function x(I,$){if(!(I instanceof $))throw new TypeError("Cannot call a class as a function")}function v(I,$){if(!I)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return $&&(typeof $=="object"||typeof $=="function")?$:I}function w(I,$){if(typeof $!="function"&&$!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof $);I.prototype=Object.create($&&$.prototype,{constructor:{value:I,enumerable:!1,writable:!0,configurable:!0}}),$&&(Object.setPrototypeOf?Object.setPrototypeOf(I,$):I.__proto__=$)}var k=function(I){w($,I);function $(){return x(this,$),v(this,($.__proto__||Object.getPrototypeOf($)).apply(this,arguments))}return $}(m.default);k.blotName="code",k.tagName="CODE";var S=function(I){w($,I);function $(){return x(this,$),v(this,($.__proto__||Object.getPrototypeOf($)).apply(this,arguments))}return i($,[{key:"delta",value:function(){var T=this,N=this.domNode.textContent;return N.endsWith(`
`)&&(N=N.slice(0,-1)),N.split(`
`).reduce(function(E,_){return E.insert(_).insert(`
`,T.formats())},new u.default)}},{key:"format",value:function(T,N){if(!(T===this.statics.blotName&&N)){var E=this.descendant(y.default,this.length()-1),_=a(E,1),R=_[0];R!=null&&R.deleteAt(R.length()-1,1),o($.prototype.__proto__||Object.getPrototypeOf($.prototype),"format",this).call(this,T,N)}}},{key:"formatAt",value:function(T,N,E,_){if(N!==0&&!(d.default.query(E,d.default.Scope.BLOCK)==null||E===this.statics.blotName&&_===this.statics.formats(this.domNode))){var R=this.newlineIndex(T);if(!(R<0||R>=T+N)){var z=this.newlineIndex(T,!0)+1,W=R-z+1,F=this.isolate(z,W),L=F.next;F.format(E,_),L instanceof $&&L.formatAt(0,T-z+N-W,E,_)}}}},{key:"insertAt",value:function(T,N,E){if(E==null){var _=this.descendant(y.default,T),R=a(_,2),z=R[0],W=R[1];z.insertAt(W,N)}}},{key:"length",value:function(){var T=this.domNode.textContent.length;return this.domNode.textContent.endsWith(`
`)?T:T+1}},{key:"newlineIndex",value:function(T){var N=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;if(N)return this.domNode.textContent.slice(0,T).lastIndexOf(`
`);var E=this.domNode.textContent.slice(T).indexOf(`
`);return E>-1?T+E:-1}},{key:"optimize",value:function(T){this.domNode.textContent.endsWith(`
`)||this.appendChild(d.default.create("text",`
`)),o($.prototype.__proto__||Object.getPrototypeOf($.prototype),"optimize",this).call(this,T);var N=this.next;N!=null&&N.prev===this&&N.statics.blotName===this.statics.blotName&&this.statics.formats(this.domNode)===N.statics.formats(N.domNode)&&(N.optimize(T),N.moveChildren(this),N.remove())}},{key:"replace",value:function(T){o($.prototype.__proto__||Object.getPrototypeOf($.prototype),"replace",this).call(this,T),[].slice.call(this.domNode.querySelectorAll("*")).forEach(function(N){var E=d.default.find(N);E==null?N.parentNode.removeChild(N):E instanceof d.default.Embed?E.remove():E.unwrap()})}}],[{key:"create",value:function(T){var N=o($.__proto__||Object.getPrototypeOf($),"create",this).call(this,T);return N.setAttribute("spellcheck",!1),N}},{key:"formats",value:function(){return!0}}]),$}(p.default);S.blotName="code-block",S.tagName="PRE",S.TAB="  ",r.Code=k,r.default=S},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(L){return typeof L}:function(L){return L&&typeof Symbol=="function"&&L.constructor===Symbol&&L!==Symbol.prototype?"symbol":typeof L},i=function(){function L(O,D){var B=[],V=!0,K=!1,G=void 0;try{for(var U=O[Symbol.iterator](),q;!(V=(q=U.next()).done)&&(B.push(q.value),!(D&&B.length===D));V=!0);}catch(Q){K=!0,G=Q}finally{try{!V&&U.return&&U.return()}finally{if(K)throw G}}return B}return function(O,D){if(Array.isArray(O))return O;if(Symbol.iterator in Object(O))return L(O,D);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),o=function(){function L(O,D){for(var B=0;B<D.length;B++){var V=D[B];V.enumerable=V.enumerable||!1,V.configurable=!0,"value"in V&&(V.writable=!0),Object.defineProperty(O,V.key,V)}}return function(O,D,B){return D&&L(O.prototype,D),B&&L(O,B),O}}(),l=s(2),u=N(l),c=s(20),d=N(c),h=s(0),p=N(h),f=s(13),m=N(f),g=s(24),y=N(g),b=s(4),x=N(b),v=s(16),w=N(v),k=s(21),S=N(k),I=s(11),$=N(I),C=s(3),T=N(C);function N(L){return L&&L.__esModule?L:{default:L}}function E(L,O,D){return O in L?Object.defineProperty(L,O,{value:D,enumerable:!0,configurable:!0,writable:!0}):L[O]=D,L}function _(L,O){if(!(L instanceof O))throw new TypeError("Cannot call a class as a function")}var R=/^[ -~]*$/,z=function(){function L(O){_(this,L),this.scroll=O,this.delta=this.getDelta()}return o(L,[{key:"applyDelta",value:function(D){var B=this,V=!1;this.scroll.update();var K=this.scroll.length();return this.scroll.batchStart(),D=F(D),D.reduce(function(G,U){var q=U.retain||U.delete||U.insert.length||1,Q=U.attributes||{};if(U.insert!=null){if(typeof U.insert=="string"){var ee=U.insert;ee.endsWith(`
`)&&V&&(V=!1,ee=ee.slice(0,-1)),G>=K&&!ee.endsWith(`
`)&&(V=!0),B.scroll.insertAt(G,ee);var ae=B.scroll.line(G),ye=i(ae,2),j=ye[0],ce=ye[1],be=(0,T.default)({},(0,b.bubbleFormats)(j));if(j instanceof x.default){var ke=j.descendant(p.default.Leaf,ce),Ae=i(ke,1),Pe=Ae[0];be=(0,T.default)(be,(0,b.bubbleFormats)(Pe))}Q=d.default.attributes.diff(be,Q)||{}}else if(a(U.insert)==="object"){var ie=Object.keys(U.insert)[0];if(ie==null)return G;B.scroll.insertAt(G,ie,U.insert[ie])}K+=q}return Object.keys(Q).forEach(function(Te){B.scroll.formatAt(G,q,Te,Q[Te])}),G+q},0),D.reduce(function(G,U){return typeof U.delete=="number"?(B.scroll.deleteAt(G,U.delete),G):G+(U.retain||U.insert.length||1)},0),this.scroll.batchEnd(),this.update(D)}},{key:"deleteText",value:function(D,B){return this.scroll.deleteAt(D,B),this.update(new u.default().retain(D).delete(B))}},{key:"formatLine",value:function(D,B){var V=this,K=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return this.scroll.update(),Object.keys(K).forEach(function(G){if(!(V.scroll.whitelist!=null&&!V.scroll.whitelist[G])){var U=V.scroll.lines(D,Math.max(B,1)),q=B;U.forEach(function(Q){var ee=Q.length();if(!(Q instanceof m.default))Q.format(G,K[G]);else{var ae=D-Q.offset(V.scroll),ye=Q.newlineIndex(ae+q)-ae+1;Q.formatAt(ae,ye,G,K[G])}q-=ee})}}),this.scroll.optimize(),this.update(new u.default().retain(D).retain(B,(0,S.default)(K)))}},{key:"formatText",value:function(D,B){var V=this,K=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return Object.keys(K).forEach(function(G){V.scroll.formatAt(D,B,G,K[G])}),this.update(new u.default().retain(D).retain(B,(0,S.default)(K)))}},{key:"getContents",value:function(D,B){return this.delta.slice(D,D+B)}},{key:"getDelta",value:function(){return this.scroll.lines().reduce(function(D,B){return D.concat(B.delta())},new u.default)}},{key:"getFormat",value:function(D){var B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,V=[],K=[];B===0?this.scroll.path(D).forEach(function(U){var q=i(U,1),Q=q[0];Q instanceof x.default?V.push(Q):Q instanceof p.default.Leaf&&K.push(Q)}):(V=this.scroll.lines(D,B),K=this.scroll.descendants(p.default.Leaf,D,B));var G=[V,K].map(function(U){if(U.length===0)return{};for(var q=(0,b.bubbleFormats)(U.shift());Object.keys(q).length>0;){var Q=U.shift();if(Q==null)return q;q=W((0,b.bubbleFormats)(Q),q)}return q});return T.default.apply(T.default,G)}},{key:"getText",value:function(D,B){return this.getContents(D,B).filter(function(V){return typeof V.insert=="string"}).map(function(V){return V.insert}).join("")}},{key:"insertEmbed",value:function(D,B,V){return this.scroll.insertAt(D,B,V),this.update(new u.default().retain(D).insert(E({},B,V)))}},{key:"insertText",value:function(D,B){var V=this,K=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return B=B.replace(/\r\n/g,`
`).replace(/\r/g,`
`),this.scroll.insertAt(D,B),Object.keys(K).forEach(function(G){V.scroll.formatAt(D,B.length,G,K[G])}),this.update(new u.default().retain(D).insert(B,(0,S.default)(K)))}},{key:"isBlank",value:function(){if(this.scroll.children.length==0)return!0;if(this.scroll.children.length>1)return!1;var D=this.scroll.children.head;return D.statics.blotName!==x.default.blotName||D.children.length>1?!1:D.children.head instanceof w.default}},{key:"removeFormat",value:function(D,B){var V=this.getText(D,B),K=this.scroll.line(D+B),G=i(K,2),U=G[0],q=G[1],Q=0,ee=new u.default;U!=null&&(U instanceof m.default?Q=U.newlineIndex(q)-q+1:Q=U.length()-q,ee=U.delta().slice(q,q+Q-1).insert(`
`));var ae=this.getContents(D,B+Q),ye=ae.diff(new u.default().insert(V).concat(ee)),j=new u.default().retain(D).concat(ye);return this.applyDelta(j)}},{key:"update",value:function(D){var B=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[],V=arguments.length>2&&arguments[2]!==void 0?arguments[2]:void 0,K=this.delta;if(B.length===1&&B[0].type==="characterData"&&B[0].target.data.match(R)&&p.default.find(B[0].target)){var G=p.default.find(B[0].target),U=(0,b.bubbleFormats)(G),q=G.offset(this.scroll),Q=B[0].oldValue.replace(y.default.CONTENTS,""),ee=new u.default().insert(Q),ae=new u.default().insert(G.value()),ye=new u.default().retain(q).concat(ee.diff(ae,V));D=ye.reduce(function(j,ce){return ce.insert?j.insert(ce.insert,U):j.push(ce)},new u.default),this.delta=K.compose(D)}else this.delta=this.getDelta(),(!D||!(0,$.default)(K.compose(D),this.delta))&&(D=K.diff(this.delta,V));return D}}]),L}();function W(L,O){return Object.keys(O).reduce(function(D,B){return L[B]==null||(O[B]===L[B]?D[B]=O[B]:Array.isArray(O[B])?O[B].indexOf(L[B])<0&&(D[B]=O[B].concat([L[B]])):D[B]=[O[B],L[B]]),D},{})}function F(L){return L.reduce(function(O,D){if(D.insert===1){var B=(0,S.default)(D.attributes);return delete B.image,O.insert({image:D.attributes.image},B)}if(D.attributes!=null&&(D.attributes.list===!0||D.attributes.bullet===!0)&&(D=(0,S.default)(D),D.attributes.list?D.attributes.list="ordered":(D.attributes.list="bullet",delete D.attributes.bullet)),typeof D.insert=="string"){var V=D.insert.replace(/\r\n/g,`
`).replace(/\r/g,`
`);return O.insert(V,D.attributes)}return O.push(D)},new u.default)}r.default=z},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.Range=void 0;var a=function(){function I($,C){var T=[],N=!0,E=!1,_=void 0;try{for(var R=$[Symbol.iterator](),z;!(N=(z=R.next()).done)&&(T.push(z.value),!(C&&T.length===C));N=!0);}catch(W){E=!0,_=W}finally{try{!N&&R.return&&R.return()}finally{if(E)throw _}}return T}return function($,C){if(Array.isArray($))return $;if(Symbol.iterator in Object($))return I($,C);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function(){function I($,C){for(var T=0;T<C.length;T++){var N=C[T];N.enumerable=N.enumerable||!1,N.configurable=!0,"value"in N&&(N.writable=!0),Object.defineProperty($,N.key,N)}}return function($,C,T){return C&&I($.prototype,C),T&&I($,T),$}}(),o=s(0),l=y(o),u=s(21),c=y(u),d=s(11),h=y(d),p=s(8),f=y(p),m=s(10),g=y(m);function y(I){return I&&I.__esModule?I:{default:I}}function b(I){if(Array.isArray(I)){for(var $=0,C=Array(I.length);$<I.length;$++)C[$]=I[$];return C}else return Array.from(I)}function x(I,$){if(!(I instanceof $))throw new TypeError("Cannot call a class as a function")}var v=(0,g.default)("quill:selection"),w=function I($){var C=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0;x(this,I),this.index=$,this.length=C},k=function(){function I($,C){var T=this;x(this,I),this.emitter=C,this.scroll=$,this.composing=!1,this.mouseDown=!1,this.root=this.scroll.domNode,this.cursor=l.default.create("cursor",this),this.lastRange=this.savedRange=new w(0,0),this.handleComposition(),this.handleDragging(),this.emitter.listenDOM("selectionchange",document,function(){T.mouseDown||setTimeout(T.update.bind(T,f.default.sources.USER),1)}),this.emitter.on(f.default.events.EDITOR_CHANGE,function(N,E){N===f.default.events.TEXT_CHANGE&&E.length()>0&&T.update(f.default.sources.SILENT)}),this.emitter.on(f.default.events.SCROLL_BEFORE_UPDATE,function(){if(T.hasFocus()){var N=T.getNativeRange();N!=null&&N.start.node!==T.cursor.textNode&&T.emitter.once(f.default.events.SCROLL_UPDATE,function(){try{T.setNativeRange(N.start.node,N.start.offset,N.end.node,N.end.offset)}catch{}})}}),this.emitter.on(f.default.events.SCROLL_OPTIMIZE,function(N,E){if(E.range){var _=E.range,R=_.startNode,z=_.startOffset,W=_.endNode,F=_.endOffset;T.setNativeRange(R,z,W,F)}}),this.update(f.default.sources.SILENT)}return i(I,[{key:"handleComposition",value:function(){var C=this;this.root.addEventListener("compositionstart",function(){C.composing=!0}),this.root.addEventListener("compositionend",function(){if(C.composing=!1,C.cursor.parent){var T=C.cursor.restore();if(!T)return;setTimeout(function(){C.setNativeRange(T.startNode,T.startOffset,T.endNode,T.endOffset)},1)}})}},{key:"handleDragging",value:function(){var C=this;this.emitter.listenDOM("mousedown",document.body,function(){C.mouseDown=!0}),this.emitter.listenDOM("mouseup",document.body,function(){C.mouseDown=!1,C.update(f.default.sources.USER)})}},{key:"focus",value:function(){this.hasFocus()||(this.root.focus(),this.setRange(this.savedRange))}},{key:"format",value:function(C,T){if(!(this.scroll.whitelist!=null&&!this.scroll.whitelist[C])){this.scroll.update();var N=this.getNativeRange();if(!(N==null||!N.native.collapsed||l.default.query(C,l.default.Scope.BLOCK))){if(N.start.node!==this.cursor.textNode){var E=l.default.find(N.start.node,!1);if(E==null)return;if(E instanceof l.default.Leaf){var _=E.split(N.start.offset);E.parent.insertBefore(this.cursor,_)}else E.insertBefore(this.cursor,N.start.node);this.cursor.attach()}this.cursor.format(C,T),this.scroll.optimize(),this.setNativeRange(this.cursor.textNode,this.cursor.textNode.data.length),this.update()}}}},{key:"getBounds",value:function(C){var T=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,N=this.scroll.length();C=Math.min(C,N-1),T=Math.min(C+T,N-1)-C;var E=void 0,_=this.scroll.leaf(C),R=a(_,2),z=R[0],W=R[1];if(z==null)return null;var F=z.position(W,!0),L=a(F,2);E=L[0],W=L[1];var O=document.createRange();if(T>0){O.setStart(E,W);var D=this.scroll.leaf(C+T),B=a(D,2);if(z=B[0],W=B[1],z==null)return null;var V=z.position(W,!0),K=a(V,2);return E=K[0],W=K[1],O.setEnd(E,W),O.getBoundingClientRect()}else{var G="left",U=void 0;return E instanceof Text?(W<E.data.length?(O.setStart(E,W),O.setEnd(E,W+1)):(O.setStart(E,W-1),O.setEnd(E,W),G="right"),U=O.getBoundingClientRect()):(U=z.domNode.getBoundingClientRect(),W>0&&(G="right")),{bottom:U.top+U.height,height:U.height,left:U[G],right:U[G],top:U.top,width:0}}}},{key:"getNativeRange",value:function(){var C=document.getSelection();if(C==null||C.rangeCount<=0)return null;var T=C.getRangeAt(0);if(T==null)return null;var N=this.normalizeNative(T);return v.info("getNativeRange",N),N}},{key:"getRange",value:function(){var C=this.getNativeRange();if(C==null)return[null,null];var T=this.normalizedToRange(C);return[T,C]}},{key:"hasFocus",value:function(){return document.activeElement===this.root}},{key:"normalizedToRange",value:function(C){var T=this,N=[[C.start.node,C.start.offset]];C.native.collapsed||N.push([C.end.node,C.end.offset]);var E=N.map(function(z){var W=a(z,2),F=W[0],L=W[1],O=l.default.find(F,!0),D=O.offset(T.scroll);return L===0?D:O instanceof l.default.Container?D+O.length():D+O.index(F,L)}),_=Math.min(Math.max.apply(Math,b(E)),this.scroll.length()-1),R=Math.min.apply(Math,[_].concat(b(E)));return new w(R,_-R)}},{key:"normalizeNative",value:function(C){if(!S(this.root,C.startContainer)||!C.collapsed&&!S(this.root,C.endContainer))return null;var T={start:{node:C.startContainer,offset:C.startOffset},end:{node:C.endContainer,offset:C.endOffset},native:C};return[T.start,T.end].forEach(function(N){for(var E=N.node,_=N.offset;!(E instanceof Text)&&E.childNodes.length>0;)if(E.childNodes.length>_)E=E.childNodes[_],_=0;else if(E.childNodes.length===_)E=E.lastChild,_=E instanceof Text?E.data.length:E.childNodes.length+1;else break;N.node=E,N.offset=_}),T}},{key:"rangeToNative",value:function(C){var T=this,N=C.collapsed?[C.index]:[C.index,C.index+C.length],E=[],_=this.scroll.length();return N.forEach(function(R,z){R=Math.min(_-1,R);var W=void 0,F=T.scroll.leaf(R),L=a(F,2),O=L[0],D=L[1],B=O.position(D,z!==0),V=a(B,2);W=V[0],D=V[1],E.push(W,D)}),E.length<2&&(E=E.concat(E)),E}},{key:"scrollIntoView",value:function(C){var T=this.lastRange;if(T!=null){var N=this.getBounds(T.index,T.length);if(N!=null){var E=this.scroll.length()-1,_=this.scroll.line(Math.min(T.index,E)),R=a(_,1),z=R[0],W=z;if(T.length>0){var F=this.scroll.line(Math.min(T.index+T.length,E)),L=a(F,1);W=L[0]}if(!(z==null||W==null)){var O=C.getBoundingClientRect();N.top<O.top?C.scrollTop-=O.top-N.top:N.bottom>O.bottom&&(C.scrollTop+=N.bottom-O.bottom)}}}}},{key:"setNativeRange",value:function(C,T){var N=arguments.length>2&&arguments[2]!==void 0?arguments[2]:C,E=arguments.length>3&&arguments[3]!==void 0?arguments[3]:T,_=arguments.length>4&&arguments[4]!==void 0?arguments[4]:!1;if(v.info("setNativeRange",C,T,N,E),!(C!=null&&(this.root.parentNode==null||C.parentNode==null||N.parentNode==null))){var R=document.getSelection();if(R!=null)if(C!=null){this.hasFocus()||this.root.focus();var z=(this.getNativeRange()||{}).native;if(z==null||_||C!==z.startContainer||T!==z.startOffset||N!==z.endContainer||E!==z.endOffset){C.tagName=="BR"&&(T=[].indexOf.call(C.parentNode.childNodes,C),C=C.parentNode),N.tagName=="BR"&&(E=[].indexOf.call(N.parentNode.childNodes,N),N=N.parentNode);var W=document.createRange();W.setStart(C,T),W.setEnd(N,E),R.removeAllRanges(),R.addRange(W)}}else R.removeAllRanges(),this.root.blur(),document.body.focus()}}},{key:"setRange",value:function(C){var T=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,N=arguments.length>2&&arguments[2]!==void 0?arguments[2]:f.default.sources.API;if(typeof T=="string"&&(N=T,T=!1),v.info("setRange",C),C!=null){var E=this.rangeToNative(C);this.setNativeRange.apply(this,b(E).concat([T]))}else this.setNativeRange(null);this.update(N)}},{key:"update",value:function(){var C=arguments.length>0&&arguments[0]!==void 0?arguments[0]:f.default.sources.USER,T=this.lastRange,N=this.getRange(),E=a(N,2),_=E[0],R=E[1];if(this.lastRange=_,this.lastRange!=null&&(this.savedRange=this.lastRange),!(0,h.default)(T,this.lastRange)){var z;!this.composing&&R!=null&&R.native.collapsed&&R.start.node!==this.cursor.textNode&&this.cursor.restore();var W=[f.default.events.SELECTION_CHANGE,(0,c.default)(this.lastRange),(0,c.default)(T),C];if((z=this.emitter).emit.apply(z,[f.default.events.EDITOR_CHANGE].concat(W)),C!==f.default.sources.SILENT){var F;(F=this.emitter).emit.apply(F,W)}}}}]),I}();function S(I,$){try{$.parentNode}catch{return!1}return $ instanceof Text&&($=$.parentNode),I.contains($)}r.Range=w,r.default=k},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function f(m,g){for(var y=0;y<g.length;y++){var b=g[y];b.enumerable=b.enumerable||!1,b.configurable=!0,"value"in b&&(b.writable=!0),Object.defineProperty(m,b.key,b)}}return function(m,g,y){return g&&f(m.prototype,g),y&&f(m,y),m}}(),i=function f(m,g,y){m===null&&(m=Function.prototype);var b=Object.getOwnPropertyDescriptor(m,g);if(b===void 0){var x=Object.getPrototypeOf(m);return x===null?void 0:f(x,g,y)}else{if("value"in b)return b.value;var v=b.get;return v===void 0?void 0:v.call(y)}},o=s(0),l=u(o);function u(f){return f&&f.__esModule?f:{default:f}}function c(f,m){if(!(f instanceof m))throw new TypeError("Cannot call a class as a function")}function d(f,m){if(!f)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return m&&(typeof m=="object"||typeof m=="function")?m:f}function h(f,m){if(typeof m!="function"&&m!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof m);f.prototype=Object.create(m&&m.prototype,{constructor:{value:f,enumerable:!1,writable:!0,configurable:!0}}),m&&(Object.setPrototypeOf?Object.setPrototypeOf(f,m):f.__proto__=m)}var p=function(f){h(m,f);function m(){return c(this,m),d(this,(m.__proto__||Object.getPrototypeOf(m)).apply(this,arguments))}return a(m,[{key:"insertInto",value:function(y,b){y.children.length===0?i(m.prototype.__proto__||Object.getPrototypeOf(m.prototype),"insertInto",this).call(this,y,b):this.remove()}},{key:"length",value:function(){return 0}},{key:"value",value:function(){return""}}],[{key:"value",value:function(){}}]),m}(l.default.Embed);p.blotName="break",p.tagName="BR",r.default=p},function(n,r,s){var a=this&&this.__extends||function(){var d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(h,p){h.__proto__=p}||function(h,p){for(var f in p)p.hasOwnProperty(f)&&(h[f]=p[f])};return function(h,p){d(h,p);function f(){this.constructor=h}h.prototype=p===null?Object.create(p):(f.prototype=p.prototype,new f)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(44),o=s(30),l=s(1),u=function(d){a(h,d);function h(p){var f=d.call(this,p)||this;return f.build(),f}return h.prototype.appendChild=function(p){this.insertBefore(p)},h.prototype.attach=function(){d.prototype.attach.call(this),this.children.forEach(function(p){p.attach()})},h.prototype.build=function(){var p=this;this.children=new i.default,[].slice.call(this.domNode.childNodes).reverse().forEach(function(f){try{var m=c(f);p.insertBefore(m,p.children.head||void 0)}catch(g){if(g instanceof l.ParchmentError)return;throw g}})},h.prototype.deleteAt=function(p,f){if(p===0&&f===this.length())return this.remove();this.children.forEachAt(p,f,function(m,g,y){m.deleteAt(g,y)})},h.prototype.descendant=function(p,f){var m=this.children.find(f),g=m[0],y=m[1];return p.blotName==null&&p(g)||p.blotName!=null&&g instanceof p?[g,y]:g instanceof h?g.descendant(p,y):[null,-1]},h.prototype.descendants=function(p,f,m){f===void 0&&(f=0),m===void 0&&(m=Number.MAX_VALUE);var g=[],y=m;return this.children.forEachAt(f,m,function(b,x,v){(p.blotName==null&&p(b)||p.blotName!=null&&b instanceof p)&&g.push(b),b instanceof h&&(g=g.concat(b.descendants(p,x,y))),y-=v}),g},h.prototype.detach=function(){this.children.forEach(function(p){p.detach()}),d.prototype.detach.call(this)},h.prototype.formatAt=function(p,f,m,g){this.children.forEachAt(p,f,function(y,b,x){y.formatAt(b,x,m,g)})},h.prototype.insertAt=function(p,f,m){var g=this.children.find(p),y=g[0],b=g[1];if(y)y.insertAt(b,f,m);else{var x=m==null?l.create("text",f):l.create(f,m);this.appendChild(x)}},h.prototype.insertBefore=function(p,f){if(this.statics.allowedChildren!=null&&!this.statics.allowedChildren.some(function(m){return p instanceof m}))throw new l.ParchmentError("Cannot insert "+p.statics.blotName+" into "+this.statics.blotName);p.insertInto(this,f)},h.prototype.length=function(){return this.children.reduce(function(p,f){return p+f.length()},0)},h.prototype.moveChildren=function(p,f){this.children.forEach(function(m){p.insertBefore(m,f)})},h.prototype.optimize=function(p){if(d.prototype.optimize.call(this,p),this.children.length===0)if(this.statics.defaultChild!=null){var f=l.create(this.statics.defaultChild);this.appendChild(f),f.optimize(p)}else this.remove()},h.prototype.path=function(p,f){f===void 0&&(f=!1);var m=this.children.find(p,f),g=m[0],y=m[1],b=[[this,p]];return g instanceof h?b.concat(g.path(y,f)):(g!=null&&b.push([g,y]),b)},h.prototype.removeChild=function(p){this.children.remove(p)},h.prototype.replace=function(p){p instanceof h&&p.moveChildren(this),d.prototype.replace.call(this,p)},h.prototype.split=function(p,f){if(f===void 0&&(f=!1),!f){if(p===0)return this;if(p===this.length())return this.next}var m=this.clone();return this.parent.insertBefore(m,this.next),this.children.forEachAt(p,this.length(),function(g,y,b){g=g.split(y,f),m.appendChild(g)}),m},h.prototype.unwrap=function(){this.moveChildren(this.parent,this.next),this.remove()},h.prototype.update=function(p,f){var m=this,g=[],y=[];p.forEach(function(b){b.target===m.domNode&&b.type==="childList"&&(g.push.apply(g,b.addedNodes),y.push.apply(y,b.removedNodes))}),y.forEach(function(b){if(!(b.parentNode!=null&&b.tagName!=="IFRAME"&&document.body.compareDocumentPosition(b)&Node.DOCUMENT_POSITION_CONTAINED_BY)){var x=l.find(b);x!=null&&(x.domNode.parentNode==null||x.domNode.parentNode===m.domNode)&&x.detach()}}),g.filter(function(b){return b.parentNode==m.domNode}).sort(function(b,x){return b===x?0:b.compareDocumentPosition(x)&Node.DOCUMENT_POSITION_FOLLOWING?1:-1}).forEach(function(b){var x=null;b.nextSibling!=null&&(x=l.find(b.nextSibling));var v=c(b);(v.next!=x||v.next==null)&&(v.parent!=null&&v.parent.removeChild(m),m.insertBefore(v,x||void 0))})},h}(o.default);function c(d){var h=l.find(d);if(h==null)try{h=l.create(d)}catch{h=l.create(l.Scope.INLINE),[].slice.call(d.childNodes).forEach(function(f){h.domNode.appendChild(f)}),d.parentNode&&d.parentNode.replaceChild(h.domNode,d),h.attach()}return h}r.default=u},function(n,r,s){var a=this&&this.__extends||function(){var d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(h,p){h.__proto__=p}||function(h,p){for(var f in p)p.hasOwnProperty(f)&&(h[f]=p[f])};return function(h,p){d(h,p);function f(){this.constructor=h}h.prototype=p===null?Object.create(p):(f.prototype=p.prototype,new f)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(12),o=s(31),l=s(17),u=s(1),c=function(d){a(h,d);function h(p){var f=d.call(this,p)||this;return f.attributes=new o.default(f.domNode),f}return h.formats=function(p){if(typeof this.tagName=="string")return!0;if(Array.isArray(this.tagName))return p.tagName.toLowerCase()},h.prototype.format=function(p,f){var m=u.query(p);m instanceof i.default?this.attributes.attribute(m,f):f&&m!=null&&(p!==this.statics.blotName||this.formats()[p]!==f)&&this.replaceWith(p,f)},h.prototype.formats=function(){var p=this.attributes.values(),f=this.statics.formats(this.domNode);return f!=null&&(p[this.statics.blotName]=f),p},h.prototype.replaceWith=function(p,f){var m=d.prototype.replaceWith.call(this,p,f);return this.attributes.copy(m),m},h.prototype.update=function(p,f){var m=this;d.prototype.update.call(this,p,f),p.some(function(g){return g.target===m.domNode&&g.type==="attributes"})&&this.attributes.build()},h.prototype.wrap=function(p,f){var m=d.prototype.wrap.call(this,p,f);return m instanceof h&&m.statics.scope===this.statics.scope&&this.attributes.move(m),m},h}(l.default);r.default=c},function(n,r,s){var a=this&&this.__extends||function(){var u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(c,d){c.__proto__=d}||function(c,d){for(var h in d)d.hasOwnProperty(h)&&(c[h]=d[h])};return function(c,d){u(c,d);function h(){this.constructor=c}c.prototype=d===null?Object.create(d):(h.prototype=d.prototype,new h)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(30),o=s(1),l=function(u){a(c,u);function c(){return u!==null&&u.apply(this,arguments)||this}return c.value=function(d){return!0},c.prototype.index=function(d,h){return this.domNode===d||this.domNode.compareDocumentPosition(d)&Node.DOCUMENT_POSITION_CONTAINED_BY?Math.min(h,1):-1},c.prototype.position=function(d,h){var p=[].indexOf.call(this.parent.domNode.childNodes,this.domNode);return d>0&&(p+=1),[this.parent.domNode,p]},c.prototype.value=function(){var d;return d={},d[this.statics.blotName]=this.statics.value(this.domNode)||!0,d},c.scope=o.Scope.INLINE_BLOT,c}(i.default);r.default=l},function(n,r,s){var a=s(11),i=s(3),o={attributes:{compose:function(u,c,d){typeof u!="object"&&(u={}),typeof c!="object"&&(c={});var h=i(!0,{},c);d||(h=Object.keys(h).reduce(function(f,m){return h[m]!=null&&(f[m]=h[m]),f},{}));for(var p in u)u[p]!==void 0&&c[p]===void 0&&(h[p]=u[p]);return Object.keys(h).length>0?h:void 0},diff:function(u,c){typeof u!="object"&&(u={}),typeof c!="object"&&(c={});var d=Object.keys(u).concat(Object.keys(c)).reduce(function(h,p){return a(u[p],c[p])||(h[p]=c[p]===void 0?null:c[p]),h},{});return Object.keys(d).length>0?d:void 0},transform:function(u,c,d){if(typeof u!="object")return c;if(typeof c=="object"){if(!d)return c;var h=Object.keys(c).reduce(function(p,f){return u[f]===void 0&&(p[f]=c[f]),p},{});return Object.keys(h).length>0?h:void 0}}},iterator:function(u){return new l(u)},length:function(u){return typeof u.delete=="number"?u.delete:typeof u.retain=="number"?u.retain:typeof u.insert=="string"?u.insert.length:1}};function l(u){this.ops=u,this.index=0,this.offset=0}l.prototype.hasNext=function(){return this.peekLength()<1/0},l.prototype.next=function(u){u||(u=1/0);var c=this.ops[this.index];if(c){var d=this.offset,h=o.length(c);if(u>=h-d?(u=h-d,this.index+=1,this.offset=0):this.offset+=u,typeof c.delete=="number")return{delete:u};var p={};return c.attributes&&(p.attributes=c.attributes),typeof c.retain=="number"?p.retain=u:typeof c.insert=="string"?p.insert=c.insert.substr(d,u):p.insert=c.insert,p}else return{retain:1/0}},l.prototype.peek=function(){return this.ops[this.index]},l.prototype.peekLength=function(){return this.ops[this.index]?o.length(this.ops[this.index])-this.offset:1/0},l.prototype.peekType=function(){return this.ops[this.index]?typeof this.ops[this.index].delete=="number"?"delete":typeof this.ops[this.index].retain=="number"?"retain":"insert":"retain"},l.prototype.rest=function(){if(this.hasNext()){if(this.offset===0)return this.ops.slice(this.index);var u=this.offset,c=this.index,d=this.next(),h=this.ops.slice(this.index);return this.offset=u,this.index=c,[d].concat(h)}else return[]},n.exports=o},function(n,r){var s=function(){function a(m,g){return g!=null&&m instanceof g}var i;try{i=Map}catch{i=function(){}}var o;try{o=Set}catch{o=function(){}}var l;try{l=Promise}catch{l=function(){}}function u(m,g,y,b,x){typeof g=="object"&&(y=g.depth,b=g.prototype,x=g.includeNonEnumerable,g=g.circular);var v=[],w=[],k=typeof Buffer<"u";typeof g>"u"&&(g=!0),typeof y>"u"&&(y=1/0);function S(I,$){if(I===null)return null;if($===0)return I;var C,T;if(typeof I!="object")return I;if(a(I,i))C=new i;else if(a(I,o))C=new o;else if(a(I,l))C=new l(function(O,D){I.then(function(B){O(S(B,$-1))},function(B){D(S(B,$-1))})});else if(u.__isArray(I))C=[];else if(u.__isRegExp(I))C=new RegExp(I.source,f(I)),I.lastIndex&&(C.lastIndex=I.lastIndex);else if(u.__isDate(I))C=new Date(I.getTime());else{if(k&&Buffer.isBuffer(I))return Buffer.allocUnsafe?C=Buffer.allocUnsafe(I.length):C=new Buffer(I.length),I.copy(C),C;a(I,Error)?C=Object.create(I):typeof b>"u"?(T=Object.getPrototypeOf(I),C=Object.create(T)):(C=Object.create(b),T=b)}if(g){var N=v.indexOf(I);if(N!=-1)return w[N];v.push(I),w.push(C)}a(I,i)&&I.forEach(function(O,D){var B=S(D,$-1),V=S(O,$-1);C.set(B,V)}),a(I,o)&&I.forEach(function(O){var D=S(O,$-1);C.add(D)});for(var E in I){var _;T&&(_=Object.getOwnPropertyDescriptor(T,E)),!(_&&_.set==null)&&(C[E]=S(I[E],$-1))}if(Object.getOwnPropertySymbols)for(var R=Object.getOwnPropertySymbols(I),E=0;E<R.length;E++){var z=R[E],W=Object.getOwnPropertyDescriptor(I,z);W&&!W.enumerable&&!x||(C[z]=S(I[z],$-1),W.enumerable||Object.defineProperty(C,z,{enumerable:!1}))}if(x)for(var F=Object.getOwnPropertyNames(I),E=0;E<F.length;E++){var L=F[E],W=Object.getOwnPropertyDescriptor(I,L);W&&W.enumerable||(C[L]=S(I[L],$-1),Object.defineProperty(C,L,{enumerable:!1}))}return C}return S(m,y)}u.clonePrototype=function(g){if(g===null)return null;var y=function(){};return y.prototype=g,new y};function c(m){return Object.prototype.toString.call(m)}u.__objToStr=c;function d(m){return typeof m=="object"&&c(m)==="[object Date]"}u.__isDate=d;function h(m){return typeof m=="object"&&c(m)==="[object Array]"}u.__isArray=h;function p(m){return typeof m=="object"&&c(m)==="[object RegExp]"}u.__isRegExp=p;function f(m){var g="";return m.global&&(g+="g"),m.ignoreCase&&(g+="i"),m.multiline&&(g+="m"),g}return u.__getRegExpFlags=f,u}();typeof n=="object"&&n.exports&&(n.exports=s)},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function C(T,N){var E=[],_=!0,R=!1,z=void 0;try{for(var W=T[Symbol.iterator](),F;!(_=(F=W.next()).done)&&(E.push(F.value),!(N&&E.length===N));_=!0);}catch(L){R=!0,z=L}finally{try{!_&&W.return&&W.return()}finally{if(R)throw z}}return E}return function(T,N){if(Array.isArray(T))return T;if(Symbol.iterator in Object(T))return C(T,N);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function(){function C(T,N){for(var E=0;E<N.length;E++){var _=N[E];_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(T,_.key,_)}}return function(T,N,E){return N&&C(T.prototype,N),E&&C(T,E),T}}(),o=function C(T,N,E){T===null&&(T=Function.prototype);var _=Object.getOwnPropertyDescriptor(T,N);if(_===void 0){var R=Object.getPrototypeOf(T);return R===null?void 0:C(R,N,E)}else{if("value"in _)return _.value;var z=_.get;return z===void 0?void 0:z.call(E)}},l=s(0),u=v(l),c=s(8),d=v(c),h=s(4),p=v(h),f=s(16),m=v(f),g=s(13),y=v(g),b=s(25),x=v(b);function v(C){return C&&C.__esModule?C:{default:C}}function w(C,T){if(!(C instanceof T))throw new TypeError("Cannot call a class as a function")}function k(C,T){if(!C)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return T&&(typeof T=="object"||typeof T=="function")?T:C}function S(C,T){if(typeof T!="function"&&T!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof T);C.prototype=Object.create(T&&T.prototype,{constructor:{value:C,enumerable:!1,writable:!0,configurable:!0}}),T&&(Object.setPrototypeOf?Object.setPrototypeOf(C,T):C.__proto__=T)}function I(C){return C instanceof p.default||C instanceof h.BlockEmbed}var $=function(C){S(T,C);function T(N,E){w(this,T);var _=k(this,(T.__proto__||Object.getPrototypeOf(T)).call(this,N));return _.emitter=E.emitter,Array.isArray(E.whitelist)&&(_.whitelist=E.whitelist.reduce(function(R,z){return R[z]=!0,R},{})),_.domNode.addEventListener("DOMNodeInserted",function(){}),_.optimize(),_.enable(),_}return i(T,[{key:"batchStart",value:function(){this.batch=!0}},{key:"batchEnd",value:function(){this.batch=!1,this.optimize()}},{key:"deleteAt",value:function(E,_){var R=this.line(E),z=a(R,2),W=z[0],F=z[1],L=this.line(E+_),O=a(L,1),D=O[0];if(o(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"deleteAt",this).call(this,E,_),D!=null&&W!==D&&F>0){if(W instanceof h.BlockEmbed||D instanceof h.BlockEmbed){this.optimize();return}if(W instanceof y.default){var B=W.newlineIndex(W.length(),!0);if(B>-1&&(W=W.split(B+1),W===D)){this.optimize();return}}else if(D instanceof y.default){var V=D.newlineIndex(0);V>-1&&D.split(V+1)}var K=D.children.head instanceof m.default?null:D.children.head;W.moveChildren(D,K),W.remove()}this.optimize()}},{key:"enable",value:function(){var E=arguments.length>0&&arguments[0]!==void 0?arguments[0]:!0;this.domNode.setAttribute("contenteditable",E)}},{key:"formatAt",value:function(E,_,R,z){this.whitelist!=null&&!this.whitelist[R]||(o(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"formatAt",this).call(this,E,_,R,z),this.optimize())}},{key:"insertAt",value:function(E,_,R){if(!(R!=null&&this.whitelist!=null&&!this.whitelist[_])){if(E>=this.length())if(R==null||u.default.query(_,u.default.Scope.BLOCK)==null){var z=u.default.create(this.statics.defaultChild);this.appendChild(z),R==null&&_.endsWith(`
`)&&(_=_.slice(0,-1)),z.insertAt(0,_,R)}else{var W=u.default.create(_,R);this.appendChild(W)}else o(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"insertAt",this).call(this,E,_,R);this.optimize()}}},{key:"insertBefore",value:function(E,_){if(E.statics.scope===u.default.Scope.INLINE_BLOT){var R=u.default.create(this.statics.defaultChild);R.appendChild(E),E=R}o(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"insertBefore",this).call(this,E,_)}},{key:"leaf",value:function(E){return this.path(E).pop()||[null,-1]}},{key:"line",value:function(E){return E===this.length()?this.line(E-1):this.descendant(I,E)}},{key:"lines",value:function(){var E=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0,_=arguments.length>1&&arguments[1]!==void 0?arguments[1]:Number.MAX_VALUE,R=function z(W,F,L){var O=[],D=L;return W.children.forEachAt(F,L,function(B,V,K){I(B)?O.push(B):B instanceof u.default.Container&&(O=O.concat(z(B,V,D))),D-=K}),O};return R(this,E,_)}},{key:"optimize",value:function(){var E=arguments.length>0&&arguments[0]!==void 0?arguments[0]:[],_=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};this.batch!==!0&&(o(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"optimize",this).call(this,E,_),E.length>0&&this.emitter.emit(d.default.events.SCROLL_OPTIMIZE,E,_))}},{key:"path",value:function(E){return o(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"path",this).call(this,E).slice(1)}},{key:"update",value:function(E){if(this.batch!==!0){var _=d.default.sources.USER;typeof E=="string"&&(_=E),Array.isArray(E)||(E=this.observer.takeRecords()),E.length>0&&this.emitter.emit(d.default.events.SCROLL_BEFORE_UPDATE,_,E),o(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"update",this).call(this,E.concat([])),E.length>0&&this.emitter.emit(d.default.events.SCROLL_UPDATE,_,E)}}}]),T}(u.default.Scroll);$.blotName="scroll",$.className="ql-editor",$.tagName="DIV",$.defaultChild="block",$.allowedChildren=[p.default,h.BlockEmbed,x.default],r.default=$},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.SHORTKEY=r.default=void 0;var a=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(U){return typeof U}:function(U){return U&&typeof Symbol=="function"&&U.constructor===Symbol&&U!==Symbol.prototype?"symbol":typeof U},i=function(){function U(q,Q){var ee=[],ae=!0,ye=!1,j=void 0;try{for(var ce=q[Symbol.iterator](),be;!(ae=(be=ce.next()).done)&&(ee.push(be.value),!(Q&&ee.length===Q));ae=!0);}catch(ke){ye=!0,j=ke}finally{try{!ae&&ce.return&&ce.return()}finally{if(ye)throw j}}return ee}return function(q,Q){if(Array.isArray(q))return q;if(Symbol.iterator in Object(q))return U(q,Q);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),o=function(){function U(q,Q){for(var ee=0;ee<Q.length;ee++){var ae=Q[ee];ae.enumerable=ae.enumerable||!1,ae.configurable=!0,"value"in ae&&(ae.writable=!0),Object.defineProperty(q,ae.key,ae)}}return function(q,Q,ee){return Q&&U(q.prototype,Q),ee&&U(q,ee),q}}(),l=s(21),u=C(l),c=s(11),d=C(c),h=s(3),p=C(h),f=s(2),m=C(f),g=s(20),y=C(g),b=s(0),x=C(b),v=s(5),w=C(v),k=s(10),S=C(k),I=s(9),$=C(I);function C(U){return U&&U.__esModule?U:{default:U}}function T(U,q,Q){return q in U?Object.defineProperty(U,q,{value:Q,enumerable:!0,configurable:!0,writable:!0}):U[q]=Q,U}function N(U,q){if(!(U instanceof q))throw new TypeError("Cannot call a class as a function")}function E(U,q){if(!U)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return q&&(typeof q=="object"||typeof q=="function")?q:U}function _(U,q){if(typeof q!="function"&&q!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof q);U.prototype=Object.create(q&&q.prototype,{constructor:{value:U,enumerable:!1,writable:!0,configurable:!0}}),q&&(Object.setPrototypeOf?Object.setPrototypeOf(U,q):U.__proto__=q)}var R=(0,S.default)("quill:keyboard"),z=/Mac/i.test(navigator.platform)?"metaKey":"ctrlKey",W=function(U){_(q,U),o(q,null,[{key:"match",value:function(ee,ae){return ae=G(ae),["altKey","ctrlKey","metaKey","shiftKey"].some(function(ye){return!!ae[ye]!==ee[ye]&&ae[ye]!==null})?!1:ae.key===(ee.which||ee.keyCode)}}]);function q(Q,ee){N(this,q);var ae=E(this,(q.__proto__||Object.getPrototypeOf(q)).call(this,Q,ee));return ae.bindings={},Object.keys(ae.options.bindings).forEach(function(ye){ye==="list autofill"&&Q.scroll.whitelist!=null&&!Q.scroll.whitelist.list||ae.options.bindings[ye]&&ae.addBinding(ae.options.bindings[ye])}),ae.addBinding({key:q.keys.ENTER,shiftKey:null},B),ae.addBinding({key:q.keys.ENTER,metaKey:null,ctrlKey:null,altKey:null},function(){}),/Firefox/i.test(navigator.userAgent)?(ae.addBinding({key:q.keys.BACKSPACE},{collapsed:!0},L),ae.addBinding({key:q.keys.DELETE},{collapsed:!0},O)):(ae.addBinding({key:q.keys.BACKSPACE},{collapsed:!0,prefix:/^.?$/},L),ae.addBinding({key:q.keys.DELETE},{collapsed:!0,suffix:/^.?$/},O)),ae.addBinding({key:q.keys.BACKSPACE},{collapsed:!1},D),ae.addBinding({key:q.keys.DELETE},{collapsed:!1},D),ae.addBinding({key:q.keys.BACKSPACE,altKey:null,ctrlKey:null,metaKey:null,shiftKey:null},{collapsed:!0,offset:0},L),ae.listen(),ae}return o(q,[{key:"addBinding",value:function(ee){var ae=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},ye=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},j=G(ee);if(j==null||j.key==null)return R.warn("Attempted to add invalid keyboard binding",j);typeof ae=="function"&&(ae={handler:ae}),typeof ye=="function"&&(ye={handler:ye}),j=(0,p.default)(j,ae,ye),this.bindings[j.key]=this.bindings[j.key]||[],this.bindings[j.key].push(j)}},{key:"listen",value:function(){var ee=this;this.quill.root.addEventListener("keydown",function(ae){if(!ae.defaultPrevented){var ye=ae.which||ae.keyCode,j=(ee.bindings[ye]||[]).filter(function(Ue){return q.match(ae,Ue)});if(j.length!==0){var ce=ee.quill.getSelection();if(!(ce==null||!ee.quill.hasFocus())){var be=ee.quill.getLine(ce.index),ke=i(be,2),Ae=ke[0],Pe=ke[1],ie=ee.quill.getLeaf(ce.index),Te=i(ie,2),Le=Te[0],$e=Te[1],ge=ce.length===0?[Le,$e]:ee.quill.getLeaf(ce.index+ce.length),ve=i(ge,2),pe=ve[0],Ie=ve[1],ze=Le instanceof x.default.Text?Le.value().slice(0,$e):"",Ye=pe instanceof x.default.Text?pe.value().slice(Ie):"",Je={collapsed:ce.length===0,empty:ce.length===0&&Ae.length()<=1,format:ee.quill.getFormat(ce),offset:Pe,prefix:ze,suffix:Ye},Ke=j.some(function(Ue){if(Ue.collapsed!=null&&Ue.collapsed!==Je.collapsed||Ue.empty!=null&&Ue.empty!==Je.empty||Ue.offset!=null&&Ue.offset!==Je.offset)return!1;if(Array.isArray(Ue.format)){if(Ue.format.every(function(Xe){return Je.format[Xe]==null}))return!1}else if(a(Ue.format)==="object"&&!Object.keys(Ue.format).every(function(Xe){return Ue.format[Xe]===!0?Je.format[Xe]!=null:Ue.format[Xe]===!1?Je.format[Xe]==null:(0,d.default)(Ue.format[Xe],Je.format[Xe])}))return!1;return Ue.prefix!=null&&!Ue.prefix.test(Je.prefix)||Ue.suffix!=null&&!Ue.suffix.test(Je.suffix)?!1:Ue.handler.call(ee,ce,Je)!==!0});Ke&&ae.preventDefault()}}}})}}]),q}($.default);W.keys={BACKSPACE:8,TAB:9,ENTER:13,ESCAPE:27,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46},W.DEFAULTS={bindings:{bold:K("bold"),italic:K("italic"),underline:K("underline"),indent:{key:W.keys.TAB,format:["blockquote","indent","list"],handler:function(q,Q){if(Q.collapsed&&Q.offset!==0)return!0;this.quill.format("indent","+1",w.default.sources.USER)}},outdent:{key:W.keys.TAB,shiftKey:!0,format:["blockquote","indent","list"],handler:function(q,Q){if(Q.collapsed&&Q.offset!==0)return!0;this.quill.format("indent","-1",w.default.sources.USER)}},"outdent backspace":{key:W.keys.BACKSPACE,collapsed:!0,shiftKey:null,metaKey:null,ctrlKey:null,altKey:null,format:["indent","list"],offset:0,handler:function(q,Q){Q.format.indent!=null?this.quill.format("indent","-1",w.default.sources.USER):Q.format.list!=null&&this.quill.format("list",!1,w.default.sources.USER)}},"indent code-block":V(!0),"outdent code-block":V(!1),"remove tab":{key:W.keys.TAB,shiftKey:!0,collapsed:!0,prefix:/\t$/,handler:function(q){this.quill.deleteText(q.index-1,1,w.default.sources.USER)}},tab:{key:W.keys.TAB,handler:function(q){this.quill.history.cutoff();var Q=new m.default().retain(q.index).delete(q.length).insert("	");this.quill.updateContents(Q,w.default.sources.USER),this.quill.history.cutoff(),this.quill.setSelection(q.index+1,w.default.sources.SILENT)}},"list empty enter":{key:W.keys.ENTER,collapsed:!0,format:["list"],empty:!0,handler:function(q,Q){this.quill.format("list",!1,w.default.sources.USER),Q.format.indent&&this.quill.format("indent",!1,w.default.sources.USER)}},"checklist enter":{key:W.keys.ENTER,collapsed:!0,format:{list:"checked"},handler:function(q){var Q=this.quill.getLine(q.index),ee=i(Q,2),ae=ee[0],ye=ee[1],j=(0,p.default)({},ae.formats(),{list:"checked"}),ce=new m.default().retain(q.index).insert(`
`,j).retain(ae.length()-ye-1).retain(1,{list:"unchecked"});this.quill.updateContents(ce,w.default.sources.USER),this.quill.setSelection(q.index+1,w.default.sources.SILENT),this.quill.scrollIntoView()}},"header enter":{key:W.keys.ENTER,collapsed:!0,format:["header"],suffix:/^$/,handler:function(q,Q){var ee=this.quill.getLine(q.index),ae=i(ee,2),ye=ae[0],j=ae[1],ce=new m.default().retain(q.index).insert(`
`,Q.format).retain(ye.length()-j-1).retain(1,{header:null});this.quill.updateContents(ce,w.default.sources.USER),this.quill.setSelection(q.index+1,w.default.sources.SILENT),this.quill.scrollIntoView()}},"list autofill":{key:" ",collapsed:!0,format:{list:!1},prefix:/^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,handler:function(q,Q){var ee=Q.prefix.length,ae=this.quill.getLine(q.index),ye=i(ae,2),j=ye[0],ce=ye[1];if(ce>ee)return!0;var be=void 0;switch(Q.prefix.trim()){case"[]":case"[ ]":be="unchecked";break;case"[x]":be="checked";break;case"-":case"*":be="bullet";break;default:be="ordered"}this.quill.insertText(q.index," ",w.default.sources.USER),this.quill.history.cutoff();var ke=new m.default().retain(q.index-ce).delete(ee+1).retain(j.length()-2-ce).retain(1,{list:be});this.quill.updateContents(ke,w.default.sources.USER),this.quill.history.cutoff(),this.quill.setSelection(q.index-ee,w.default.sources.SILENT)}},"code exit":{key:W.keys.ENTER,collapsed:!0,format:["code-block"],prefix:/\n\n$/,suffix:/^\s+$/,handler:function(q){var Q=this.quill.getLine(q.index),ee=i(Q,2),ae=ee[0],ye=ee[1],j=new m.default().retain(q.index+ae.length()-ye-2).retain(1,{"code-block":null}).delete(1);this.quill.updateContents(j,w.default.sources.USER)}},"embed left":F(W.keys.LEFT,!1),"embed left shift":F(W.keys.LEFT,!0),"embed right":F(W.keys.RIGHT,!1),"embed right shift":F(W.keys.RIGHT,!0)}};function F(U,q){var Q,ee=U===W.keys.LEFT?"prefix":"suffix";return Q={key:U,shiftKey:q,altKey:null},T(Q,ee,/^$/),T(Q,"handler",function(ye){var j=ye.index;U===W.keys.RIGHT&&(j+=ye.length+1);var ce=this.quill.getLeaf(j),be=i(ce,1),ke=be[0];return ke instanceof x.default.Embed?(U===W.keys.LEFT?q?this.quill.setSelection(ye.index-1,ye.length+1,w.default.sources.USER):this.quill.setSelection(ye.index-1,w.default.sources.USER):q?this.quill.setSelection(ye.index,ye.length+1,w.default.sources.USER):this.quill.setSelection(ye.index+ye.length+1,w.default.sources.USER),!1):!0}),Q}function L(U,q){if(!(U.index===0||this.quill.getLength()<=1)){var Q=this.quill.getLine(U.index),ee=i(Q,1),ae=ee[0],ye={};if(q.offset===0){var j=this.quill.getLine(U.index-1),ce=i(j,1),be=ce[0];if(be!=null&&be.length()>1){var ke=ae.formats(),Ae=this.quill.getFormat(U.index-1,1);ye=y.default.attributes.diff(ke,Ae)||{}}}var Pe=/[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(q.prefix)?2:1;this.quill.deleteText(U.index-Pe,Pe,w.default.sources.USER),Object.keys(ye).length>0&&this.quill.formatLine(U.index-Pe,Pe,ye,w.default.sources.USER),this.quill.focus()}}function O(U,q){var Q=/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(q.suffix)?2:1;if(!(U.index>=this.quill.getLength()-Q)){var ee={},ae=0,ye=this.quill.getLine(U.index),j=i(ye,1),ce=j[0];if(q.offset>=ce.length()-1){var be=this.quill.getLine(U.index+1),ke=i(be,1),Ae=ke[0];if(Ae){var Pe=ce.formats(),ie=this.quill.getFormat(U.index,1);ee=y.default.attributes.diff(Pe,ie)||{},ae=Ae.length()}}this.quill.deleteText(U.index,Q,w.default.sources.USER),Object.keys(ee).length>0&&this.quill.formatLine(U.index+ae-1,Q,ee,w.default.sources.USER)}}function D(U){var q=this.quill.getLines(U),Q={};if(q.length>1){var ee=q[0].formats(),ae=q[q.length-1].formats();Q=y.default.attributes.diff(ae,ee)||{}}this.quill.deleteText(U,w.default.sources.USER),Object.keys(Q).length>0&&this.quill.formatLine(U.index,1,Q,w.default.sources.USER),this.quill.setSelection(U.index,w.default.sources.SILENT),this.quill.focus()}function B(U,q){var Q=this;U.length>0&&this.quill.scroll.deleteAt(U.index,U.length);var ee=Object.keys(q.format).reduce(function(ae,ye){return x.default.query(ye,x.default.Scope.BLOCK)&&!Array.isArray(q.format[ye])&&(ae[ye]=q.format[ye]),ae},{});this.quill.insertText(U.index,`
`,ee,w.default.sources.USER),this.quill.setSelection(U.index+1,w.default.sources.SILENT),this.quill.focus(),Object.keys(q.format).forEach(function(ae){ee[ae]==null&&(Array.isArray(q.format[ae])||ae!=="link"&&Q.quill.format(ae,q.format[ae],w.default.sources.USER))})}function V(U){return{key:W.keys.TAB,shiftKey:!U,format:{"code-block":!0},handler:function(Q){var ee=x.default.query("code-block"),ae=Q.index,ye=Q.length,j=this.quill.scroll.descendant(ee,ae),ce=i(j,2),be=ce[0],ke=ce[1];if(be!=null){var Ae=this.quill.getIndex(be),Pe=be.newlineIndex(ke,!0)+1,ie=be.newlineIndex(Ae+ke+ye),Te=be.domNode.textContent.slice(Pe,ie).split(`
`);ke=0,Te.forEach(function(Le,$e){U?(be.insertAt(Pe+ke,ee.TAB),ke+=ee.TAB.length,$e===0?ae+=ee.TAB.length:ye+=ee.TAB.length):Le.startsWith(ee.TAB)&&(be.deleteAt(Pe+ke,ee.TAB.length),ke-=ee.TAB.length,$e===0?ae-=ee.TAB.length:ye-=ee.TAB.length),ke+=Le.length+1}),this.quill.update(w.default.sources.USER),this.quill.setSelection(ae,ye,w.default.sources.SILENT)}}}}function K(U){return{key:U[0].toUpperCase(),shortKey:!0,handler:function(Q,ee){this.quill.format(U,!ee.format[U],w.default.sources.USER)}}}function G(U){if(typeof U=="string"||typeof U=="number")return G({key:U});if((typeof U>"u"?"undefined":a(U))==="object"&&(U=(0,u.default)(U,!1)),typeof U.key=="string")if(W.keys[U.key.toUpperCase()]!=null)U.key=W.keys[U.key.toUpperCase()];else if(U.key.length===1)U.key=U.key.toUpperCase().charCodeAt(0);else return null;return U.shortKey&&(U[z]=U.shortKey,delete U.shortKey),U}r.default=W,r.SHORTKEY=z},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function y(b,x){var v=[],w=!0,k=!1,S=void 0;try{for(var I=b[Symbol.iterator](),$;!(w=($=I.next()).done)&&(v.push($.value),!(x&&v.length===x));w=!0);}catch(C){k=!0,S=C}finally{try{!w&&I.return&&I.return()}finally{if(k)throw S}}return v}return function(b,x){if(Array.isArray(b))return b;if(Symbol.iterator in Object(b))return y(b,x);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function y(b,x,v){b===null&&(b=Function.prototype);var w=Object.getOwnPropertyDescriptor(b,x);if(w===void 0){var k=Object.getPrototypeOf(b);return k===null?void 0:y(k,x,v)}else{if("value"in w)return w.value;var S=w.get;return S===void 0?void 0:S.call(v)}},o=function(){function y(b,x){for(var v=0;v<x.length;v++){var w=x[v];w.enumerable=w.enumerable||!1,w.configurable=!0,"value"in w&&(w.writable=!0),Object.defineProperty(b,w.key,w)}}return function(b,x,v){return x&&y(b.prototype,x),v&&y(b,v),b}}(),l=s(0),u=h(l),c=s(7),d=h(c);function h(y){return y&&y.__esModule?y:{default:y}}function p(y,b){if(!(y instanceof b))throw new TypeError("Cannot call a class as a function")}function f(y,b){if(!y)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return b&&(typeof b=="object"||typeof b=="function")?b:y}function m(y,b){if(typeof b!="function"&&b!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof b);y.prototype=Object.create(b&&b.prototype,{constructor:{value:y,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(y,b):y.__proto__=b)}var g=function(y){m(b,y),o(b,null,[{key:"value",value:function(){}}]);function b(x,v){p(this,b);var w=f(this,(b.__proto__||Object.getPrototypeOf(b)).call(this,x));return w.selection=v,w.textNode=document.createTextNode(b.CONTENTS),w.domNode.appendChild(w.textNode),w._length=0,w}return o(b,[{key:"detach",value:function(){this.parent!=null&&this.parent.removeChild(this)}},{key:"format",value:function(v,w){if(this._length!==0)return i(b.prototype.__proto__||Object.getPrototypeOf(b.prototype),"format",this).call(this,v,w);for(var k=this,S=0;k!=null&&k.statics.scope!==u.default.Scope.BLOCK_BLOT;)S+=k.offset(k.parent),k=k.parent;k!=null&&(this._length=b.CONTENTS.length,k.optimize(),k.formatAt(S,b.CONTENTS.length,v,w),this._length=0)}},{key:"index",value:function(v,w){return v===this.textNode?0:i(b.prototype.__proto__||Object.getPrototypeOf(b.prototype),"index",this).call(this,v,w)}},{key:"length",value:function(){return this._length}},{key:"position",value:function(){return[this.textNode,this.textNode.data.length]}},{key:"remove",value:function(){i(b.prototype.__proto__||Object.getPrototypeOf(b.prototype),"remove",this).call(this),this.parent=null}},{key:"restore",value:function(){if(!(this.selection.composing||this.parent==null)){var v=this.textNode,w=this.selection.getNativeRange(),k=void 0,S=void 0,I=void 0;if(w!=null&&w.start.node===v&&w.end.node===v){var $=[v,w.start.offset,w.end.offset];k=$[0],S=$[1],I=$[2]}for(;this.domNode.lastChild!=null&&this.domNode.lastChild!==this.textNode;)this.domNode.parentNode.insertBefore(this.domNode.lastChild,this.domNode);if(this.textNode.data!==b.CONTENTS){var C=this.textNode.data.split(b.CONTENTS).join("");this.next instanceof d.default?(k=this.next.domNode,this.next.insertAt(0,C),this.textNode.data=b.CONTENTS):(this.textNode.data=C,this.parent.insertBefore(u.default.create(this.textNode),this),this.textNode=document.createTextNode(b.CONTENTS),this.domNode.appendChild(this.textNode))}if(this.remove(),S!=null){var T=[S,I].map(function(E){return Math.max(0,Math.min(k.data.length,E-1))}),N=a(T,2);return S=N[0],I=N[1],{startNode:k,startOffset:S,endNode:k,endOffset:I}}}}},{key:"update",value:function(v,w){var k=this;if(v.some(function(I){return I.type==="characterData"&&I.target===k.textNode})){var S=this.restore();S&&(w.range=S)}}},{key:"value",value:function(){return""}}]),b}(u.default.Embed);g.blotName="cursor",g.className="ql-cursor",g.tagName="span",g.CONTENTS="\uFEFF",r.default=g},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(0),i=u(a),o=s(4),l=u(o);function u(f){return f&&f.__esModule?f:{default:f}}function c(f,m){if(!(f instanceof m))throw new TypeError("Cannot call a class as a function")}function d(f,m){if(!f)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return m&&(typeof m=="object"||typeof m=="function")?m:f}function h(f,m){if(typeof m!="function"&&m!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof m);f.prototype=Object.create(m&&m.prototype,{constructor:{value:f,enumerable:!1,writable:!0,configurable:!0}}),m&&(Object.setPrototypeOf?Object.setPrototypeOf(f,m):f.__proto__=m)}var p=function(f){h(m,f);function m(){return c(this,m),d(this,(m.__proto__||Object.getPrototypeOf(m)).apply(this,arguments))}return m}(i.default.Container);p.allowedChildren=[l.default,o.BlockEmbed,p],r.default=p},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.ColorStyle=r.ColorClass=r.ColorAttributor=void 0;var a=function(){function g(y,b){for(var x=0;x<b.length;x++){var v=b[x];v.enumerable=v.enumerable||!1,v.configurable=!0,"value"in v&&(v.writable=!0),Object.defineProperty(y,v.key,v)}}return function(y,b,x){return b&&g(y.prototype,b),x&&g(y,x),y}}(),i=function g(y,b,x){y===null&&(y=Function.prototype);var v=Object.getOwnPropertyDescriptor(y,b);if(v===void 0){var w=Object.getPrototypeOf(y);return w===null?void 0:g(w,b,x)}else{if("value"in v)return v.value;var k=v.get;return k===void 0?void 0:k.call(x)}},o=s(0),l=u(o);function u(g){return g&&g.__esModule?g:{default:g}}function c(g,y){if(!(g instanceof y))throw new TypeError("Cannot call a class as a function")}function d(g,y){if(!g)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return y&&(typeof y=="object"||typeof y=="function")?y:g}function h(g,y){if(typeof y!="function"&&y!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof y);g.prototype=Object.create(y&&y.prototype,{constructor:{value:g,enumerable:!1,writable:!0,configurable:!0}}),y&&(Object.setPrototypeOf?Object.setPrototypeOf(g,y):g.__proto__=y)}var p=function(g){h(y,g);function y(){return c(this,y),d(this,(y.__proto__||Object.getPrototypeOf(y)).apply(this,arguments))}return a(y,[{key:"value",value:function(x){var v=i(y.prototype.__proto__||Object.getPrototypeOf(y.prototype),"value",this).call(this,x);return v.startsWith("rgb(")?(v=v.replace(/^[^\d]+/,"").replace(/[^\d]+$/,""),"#"+v.split(",").map(function(w){return("00"+parseInt(w).toString(16)).slice(-2)}).join("")):v}}]),y}(l.default.Attributor.Style),f=new l.default.Attributor.Class("color","ql-color",{scope:l.default.Scope.INLINE}),m=new p("color","color",{scope:l.default.Scope.INLINE});r.ColorAttributor=p,r.ColorClass=f,r.ColorStyle=m},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.sanitize=r.default=void 0;var a=function(){function m(g,y){for(var b=0;b<y.length;b++){var x=y[b];x.enumerable=x.enumerable||!1,x.configurable=!0,"value"in x&&(x.writable=!0),Object.defineProperty(g,x.key,x)}}return function(g,y,b){return y&&m(g.prototype,y),b&&m(g,b),g}}(),i=function m(g,y,b){g===null&&(g=Function.prototype);var x=Object.getOwnPropertyDescriptor(g,y);if(x===void 0){var v=Object.getPrototypeOf(g);return v===null?void 0:m(v,y,b)}else{if("value"in x)return x.value;var w=x.get;return w===void 0?void 0:w.call(b)}},o=s(6),l=u(o);function u(m){return m&&m.__esModule?m:{default:m}}function c(m,g){if(!(m instanceof g))throw new TypeError("Cannot call a class as a function")}function d(m,g){if(!m)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return g&&(typeof g=="object"||typeof g=="function")?g:m}function h(m,g){if(typeof g!="function"&&g!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof g);m.prototype=Object.create(g&&g.prototype,{constructor:{value:m,enumerable:!1,writable:!0,configurable:!0}}),g&&(Object.setPrototypeOf?Object.setPrototypeOf(m,g):m.__proto__=g)}var p=function(m){h(g,m);function g(){return c(this,g),d(this,(g.__proto__||Object.getPrototypeOf(g)).apply(this,arguments))}return a(g,[{key:"format",value:function(b,x){if(b!==this.statics.blotName||!x)return i(g.prototype.__proto__||Object.getPrototypeOf(g.prototype),"format",this).call(this,b,x);x=this.constructor.sanitize(x),this.domNode.setAttribute("href",x)}}],[{key:"create",value:function(b){var x=i(g.__proto__||Object.getPrototypeOf(g),"create",this).call(this,b);return b=this.sanitize(b),x.setAttribute("href",b),x.setAttribute("rel","noopener noreferrer"),x.setAttribute("target","_blank"),x}},{key:"formats",value:function(b){return b.getAttribute("href")}},{key:"sanitize",value:function(b){return f(b,this.PROTOCOL_WHITELIST)?b:this.SANITIZED_URL}}]),g}(l.default);p.blotName="link",p.tagName="A",p.SANITIZED_URL="about:blank",p.PROTOCOL_WHITELIST=["http","https","mailto","tel"];function f(m,g){var y=document.createElement("a");y.href=m;var b=y.href.slice(0,y.href.indexOf(":"));return g.indexOf(b)>-1}r.default=p,r.sanitize=f},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(g){return typeof g}:function(g){return g&&typeof Symbol=="function"&&g.constructor===Symbol&&g!==Symbol.prototype?"symbol":typeof g},i=function(){function g(y,b){for(var x=0;x<b.length;x++){var v=b[x];v.enumerable=v.enumerable||!1,v.configurable=!0,"value"in v&&(v.writable=!0),Object.defineProperty(y,v.key,v)}}return function(y,b,x){return b&&g(y.prototype,b),x&&g(y,x),y}}(),o=s(23),l=d(o),u=s(107),c=d(u);function d(g){return g&&g.__esModule?g:{default:g}}function h(g,y){if(!(g instanceof y))throw new TypeError("Cannot call a class as a function")}var p=0;function f(g,y){g.setAttribute(y,g.getAttribute(y)!=="true")}var m=function(){function g(y){var b=this;h(this,g),this.select=y,this.container=document.createElement("span"),this.buildPicker(),this.select.style.display="none",this.select.parentNode.insertBefore(this.container,this.select),this.label.addEventListener("mousedown",function(){b.togglePicker()}),this.label.addEventListener("keydown",function(x){switch(x.keyCode){case l.default.keys.ENTER:b.togglePicker();break;case l.default.keys.ESCAPE:b.escape(),x.preventDefault();break}}),this.select.addEventListener("change",this.update.bind(this))}return i(g,[{key:"togglePicker",value:function(){this.container.classList.toggle("ql-expanded"),f(this.label,"aria-expanded"),f(this.options,"aria-hidden")}},{key:"buildItem",value:function(b){var x=this,v=document.createElement("span");return v.tabIndex="0",v.setAttribute("role","button"),v.classList.add("ql-picker-item"),b.hasAttribute("value")&&v.setAttribute("data-value",b.getAttribute("value")),b.textContent&&v.setAttribute("data-label",b.textContent),v.addEventListener("click",function(){x.selectItem(v,!0)}),v.addEventListener("keydown",function(w){switch(w.keyCode){case l.default.keys.ENTER:x.selectItem(v,!0),w.preventDefault();break;case l.default.keys.ESCAPE:x.escape(),w.preventDefault();break}}),v}},{key:"buildLabel",value:function(){var b=document.createElement("span");return b.classList.add("ql-picker-label"),b.innerHTML=c.default,b.tabIndex="0",b.setAttribute("role","button"),b.setAttribute("aria-expanded","false"),this.container.appendChild(b),b}},{key:"buildOptions",value:function(){var b=this,x=document.createElement("span");x.classList.add("ql-picker-options"),x.setAttribute("aria-hidden","true"),x.tabIndex="-1",x.id="ql-picker-options-"+p,p+=1,this.label.setAttribute("aria-controls",x.id),this.options=x,[].slice.call(this.select.options).forEach(function(v){var w=b.buildItem(v);x.appendChild(w),v.selected===!0&&b.selectItem(w)}),this.container.appendChild(x)}},{key:"buildPicker",value:function(){var b=this;[].slice.call(this.select.attributes).forEach(function(x){b.container.setAttribute(x.name,x.value)}),this.container.classList.add("ql-picker"),this.label=this.buildLabel(),this.buildOptions()}},{key:"escape",value:function(){var b=this;this.close(),setTimeout(function(){return b.label.focus()},1)}},{key:"close",value:function(){this.container.classList.remove("ql-expanded"),this.label.setAttribute("aria-expanded","false"),this.options.setAttribute("aria-hidden","true")}},{key:"selectItem",value:function(b){var x=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1,v=this.container.querySelector(".ql-selected");if(b!==v&&(v!=null&&v.classList.remove("ql-selected"),b!=null&&(b.classList.add("ql-selected"),this.select.selectedIndex=[].indexOf.call(b.parentNode.children,b),b.hasAttribute("data-value")?this.label.setAttribute("data-value",b.getAttribute("data-value")):this.label.removeAttribute("data-value"),b.hasAttribute("data-label")?this.label.setAttribute("data-label",b.getAttribute("data-label")):this.label.removeAttribute("data-label"),x))){if(typeof Event=="function")this.select.dispatchEvent(new Event("change"));else if((typeof Event>"u"?"undefined":a(Event))==="object"){var w=document.createEvent("Event");w.initEvent("change",!0,!0),this.select.dispatchEvent(w)}this.close()}}},{key:"update",value:function(){var b=void 0;if(this.select.selectedIndex>-1){var x=this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];b=this.select.options[this.select.selectedIndex],this.selectItem(x)}else this.selectItem(null);var v=b!=null&&b!==this.select.querySelector("option[selected]");this.label.classList.toggle("ql-active",v)}}]),g}();r.default=m},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(0),i=R(a),o=s(5),l=R(o),u=s(4),c=R(u),d=s(16),h=R(d),p=s(25),f=R(p),m=s(24),g=R(m),y=s(35),b=R(y),x=s(6),v=R(x),w=s(22),k=R(w),S=s(7),I=R(S),$=s(55),C=R($),T=s(42),N=R(T),E=s(23),_=R(E);function R(z){return z&&z.__esModule?z:{default:z}}l.default.register({"blots/block":c.default,"blots/block/embed":u.BlockEmbed,"blots/break":h.default,"blots/container":f.default,"blots/cursor":g.default,"blots/embed":b.default,"blots/inline":v.default,"blots/scroll":k.default,"blots/text":I.default,"modules/clipboard":C.default,"modules/history":N.default,"modules/keyboard":_.default}),i.default.register(c.default,h.default,g.default,v.default,k.default,I.default),r.default=l.default},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(1),i=function(){function o(l){this.domNode=l,this.domNode[a.DATA_KEY]={blot:this}}return Object.defineProperty(o.prototype,"statics",{get:function(){return this.constructor},enumerable:!0,configurable:!0}),o.create=function(l){if(this.tagName==null)throw new a.ParchmentError("Blot definition missing tagName");var u;return Array.isArray(this.tagName)?(typeof l=="string"&&(l=l.toUpperCase(),parseInt(l).toString()===l&&(l=parseInt(l))),typeof l=="number"?u=document.createElement(this.tagName[l-1]):this.tagName.indexOf(l)>-1?u=document.createElement(l):u=document.createElement(this.tagName[0])):u=document.createElement(this.tagName),this.className&&u.classList.add(this.className),u},o.prototype.attach=function(){this.parent!=null&&(this.scroll=this.parent.scroll)},o.prototype.clone=function(){var l=this.domNode.cloneNode(!1);return a.create(l)},o.prototype.detach=function(){this.parent!=null&&this.parent.removeChild(this),delete this.domNode[a.DATA_KEY]},o.prototype.deleteAt=function(l,u){var c=this.isolate(l,u);c.remove()},o.prototype.formatAt=function(l,u,c,d){var h=this.isolate(l,u);if(a.query(c,a.Scope.BLOT)!=null&&d)h.wrap(c,d);else if(a.query(c,a.Scope.ATTRIBUTE)!=null){var p=a.create(this.statics.scope);h.wrap(p),p.format(c,d)}},o.prototype.insertAt=function(l,u,c){var d=c==null?a.create("text",u):a.create(u,c),h=this.split(l);this.parent.insertBefore(d,h)},o.prototype.insertInto=function(l,u){u===void 0&&(u=null),this.parent!=null&&this.parent.children.remove(this);var c=null;l.children.insertBefore(this,u),u!=null&&(c=u.domNode),(this.domNode.parentNode!=l.domNode||this.domNode.nextSibling!=c)&&l.domNode.insertBefore(this.domNode,c),this.parent=l,this.attach()},o.prototype.isolate=function(l,u){var c=this.split(l);return c.split(u),c},o.prototype.length=function(){return 1},o.prototype.offset=function(l){return l===void 0&&(l=this.parent),this.parent==null||this==l?0:this.parent.children.offset(this)+this.parent.offset(l)},o.prototype.optimize=function(l){this.domNode[a.DATA_KEY]!=null&&delete this.domNode[a.DATA_KEY].mutations},o.prototype.remove=function(){this.domNode.parentNode!=null&&this.domNode.parentNode.removeChild(this.domNode),this.detach()},o.prototype.replace=function(l){l.parent!=null&&(l.parent.insertBefore(this,l.next),l.remove())},o.prototype.replaceWith=function(l,u){var c=typeof l=="string"?a.create(l,u):l;return c.replace(this),c},o.prototype.split=function(l,u){return l===0?this:this.next},o.prototype.update=function(l,u){},o.prototype.wrap=function(l,u){var c=typeof l=="string"?a.create(l,u):l;return this.parent!=null&&this.parent.insertBefore(c,this.next),c.appendChild(this),c},o.blotName="abstract",o}();r.default=i},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(12),i=s(32),o=s(33),l=s(1),u=function(){function c(d){this.attributes={},this.domNode=d,this.build()}return c.prototype.attribute=function(d,h){h?d.add(this.domNode,h)&&(d.value(this.domNode)!=null?this.attributes[d.attrName]=d:delete this.attributes[d.attrName]):(d.remove(this.domNode),delete this.attributes[d.attrName])},c.prototype.build=function(){var d=this;this.attributes={};var h=a.default.keys(this.domNode),p=i.default.keys(this.domNode),f=o.default.keys(this.domNode);h.concat(p).concat(f).forEach(function(m){var g=l.query(m,l.Scope.ATTRIBUTE);g instanceof a.default&&(d.attributes[g.attrName]=g)})},c.prototype.copy=function(d){var h=this;Object.keys(this.attributes).forEach(function(p){var f=h.attributes[p].value(h.domNode);d.format(p,f)})},c.prototype.move=function(d){var h=this;this.copy(d),Object.keys(this.attributes).forEach(function(p){h.attributes[p].remove(h.domNode)}),this.attributes={}},c.prototype.values=function(){var d=this;return Object.keys(this.attributes).reduce(function(h,p){return h[p]=d.attributes[p].value(d.domNode),h},{})},c}();r.default=u},function(n,r,s){var a=this&&this.__extends||function(){var u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(c,d){c.__proto__=d}||function(c,d){for(var h in d)d.hasOwnProperty(h)&&(c[h]=d[h])};return function(c,d){u(c,d);function h(){this.constructor=c}c.prototype=d===null?Object.create(d):(h.prototype=d.prototype,new h)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(12);function o(u,c){var d=u.getAttribute("class")||"";return d.split(/\s+/).filter(function(h){return h.indexOf(c+"-")===0})}var l=function(u){a(c,u);function c(){return u!==null&&u.apply(this,arguments)||this}return c.keys=function(d){return(d.getAttribute("class")||"").split(/\s+/).map(function(h){return h.split("-").slice(0,-1).join("-")})},c.prototype.add=function(d,h){return this.canAdd(d,h)?(this.remove(d),d.classList.add(this.keyName+"-"+h),!0):!1},c.prototype.remove=function(d){var h=o(d,this.keyName);h.forEach(function(p){d.classList.remove(p)}),d.classList.length===0&&d.removeAttribute("class")},c.prototype.value=function(d){var h=o(d,this.keyName)[0]||"",p=h.slice(this.keyName.length+1);return this.canAdd(d,p)?p:""},c}(i.default);r.default=l},function(n,r,s){var a=this&&this.__extends||function(){var u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(c,d){c.__proto__=d}||function(c,d){for(var h in d)d.hasOwnProperty(h)&&(c[h]=d[h])};return function(c,d){u(c,d);function h(){this.constructor=c}c.prototype=d===null?Object.create(d):(h.prototype=d.prototype,new h)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(12);function o(u){var c=u.split("-"),d=c.slice(1).map(function(h){return h[0].toUpperCase()+h.slice(1)}).join("");return c[0]+d}var l=function(u){a(c,u);function c(){return u!==null&&u.apply(this,arguments)||this}return c.keys=function(d){return(d.getAttribute("style")||"").split(";").map(function(h){var p=h.split(":");return p[0].trim()})},c.prototype.add=function(d,h){return this.canAdd(d,h)?(d.style[o(this.keyName)]=h,!0):!1},c.prototype.remove=function(d){d.style[o(this.keyName)]="",d.getAttribute("style")||d.removeAttribute("style")},c.prototype.value=function(d){var h=d.style[o(this.keyName)];return this.canAdd(d,h)?h:""},c}(i.default);r.default=l},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function l(u,c){for(var d=0;d<c.length;d++){var h=c[d];h.enumerable=h.enumerable||!1,h.configurable=!0,"value"in h&&(h.writable=!0),Object.defineProperty(u,h.key,h)}}return function(u,c,d){return c&&l(u.prototype,c),d&&l(u,d),u}}();function i(l,u){if(!(l instanceof u))throw new TypeError("Cannot call a class as a function")}var o=function(){function l(u,c){i(this,l),this.quill=u,this.options=c,this.modules={}}return a(l,[{key:"init",value:function(){var c=this;Object.keys(this.options.modules).forEach(function(d){c.modules[d]==null&&c.addModule(d)})}},{key:"addModule",value:function(c){var d=this.quill.constructor.import("modules/"+c);return this.modules[c]=new d(this.quill,this.options.modules[c]||{}),this.modules[c]}}]),l}();o.DEFAULTS={modules:{}},o.themes={default:o},r.default=o},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function y(b,x){for(var v=0;v<x.length;v++){var w=x[v];w.enumerable=w.enumerable||!1,w.configurable=!0,"value"in w&&(w.writable=!0),Object.defineProperty(b,w.key,w)}}return function(b,x,v){return x&&y(b.prototype,x),v&&y(b,v),b}}(),i=function y(b,x,v){b===null&&(b=Function.prototype);var w=Object.getOwnPropertyDescriptor(b,x);if(w===void 0){var k=Object.getPrototypeOf(b);return k===null?void 0:y(k,x,v)}else{if("value"in w)return w.value;var S=w.get;return S===void 0?void 0:S.call(v)}},o=s(0),l=d(o),u=s(7),c=d(u);function d(y){return y&&y.__esModule?y:{default:y}}function h(y,b){if(!(y instanceof b))throw new TypeError("Cannot call a class as a function")}function p(y,b){if(!y)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return b&&(typeof b=="object"||typeof b=="function")?b:y}function f(y,b){if(typeof b!="function"&&b!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof b);y.prototype=Object.create(b&&b.prototype,{constructor:{value:y,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(y,b):y.__proto__=b)}var m="\uFEFF",g=function(y){f(b,y);function b(x){h(this,b);var v=p(this,(b.__proto__||Object.getPrototypeOf(b)).call(this,x));return v.contentNode=document.createElement("span"),v.contentNode.setAttribute("contenteditable",!1),[].slice.call(v.domNode.childNodes).forEach(function(w){v.contentNode.appendChild(w)}),v.leftGuard=document.createTextNode(m),v.rightGuard=document.createTextNode(m),v.domNode.appendChild(v.leftGuard),v.domNode.appendChild(v.contentNode),v.domNode.appendChild(v.rightGuard),v}return a(b,[{key:"index",value:function(v,w){return v===this.leftGuard?0:v===this.rightGuard?1:i(b.prototype.__proto__||Object.getPrototypeOf(b.prototype),"index",this).call(this,v,w)}},{key:"restore",value:function(v){var w=void 0,k=void 0,S=v.data.split(m).join("");if(v===this.leftGuard)if(this.prev instanceof c.default){var I=this.prev.length();this.prev.insertAt(I,S),w={startNode:this.prev.domNode,startOffset:I+S.length}}else k=document.createTextNode(S),this.parent.insertBefore(l.default.create(k),this),w={startNode:k,startOffset:S.length};else v===this.rightGuard&&(this.next instanceof c.default?(this.next.insertAt(0,S),w={startNode:this.next.domNode,startOffset:S.length}):(k=document.createTextNode(S),this.parent.insertBefore(l.default.create(k),this.next),w={startNode:k,startOffset:S.length}));return v.data=m,w}},{key:"update",value:function(v,w){var k=this;v.forEach(function(S){if(S.type==="characterData"&&(S.target===k.leftGuard||S.target===k.rightGuard)){var I=k.restore(S.target);I&&(w.range=I)}})}}]),b}(l.default.Embed);r.default=g},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.AlignStyle=r.AlignClass=r.AlignAttribute=void 0;var a=s(0),i=o(a);function o(h){return h&&h.__esModule?h:{default:h}}var l={scope:i.default.Scope.BLOCK,whitelist:["right","center","justify"]},u=new i.default.Attributor.Attribute("align","align",l),c=new i.default.Attributor.Class("align","ql-align",l),d=new i.default.Attributor.Style("align","text-align",l);r.AlignAttribute=u,r.AlignClass=c,r.AlignStyle=d},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.BackgroundStyle=r.BackgroundClass=void 0;var a=s(0),i=l(a),o=s(26);function l(d){return d&&d.__esModule?d:{default:d}}var u=new i.default.Attributor.Class("background","ql-bg",{scope:i.default.Scope.INLINE}),c=new o.ColorAttributor("background","background-color",{scope:i.default.Scope.INLINE});r.BackgroundClass=u,r.BackgroundStyle=c},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.DirectionStyle=r.DirectionClass=r.DirectionAttribute=void 0;var a=s(0),i=o(a);function o(h){return h&&h.__esModule?h:{default:h}}var l={scope:i.default.Scope.BLOCK,whitelist:["rtl"]},u=new i.default.Attributor.Attribute("direction","dir",l),c=new i.default.Attributor.Class("direction","ql-direction",l),d=new i.default.Attributor.Style("direction","direction",l);r.DirectionAttribute=u,r.DirectionClass=c,r.DirectionStyle=d},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.FontClass=r.FontStyle=void 0;var a=function(){function y(b,x){for(var v=0;v<x.length;v++){var w=x[v];w.enumerable=w.enumerable||!1,w.configurable=!0,"value"in w&&(w.writable=!0),Object.defineProperty(b,w.key,w)}}return function(b,x,v){return x&&y(b.prototype,x),v&&y(b,v),b}}(),i=function y(b,x,v){b===null&&(b=Function.prototype);var w=Object.getOwnPropertyDescriptor(b,x);if(w===void 0){var k=Object.getPrototypeOf(b);return k===null?void 0:y(k,x,v)}else{if("value"in w)return w.value;var S=w.get;return S===void 0?void 0:S.call(v)}},o=s(0),l=u(o);function u(y){return y&&y.__esModule?y:{default:y}}function c(y,b){if(!(y instanceof b))throw new TypeError("Cannot call a class as a function")}function d(y,b){if(!y)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return b&&(typeof b=="object"||typeof b=="function")?b:y}function h(y,b){if(typeof b!="function"&&b!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof b);y.prototype=Object.create(b&&b.prototype,{constructor:{value:y,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(y,b):y.__proto__=b)}var p={scope:l.default.Scope.INLINE,whitelist:["serif","monospace"]},f=new l.default.Attributor.Class("font","ql-font",p),m=function(y){h(b,y);function b(){return c(this,b),d(this,(b.__proto__||Object.getPrototypeOf(b)).apply(this,arguments))}return a(b,[{key:"value",value:function(v){return i(b.prototype.__proto__||Object.getPrototypeOf(b.prototype),"value",this).call(this,v).replace(/["']/g,"")}}]),b}(l.default.Attributor.Style),g=new m("font","font-family",p);r.FontStyle=g,r.FontClass=f},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.SizeStyle=r.SizeClass=void 0;var a=s(0),i=o(a);function o(c){return c&&c.__esModule?c:{default:c}}var l=new i.default.Attributor.Class("size","ql-size",{scope:i.default.Scope.INLINE,whitelist:["small","large","huge"]}),u=new i.default.Attributor.Style("size","font-size",{scope:i.default.Scope.INLINE,whitelist:["10px","18px","32px"]});r.SizeClass=l,r.SizeStyle=u},function(n,r,s){n.exports={align:{"":s(76),center:s(77),right:s(78),justify:s(79)},background:s(80),blockquote:s(81),bold:s(82),clean:s(83),code:s(58),"code-block":s(58),color:s(84),direction:{"":s(85),rtl:s(86)},float:{center:s(87),full:s(88),left:s(89),right:s(90)},formula:s(91),header:{1:s(92),2:s(93)},italic:s(94),image:s(95),indent:{"+1":s(96),"-1":s(97)},link:s(98),list:{ordered:s(99),bullet:s(100),check:s(101)},script:{sub:s(102),super:s(103)},strike:s(104),underline:s(105),video:s(106)}},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.getLastChangeIndex=r.default=void 0;var a=function(){function x(v,w){for(var k=0;k<w.length;k++){var S=w[k];S.enumerable=S.enumerable||!1,S.configurable=!0,"value"in S&&(S.writable=!0),Object.defineProperty(v,S.key,S)}}return function(v,w,k){return w&&x(v.prototype,w),k&&x(v,k),v}}(),i=s(0),o=h(i),l=s(5),u=h(l),c=s(9),d=h(c);function h(x){return x&&x.__esModule?x:{default:x}}function p(x,v){if(!(x instanceof v))throw new TypeError("Cannot call a class as a function")}function f(x,v){if(!x)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return v&&(typeof v=="object"||typeof v=="function")?v:x}function m(x,v){if(typeof v!="function"&&v!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof v);x.prototype=Object.create(v&&v.prototype,{constructor:{value:x,enumerable:!1,writable:!0,configurable:!0}}),v&&(Object.setPrototypeOf?Object.setPrototypeOf(x,v):x.__proto__=v)}var g=function(x){m(v,x);function v(w,k){p(this,v);var S=f(this,(v.__proto__||Object.getPrototypeOf(v)).call(this,w,k));return S.lastRecorded=0,S.ignoreChange=!1,S.clear(),S.quill.on(u.default.events.EDITOR_CHANGE,function(I,$,C,T){I!==u.default.events.TEXT_CHANGE||S.ignoreChange||(!S.options.userOnly||T===u.default.sources.USER?S.record($,C):S.transform($))}),S.quill.keyboard.addBinding({key:"Z",shortKey:!0},S.undo.bind(S)),S.quill.keyboard.addBinding({key:"Z",shortKey:!0,shiftKey:!0},S.redo.bind(S)),/Win/i.test(navigator.platform)&&S.quill.keyboard.addBinding({key:"Y",shortKey:!0},S.redo.bind(S)),S}return a(v,[{key:"change",value:function(k,S){if(this.stack[k].length!==0){var I=this.stack[k].pop();this.stack[S].push(I),this.lastRecorded=0,this.ignoreChange=!0,this.quill.updateContents(I[k],u.default.sources.USER),this.ignoreChange=!1;var $=b(I[k]);this.quill.setSelection($)}}},{key:"clear",value:function(){this.stack={undo:[],redo:[]}}},{key:"cutoff",value:function(){this.lastRecorded=0}},{key:"record",value:function(k,S){if(k.ops.length!==0){this.stack.redo=[];var I=this.quill.getContents().diff(S),$=Date.now();if(this.lastRecorded+this.options.delay>$&&this.stack.undo.length>0){var C=this.stack.undo.pop();I=I.compose(C.undo),k=C.redo.compose(k)}else this.lastRecorded=$;this.stack.undo.push({redo:k,undo:I}),this.stack.undo.length>this.options.maxStack&&this.stack.undo.shift()}}},{key:"redo",value:function(){this.change("redo","undo")}},{key:"transform",value:function(k){this.stack.undo.forEach(function(S){S.undo=k.transform(S.undo,!0),S.redo=k.transform(S.redo,!0)}),this.stack.redo.forEach(function(S){S.undo=k.transform(S.undo,!0),S.redo=k.transform(S.redo,!0)})}},{key:"undo",value:function(){this.change("undo","redo")}}]),v}(d.default);g.DEFAULTS={delay:1e3,maxStack:100,userOnly:!1};function y(x){var v=x.ops[x.ops.length-1];return v==null?!1:v.insert!=null?typeof v.insert=="string"&&v.insert.endsWith(`
`):v.attributes!=null?Object.keys(v.attributes).some(function(w){return o.default.query(w,o.default.Scope.BLOCK)!=null}):!1}function b(x){var v=x.reduce(function(k,S){return k+=S.delete||0,k},0),w=x.length()-v;return y(x)&&(w-=1),w}r.default=g,r.getLastChangeIndex=b},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.BaseTooltip=void 0;var a=function(){function B(V,K){for(var G=0;G<K.length;G++){var U=K[G];U.enumerable=U.enumerable||!1,U.configurable=!0,"value"in U&&(U.writable=!0),Object.defineProperty(V,U.key,U)}}return function(V,K,G){return K&&B(V.prototype,K),G&&B(V,G),V}}(),i=function B(V,K,G){V===null&&(V=Function.prototype);var U=Object.getOwnPropertyDescriptor(V,K);if(U===void 0){var q=Object.getPrototypeOf(V);return q===null?void 0:B(q,K,G)}else{if("value"in U)return U.value;var Q=U.get;return Q===void 0?void 0:Q.call(G)}},o=s(3),l=$(o),u=s(2),c=$(u),d=s(8),h=$(d),p=s(23),f=$(p),m=s(34),g=$(m),y=s(59),b=$(y),x=s(60),v=$(x),w=s(28),k=$(w),S=s(61),I=$(S);function $(B){return B&&B.__esModule?B:{default:B}}function C(B,V){if(!(B instanceof V))throw new TypeError("Cannot call a class as a function")}function T(B,V){if(!B)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return V&&(typeof V=="object"||typeof V=="function")?V:B}function N(B,V){if(typeof V!="function"&&V!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof V);B.prototype=Object.create(V&&V.prototype,{constructor:{value:B,enumerable:!1,writable:!0,configurable:!0}}),V&&(Object.setPrototypeOf?Object.setPrototypeOf(B,V):B.__proto__=V)}var E=[!1,"center","right","justify"],_=["#000000","#e60000","#ff9900","#ffff00","#008a00","#0066cc","#9933ff","#ffffff","#facccc","#ffebcc","#ffffcc","#cce8cc","#cce0f5","#ebd6ff","#bbbbbb","#f06666","#ffc266","#ffff66","#66b966","#66a3e0","#c285ff","#888888","#a10000","#b26b00","#b2b200","#006100","#0047b2","#6b24b2","#444444","#5c0000","#663d00","#666600","#003700","#002966","#3d1466"],R=[!1,"serif","monospace"],z=["1","2","3",!1],W=["small",!1,"large","huge"],F=function(B){N(V,B);function V(K,G){C(this,V);var U=T(this,(V.__proto__||Object.getPrototypeOf(V)).call(this,K,G)),q=function Q(ee){if(!document.body.contains(K.root))return document.body.removeEventListener("click",Q);U.tooltip!=null&&!U.tooltip.root.contains(ee.target)&&document.activeElement!==U.tooltip.textbox&&!U.quill.hasFocus()&&U.tooltip.hide(),U.pickers!=null&&U.pickers.forEach(function(ae){ae.container.contains(ee.target)||ae.close()})};return K.emitter.listenDOM("click",document.body,q),U}return a(V,[{key:"addModule",value:function(G){var U=i(V.prototype.__proto__||Object.getPrototypeOf(V.prototype),"addModule",this).call(this,G);return G==="toolbar"&&this.extendToolbar(U),U}},{key:"buildButtons",value:function(G,U){G.forEach(function(q){var Q=q.getAttribute("class")||"";Q.split(/\s+/).forEach(function(ee){if(ee.startsWith("ql-")&&(ee=ee.slice(3),U[ee]!=null))if(ee==="direction")q.innerHTML=U[ee][""]+U[ee].rtl;else if(typeof U[ee]=="string")q.innerHTML=U[ee];else{var ae=q.value||"";ae!=null&&U[ee][ae]&&(q.innerHTML=U[ee][ae])}})})}},{key:"buildPickers",value:function(G,U){var q=this;this.pickers=G.map(function(ee){if(ee.classList.contains("ql-align"))return ee.querySelector("option")==null&&D(ee,E),new v.default(ee,U.align);if(ee.classList.contains("ql-background")||ee.classList.contains("ql-color")){var ae=ee.classList.contains("ql-background")?"background":"color";return ee.querySelector("option")==null&&D(ee,_,ae==="background"?"#ffffff":"#000000"),new b.default(ee,U[ae])}else return ee.querySelector("option")==null&&(ee.classList.contains("ql-font")?D(ee,R):ee.classList.contains("ql-header")?D(ee,z):ee.classList.contains("ql-size")&&D(ee,W)),new k.default(ee)});var Q=function(){q.pickers.forEach(function(ae){ae.update()})};this.quill.on(h.default.events.EDITOR_CHANGE,Q)}}]),V}(g.default);F.DEFAULTS=(0,l.default)(!0,{},g.default.DEFAULTS,{modules:{toolbar:{handlers:{formula:function(){this.quill.theme.tooltip.edit("formula")},image:function(){var V=this,K=this.container.querySelector("input.ql-image[type=file]");K==null&&(K=document.createElement("input"),K.setAttribute("type","file"),K.setAttribute("accept","image/png, image/gif, image/jpeg, image/bmp, image/x-icon"),K.classList.add("ql-image"),K.addEventListener("change",function(){if(K.files!=null&&K.files[0]!=null){var G=new FileReader;G.onload=function(U){var q=V.quill.getSelection(!0);V.quill.updateContents(new c.default().retain(q.index).delete(q.length).insert({image:U.target.result}),h.default.sources.USER),V.quill.setSelection(q.index+1,h.default.sources.SILENT),K.value=""},G.readAsDataURL(K.files[0])}}),this.container.appendChild(K)),K.click()},video:function(){this.quill.theme.tooltip.edit("video")}}}}});var L=function(B){N(V,B);function V(K,G){C(this,V);var U=T(this,(V.__proto__||Object.getPrototypeOf(V)).call(this,K,G));return U.textbox=U.root.querySelector('input[type="text"]'),U.listen(),U}return a(V,[{key:"listen",value:function(){var G=this;this.textbox.addEventListener("keydown",function(U){f.default.match(U,"enter")?(G.save(),U.preventDefault()):f.default.match(U,"escape")&&(G.cancel(),U.preventDefault())})}},{key:"cancel",value:function(){this.hide()}},{key:"edit",value:function(){var G=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"link",U=arguments.length>1&&arguments[1]!==void 0?arguments[1]:null;this.root.classList.remove("ql-hidden"),this.root.classList.add("ql-editing"),U!=null?this.textbox.value=U:G!==this.root.getAttribute("data-mode")&&(this.textbox.value=""),this.position(this.quill.getBounds(this.quill.selection.savedRange)),this.textbox.select(),this.textbox.setAttribute("placeholder",this.textbox.getAttribute("data-"+G)||""),this.root.setAttribute("data-mode",G)}},{key:"restoreFocus",value:function(){var G=this.quill.scrollingContainer.scrollTop;this.quill.focus(),this.quill.scrollingContainer.scrollTop=G}},{key:"save",value:function(){var G=this.textbox.value;switch(this.root.getAttribute("data-mode")){case"link":{var U=this.quill.root.scrollTop;this.linkRange?(this.quill.formatText(this.linkRange,"link",G,h.default.sources.USER),delete this.linkRange):(this.restoreFocus(),this.quill.format("link",G,h.default.sources.USER)),this.quill.root.scrollTop=U;break}case"video":G=O(G);case"formula":{if(!G)break;var q=this.quill.getSelection(!0);if(q!=null){var Q=q.index+q.length;this.quill.insertEmbed(Q,this.root.getAttribute("data-mode"),G,h.default.sources.USER),this.root.getAttribute("data-mode")==="formula"&&this.quill.insertText(Q+1," ",h.default.sources.USER),this.quill.setSelection(Q+2,h.default.sources.USER)}break}}this.textbox.value="",this.hide()}}]),V}(I.default);function O(B){var V=B.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/)||B.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);return V?(V[1]||"https")+"://www.youtube.com/embed/"+V[2]+"?showinfo=0":(V=B.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/))?(V[1]||"https")+"://player.vimeo.com/video/"+V[2]+"/":B}function D(B,V){var K=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;V.forEach(function(G){var U=document.createElement("option");G===K?U.setAttribute("selected","selected"):U.setAttribute("value",G),B.appendChild(U)})}r.BaseTooltip=L,r.default=F},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function i(){this.head=this.tail=null,this.length=0}return i.prototype.append=function(){for(var o=[],l=0;l<arguments.length;l++)o[l]=arguments[l];this.insertBefore(o[0],null),o.length>1&&this.append.apply(this,o.slice(1))},i.prototype.contains=function(o){for(var l,u=this.iterator();l=u();)if(l===o)return!0;return!1},i.prototype.insertBefore=function(o,l){o&&(o.next=l,l!=null?(o.prev=l.prev,l.prev!=null&&(l.prev.next=o),l.prev=o,l===this.head&&(this.head=o)):this.tail!=null?(this.tail.next=o,o.prev=this.tail,this.tail=o):(o.prev=null,this.head=this.tail=o),this.length+=1)},i.prototype.offset=function(o){for(var l=0,u=this.head;u!=null;){if(u===o)return l;l+=u.length(),u=u.next}return-1},i.prototype.remove=function(o){this.contains(o)&&(o.prev!=null&&(o.prev.next=o.next),o.next!=null&&(o.next.prev=o.prev),o===this.head&&(this.head=o.next),o===this.tail&&(this.tail=o.prev),this.length-=1)},i.prototype.iterator=function(o){return o===void 0&&(o=this.head),function(){var l=o;return o!=null&&(o=o.next),l}},i.prototype.find=function(o,l){l===void 0&&(l=!1);for(var u,c=this.iterator();u=c();){var d=u.length();if(o<d||l&&o===d&&(u.next==null||u.next.length()!==0))return[u,o];o-=d}return[null,0]},i.prototype.forEach=function(o){for(var l,u=this.iterator();l=u();)o(l)},i.prototype.forEachAt=function(o,l,u){if(!(l<=0))for(var c=this.find(o),d=c[0],h=c[1],p,f=o-h,m=this.iterator(d);(p=m())&&f<o+l;){var g=p.length();o>f?u(p,o-f,Math.min(l,f+g-o)):u(p,0,Math.min(g,o+l-f)),f+=g}},i.prototype.map=function(o){return this.reduce(function(l,u){return l.push(o(u)),l},[])},i.prototype.reduce=function(o,l){for(var u,c=this.iterator();u=c();)l=o(l,u);return l},i}();r.default=a},function(n,r,s){var a=this&&this.__extends||function(){var d=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(h,p){h.__proto__=p}||function(h,p){for(var f in p)p.hasOwnProperty(f)&&(h[f]=p[f])};return function(h,p){d(h,p);function f(){this.constructor=h}h.prototype=p===null?Object.create(p):(f.prototype=p.prototype,new f)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(17),o=s(1),l={attributes:!0,characterData:!0,characterDataOldValue:!0,childList:!0,subtree:!0},u=100,c=function(d){a(h,d);function h(p){var f=d.call(this,p)||this;return f.scroll=f,f.observer=new MutationObserver(function(m){f.update(m)}),f.observer.observe(f.domNode,l),f.attach(),f}return h.prototype.detach=function(){d.prototype.detach.call(this),this.observer.disconnect()},h.prototype.deleteAt=function(p,f){this.update(),p===0&&f===this.length()?this.children.forEach(function(m){m.remove()}):d.prototype.deleteAt.call(this,p,f)},h.prototype.formatAt=function(p,f,m,g){this.update(),d.prototype.formatAt.call(this,p,f,m,g)},h.prototype.insertAt=function(p,f,m){this.update(),d.prototype.insertAt.call(this,p,f,m)},h.prototype.optimize=function(p,f){var m=this;p===void 0&&(p=[]),f===void 0&&(f={}),d.prototype.optimize.call(this,f);for(var g=[].slice.call(this.observer.takeRecords());g.length>0;)p.push(g.pop());for(var y=function(w,k){k===void 0&&(k=!0),!(w==null||w===m)&&w.domNode.parentNode!=null&&(w.domNode[o.DATA_KEY].mutations==null&&(w.domNode[o.DATA_KEY].mutations=[]),k&&y(w.parent))},b=function(w){w.domNode[o.DATA_KEY]==null||w.domNode[o.DATA_KEY].mutations==null||(w instanceof i.default&&w.children.forEach(b),w.optimize(f))},x=p,v=0;x.length>0;v+=1){if(v>=u)throw new Error("[Parchment] Maximum optimize iterations reached");for(x.forEach(function(w){var k=o.find(w.target,!0);k!=null&&(k.domNode===w.target&&(w.type==="childList"?(y(o.find(w.previousSibling,!1)),[].forEach.call(w.addedNodes,function(S){var I=o.find(S,!1);y(I,!1),I instanceof i.default&&I.children.forEach(function($){y($,!1)})})):w.type==="attributes"&&y(k.prev)),y(k))}),this.children.forEach(b),x=[].slice.call(this.observer.takeRecords()),g=x.slice();g.length>0;)p.push(g.pop())}},h.prototype.update=function(p,f){var m=this;f===void 0&&(f={}),p=p||this.observer.takeRecords(),p.map(function(g){var y=o.find(g.target,!0);return y==null?null:y.domNode[o.DATA_KEY].mutations==null?(y.domNode[o.DATA_KEY].mutations=[g],y):(y.domNode[o.DATA_KEY].mutations.push(g),null)}).forEach(function(g){g==null||g===m||g.domNode[o.DATA_KEY]==null||g.update(g.domNode[o.DATA_KEY].mutations||[],f)}),this.domNode[o.DATA_KEY].mutations!=null&&d.prototype.update.call(this,this.domNode[o.DATA_KEY].mutations,f),this.optimize(p,f)},h.blotName="scroll",h.defaultChild="block",h.scope=o.Scope.BLOCK_BLOT,h.tagName="DIV",h}(i.default);r.default=c},function(n,r,s){var a=this&&this.__extends||function(){var c=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,h){d.__proto__=h}||function(d,h){for(var p in h)h.hasOwnProperty(p)&&(d[p]=h[p])};return function(d,h){c(d,h);function p(){this.constructor=d}d.prototype=h===null?Object.create(h):(p.prototype=h.prototype,new p)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(18),o=s(1);function l(c,d){if(Object.keys(c).length!==Object.keys(d).length)return!1;for(var h in c)if(c[h]!==d[h])return!1;return!0}var u=function(c){a(d,c);function d(){return c!==null&&c.apply(this,arguments)||this}return d.formats=function(h){if(h.tagName!==d.tagName)return c.formats.call(this,h)},d.prototype.format=function(h,p){var f=this;h===this.statics.blotName&&!p?(this.children.forEach(function(m){m instanceof i.default||(m=m.wrap(d.blotName,!0)),f.attributes.copy(m)}),this.unwrap()):c.prototype.format.call(this,h,p)},d.prototype.formatAt=function(h,p,f,m){if(this.formats()[f]!=null||o.query(f,o.Scope.ATTRIBUTE)){var g=this.isolate(h,p);g.format(f,m)}else c.prototype.formatAt.call(this,h,p,f,m)},d.prototype.optimize=function(h){c.prototype.optimize.call(this,h);var p=this.formats();if(Object.keys(p).length===0)return this.unwrap();var f=this.next;f instanceof d&&f.prev===this&&l(p,f.formats())&&(f.moveChildren(this),f.remove())},d.blotName="inline",d.scope=o.Scope.INLINE_BLOT,d.tagName="SPAN",d}(i.default);r.default=u},function(n,r,s){var a=this&&this.__extends||function(){var u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(c,d){c.__proto__=d}||function(c,d){for(var h in d)d.hasOwnProperty(h)&&(c[h]=d[h])};return function(c,d){u(c,d);function h(){this.constructor=c}c.prototype=d===null?Object.create(d):(h.prototype=d.prototype,new h)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(18),o=s(1),l=function(u){a(c,u);function c(){return u!==null&&u.apply(this,arguments)||this}return c.formats=function(d){var h=o.query(c.blotName).tagName;if(d.tagName!==h)return u.formats.call(this,d)},c.prototype.format=function(d,h){o.query(d,o.Scope.BLOCK)!=null&&(d===this.statics.blotName&&!h?this.replaceWith(c.blotName):u.prototype.format.call(this,d,h))},c.prototype.formatAt=function(d,h,p,f){o.query(p,o.Scope.BLOCK)!=null?this.format(p,f):u.prototype.formatAt.call(this,d,h,p,f)},c.prototype.insertAt=function(d,h,p){if(p==null||o.query(h,o.Scope.INLINE)!=null)u.prototype.insertAt.call(this,d,h,p);else{var f=this.split(d),m=o.create(h,p);f.parent.insertBefore(m,f)}},c.prototype.update=function(d,h){navigator.userAgent.match(/Trident/)?this.build():u.prototype.update.call(this,d,h)},c.blotName="block",c.scope=o.Scope.BLOCK_BLOT,c.tagName="P",c}(i.default);r.default=l},function(n,r,s){var a=this&&this.__extends||function(){var l=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(u,c){u.__proto__=c}||function(u,c){for(var d in c)c.hasOwnProperty(d)&&(u[d]=c[d])};return function(u,c){l(u,c);function d(){this.constructor=u}u.prototype=c===null?Object.create(c):(d.prototype=c.prototype,new d)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(19),o=function(l){a(u,l);function u(){return l!==null&&l.apply(this,arguments)||this}return u.formats=function(c){},u.prototype.format=function(c,d){l.prototype.formatAt.call(this,0,this.length(),c,d)},u.prototype.formatAt=function(c,d,h,p){c===0&&d===this.length()?this.format(h,p):l.prototype.formatAt.call(this,c,d,h,p)},u.prototype.formats=function(){return this.statics.formats(this.domNode)},u}(i.default);r.default=o},function(n,r,s){var a=this&&this.__extends||function(){var u=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(c,d){c.__proto__=d}||function(c,d){for(var h in d)d.hasOwnProperty(h)&&(c[h]=d[h])};return function(c,d){u(c,d);function h(){this.constructor=c}c.prototype=d===null?Object.create(d):(h.prototype=d.prototype,new h)}}();Object.defineProperty(r,"__esModule",{value:!0});var i=s(19),o=s(1),l=function(u){a(c,u);function c(d){var h=u.call(this,d)||this;return h.text=h.statics.value(h.domNode),h}return c.create=function(d){return document.createTextNode(d)},c.value=function(d){var h=d.data;return h.normalize&&(h=h.normalize()),h},c.prototype.deleteAt=function(d,h){this.domNode.data=this.text=this.text.slice(0,d)+this.text.slice(d+h)},c.prototype.index=function(d,h){return this.domNode===d?h:-1},c.prototype.insertAt=function(d,h,p){p==null?(this.text=this.text.slice(0,d)+h+this.text.slice(d),this.domNode.data=this.text):u.prototype.insertAt.call(this,d,h,p)},c.prototype.length=function(){return this.text.length},c.prototype.optimize=function(d){u.prototype.optimize.call(this,d),this.text=this.statics.value(this.domNode),this.text.length===0?this.remove():this.next instanceof c&&this.next.prev===this&&(this.insertAt(this.length(),this.next.value()),this.next.remove())},c.prototype.position=function(d,h){return[this.domNode,d]},c.prototype.split=function(d,h){if(h===void 0&&(h=!1),!h){if(d===0)return this;if(d===this.length())return this.next}var p=o.create(this.domNode.splitText(d));return this.parent.insertBefore(p,this.next),this.text=this.statics.value(this.domNode),p},c.prototype.update=function(d,h){var p=this;d.some(function(f){return f.type==="characterData"&&f.target===p.domNode})&&(this.text=this.statics.value(this.domNode))},c.prototype.value=function(){return this.text},c.blotName="text",c.scope=o.Scope.INLINE_BLOT,c}(i.default);r.default=l},function(n,r,s){var a=document.createElement("div");if(a.classList.toggle("test-class",!1),a.classList.contains("test-class")){var i=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(o,l){return arguments.length>1&&!this.contains(o)==!l?l:i.call(this,o)}}String.prototype.startsWith||(String.prototype.startsWith=function(o,l){return l=l||0,this.substr(l,o.length)===o}),String.prototype.endsWith||(String.prototype.endsWith=function(o,l){var u=this.toString();(typeof l!="number"||!isFinite(l)||Math.floor(l)!==l||l>u.length)&&(l=u.length),l-=o.length;var c=u.indexOf(o,l);return c!==-1&&c===l}),Array.prototype.find||Object.defineProperty(Array.prototype,"find",{value:function(l){if(this===null)throw new TypeError("Array.prototype.find called on null or undefined");if(typeof l!="function")throw new TypeError("predicate must be a function");for(var u=Object(this),c=u.length>>>0,d=arguments[1],h,p=0;p<c;p++)if(h=u[p],l.call(d,h,p,u))return h}}),document.addEventListener("DOMContentLoaded",function(){document.execCommand("enableObjectResizing",!1,!1),document.execCommand("autoUrlDetect",!1,!1)})},function(n,r){var s=-1,a=1,i=0;function o(v,w,k){if(v==w)return v?[[i,v]]:[];(k<0||v.length<k)&&(k=null);var S=d(v,w),I=v.substring(0,S);v=v.substring(S),w=w.substring(S),S=h(v,w);var $=v.substring(v.length-S);v=v.substring(0,v.length-S),w=w.substring(0,w.length-S);var C=l(v,w);return I&&C.unshift([i,I]),$&&C.push([i,$]),f(C),k!=null&&(C=y(C,k)),C=b(C),C}function l(v,w){var k;if(!v)return[[a,w]];if(!w)return[[s,v]];var S=v.length>w.length?v:w,I=v.length>w.length?w:v,$=S.indexOf(I);if($!=-1)return k=[[a,S.substring(0,$)],[i,I],[a,S.substring($+I.length)]],v.length>w.length&&(k[0][0]=k[2][0]=s),k;if(I.length==1)return[[s,v],[a,w]];var C=p(v,w);if(C){var T=C[0],N=C[1],E=C[2],_=C[3],R=C[4],z=o(T,E),W=o(N,_);return z.concat([[i,R]],W)}return u(v,w)}function u(v,w){for(var k=v.length,S=w.length,I=Math.ceil((k+S)/2),$=I,C=2*I,T=new Array(C),N=new Array(C),E=0;E<C;E++)T[E]=-1,N[E]=-1;T[$+1]=0,N[$+1]=0;for(var _=k-S,R=_%2!=0,z=0,W=0,F=0,L=0,O=0;O<I;O++){for(var D=-O+z;D<=O-W;D+=2){var B=$+D,V;D==-O||D!=O&&T[B-1]<T[B+1]?V=T[B+1]:V=T[B-1]+1;for(var K=V-D;V<k&&K<S&&v.charAt(V)==w.charAt(K);)V++,K++;if(T[B]=V,V>k)W+=2;else if(K>S)z+=2;else if(R){var G=$+_-D;if(G>=0&&G<C&&N[G]!=-1){var U=k-N[G];if(V>=U)return c(v,w,V,K)}}}for(var q=-O+F;q<=O-L;q+=2){var G=$+q,U;q==-O||q!=O&&N[G-1]<N[G+1]?U=N[G+1]:U=N[G-1]+1;for(var Q=U-q;U<k&&Q<S&&v.charAt(k-U-1)==w.charAt(S-Q-1);)U++,Q++;if(N[G]=U,U>k)L+=2;else if(Q>S)F+=2;else if(!R){var B=$+_-q;if(B>=0&&B<C&&T[B]!=-1){var V=T[B],K=$+V-B;if(U=k-U,V>=U)return c(v,w,V,K)}}}}return[[s,v],[a,w]]}function c(v,w,k,S){var I=v.substring(0,k),$=w.substring(0,S),C=v.substring(k),T=w.substring(S),N=o(I,$),E=o(C,T);return N.concat(E)}function d(v,w){if(!v||!w||v.charAt(0)!=w.charAt(0))return 0;for(var k=0,S=Math.min(v.length,w.length),I=S,$=0;k<I;)v.substring($,I)==w.substring($,I)?(k=I,$=k):S=I,I=Math.floor((S-k)/2+k);return I}function h(v,w){if(!v||!w||v.charAt(v.length-1)!=w.charAt(w.length-1))return 0;for(var k=0,S=Math.min(v.length,w.length),I=S,$=0;k<I;)v.substring(v.length-I,v.length-$)==w.substring(w.length-I,w.length-$)?(k=I,$=k):S=I,I=Math.floor((S-k)/2+k);return I}function p(v,w){var k=v.length>w.length?v:w,S=v.length>w.length?w:v;if(k.length<4||S.length*2<k.length)return null;function I(W,F,L){for(var O=W.substring(L,L+Math.floor(W.length/4)),D=-1,B="",V,K,G,U;(D=F.indexOf(O,D+1))!=-1;){var q=d(W.substring(L),F.substring(D)),Q=h(W.substring(0,L),F.substring(0,D));B.length<Q+q&&(B=F.substring(D-Q,D)+F.substring(D,D+q),V=W.substring(0,L-Q),K=W.substring(L+q),G=F.substring(0,D-Q),U=F.substring(D+q))}return B.length*2>=W.length?[V,K,G,U,B]:null}var $=I(k,S,Math.ceil(k.length/4)),C=I(k,S,Math.ceil(k.length/2)),T;if(!$&&!C)return null;C?$?T=$[4].length>C[4].length?$:C:T=C:T=$;var N,E,_,R;v.length>w.length?(N=T[0],E=T[1],_=T[2],R=T[3]):(_=T[0],R=T[1],N=T[2],E=T[3]);var z=T[4];return[N,E,_,R,z]}function f(v){v.push([i,""]);for(var w=0,k=0,S=0,I="",$="",C;w<v.length;)switch(v[w][0]){case a:S++,$+=v[w][1],w++;break;case s:k++,I+=v[w][1],w++;break;case i:k+S>1?(k!==0&&S!==0&&(C=d($,I),C!==0&&(w-k-S>0&&v[w-k-S-1][0]==i?v[w-k-S-1][1]+=$.substring(0,C):(v.splice(0,0,[i,$.substring(0,C)]),w++),$=$.substring(C),I=I.substring(C)),C=h($,I),C!==0&&(v[w][1]=$.substring($.length-C)+v[w][1],$=$.substring(0,$.length-C),I=I.substring(0,I.length-C))),k===0?v.splice(w-S,k+S,[a,$]):S===0?v.splice(w-k,k+S,[s,I]):v.splice(w-k-S,k+S,[s,I],[a,$]),w=w-k-S+(k?1:0)+(S?1:0)+1):w!==0&&v[w-1][0]==i?(v[w-1][1]+=v[w][1],v.splice(w,1)):w++,S=0,k=0,I="",$="";break}v[v.length-1][1]===""&&v.pop();var T=!1;for(w=1;w<v.length-1;)v[w-1][0]==i&&v[w+1][0]==i&&(v[w][1].substring(v[w][1].length-v[w-1][1].length)==v[w-1][1]?(v[w][1]=v[w-1][1]+v[w][1].substring(0,v[w][1].length-v[w-1][1].length),v[w+1][1]=v[w-1][1]+v[w+1][1],v.splice(w-1,1),T=!0):v[w][1].substring(0,v[w+1][1].length)==v[w+1][1]&&(v[w-1][1]+=v[w+1][1],v[w][1]=v[w][1].substring(v[w+1][1].length)+v[w+1][1],v.splice(w+1,1),T=!0)),w++;T&&f(v)}var m=o;m.INSERT=a,m.DELETE=s,m.EQUAL=i,n.exports=m;function g(v,w){if(w===0)return[i,v];for(var k=0,S=0;S<v.length;S++){var I=v[S];if(I[0]===s||I[0]===i){var $=k+I[1].length;if(w===$)return[S+1,v];if(w<$){v=v.slice();var C=w-k,T=[I[0],I[1].slice(0,C)],N=[I[0],I[1].slice(C)];return v.splice(S,1,T,N),[S+1,v]}else k=$}}throw new Error("cursor_pos is out of bounds!")}function y(v,w){var k=g(v,w),S=k[1],I=k[0],$=S[I],C=S[I+1];if($==null)return v;if($[0]!==i)return v;if(C!=null&&$[1]+C[1]===C[1]+$[1])return S.splice(I,2,C,$),x(S,I,2);if(C!=null&&C[1].indexOf($[1])===0){S.splice(I,2,[C[0],$[1]],[0,$[1]]);var T=C[1].slice($[1].length);return T.length>0&&S.splice(I+2,0,[C[0],T]),x(S,I,3)}else return v}function b(v){for(var w=!1,k=function(C){return C.charCodeAt(0)>=56320&&C.charCodeAt(0)<=57343},S=function(C){return C.charCodeAt(C.length-1)>=55296&&C.charCodeAt(C.length-1)<=56319},I=2;I<v.length;I+=1)v[I-2][0]===i&&S(v[I-2][1])&&v[I-1][0]===s&&k(v[I-1][1])&&v[I][0]===a&&k(v[I][1])&&(w=!0,v[I-1][1]=v[I-2][1].slice(-1)+v[I-1][1],v[I][1]=v[I-2][1].slice(-1)+v[I][1],v[I-2][1]=v[I-2][1].slice(0,-1));if(!w)return v;for(var $=[],I=0;I<v.length;I+=1)v[I][1].length>0&&$.push(v[I]);return $}function x(v,w,k){for(var S=w+k-1;S>=0&&S>=w-1;S--)if(S+1<v.length){var I=v[S],$=v[S+1];I[0]===$[1]&&v.splice(S,2,[I[0],I[1]+$[1]])}return v}},function(n,r){r=n.exports=typeof Object.keys=="function"?Object.keys:s,r.shim=s;function s(a){var i=[];for(var o in a)i.push(o);return i}},function(n,r){var s=function(){return Object.prototype.toString.call(arguments)}()=="[object Arguments]";r=n.exports=s?a:i,r.supported=a;function a(o){return Object.prototype.toString.call(o)=="[object Arguments]"}r.unsupported=i;function i(o){return o&&typeof o=="object"&&typeof o.length=="number"&&Object.prototype.hasOwnProperty.call(o,"callee")&&!Object.prototype.propertyIsEnumerable.call(o,"callee")||!1}},function(n,r){var s=Object.prototype.hasOwnProperty,a="~";function i(){}Object.create&&(i.prototype=Object.create(null),new i().__proto__||(a=!1));function o(u,c,d){this.fn=u,this.context=c,this.once=d||!1}function l(){this._events=new i,this._eventsCount=0}l.prototype.eventNames=function(){var c=[],d,h;if(this._eventsCount===0)return c;for(h in d=this._events)s.call(d,h)&&c.push(a?h.slice(1):h);return Object.getOwnPropertySymbols?c.concat(Object.getOwnPropertySymbols(d)):c},l.prototype.listeners=function(c,d){var h=a?a+c:c,p=this._events[h];if(d)return!!p;if(!p)return[];if(p.fn)return[p.fn];for(var f=0,m=p.length,g=new Array(m);f<m;f++)g[f]=p[f].fn;return g},l.prototype.emit=function(c,d,h,p,f,m){var g=a?a+c:c;if(!this._events[g])return!1;var y=this._events[g],b=arguments.length,x,v;if(y.fn){switch(y.once&&this.removeListener(c,y.fn,void 0,!0),b){case 1:return y.fn.call(y.context),!0;case 2:return y.fn.call(y.context,d),!0;case 3:return y.fn.call(y.context,d,h),!0;case 4:return y.fn.call(y.context,d,h,p),!0;case 5:return y.fn.call(y.context,d,h,p,f),!0;case 6:return y.fn.call(y.context,d,h,p,f,m),!0}for(v=1,x=new Array(b-1);v<b;v++)x[v-1]=arguments[v];y.fn.apply(y.context,x)}else{var w=y.length,k;for(v=0;v<w;v++)switch(y[v].once&&this.removeListener(c,y[v].fn,void 0,!0),b){case 1:y[v].fn.call(y[v].context);break;case 2:y[v].fn.call(y[v].context,d);break;case 3:y[v].fn.call(y[v].context,d,h);break;case 4:y[v].fn.call(y[v].context,d,h,p);break;default:if(!x)for(k=1,x=new Array(b-1);k<b;k++)x[k-1]=arguments[k];y[v].fn.apply(y[v].context,x)}}return!0},l.prototype.on=function(c,d,h){var p=new o(d,h||this),f=a?a+c:c;return this._events[f]?this._events[f].fn?this._events[f]=[this._events[f],p]:this._events[f].push(p):(this._events[f]=p,this._eventsCount++),this},l.prototype.once=function(c,d,h){var p=new o(d,h||this,!0),f=a?a+c:c;return this._events[f]?this._events[f].fn?this._events[f]=[this._events[f],p]:this._events[f].push(p):(this._events[f]=p,this._eventsCount++),this},l.prototype.removeListener=function(c,d,h,p){var f=a?a+c:c;if(!this._events[f])return this;if(!d)return--this._eventsCount===0?this._events=new i:delete this._events[f],this;var m=this._events[f];if(m.fn)m.fn===d&&(!p||m.once)&&(!h||m.context===h)&&(--this._eventsCount===0?this._events=new i:delete this._events[f]);else{for(var g=0,y=[],b=m.length;g<b;g++)(m[g].fn!==d||p&&!m[g].once||h&&m[g].context!==h)&&y.push(m[g]);y.length?this._events[f]=y.length===1?y[0]:y:--this._eventsCount===0?this._events=new i:delete this._events[f]}return this},l.prototype.removeAllListeners=function(c){var d;return c?(d=a?a+c:c,this._events[d]&&(--this._eventsCount===0?this._events=new i:delete this._events[d])):(this._events=new i,this._eventsCount=0),this},l.prototype.off=l.prototype.removeListener,l.prototype.addListener=l.prototype.on,l.prototype.setMaxListeners=function(){return this},l.prefixed=a,l.EventEmitter=l,typeof n<"u"&&(n.exports=l)},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.matchText=r.matchSpacing=r.matchNewline=r.matchBlot=r.matchAttributor=r.default=void 0;var a=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?function(ie){return typeof ie}:function(ie){return ie&&typeof Symbol=="function"&&ie.constructor===Symbol&&ie!==Symbol.prototype?"symbol":typeof ie},i=function(){function ie(Te,Le){var $e=[],ge=!0,ve=!1,pe=void 0;try{for(var Ie=Te[Symbol.iterator](),ze;!(ge=(ze=Ie.next()).done)&&($e.push(ze.value),!(Le&&$e.length===Le));ge=!0);}catch(Ye){ve=!0,pe=Ye}finally{try{!ge&&Ie.return&&Ie.return()}finally{if(ve)throw pe}}return $e}return function(Te,Le){if(Array.isArray(Te))return Te;if(Symbol.iterator in Object(Te))return ie(Te,Le);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),o=function(){function ie(Te,Le){for(var $e=0;$e<Le.length;$e++){var ge=Le[$e];ge.enumerable=ge.enumerable||!1,ge.configurable=!0,"value"in ge&&(ge.writable=!0),Object.defineProperty(Te,ge.key,ge)}}return function(Te,Le,$e){return Le&&ie(Te.prototype,Le),$e&&ie(Te,$e),Te}}(),l=s(3),u=N(l),c=s(2),d=N(c),h=s(0),p=N(h),f=s(5),m=N(f),g=s(10),y=N(g),b=s(9),x=N(b),v=s(36),w=s(37),k=s(13),S=N(k),I=s(26),$=s(38),C=s(39),T=s(40);function N(ie){return ie&&ie.__esModule?ie:{default:ie}}function E(ie,Te,Le){return Te in ie?Object.defineProperty(ie,Te,{value:Le,enumerable:!0,configurable:!0,writable:!0}):ie[Te]=Le,ie}function _(ie,Te){if(!(ie instanceof Te))throw new TypeError("Cannot call a class as a function")}function R(ie,Te){if(!ie)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return Te&&(typeof Te=="object"||typeof Te=="function")?Te:ie}function z(ie,Te){if(typeof Te!="function"&&Te!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof Te);ie.prototype=Object.create(Te&&Te.prototype,{constructor:{value:ie,enumerable:!1,writable:!0,configurable:!0}}),Te&&(Object.setPrototypeOf?Object.setPrototypeOf(ie,Te):ie.__proto__=Te)}var W=(0,y.default)("quill:clipboard"),F="__ql-matcher",L=[[Node.TEXT_NODE,Pe],[Node.TEXT_NODE,be],["br",ye],[Node.ELEMENT_NODE,be],[Node.ELEMENT_NODE,ae],[Node.ELEMENT_NODE,ke],[Node.ELEMENT_NODE,ee],[Node.ELEMENT_NODE,Ae],["li",ce],["b",Q.bind(Q,"bold")],["i",Q.bind(Q,"italic")],["style",j]],O=[v.AlignAttribute,$.DirectionAttribute].reduce(function(ie,Te){return ie[Te.keyName]=Te,ie},{}),D=[v.AlignStyle,w.BackgroundStyle,I.ColorStyle,$.DirectionStyle,C.FontStyle,T.SizeStyle].reduce(function(ie,Te){return ie[Te.keyName]=Te,ie},{}),B=function(ie){z(Te,ie);function Te(Le,$e){_(this,Te);var ge=R(this,(Te.__proto__||Object.getPrototypeOf(Te)).call(this,Le,$e));return ge.quill.root.addEventListener("paste",ge.onPaste.bind(ge)),ge.container=ge.quill.addContainer("ql-clipboard"),ge.container.setAttribute("contenteditable",!0),ge.container.setAttribute("tabindex",-1),ge.matchers=[],L.concat(ge.options.matchers).forEach(function(ve){var pe=i(ve,2),Ie=pe[0],ze=pe[1];!$e.matchVisual&&ze===ke||ge.addMatcher(Ie,ze)}),ge}return o(Te,[{key:"addMatcher",value:function($e,ge){this.matchers.push([$e,ge])}},{key:"convert",value:function($e){if(typeof $e=="string")return this.container.innerHTML=$e.replace(/\>\r?\n +\</g,"><"),this.convert();var ge=this.quill.getFormat(this.quill.selection.savedRange.index);if(ge[S.default.blotName]){var ve=this.container.innerText;return this.container.innerHTML="",new d.default().insert(ve,E({},S.default.blotName,ge[S.default.blotName]))}var pe=this.prepareMatching(),Ie=i(pe,2),ze=Ie[0],Ye=Ie[1],Je=q(this.container,ze,Ye);return G(Je,`
`)&&Je.ops[Je.ops.length-1].attributes==null&&(Je=Je.compose(new d.default().retain(Je.length()-1).delete(1))),W.log("convert",this.container.innerHTML,Je),this.container.innerHTML="",Je}},{key:"dangerouslyPasteHTML",value:function($e,ge){var ve=arguments.length>2&&arguments[2]!==void 0?arguments[2]:m.default.sources.API;if(typeof $e=="string")this.quill.setContents(this.convert($e),ge),this.quill.setSelection(0,m.default.sources.SILENT);else{var pe=this.convert(ge);this.quill.updateContents(new d.default().retain($e).concat(pe),ve),this.quill.setSelection($e+pe.length(),m.default.sources.SILENT)}}},{key:"onPaste",value:function($e){var ge=this;if(!($e.defaultPrevented||!this.quill.isEnabled())){var ve=this.quill.getSelection(),pe=new d.default().retain(ve.index),Ie=this.quill.scrollingContainer.scrollTop;this.container.focus(),this.quill.selection.update(m.default.sources.SILENT),setTimeout(function(){pe=pe.concat(ge.convert()).delete(ve.length),ge.quill.updateContents(pe,m.default.sources.USER),ge.quill.setSelection(pe.length()-ve.length,m.default.sources.SILENT),ge.quill.scrollingContainer.scrollTop=Ie,ge.quill.focus()},1)}}},{key:"prepareMatching",value:function(){var $e=this,ge=[],ve=[];return this.matchers.forEach(function(pe){var Ie=i(pe,2),ze=Ie[0],Ye=Ie[1];switch(ze){case Node.TEXT_NODE:ve.push(Ye);break;case Node.ELEMENT_NODE:ge.push(Ye);break;default:[].forEach.call($e.container.querySelectorAll(ze),function(Je){Je[F]=Je[F]||[],Je[F].push(Ye)});break}}),[ge,ve]}}]),Te}(x.default);B.DEFAULTS={matchers:[],matchVisual:!0};function V(ie,Te,Le){return(typeof Te>"u"?"undefined":a(Te))==="object"?Object.keys(Te).reduce(function($e,ge){return V($e,ge,Te[ge])},ie):ie.reduce(function($e,ge){return ge.attributes&&ge.attributes[Te]?$e.push(ge):$e.insert(ge.insert,(0,u.default)({},E({},Te,Le),ge.attributes))},new d.default)}function K(ie){if(ie.nodeType!==Node.ELEMENT_NODE)return{};var Te="__ql-computed-style";return ie[Te]||(ie[Te]=window.getComputedStyle(ie))}function G(ie,Te){for(var Le="",$e=ie.ops.length-1;$e>=0&&Le.length<Te.length;--$e){var ge=ie.ops[$e];if(typeof ge.insert!="string")break;Le=ge.insert+Le}return Le.slice(-1*Te.length)===Te}function U(ie){if(ie.childNodes.length===0)return!1;var Te=K(ie);return["block","list-item"].indexOf(Te.display)>-1}function q(ie,Te,Le){return ie.nodeType===ie.TEXT_NODE?Le.reduce(function($e,ge){return ge(ie,$e)},new d.default):ie.nodeType===ie.ELEMENT_NODE?[].reduce.call(ie.childNodes||[],function($e,ge){var ve=q(ge,Te,Le);return ge.nodeType===ie.ELEMENT_NODE&&(ve=Te.reduce(function(pe,Ie){return Ie(ge,pe)},ve),ve=(ge[F]||[]).reduce(function(pe,Ie){return Ie(ge,pe)},ve)),$e.concat(ve)},new d.default):new d.default}function Q(ie,Te,Le){return V(Le,ie,!0)}function ee(ie,Te){var Le=p.default.Attributor.Attribute.keys(ie),$e=p.default.Attributor.Class.keys(ie),ge=p.default.Attributor.Style.keys(ie),ve={};return Le.concat($e).concat(ge).forEach(function(pe){var Ie=p.default.query(pe,p.default.Scope.ATTRIBUTE);Ie!=null&&(ve[Ie.attrName]=Ie.value(ie),ve[Ie.attrName])||(Ie=O[pe],Ie!=null&&(Ie.attrName===pe||Ie.keyName===pe)&&(ve[Ie.attrName]=Ie.value(ie)||void 0),Ie=D[pe],Ie!=null&&(Ie.attrName===pe||Ie.keyName===pe)&&(Ie=D[pe],ve[Ie.attrName]=Ie.value(ie)||void 0))}),Object.keys(ve).length>0&&(Te=V(Te,ve)),Te}function ae(ie,Te){var Le=p.default.query(ie);if(Le==null)return Te;if(Le.prototype instanceof p.default.Embed){var $e={},ge=Le.value(ie);ge!=null&&($e[Le.blotName]=ge,Te=new d.default().insert($e,Le.formats(ie)))}else typeof Le.formats=="function"&&(Te=V(Te,Le.blotName,Le.formats(ie)));return Te}function ye(ie,Te){return G(Te,`
`)||Te.insert(`
`),Te}function j(){return new d.default}function ce(ie,Te){var Le=p.default.query(ie);if(Le==null||Le.blotName!=="list-item"||!G(Te,`
`))return Te;for(var $e=-1,ge=ie.parentNode;!ge.classList.contains("ql-clipboard");)(p.default.query(ge)||{}).blotName==="list"&&($e+=1),ge=ge.parentNode;return $e<=0?Te:Te.compose(new d.default().retain(Te.length()-1).retain(1,{indent:$e}))}function be(ie,Te){return G(Te,`
`)||(U(ie)||Te.length()>0&&ie.nextSibling&&U(ie.nextSibling))&&Te.insert(`
`),Te}function ke(ie,Te){if(U(ie)&&ie.nextElementSibling!=null&&!G(Te,`

`)){var Le=ie.offsetHeight+parseFloat(K(ie).marginTop)+parseFloat(K(ie).marginBottom);ie.nextElementSibling.offsetTop>ie.offsetTop+Le*1.5&&Te.insert(`
`)}return Te}function Ae(ie,Te){var Le={},$e=ie.style||{};return $e.fontStyle&&K(ie).fontStyle==="italic"&&(Le.italic=!0),$e.fontWeight&&(K(ie).fontWeight.startsWith("bold")||parseInt(K(ie).fontWeight)>=700)&&(Le.bold=!0),Object.keys(Le).length>0&&(Te=V(Te,Le)),parseFloat($e.textIndent||0)>0&&(Te=new d.default().insert("	").concat(Te)),Te}function Pe(ie,Te){var Le=ie.data;if(ie.parentNode.tagName==="O:P")return Te.insert(Le.trim());if(Le.trim().length===0&&ie.parentNode.classList.contains("ql-clipboard"))return Te;if(!K(ie.parentNode).whiteSpace.startsWith("pre")){var $e=function(ve,pe){return pe=pe.replace(/[^\u00a0]/g,""),pe.length<1&&ve?" ":pe};Le=Le.replace(/\r\n/g," ").replace(/\n/g," "),Le=Le.replace(/\s\s+/g,$e.bind($e,!0)),(ie.previousSibling==null&&U(ie.parentNode)||ie.previousSibling!=null&&U(ie.previousSibling))&&(Le=Le.replace(/^\s+/,$e.bind($e,!1))),(ie.nextSibling==null&&U(ie.parentNode)||ie.nextSibling!=null&&U(ie.nextSibling))&&(Le=Le.replace(/\s+$/,$e.bind($e,!1)))}return Te.insert(Le)}r.default=B,r.matchAttributor=ee,r.matchBlot=ae,r.matchNewline=be,r.matchSpacing=ke,r.matchText=Pe},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function f(m,g){for(var y=0;y<g.length;y++){var b=g[y];b.enumerable=b.enumerable||!1,b.configurable=!0,"value"in b&&(b.writable=!0),Object.defineProperty(m,b.key,b)}}return function(m,g,y){return g&&f(m.prototype,g),y&&f(m,y),m}}(),i=function f(m,g,y){m===null&&(m=Function.prototype);var b=Object.getOwnPropertyDescriptor(m,g);if(b===void 0){var x=Object.getPrototypeOf(m);return x===null?void 0:f(x,g,y)}else{if("value"in b)return b.value;var v=b.get;return v===void 0?void 0:v.call(y)}},o=s(6),l=u(o);function u(f){return f&&f.__esModule?f:{default:f}}function c(f,m){if(!(f instanceof m))throw new TypeError("Cannot call a class as a function")}function d(f,m){if(!f)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return m&&(typeof m=="object"||typeof m=="function")?m:f}function h(f,m){if(typeof m!="function"&&m!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof m);f.prototype=Object.create(m&&m.prototype,{constructor:{value:f,enumerable:!1,writable:!0,configurable:!0}}),m&&(Object.setPrototypeOf?Object.setPrototypeOf(f,m):f.__proto__=m)}var p=function(f){h(m,f);function m(){return c(this,m),d(this,(m.__proto__||Object.getPrototypeOf(m)).apply(this,arguments))}return a(m,[{key:"optimize",value:function(y){i(m.prototype.__proto__||Object.getPrototypeOf(m.prototype),"optimize",this).call(this,y),this.domNode.tagName!==this.statics.tagName[0]&&this.replaceWith(this.statics.blotName)}}],[{key:"create",value:function(){return i(m.__proto__||Object.getPrototypeOf(m),"create",this).call(this)}},{key:"formats",value:function(){return!0}}]),m}(l.default);p.blotName="bold",p.tagName=["STRONG","B"],r.default=p},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.addControls=r.default=void 0;var a=function(){function T(N,E){var _=[],R=!0,z=!1,W=void 0;try{for(var F=N[Symbol.iterator](),L;!(R=(L=F.next()).done)&&(_.push(L.value),!(E&&_.length===E));R=!0);}catch(O){z=!0,W=O}finally{try{!R&&F.return&&F.return()}finally{if(z)throw W}}return _}return function(N,E){if(Array.isArray(N))return N;if(Symbol.iterator in Object(N))return T(N,E);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function(){function T(N,E){for(var _=0;_<E.length;_++){var R=E[_];R.enumerable=R.enumerable||!1,R.configurable=!0,"value"in R&&(R.writable=!0),Object.defineProperty(N,R.key,R)}}return function(N,E,_){return E&&T(N.prototype,E),_&&T(N,_),N}}(),o=s(2),l=y(o),u=s(0),c=y(u),d=s(5),h=y(d),p=s(10),f=y(p),m=s(9),g=y(m);function y(T){return T&&T.__esModule?T:{default:T}}function b(T,N,E){return N in T?Object.defineProperty(T,N,{value:E,enumerable:!0,configurable:!0,writable:!0}):T[N]=E,T}function x(T,N){if(!(T instanceof N))throw new TypeError("Cannot call a class as a function")}function v(T,N){if(!T)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return N&&(typeof N=="object"||typeof N=="function")?N:T}function w(T,N){if(typeof N!="function"&&N!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof N);T.prototype=Object.create(N&&N.prototype,{constructor:{value:T,enumerable:!1,writable:!0,configurable:!0}}),N&&(Object.setPrototypeOf?Object.setPrototypeOf(T,N):T.__proto__=N)}var k=(0,f.default)("quill:toolbar"),S=function(T){w(N,T);function N(E,_){x(this,N);var R=v(this,(N.__proto__||Object.getPrototypeOf(N)).call(this,E,_));if(Array.isArray(R.options.container)){var z=document.createElement("div");$(z,R.options.container),E.container.parentNode.insertBefore(z,E.container),R.container=z}else typeof R.options.container=="string"?R.container=document.querySelector(R.options.container):R.container=R.options.container;if(!(R.container instanceof HTMLElement)){var W;return W=k.error("Container required for toolbar",R.options),v(R,W)}return R.container.classList.add("ql-toolbar"),R.controls=[],R.handlers={},Object.keys(R.options.handlers).forEach(function(F){R.addHandler(F,R.options.handlers[F])}),[].forEach.call(R.container.querySelectorAll("button, select"),function(F){R.attach(F)}),R.quill.on(h.default.events.EDITOR_CHANGE,function(F,L){F===h.default.events.SELECTION_CHANGE&&R.update(L)}),R.quill.on(h.default.events.SCROLL_OPTIMIZE,function(){var F=R.quill.selection.getRange(),L=a(F,1),O=L[0];R.update(O)}),R}return i(N,[{key:"addHandler",value:function(_,R){this.handlers[_]=R}},{key:"attach",value:function(_){var R=this,z=[].find.call(_.classList,function(F){return F.indexOf("ql-")===0});if(z){if(z=z.slice(3),_.tagName==="BUTTON"&&_.setAttribute("type","button"),this.handlers[z]==null){if(this.quill.scroll.whitelist!=null&&this.quill.scroll.whitelist[z]==null){k.warn("ignoring attaching to disabled format",z,_);return}if(c.default.query(z)==null){k.warn("ignoring attaching to nonexistent format",z,_);return}}var W=_.tagName==="SELECT"?"change":"click";_.addEventListener(W,function(F){var L=void 0;if(_.tagName==="SELECT"){if(_.selectedIndex<0)return;var O=_.options[_.selectedIndex];O.hasAttribute("selected")?L=!1:L=O.value||!1}else _.classList.contains("ql-active")?L=!1:L=_.value||!_.hasAttribute("value"),F.preventDefault();R.quill.focus();var D=R.quill.selection.getRange(),B=a(D,1),V=B[0];if(R.handlers[z]!=null)R.handlers[z].call(R,L);else if(c.default.query(z).prototype instanceof c.default.Embed){if(L=prompt("Enter "+z),!L)return;R.quill.updateContents(new l.default().retain(V.index).delete(V.length).insert(b({},z,L)),h.default.sources.USER)}else R.quill.format(z,L,h.default.sources.USER);R.update(V)}),this.controls.push([z,_])}}},{key:"update",value:function(_){var R=_==null?{}:this.quill.getFormat(_);this.controls.forEach(function(z){var W=a(z,2),F=W[0],L=W[1];if(L.tagName==="SELECT"){var O=void 0;if(_==null)O=null;else if(R[F]==null)O=L.querySelector("option[selected]");else if(!Array.isArray(R[F])){var D=R[F];typeof D=="string"&&(D=D.replace(/\"/g,'\\"')),O=L.querySelector('option[value="'+D+'"]')}O==null?(L.value="",L.selectedIndex=-1):O.selected=!0}else if(_==null)L.classList.remove("ql-active");else if(L.hasAttribute("value")){var B=R[F]===L.getAttribute("value")||R[F]!=null&&R[F].toString()===L.getAttribute("value")||R[F]==null&&!L.getAttribute("value");L.classList.toggle("ql-active",B)}else L.classList.toggle("ql-active",R[F]!=null)})}}]),N}(g.default);S.DEFAULTS={};function I(T,N,E){var _=document.createElement("button");_.setAttribute("type","button"),_.classList.add("ql-"+N),E!=null&&(_.value=E),T.appendChild(_)}function $(T,N){Array.isArray(N[0])||(N=[N]),N.forEach(function(E){var _=document.createElement("span");_.classList.add("ql-formats"),E.forEach(function(R){if(typeof R=="string")I(_,R);else{var z=Object.keys(R)[0],W=R[z];Array.isArray(W)?C(_,z,W):I(_,z,W)}}),T.appendChild(_)})}function C(T,N,E){var _=document.createElement("select");_.classList.add("ql-"+N),E.forEach(function(R){var z=document.createElement("option");R!==!1?z.setAttribute("value",R):z.setAttribute("selected","selected"),_.appendChild(z)}),T.appendChild(_)}S.DEFAULTS={container:null,handlers:{clean:function(){var N=this,E=this.quill.getSelection();if(E!=null)if(E.length==0){var _=this.quill.getFormat();Object.keys(_).forEach(function(R){c.default.query(R,c.default.Scope.INLINE)!=null&&N.quill.format(R,!1)})}else this.quill.removeFormat(E,h.default.sources.USER)},direction:function(N){var E=this.quill.getFormat().align;N==="rtl"&&E==null?this.quill.format("align","right",h.default.sources.USER):!N&&E==="right"&&this.quill.format("align",!1,h.default.sources.USER),this.quill.format("direction",N,h.default.sources.USER)},indent:function(N){var E=this.quill.getSelection(),_=this.quill.getFormat(E),R=parseInt(_.indent||0);if(N==="+1"||N==="-1"){var z=N==="+1"?1:-1;_.direction==="rtl"&&(z*=-1),this.quill.format("indent",R+z,h.default.sources.USER)}},link:function(N){N===!0&&(N=prompt("Enter link URL:")),this.quill.format("link",N,h.default.sources.USER)},list:function(N){var E=this.quill.getSelection(),_=this.quill.getFormat(E);N==="check"?_.list==="checked"||_.list==="unchecked"?this.quill.format("list",!1,h.default.sources.USER):this.quill.format("list","unchecked",h.default.sources.USER):this.quill.format("list",N,h.default.sources.USER)}}},r.default=S,r.addControls=$},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>'},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function f(m,g){for(var y=0;y<g.length;y++){var b=g[y];b.enumerable=b.enumerable||!1,b.configurable=!0,"value"in b&&(b.writable=!0),Object.defineProperty(m,b.key,b)}}return function(m,g,y){return g&&f(m.prototype,g),y&&f(m,y),m}}(),i=function f(m,g,y){m===null&&(m=Function.prototype);var b=Object.getOwnPropertyDescriptor(m,g);if(b===void 0){var x=Object.getPrototypeOf(m);return x===null?void 0:f(x,g,y)}else{if("value"in b)return b.value;var v=b.get;return v===void 0?void 0:v.call(y)}},o=s(28),l=u(o);function u(f){return f&&f.__esModule?f:{default:f}}function c(f,m){if(!(f instanceof m))throw new TypeError("Cannot call a class as a function")}function d(f,m){if(!f)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return m&&(typeof m=="object"||typeof m=="function")?m:f}function h(f,m){if(typeof m!="function"&&m!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof m);f.prototype=Object.create(m&&m.prototype,{constructor:{value:f,enumerable:!1,writable:!0,configurable:!0}}),m&&(Object.setPrototypeOf?Object.setPrototypeOf(f,m):f.__proto__=m)}var p=function(f){h(m,f);function m(g,y){c(this,m);var b=d(this,(m.__proto__||Object.getPrototypeOf(m)).call(this,g));return b.label.innerHTML=y,b.container.classList.add("ql-color-picker"),[].slice.call(b.container.querySelectorAll(".ql-picker-item"),0,7).forEach(function(x){x.classList.add("ql-primary")}),b}return a(m,[{key:"buildItem",value:function(y){var b=i(m.prototype.__proto__||Object.getPrototypeOf(m.prototype),"buildItem",this).call(this,y);return b.style.backgroundColor=y.getAttribute("value")||"",b}},{key:"selectItem",value:function(y,b){i(m.prototype.__proto__||Object.getPrototypeOf(m.prototype),"selectItem",this).call(this,y,b);var x=this.label.querySelector(".ql-color-label"),v=y&&y.getAttribute("data-value")||"";x&&(x.tagName==="line"?x.style.stroke=v:x.style.fill=v)}}]),m}(l.default);r.default=p},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function f(m,g){for(var y=0;y<g.length;y++){var b=g[y];b.enumerable=b.enumerable||!1,b.configurable=!0,"value"in b&&(b.writable=!0),Object.defineProperty(m,b.key,b)}}return function(m,g,y){return g&&f(m.prototype,g),y&&f(m,y),m}}(),i=function f(m,g,y){m===null&&(m=Function.prototype);var b=Object.getOwnPropertyDescriptor(m,g);if(b===void 0){var x=Object.getPrototypeOf(m);return x===null?void 0:f(x,g,y)}else{if("value"in b)return b.value;var v=b.get;return v===void 0?void 0:v.call(y)}},o=s(28),l=u(o);function u(f){return f&&f.__esModule?f:{default:f}}function c(f,m){if(!(f instanceof m))throw new TypeError("Cannot call a class as a function")}function d(f,m){if(!f)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return m&&(typeof m=="object"||typeof m=="function")?m:f}function h(f,m){if(typeof m!="function"&&m!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof m);f.prototype=Object.create(m&&m.prototype,{constructor:{value:f,enumerable:!1,writable:!0,configurable:!0}}),m&&(Object.setPrototypeOf?Object.setPrototypeOf(f,m):f.__proto__=m)}var p=function(f){h(m,f);function m(g,y){c(this,m);var b=d(this,(m.__proto__||Object.getPrototypeOf(m)).call(this,g));return b.container.classList.add("ql-icon-picker"),[].forEach.call(b.container.querySelectorAll(".ql-picker-item"),function(x){x.innerHTML=y[x.getAttribute("data-value")||""]}),b.defaultItem=b.container.querySelector(".ql-selected"),b.selectItem(b.defaultItem),b}return a(m,[{key:"selectItem",value:function(y,b){i(m.prototype.__proto__||Object.getPrototypeOf(m.prototype),"selectItem",this).call(this,y,b),y=y||this.defaultItem,this.label.innerHTML=y.innerHTML}}]),m}(l.default);r.default=p},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function l(u,c){for(var d=0;d<c.length;d++){var h=c[d];h.enumerable=h.enumerable||!1,h.configurable=!0,"value"in h&&(h.writable=!0),Object.defineProperty(u,h.key,h)}}return function(u,c,d){return c&&l(u.prototype,c),d&&l(u,d),u}}();function i(l,u){if(!(l instanceof u))throw new TypeError("Cannot call a class as a function")}var o=function(){function l(u,c){var d=this;i(this,l),this.quill=u,this.boundsContainer=c||document.body,this.root=u.addContainer("ql-tooltip"),this.root.innerHTML=this.constructor.TEMPLATE,this.quill.root===this.quill.scrollingContainer&&this.quill.root.addEventListener("scroll",function(){d.root.style.marginTop=-1*d.quill.root.scrollTop+"px"}),this.hide()}return a(l,[{key:"hide",value:function(){this.root.classList.add("ql-hidden")}},{key:"position",value:function(c){var d=c.left+c.width/2-this.root.offsetWidth/2,h=c.bottom+this.quill.root.scrollTop;this.root.style.left=d+"px",this.root.style.top=h+"px",this.root.classList.remove("ql-flip");var p=this.boundsContainer.getBoundingClientRect(),f=this.root.getBoundingClientRect(),m=0;if(f.right>p.right&&(m=p.right-f.right,this.root.style.left=d+m+"px"),f.left<p.left&&(m=p.left-f.left,this.root.style.left=d+m+"px"),f.bottom>p.bottom){var g=f.bottom-f.top,y=c.bottom-c.top+g;this.root.style.top=h-y+"px",this.root.classList.add("ql-flip")}return m}},{key:"show",value:function(){this.root.classList.remove("ql-editing"),this.root.classList.remove("ql-hidden")}}]),l}();r.default=o},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function C(T,N){var E=[],_=!0,R=!1,z=void 0;try{for(var W=T[Symbol.iterator](),F;!(_=(F=W.next()).done)&&(E.push(F.value),!(N&&E.length===N));_=!0);}catch(L){R=!0,z=L}finally{try{!_&&W.return&&W.return()}finally{if(R)throw z}}return E}return function(T,N){if(Array.isArray(T))return T;if(Symbol.iterator in Object(T))return C(T,N);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),i=function C(T,N,E){T===null&&(T=Function.prototype);var _=Object.getOwnPropertyDescriptor(T,N);if(_===void 0){var R=Object.getPrototypeOf(T);return R===null?void 0:C(R,N,E)}else{if("value"in _)return _.value;var z=_.get;return z===void 0?void 0:z.call(E)}},o=function(){function C(T,N){for(var E=0;E<N.length;E++){var _=N[E];_.enumerable=_.enumerable||!1,_.configurable=!0,"value"in _&&(_.writable=!0),Object.defineProperty(T,_.key,_)}}return function(T,N,E){return N&&C(T.prototype,N),E&&C(T,E),T}}(),l=s(3),u=x(l),c=s(8),d=x(c),h=s(43),p=x(h),f=s(27),m=x(f),g=s(15),y=s(41),b=x(y);function x(C){return C&&C.__esModule?C:{default:C}}function v(C,T){if(!(C instanceof T))throw new TypeError("Cannot call a class as a function")}function w(C,T){if(!C)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return T&&(typeof T=="object"||typeof T=="function")?T:C}function k(C,T){if(typeof T!="function"&&T!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof T);C.prototype=Object.create(T&&T.prototype,{constructor:{value:C,enumerable:!1,writable:!0,configurable:!0}}),T&&(Object.setPrototypeOf?Object.setPrototypeOf(C,T):C.__proto__=T)}var S=[[{header:["1","2","3",!1]}],["bold","italic","underline","link"],[{list:"ordered"},{list:"bullet"}],["clean"]],I=function(C){k(T,C);function T(N,E){v(this,T),E.modules.toolbar!=null&&E.modules.toolbar.container==null&&(E.modules.toolbar.container=S);var _=w(this,(T.__proto__||Object.getPrototypeOf(T)).call(this,N,E));return _.quill.container.classList.add("ql-snow"),_}return o(T,[{key:"extendToolbar",value:function(E){E.container.classList.add("ql-snow"),this.buildButtons([].slice.call(E.container.querySelectorAll("button")),b.default),this.buildPickers([].slice.call(E.container.querySelectorAll("select")),b.default),this.tooltip=new $(this.quill,this.options.bounds),E.container.querySelector(".ql-link")&&this.quill.keyboard.addBinding({key:"K",shortKey:!0},function(_,R){E.handlers.link.call(E,!R.format.link)})}}]),T}(p.default);I.DEFAULTS=(0,u.default)(!0,{},p.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function(T){if(T){var N=this.quill.getSelection();if(N==null||N.length==0)return;var E=this.quill.getText(N);/^\S+@\S+\.\S+$/.test(E)&&E.indexOf("mailto:")!==0&&(E="mailto:"+E);var _=this.quill.theme.tooltip;_.edit("link",E)}else this.quill.format("link",!1)}}}}});var $=function(C){k(T,C);function T(N,E){v(this,T);var _=w(this,(T.__proto__||Object.getPrototypeOf(T)).call(this,N,E));return _.preview=_.root.querySelector("a.ql-preview"),_}return o(T,[{key:"listen",value:function(){var E=this;i(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"listen",this).call(this),this.root.querySelector("a.ql-action").addEventListener("click",function(_){E.root.classList.contains("ql-editing")?E.save():E.edit("link",E.preview.textContent),_.preventDefault()}),this.root.querySelector("a.ql-remove").addEventListener("click",function(_){if(E.linkRange!=null){var R=E.linkRange;E.restoreFocus(),E.quill.formatText(R,"link",!1,d.default.sources.USER),delete E.linkRange}_.preventDefault(),E.hide()}),this.quill.on(d.default.events.SELECTION_CHANGE,function(_,R,z){if(_!=null){if(_.length===0&&z===d.default.sources.USER){var W=E.quill.scroll.descendant(m.default,_.index),F=a(W,2),L=F[0],O=F[1];if(L!=null){E.linkRange=new g.Range(_.index-O,L.length());var D=m.default.formats(L.domNode);E.preview.textContent=D,E.preview.setAttribute("href",D),E.show(),E.position(E.quill.getBounds(E.linkRange));return}}else delete E.linkRange;E.hide()}})}},{key:"show",value:function(){i(T.prototype.__proto__||Object.getPrototypeOf(T.prototype),"show",this).call(this),this.root.removeAttribute("data-mode")}}]),T}(h.BaseTooltip);$.TEMPLATE=['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-action"></a>','<a class="ql-remove"></a>'].join(""),r.default=I},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(29),i=ge(a),o=s(36),l=s(38),u=s(64),c=s(65),d=ge(c),h=s(66),p=ge(h),f=s(67),m=ge(f),g=s(37),y=s(26),b=s(39),x=s(40),v=s(56),w=ge(v),k=s(68),S=ge(k),I=s(27),$=ge(I),C=s(69),T=ge(C),N=s(70),E=ge(N),_=s(71),R=ge(_),z=s(72),W=ge(z),F=s(73),L=ge(F),O=s(13),D=ge(O),B=s(74),V=ge(B),K=s(75),G=ge(K),U=s(57),q=ge(U),Q=s(41),ee=ge(Q),ae=s(28),ye=ge(ae),j=s(59),ce=ge(j),be=s(60),ke=ge(be),Ae=s(61),Pe=ge(Ae),ie=s(108),Te=ge(ie),Le=s(62),$e=ge(Le);function ge(ve){return ve&&ve.__esModule?ve:{default:ve}}i.default.register({"attributors/attribute/direction":l.DirectionAttribute,"attributors/class/align":o.AlignClass,"attributors/class/background":g.BackgroundClass,"attributors/class/color":y.ColorClass,"attributors/class/direction":l.DirectionClass,"attributors/class/font":b.FontClass,"attributors/class/size":x.SizeClass,"attributors/style/align":o.AlignStyle,"attributors/style/background":g.BackgroundStyle,"attributors/style/color":y.ColorStyle,"attributors/style/direction":l.DirectionStyle,"attributors/style/font":b.FontStyle,"attributors/style/size":x.SizeStyle},!0),i.default.register({"formats/align":o.AlignClass,"formats/direction":l.DirectionClass,"formats/indent":u.IndentClass,"formats/background":g.BackgroundStyle,"formats/color":y.ColorStyle,"formats/font":b.FontClass,"formats/size":x.SizeClass,"formats/blockquote":d.default,"formats/code-block":D.default,"formats/header":p.default,"formats/list":m.default,"formats/bold":w.default,"formats/code":O.Code,"formats/italic":S.default,"formats/link":$.default,"formats/script":T.default,"formats/strike":E.default,"formats/underline":R.default,"formats/image":W.default,"formats/video":L.default,"formats/list/item":f.ListItem,"modules/formula":V.default,"modules/syntax":G.default,"modules/toolbar":q.default,"themes/bubble":Te.default,"themes/snow":$e.default,"ui/icons":ee.default,"ui/picker":ye.default,"ui/icon-picker":ke.default,"ui/color-picker":ce.default,"ui/tooltip":Pe.default},!0),r.default=i.default},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.IndentClass=void 0;var a=function(){function m(g,y){for(var b=0;b<y.length;b++){var x=y[b];x.enumerable=x.enumerable||!1,x.configurable=!0,"value"in x&&(x.writable=!0),Object.defineProperty(g,x.key,x)}}return function(g,y,b){return y&&m(g.prototype,y),b&&m(g,b),g}}(),i=function m(g,y,b){g===null&&(g=Function.prototype);var x=Object.getOwnPropertyDescriptor(g,y);if(x===void 0){var v=Object.getPrototypeOf(g);return v===null?void 0:m(v,y,b)}else{if("value"in x)return x.value;var w=x.get;return w===void 0?void 0:w.call(b)}},o=s(0),l=u(o);function u(m){return m&&m.__esModule?m:{default:m}}function c(m,g){if(!(m instanceof g))throw new TypeError("Cannot call a class as a function")}function d(m,g){if(!m)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return g&&(typeof g=="object"||typeof g=="function")?g:m}function h(m,g){if(typeof g!="function"&&g!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof g);m.prototype=Object.create(g&&g.prototype,{constructor:{value:m,enumerable:!1,writable:!0,configurable:!0}}),g&&(Object.setPrototypeOf?Object.setPrototypeOf(m,g):m.__proto__=g)}var p=function(m){h(g,m);function g(){return c(this,g),d(this,(g.__proto__||Object.getPrototypeOf(g)).apply(this,arguments))}return a(g,[{key:"add",value:function(b,x){if(x==="+1"||x==="-1"){var v=this.value(b)||0;x=x==="+1"?v+1:v-1}return x===0?(this.remove(b),!0):i(g.prototype.__proto__||Object.getPrototypeOf(g.prototype),"add",this).call(this,b,x)}},{key:"canAdd",value:function(b,x){return i(g.prototype.__proto__||Object.getPrototypeOf(g.prototype),"canAdd",this).call(this,b,x)||i(g.prototype.__proto__||Object.getPrototypeOf(g.prototype),"canAdd",this).call(this,b,parseInt(x))}},{key:"value",value:function(b){return parseInt(i(g.prototype.__proto__||Object.getPrototypeOf(g.prototype),"value",this).call(this,b))||void 0}}]),g}(l.default.Attributor.Class),f=new p("indent","ql-indent",{scope:l.default.Scope.BLOCK,whitelist:[1,2,3,4,5,6,7,8]});r.IndentClass=f},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(4),i=o(a);function o(h){return h&&h.__esModule?h:{default:h}}function l(h,p){if(!(h instanceof p))throw new TypeError("Cannot call a class as a function")}function u(h,p){if(!h)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return p&&(typeof p=="object"||typeof p=="function")?p:h}function c(h,p){if(typeof p!="function"&&p!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof p);h.prototype=Object.create(p&&p.prototype,{constructor:{value:h,enumerable:!1,writable:!0,configurable:!0}}),p&&(Object.setPrototypeOf?Object.setPrototypeOf(h,p):h.__proto__=p)}var d=function(h){c(p,h);function p(){return l(this,p),u(this,(p.__proto__||Object.getPrototypeOf(p)).apply(this,arguments))}return p}(i.default);d.blotName="blockquote",d.tagName="blockquote",r.default=d},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function p(f,m){for(var g=0;g<m.length;g++){var y=m[g];y.enumerable=y.enumerable||!1,y.configurable=!0,"value"in y&&(y.writable=!0),Object.defineProperty(f,y.key,y)}}return function(f,m,g){return m&&p(f.prototype,m),g&&p(f,g),f}}(),i=s(4),o=l(i);function l(p){return p&&p.__esModule?p:{default:p}}function u(p,f){if(!(p instanceof f))throw new TypeError("Cannot call a class as a function")}function c(p,f){if(!p)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return f&&(typeof f=="object"||typeof f=="function")?f:p}function d(p,f){if(typeof f!="function"&&f!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof f);p.prototype=Object.create(f&&f.prototype,{constructor:{value:p,enumerable:!1,writable:!0,configurable:!0}}),f&&(Object.setPrototypeOf?Object.setPrototypeOf(p,f):p.__proto__=f)}var h=function(p){d(f,p);function f(){return u(this,f),c(this,(f.__proto__||Object.getPrototypeOf(f)).apply(this,arguments))}return a(f,null,[{key:"formats",value:function(g){return this.tagName.indexOf(g.tagName)+1}}]),f}(o.default);h.blotName="header",h.tagName=["H1","H2","H3","H4","H5","H6"],r.default=h},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.ListItem=void 0;var a=function(){function v(w,k){for(var S=0;S<k.length;S++){var I=k[S];I.enumerable=I.enumerable||!1,I.configurable=!0,"value"in I&&(I.writable=!0),Object.defineProperty(w,I.key,I)}}return function(w,k,S){return k&&v(w.prototype,k),S&&v(w,S),w}}(),i=function v(w,k,S){w===null&&(w=Function.prototype);var I=Object.getOwnPropertyDescriptor(w,k);if(I===void 0){var $=Object.getPrototypeOf(w);return $===null?void 0:v($,k,S)}else{if("value"in I)return I.value;var C=I.get;return C===void 0?void 0:C.call(S)}},o=s(0),l=p(o),u=s(4),c=p(u),d=s(25),h=p(d);function p(v){return v&&v.__esModule?v:{default:v}}function f(v,w,k){return w in v?Object.defineProperty(v,w,{value:k,enumerable:!0,configurable:!0,writable:!0}):v[w]=k,v}function m(v,w){if(!(v instanceof w))throw new TypeError("Cannot call a class as a function")}function g(v,w){if(!v)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return w&&(typeof w=="object"||typeof w=="function")?w:v}function y(v,w){if(typeof w!="function"&&w!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof w);v.prototype=Object.create(w&&w.prototype,{constructor:{value:v,enumerable:!1,writable:!0,configurable:!0}}),w&&(Object.setPrototypeOf?Object.setPrototypeOf(v,w):v.__proto__=w)}var b=function(v){y(w,v);function w(){return m(this,w),g(this,(w.__proto__||Object.getPrototypeOf(w)).apply(this,arguments))}return a(w,[{key:"format",value:function(S,I){S===x.blotName&&!I?this.replaceWith(l.default.create(this.statics.scope)):i(w.prototype.__proto__||Object.getPrototypeOf(w.prototype),"format",this).call(this,S,I)}},{key:"remove",value:function(){this.prev==null&&this.next==null?this.parent.remove():i(w.prototype.__proto__||Object.getPrototypeOf(w.prototype),"remove",this).call(this)}},{key:"replaceWith",value:function(S,I){return this.parent.isolate(this.offset(this.parent),this.length()),S===this.parent.statics.blotName?(this.parent.replaceWith(S,I),this):(this.parent.unwrap(),i(w.prototype.__proto__||Object.getPrototypeOf(w.prototype),"replaceWith",this).call(this,S,I))}}],[{key:"formats",value:function(S){return S.tagName===this.tagName?void 0:i(w.__proto__||Object.getPrototypeOf(w),"formats",this).call(this,S)}}]),w}(c.default);b.blotName="list-item",b.tagName="LI";var x=function(v){y(w,v),a(w,null,[{key:"create",value:function(S){var I=S==="ordered"?"OL":"UL",$=i(w.__proto__||Object.getPrototypeOf(w),"create",this).call(this,I);return(S==="checked"||S==="unchecked")&&$.setAttribute("data-checked",S==="checked"),$}},{key:"formats",value:function(S){if(S.tagName==="OL")return"ordered";if(S.tagName==="UL")return S.hasAttribute("data-checked")?S.getAttribute("data-checked")==="true"?"checked":"unchecked":"bullet"}}]);function w(k){m(this,w);var S=g(this,(w.__proto__||Object.getPrototypeOf(w)).call(this,k)),I=function(C){if(C.target.parentNode===k){var T=S.statics.formats(k),N=l.default.find(C.target);T==="checked"?N.format("list","unchecked"):T==="unchecked"&&N.format("list","checked")}};return k.addEventListener("touchstart",I),k.addEventListener("mousedown",I),S}return a(w,[{key:"format",value:function(S,I){this.children.length>0&&this.children.tail.format(S,I)}},{key:"formats",value:function(){return f({},this.statics.blotName,this.statics.formats(this.domNode))}},{key:"insertBefore",value:function(S,I){if(S instanceof b)i(w.prototype.__proto__||Object.getPrototypeOf(w.prototype),"insertBefore",this).call(this,S,I);else{var $=I==null?this.length():I.offset(this),C=this.split($);C.parent.insertBefore(S,C)}}},{key:"optimize",value:function(S){i(w.prototype.__proto__||Object.getPrototypeOf(w.prototype),"optimize",this).call(this,S);var I=this.next;I!=null&&I.prev===this&&I.statics.blotName===this.statics.blotName&&I.domNode.tagName===this.domNode.tagName&&I.domNode.getAttribute("data-checked")===this.domNode.getAttribute("data-checked")&&(I.moveChildren(this),I.remove())}},{key:"replace",value:function(S){if(S.statics.blotName!==this.statics.blotName){var I=l.default.create(this.statics.defaultChild);S.moveChildren(I),this.appendChild(I)}i(w.prototype.__proto__||Object.getPrototypeOf(w.prototype),"replace",this).call(this,S)}}]),w}(h.default);x.blotName="list",x.scope=l.default.Scope.BLOCK_BLOT,x.tagName=["OL","UL"],x.defaultChild="list-item",x.allowedChildren=[b],r.ListItem=b,r.default=x},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(56),i=o(a);function o(h){return h&&h.__esModule?h:{default:h}}function l(h,p){if(!(h instanceof p))throw new TypeError("Cannot call a class as a function")}function u(h,p){if(!h)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return p&&(typeof p=="object"||typeof p=="function")?p:h}function c(h,p){if(typeof p!="function"&&p!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof p);h.prototype=Object.create(p&&p.prototype,{constructor:{value:h,enumerable:!1,writable:!0,configurable:!0}}),p&&(Object.setPrototypeOf?Object.setPrototypeOf(h,p):h.__proto__=p)}var d=function(h){c(p,h);function p(){return l(this,p),u(this,(p.__proto__||Object.getPrototypeOf(p)).apply(this,arguments))}return p}(i.default);d.blotName="italic",d.tagName=["EM","I"],r.default=d},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function f(m,g){for(var y=0;y<g.length;y++){var b=g[y];b.enumerable=b.enumerable||!1,b.configurable=!0,"value"in b&&(b.writable=!0),Object.defineProperty(m,b.key,b)}}return function(m,g,y){return g&&f(m.prototype,g),y&&f(m,y),m}}(),i=function f(m,g,y){m===null&&(m=Function.prototype);var b=Object.getOwnPropertyDescriptor(m,g);if(b===void 0){var x=Object.getPrototypeOf(m);return x===null?void 0:f(x,g,y)}else{if("value"in b)return b.value;var v=b.get;return v===void 0?void 0:v.call(y)}},o=s(6),l=u(o);function u(f){return f&&f.__esModule?f:{default:f}}function c(f,m){if(!(f instanceof m))throw new TypeError("Cannot call a class as a function")}function d(f,m){if(!f)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return m&&(typeof m=="object"||typeof m=="function")?m:f}function h(f,m){if(typeof m!="function"&&m!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof m);f.prototype=Object.create(m&&m.prototype,{constructor:{value:f,enumerable:!1,writable:!0,configurable:!0}}),m&&(Object.setPrototypeOf?Object.setPrototypeOf(f,m):f.__proto__=m)}var p=function(f){h(m,f);function m(){return c(this,m),d(this,(m.__proto__||Object.getPrototypeOf(m)).apply(this,arguments))}return a(m,null,[{key:"create",value:function(y){return y==="super"?document.createElement("sup"):y==="sub"?document.createElement("sub"):i(m.__proto__||Object.getPrototypeOf(m),"create",this).call(this,y)}},{key:"formats",value:function(y){if(y.tagName==="SUB")return"sub";if(y.tagName==="SUP")return"super"}}]),m}(l.default);p.blotName="script",p.tagName=["SUB","SUP"],r.default=p},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(6),i=o(a);function o(h){return h&&h.__esModule?h:{default:h}}function l(h,p){if(!(h instanceof p))throw new TypeError("Cannot call a class as a function")}function u(h,p){if(!h)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return p&&(typeof p=="object"||typeof p=="function")?p:h}function c(h,p){if(typeof p!="function"&&p!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof p);h.prototype=Object.create(p&&p.prototype,{constructor:{value:h,enumerable:!1,writable:!0,configurable:!0}}),p&&(Object.setPrototypeOf?Object.setPrototypeOf(h,p):h.__proto__=p)}var d=function(h){c(p,h);function p(){return l(this,p),u(this,(p.__proto__||Object.getPrototypeOf(p)).apply(this,arguments))}return p}(i.default);d.blotName="strike",d.tagName="S",r.default=d},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=s(6),i=o(a);function o(h){return h&&h.__esModule?h:{default:h}}function l(h,p){if(!(h instanceof p))throw new TypeError("Cannot call a class as a function")}function u(h,p){if(!h)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return p&&(typeof p=="object"||typeof p=="function")?p:h}function c(h,p){if(typeof p!="function"&&p!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof p);h.prototype=Object.create(p&&p.prototype,{constructor:{value:h,enumerable:!1,writable:!0,configurable:!0}}),p&&(Object.setPrototypeOf?Object.setPrototypeOf(h,p):h.__proto__=p)}var d=function(h){c(p,h);function p(){return l(this,p),u(this,(p.__proto__||Object.getPrototypeOf(p)).apply(this,arguments))}return p}(i.default);d.blotName="underline",d.tagName="U",r.default=d},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function g(y,b){for(var x=0;x<b.length;x++){var v=b[x];v.enumerable=v.enumerable||!1,v.configurable=!0,"value"in v&&(v.writable=!0),Object.defineProperty(y,v.key,v)}}return function(y,b,x){return b&&g(y.prototype,b),x&&g(y,x),y}}(),i=function g(y,b,x){y===null&&(y=Function.prototype);var v=Object.getOwnPropertyDescriptor(y,b);if(v===void 0){var w=Object.getPrototypeOf(y);return w===null?void 0:g(w,b,x)}else{if("value"in v)return v.value;var k=v.get;return k===void 0?void 0:k.call(x)}},o=s(0),l=c(o),u=s(27);function c(g){return g&&g.__esModule?g:{default:g}}function d(g,y){if(!(g instanceof y))throw new TypeError("Cannot call a class as a function")}function h(g,y){if(!g)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return y&&(typeof y=="object"||typeof y=="function")?y:g}function p(g,y){if(typeof y!="function"&&y!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof y);g.prototype=Object.create(y&&y.prototype,{constructor:{value:g,enumerable:!1,writable:!0,configurable:!0}}),y&&(Object.setPrototypeOf?Object.setPrototypeOf(g,y):g.__proto__=y)}var f=["alt","height","width"],m=function(g){p(y,g);function y(){return d(this,y),h(this,(y.__proto__||Object.getPrototypeOf(y)).apply(this,arguments))}return a(y,[{key:"format",value:function(x,v){f.indexOf(x)>-1?v?this.domNode.setAttribute(x,v):this.domNode.removeAttribute(x):i(y.prototype.__proto__||Object.getPrototypeOf(y.prototype),"format",this).call(this,x,v)}}],[{key:"create",value:function(x){var v=i(y.__proto__||Object.getPrototypeOf(y),"create",this).call(this,x);return typeof x=="string"&&v.setAttribute("src",this.sanitize(x)),v}},{key:"formats",value:function(x){return f.reduce(function(v,w){return x.hasAttribute(w)&&(v[w]=x.getAttribute(w)),v},{})}},{key:"match",value:function(x){return/\.(jpe?g|gif|png)$/.test(x)||/^data:image\/.+;base64/.test(x)}},{key:"sanitize",value:function(x){return(0,u.sanitize)(x,["http","https","data"])?x:"//:0"}},{key:"value",value:function(x){return x.getAttribute("src")}}]),y}(l.default.Embed);m.blotName="image",m.tagName="IMG",r.default=m},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0});var a=function(){function g(y,b){for(var x=0;x<b.length;x++){var v=b[x];v.enumerable=v.enumerable||!1,v.configurable=!0,"value"in v&&(v.writable=!0),Object.defineProperty(y,v.key,v)}}return function(y,b,x){return b&&g(y.prototype,b),x&&g(y,x),y}}(),i=function g(y,b,x){y===null&&(y=Function.prototype);var v=Object.getOwnPropertyDescriptor(y,b);if(v===void 0){var w=Object.getPrototypeOf(y);return w===null?void 0:g(w,b,x)}else{if("value"in v)return v.value;var k=v.get;return k===void 0?void 0:k.call(x)}},o=s(4),l=s(27),u=c(l);function c(g){return g&&g.__esModule?g:{default:g}}function d(g,y){if(!(g instanceof y))throw new TypeError("Cannot call a class as a function")}function h(g,y){if(!g)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return y&&(typeof y=="object"||typeof y=="function")?y:g}function p(g,y){if(typeof y!="function"&&y!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof y);g.prototype=Object.create(y&&y.prototype,{constructor:{value:g,enumerable:!1,writable:!0,configurable:!0}}),y&&(Object.setPrototypeOf?Object.setPrototypeOf(g,y):g.__proto__=y)}var f=["height","width"],m=function(g){p(y,g);function y(){return d(this,y),h(this,(y.__proto__||Object.getPrototypeOf(y)).apply(this,arguments))}return a(y,[{key:"format",value:function(x,v){f.indexOf(x)>-1?v?this.domNode.setAttribute(x,v):this.domNode.removeAttribute(x):i(y.prototype.__proto__||Object.getPrototypeOf(y.prototype),"format",this).call(this,x,v)}}],[{key:"create",value:function(x){var v=i(y.__proto__||Object.getPrototypeOf(y),"create",this).call(this,x);return v.setAttribute("frameborder","0"),v.setAttribute("allowfullscreen",!0),v.setAttribute("src",this.sanitize(x)),v}},{key:"formats",value:function(x){return f.reduce(function(v,w){return x.hasAttribute(w)&&(v[w]=x.getAttribute(w)),v},{})}},{key:"sanitize",value:function(x){return u.default.sanitize(x)}},{key:"value",value:function(x){return x.getAttribute("src")}}]),y}(o.BlockEmbed);m.blotName="video",m.className="ql-video",m.tagName="IFRAME",r.default=m},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.FormulaBlot=void 0;var a=function(){function x(v,w){for(var k=0;k<w.length;k++){var S=w[k];S.enumerable=S.enumerable||!1,S.configurable=!0,"value"in S&&(S.writable=!0),Object.defineProperty(v,S.key,S)}}return function(v,w,k){return w&&x(v.prototype,w),k&&x(v,k),v}}(),i=function x(v,w,k){v===null&&(v=Function.prototype);var S=Object.getOwnPropertyDescriptor(v,w);if(S===void 0){var I=Object.getPrototypeOf(v);return I===null?void 0:x(I,w,k)}else{if("value"in S)return S.value;var $=S.get;return $===void 0?void 0:$.call(k)}},o=s(35),l=p(o),u=s(5),c=p(u),d=s(9),h=p(d);function p(x){return x&&x.__esModule?x:{default:x}}function f(x,v){if(!(x instanceof v))throw new TypeError("Cannot call a class as a function")}function m(x,v){if(!x)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return v&&(typeof v=="object"||typeof v=="function")?v:x}function g(x,v){if(typeof v!="function"&&v!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof v);x.prototype=Object.create(v&&v.prototype,{constructor:{value:x,enumerable:!1,writable:!0,configurable:!0}}),v&&(Object.setPrototypeOf?Object.setPrototypeOf(x,v):x.__proto__=v)}var y=function(x){g(v,x);function v(){return f(this,v),m(this,(v.__proto__||Object.getPrototypeOf(v)).apply(this,arguments))}return a(v,null,[{key:"create",value:function(k){var S=i(v.__proto__||Object.getPrototypeOf(v),"create",this).call(this,k);return typeof k=="string"&&(window.katex.render(k,S,{throwOnError:!1,errorColor:"#f00"}),S.setAttribute("data-value",k)),S}},{key:"value",value:function(k){return k.getAttribute("data-value")}}]),v}(l.default);y.blotName="formula",y.className="ql-formula",y.tagName="SPAN";var b=function(x){g(v,x),a(v,null,[{key:"register",value:function(){c.default.register(y,!0)}}]);function v(){f(this,v);var w=m(this,(v.__proto__||Object.getPrototypeOf(v)).call(this));if(window.katex==null)throw new Error("Formula module requires KaTeX.");return w}return v}(h.default);r.FormulaBlot=y,r.default=b},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.CodeToken=r.CodeBlock=void 0;var a=function(){function k(S,I){for(var $=0;$<I.length;$++){var C=I[$];C.enumerable=C.enumerable||!1,C.configurable=!0,"value"in C&&(C.writable=!0),Object.defineProperty(S,C.key,C)}}return function(S,I,$){return I&&k(S.prototype,I),$&&k(S,$),S}}(),i=function k(S,I,$){S===null&&(S=Function.prototype);var C=Object.getOwnPropertyDescriptor(S,I);if(C===void 0){var T=Object.getPrototypeOf(S);return T===null?void 0:k(T,I,$)}else{if("value"in C)return C.value;var N=C.get;return N===void 0?void 0:N.call($)}},o=s(0),l=m(o),u=s(5),c=m(u),d=s(9),h=m(d),p=s(13),f=m(p);function m(k){return k&&k.__esModule?k:{default:k}}function g(k,S){if(!(k instanceof S))throw new TypeError("Cannot call a class as a function")}function y(k,S){if(!k)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return S&&(typeof S=="object"||typeof S=="function")?S:k}function b(k,S){if(typeof S!="function"&&S!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof S);k.prototype=Object.create(S&&S.prototype,{constructor:{value:k,enumerable:!1,writable:!0,configurable:!0}}),S&&(Object.setPrototypeOf?Object.setPrototypeOf(k,S):k.__proto__=S)}var x=function(k){b(S,k);function S(){return g(this,S),y(this,(S.__proto__||Object.getPrototypeOf(S)).apply(this,arguments))}return a(S,[{key:"replaceWith",value:function($){this.domNode.textContent=this.domNode.textContent,this.attach(),i(S.prototype.__proto__||Object.getPrototypeOf(S.prototype),"replaceWith",this).call(this,$)}},{key:"highlight",value:function($){var C=this.domNode.textContent;this.cachedText!==C&&((C.trim().length>0||this.cachedText==null)&&(this.domNode.innerHTML=$(C),this.domNode.normalize(),this.attach()),this.cachedText=C)}}]),S}(f.default);x.className="ql-syntax";var v=new l.default.Attributor.Class("token","hljs",{scope:l.default.Scope.INLINE}),w=function(k){b(S,k),a(S,null,[{key:"register",value:function(){c.default.register(v,!0),c.default.register(x,!0)}}]);function S(I,$){g(this,S);var C=y(this,(S.__proto__||Object.getPrototypeOf(S)).call(this,I,$));if(typeof C.options.highlight!="function")throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");var T=null;return C.quill.on(c.default.events.SCROLL_OPTIMIZE,function(){clearTimeout(T),T=setTimeout(function(){C.highlight(),T=null},C.options.interval)}),C.highlight(),C}return a(S,[{key:"highlight",value:function(){var $=this;if(!this.quill.selection.composing){this.quill.update(c.default.sources.USER);var C=this.quill.getSelection();this.quill.scroll.descendants(x).forEach(function(T){T.highlight($.options.highlight)}),this.quill.update(c.default.sources.SILENT),C!=null&&this.quill.setSelection(C,c.default.sources.SILENT)}}}]),S}(h.default);w.DEFAULTS={highlight:function(){return window.hljs==null?null:function(k){var S=window.hljs.highlightAuto(k);return S.value}}(),interval:1e3},r.CodeBlock=x,r.CodeToken=v,r.default=w},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>'},function(n,r){n.exports='<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>'},function(n,r){n.exports='<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>'},function(n,r){n.exports='<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>'},function(n,r){n.exports='<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>'},function(n,r){n.exports='<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>'},function(n,r,s){Object.defineProperty(r,"__esModule",{value:!0}),r.default=r.BubbleTooltip=void 0;var a=function S(I,$,C){I===null&&(I=Function.prototype);var T=Object.getOwnPropertyDescriptor(I,$);if(T===void 0){var N=Object.getPrototypeOf(I);return N===null?void 0:S(N,$,C)}else{if("value"in T)return T.value;var E=T.get;return E===void 0?void 0:E.call(C)}},i=function(){function S(I,$){for(var C=0;C<$.length;C++){var T=$[C];T.enumerable=T.enumerable||!1,T.configurable=!0,"value"in T&&(T.writable=!0),Object.defineProperty(I,T.key,T)}}return function(I,$,C){return $&&S(I.prototype,$),C&&S(I,C),I}}(),o=s(3),l=g(o),u=s(8),c=g(u),d=s(43),h=g(d),p=s(15),f=s(41),m=g(f);function g(S){return S&&S.__esModule?S:{default:S}}function y(S,I){if(!(S instanceof I))throw new TypeError("Cannot call a class as a function")}function b(S,I){if(!S)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return I&&(typeof I=="object"||typeof I=="function")?I:S}function x(S,I){if(typeof I!="function"&&I!==null)throw new TypeError("Super expression must either be null or a function, not "+typeof I);S.prototype=Object.create(I&&I.prototype,{constructor:{value:S,enumerable:!1,writable:!0,configurable:!0}}),I&&(Object.setPrototypeOf?Object.setPrototypeOf(S,I):S.__proto__=I)}var v=[["bold","italic","link"],[{header:1},{header:2},"blockquote"]],w=function(S){x(I,S);function I($,C){y(this,I),C.modules.toolbar!=null&&C.modules.toolbar.container==null&&(C.modules.toolbar.container=v);var T=b(this,(I.__proto__||Object.getPrototypeOf(I)).call(this,$,C));return T.quill.container.classList.add("ql-bubble"),T}return i(I,[{key:"extendToolbar",value:function(C){this.tooltip=new k(this.quill,this.options.bounds),this.tooltip.root.appendChild(C.container),this.buildButtons([].slice.call(C.container.querySelectorAll("button")),m.default),this.buildPickers([].slice.call(C.container.querySelectorAll("select")),m.default)}}]),I}(h.default);w.DEFAULTS=(0,l.default)(!0,{},h.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function(I){I?this.quill.theme.tooltip.edit():this.quill.format("link",!1)}}}}});var k=function(S){x(I,S);function I($,C){y(this,I);var T=b(this,(I.__proto__||Object.getPrototypeOf(I)).call(this,$,C));return T.quill.on(c.default.events.EDITOR_CHANGE,function(N,E,_,R){if(N===c.default.events.SELECTION_CHANGE)if(E!=null&&E.length>0&&R===c.default.sources.USER){T.show(),T.root.style.left="0px",T.root.style.width="",T.root.style.width=T.root.offsetWidth+"px";var z=T.quill.getLines(E.index,E.length);if(z.length===1)T.position(T.quill.getBounds(E));else{var W=z[z.length-1],F=T.quill.getIndex(W),L=Math.min(W.length()-1,E.index+E.length-F),O=T.quill.getBounds(new p.Range(F,L));T.position(O)}}else document.activeElement!==T.textbox&&T.quill.hasFocus()&&T.hide()}),T}return i(I,[{key:"listen",value:function(){var C=this;a(I.prototype.__proto__||Object.getPrototypeOf(I.prototype),"listen",this).call(this),this.root.querySelector(".ql-close").addEventListener("click",function(){C.root.classList.remove("ql-editing")}),this.quill.on(c.default.events.SCROLL_OPTIMIZE,function(){setTimeout(function(){if(!C.root.classList.contains("ql-hidden")){var T=C.quill.getSelection();T!=null&&C.position(C.quill.getBounds(T))}},1)})}},{key:"cancel",value:function(){this.show()}},{key:"position",value:function(C){var T=a(I.prototype.__proto__||Object.getPrototypeOf(I.prototype),"position",this).call(this,C),N=this.root.querySelector(".ql-tooltip-arrow");if(N.style.marginLeft="",T===0)return T;N.style.marginLeft=-1*T-N.offsetWidth/2+"px"}}]),I}(d.BaseTooltip);k.TEMPLATE=['<span class="ql-tooltip-arrow"></span>','<div class="ql-tooltip-editor">','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-close"></a>',"</div>"].join(""),r.BubbleTooltip=k,r.default=w},function(n,r,s){n.exports=s(63)}]).default})})(_J);var Qje=_J.exports,e5e=mr&&mr.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(r,s){r.__proto__=s}||function(r,s){for(var a in s)s.hasOwnProperty(a)&&(r[a]=s[a])},e(t,n)};return function(t,n){e(t,n);function r(){this.constructor=t}t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}}(),US=mr&&mr.__assign||function(){return US=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++){t=arguments[n];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e},US.apply(this,arguments)},t5e=mr&&mr.__spreadArrays||function(){for(var e=0,t=0,n=arguments.length;t<n;t++)e+=arguments[t].length;for(var r=Array(e),s=0,t=0;t<n;t++)for(var a=arguments[t],i=0,o=a.length;i<o;i++,s++)r[s]=a[i];return r},RN=mr&&mr.__importDefault||function(e){return e&&e.__esModule?e:{default:e}},Yo=RN(Z),n5e=RN(eO),vv=RN(Zje),aj=RN(Qje),r5e=function(e){e5e(t,e);function t(n){var r=e.call(this,n)||this;r.dirtyProps=["modules","formats","bounds","theme","children"],r.cleanProps=["id","className","style","placeholder","tabIndex","onChange","onChangeSelection","onFocus","onBlur","onKeyPress","onKeyDown","onKeyUp"],r.state={generation:0},r.selection=null,r.onEditorChange=function(a,i,o,l){var u,c,d,h;a==="text-change"?(c=(u=r).onEditorChangeText)===null||c===void 0||c.call(u,r.editor.root.innerHTML,i,l,r.unprivilegedEditor):a==="selection-change"&&((h=(d=r).onEditorChangeSelection)===null||h===void 0||h.call(d,i,l,r.unprivilegedEditor))};var s=r.isControlled()?n.value:n.defaultValue;return r.value=s??"",r}return t.prototype.validateProps=function(n){var r;if(Yo.default.Children.count(n.children)>1)throw new Error("The Quill editing area can only be composed of a single React element.");if(Yo.default.Children.count(n.children)){var s=Yo.default.Children.only(n.children);if(((r=s)===null||r===void 0?void 0:r.type)==="textarea")throw new Error("Quill does not support editing on a <textarea>. Use a <div> instead.")}if(this.lastDeltaChangeSet&&n.value===this.lastDeltaChangeSet)throw new Error("You are passing the `delta` object from the `onChange` event back as `value`. You most probably want `editor.getContents()` instead. See: https://github.com/zenoamaro/react-quill#using-deltas")},t.prototype.shouldComponentUpdate=function(n,r){var s=this,a;if(this.validateProps(n),!this.editor||this.state.generation!==r.generation)return!0;if("value"in n){var i=this.getEditorContents(),o=(a=n.value,a??"");this.isEqualValue(o,i)||this.setEditorContents(this.editor,o)}return n.readOnly!==this.props.readOnly&&this.setEditorReadOnly(this.editor,n.readOnly),t5e(this.cleanProps,this.dirtyProps).some(function(l){return!vv.default(n[l],s.props[l])})},t.prototype.shouldComponentRegenerate=function(n){var r=this;return this.dirtyProps.some(function(s){return!vv.default(n[s],r.props[s])})},t.prototype.componentDidMount=function(){this.instantiateEditor(),this.setEditorContents(this.editor,this.getEditorContents())},t.prototype.componentWillUnmount=function(){this.destroyEditor()},t.prototype.componentDidUpdate=function(n,r){var s=this;if(this.editor&&this.shouldComponentRegenerate(n)){var a=this.editor.getContents(),i=this.editor.getSelection();this.regenerationSnapshot={delta:a,selection:i},this.setState({generation:this.state.generation+1}),this.destroyEditor()}if(this.state.generation!==r.generation){var o=this.regenerationSnapshot,a=o.delta,l=o.selection;delete this.regenerationSnapshot,this.instantiateEditor();var u=this.editor;u.setContents(a),ij(function(){return s.setEditorSelection(u,l)})}},t.prototype.instantiateEditor=function(){this.editor?this.hookEditor(this.editor):this.editor=this.createEditor(this.getEditingArea(),this.getEditorConfig())},t.prototype.destroyEditor=function(){this.editor&&this.unhookEditor(this.editor)},t.prototype.isControlled=function(){return"value"in this.props},t.prototype.getEditorConfig=function(){return{bounds:this.props.bounds,formats:this.props.formats,modules:this.props.modules,placeholder:this.props.placeholder,readOnly:this.props.readOnly,scrollingContainer:this.props.scrollingContainer,tabIndex:this.props.tabIndex,theme:this.props.theme}},t.prototype.getEditor=function(){if(!this.editor)throw new Error("Accessing non-instantiated editor");return this.editor},t.prototype.createEditor=function(n,r){var s=new aj.default(n,r);return r.tabIndex!=null&&this.setEditorTabIndex(s,r.tabIndex),this.hookEditor(s),s},t.prototype.hookEditor=function(n){this.unprivilegedEditor=this.makeUnprivilegedEditor(n),n.on("editor-change",this.onEditorChange)},t.prototype.unhookEditor=function(n){n.off("editor-change",this.onEditorChange)},t.prototype.getEditorContents=function(){return this.value},t.prototype.getEditorSelection=function(){return this.selection},t.prototype.isDelta=function(n){return n&&n.ops},t.prototype.isEqualValue=function(n,r){return this.isDelta(n)&&this.isDelta(r)?vv.default(n.ops,r.ops):vv.default(n,r)},t.prototype.setEditorContents=function(n,r){var s=this;this.value=r;var a=this.getEditorSelection();typeof r=="string"?n.setContents(n.clipboard.convert(r)):n.setContents(r),ij(function(){return s.setEditorSelection(n,a)})},t.prototype.setEditorSelection=function(n,r){if(this.selection=r,r){var s=n.getLength();r.index=Math.max(0,Math.min(r.index,s-1)),r.length=Math.max(0,Math.min(r.length,s-1-r.index)),n.setSelection(r)}},t.prototype.setEditorTabIndex=function(n,r){var s,a;!((a=(s=n)===null||s===void 0?void 0:s.scroll)===null||a===void 0)&&a.domNode&&(n.scroll.domNode.tabIndex=r)},t.prototype.setEditorReadOnly=function(n,r){r?n.disable():n.enable()},t.prototype.makeUnprivilegedEditor=function(n){var r=n;return{getHTML:function(){return r.root.innerHTML},getLength:r.getLength.bind(r),getText:r.getText.bind(r),getContents:r.getContents.bind(r),getSelection:r.getSelection.bind(r),getBounds:r.getBounds.bind(r)}},t.prototype.getEditingArea=function(){if(!this.editingArea)throw new Error("Instantiating on missing editing area");var n=n5e.default.findDOMNode(this.editingArea);if(!n)throw new Error("Cannot find element for editing area");if(n.nodeType===3)throw new Error("Editing area cannot be a text node");return n},t.prototype.renderEditingArea=function(){var n=this,r=this.props,s=r.children,a=r.preserveWhitespace,i=this.state.generation,o={key:i,ref:function(l){n.editingArea=l}};return Yo.default.Children.count(s)?Yo.default.cloneElement(Yo.default.Children.only(s),o):a?Yo.default.createElement("pre",US({},o)):Yo.default.createElement("div",US({},o))},t.prototype.render=function(){var n;return Yo.default.createElement("div",{id:this.props.id,style:this.props.style,key:this.state.generation,className:"quill "+(n=this.props.className,n??""),onKeyPress:this.props.onKeyPress,onKeyDown:this.props.onKeyDown,onKeyUp:this.props.onKeyUp},this.renderEditingArea())},t.prototype.onEditorChangeText=function(n,r,s,a){var i,o;if(this.editor){var l=this.isDelta(this.value)?a.getContents():a.getHTML();l!==this.getEditorContents()&&(this.lastDeltaChangeSet=r,this.value=l,(o=(i=this.props).onChange)===null||o===void 0||o.call(i,n,r,s,a))}},t.prototype.onEditorChangeSelection=function(n,r,s){var a,i,o,l,u,c;if(this.editor){var d=this.getEditorSelection(),h=!d&&n,p=d&&!n;vv.default(n,d)||(this.selection=n,(i=(a=this.props).onChangeSelection)===null||i===void 0||i.call(a,n,r,s),h?(l=(o=this.props).onFocus)===null||l===void 0||l.call(o,n,r,s):p&&((c=(u=this.props).onBlur)===null||c===void 0||c.call(u,d,r,s)))}},t.prototype.focus=function(){this.editor&&this.editor.focus()},t.prototype.blur=function(){this.editor&&(this.selection=null,this.editor.blur())},t.displayName="React Quill",t.Quill=aj.default,t.defaultProps={theme:"snow",modules:{},readOnly:!1},t}(Yo.default.Component);function ij(e){Promise.resolve().then(e)}var s5e=r5e;const AJ=ey(s5e);function bi(){let e=new Date;return e.setHours(e.getHours()+1),e}async function a5e(){try{return Ym("webgl"),await Jm(),console.log("WebGL backend is compatible"),!0}catch(e){console.log("WebGL backend is not compatible:",e)}try{return Ym("wasm"),await Jm(),console.log(fF()),console.log("WASM backend is compatible"),!0}catch(e){console.log("WASM backend is not compatible:",e)}try{return Ym("cpu"),await Jm(),console.log("CPU backend is compatible"),!0}catch(e){console.log("CPU backend is not compatible:",e)}}const RJ=a5e();var i5e=o5e;function tg(e){return e instanceof Buffer?Buffer.from(e):new e.constructor(e.buffer.slice(),e.byteOffset,e.length)}function o5e(e){if(e=e||{},e.circles)return l5e(e);return e.proto?r:n;function t(s,a){for(var i=Object.keys(s),o=new Array(i.length),l=0;l<i.length;l++){var u=i[l],c=s[u];typeof c!="object"||c===null?o[u]=c:c instanceof Date?o[u]=new Date(c):ArrayBuffer.isView(c)?o[u]=tg(c):o[u]=a(c)}return o}function n(s){if(typeof s!="object"||s===null)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return t(s,n);if(s instanceof Map)return new Map(t(Array.from(s),n));if(s instanceof Set)return new Set(t(Array.from(s),n));var a={};for(var i in s)if(Object.hasOwnProperty.call(s,i)!==!1){var o=s[i];typeof o!="object"||o===null?a[i]=o:o instanceof Date?a[i]=new Date(o):o instanceof Map?a[i]=new Map(t(Array.from(o),n)):o instanceof Set?a[i]=new Set(t(Array.from(o),n)):ArrayBuffer.isView(o)?a[i]=tg(o):a[i]=n(o)}return a}function r(s){if(typeof s!="object"||s===null)return s;if(s instanceof Date)return new Date(s);if(Array.isArray(s))return t(s,r);if(s instanceof Map)return new Map(t(Array.from(s),r));if(s instanceof Set)return new Set(t(Array.from(s),r));var a={};for(var i in s){var o=s[i];typeof o!="object"||o===null?a[i]=o:o instanceof Date?a[i]=new Date(o):o instanceof Map?a[i]=new Map(t(Array.from(o),r)):o instanceof Set?a[i]=new Set(t(Array.from(o),r)):ArrayBuffer.isView(o)?a[i]=tg(o):a[i]=r(o)}return a}}function l5e(e){var t=[],n=[];return e.proto?a:s;function r(i,o){for(var l=Object.keys(i),u=new Array(l.length),c=0;c<l.length;c++){var d=l[c],h=i[d];if(typeof h!="object"||h===null)u[d]=h;else if(h instanceof Date)u[d]=new Date(h);else if(ArrayBuffer.isView(h))u[d]=tg(h);else{var p=t.indexOf(h);p!==-1?u[d]=n[p]:u[d]=o(h)}}return u}function s(i){if(typeof i!="object"||i===null)return i;if(i instanceof Date)return new Date(i);if(Array.isArray(i))return r(i,s);if(i instanceof Map)return new Map(r(Array.from(i),s));if(i instanceof Set)return new Set(r(Array.from(i),s));var o={};t.push(i),n.push(o);for(var l in i)if(Object.hasOwnProperty.call(i,l)!==!1){var u=i[l];if(typeof u!="object"||u===null)o[l]=u;else if(u instanceof Date)o[l]=new Date(u);else if(u instanceof Map)o[l]=new Map(r(Array.from(u),s));else if(u instanceof Set)o[l]=new Set(r(Array.from(u),s));else if(ArrayBuffer.isView(u))o[l]=tg(u);else{var c=t.indexOf(u);c!==-1?o[l]=n[c]:o[l]=s(u)}}return t.pop(),n.pop(),o}function a(i){if(typeof i!="object"||i===null)return i;if(i instanceof Date)return new Date(i);if(Array.isArray(i))return r(i,a);if(i instanceof Map)return new Map(r(Array.from(i),a));if(i instanceof Set)return new Set(r(Array.from(i),a));var o={};t.push(i),n.push(o);for(var l in i){var u=i[l];if(typeof u!="object"||u===null)o[l]=u;else if(u instanceof Date)o[l]=new Date(u);else if(u instanceof Map)o[l]=new Map(r(Array.from(u),a));else if(u instanceof Set)o[l]=new Set(r(Array.from(u),a));else if(ArrayBuffer.isView(u))o[l]=tg(u);else{var c=t.indexOf(u);c!==-1?o[l]=n[c]:o[l]=a(u)}}return t.pop(),n.pop(),o}}const DJ=ey(i5e);/**
 * @name codsen-utils
 * @fileoverview Various utility functions
 * @version 1.6.4
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/codsen-utils/}
 */DJ();function YA(e){if(e==null||typeof e!="object")return!1;let t=Object.getPrototypeOf(e);return t!==null&&t!==Object.prototype&&Object.getPrototypeOf(t)!==null?!1:!(Symbol.iterator in e)&&!(Symbol.toStringTag in e)}function km(e){return typeof e=="string"}function Pu(e){return Number.isSafeInteger(e)&&e>=0}function Lu(e){return e!=null}function u5e(e,t){return YA(e)&&km(t)&&t in e}var c5e=typeof global=="object"&&global&&global.Object===Object&&global;const d5e=c5e;var h5e=typeof self=="object"&&self&&self.Object===Object&&self,p5e=d5e||h5e||Function("return this")();const mM=p5e;var f5e=mM.Symbol;const Dg=f5e;var OJ=Object.prototype,m5e=OJ.hasOwnProperty,g5e=OJ.toString,xv=Dg?Dg.toStringTag:void 0;function y5e(e){var t=m5e.call(e,xv),n=e[xv];try{e[xv]=void 0;var r=!0}catch{}var s=g5e.call(e);return r&&(t?e[xv]=n:delete e[xv]),s}var b5e=Object.prototype,v5e=b5e.toString;function x5e(e){return v5e.call(e)}var w5e="[object Null]",k5e="[object Undefined]",oj=Dg?Dg.toStringTag:void 0;function FJ(e){return e==null?e===void 0?k5e:w5e:oj&&oj in Object(e)?y5e(e):x5e(e)}function MJ(e){return e!=null&&typeof e=="object"}var S5e="[object Symbol]";function I5e(e){return typeof e=="symbol"||MJ(e)&&FJ(e)==S5e}function PJ(e,t){for(var n=-1,r=e==null?0:e.length,s=Array(r);++n<r;)s[n]=t(e[n],n,e);return s}var C5e=Array.isArray;const N5e=C5e;var T5e=1/0,lj=Dg?Dg.prototype:void 0,uj=lj?lj.toString:void 0;function gM(e){if(typeof e=="string")return e;if(N5e(e))return PJ(e,gM)+"";if(I5e(e))return uj?uj.call(e):"";var t=e+"";return t=="0"&&1/e==-T5e?"-0":t}var $5e=/\s/;function E5e(e){for(var t=e.length;t--&&$5e.test(e.charAt(t)););return t}var _5e=/^\s+/;function A5e(e){return e&&e.slice(0,E5e(e)+1).replace(_5e,"")}function LJ(e){var t=typeof e;return e!=null&&(t=="object"||t=="function")}function zJ(e){return e}var R5e="[object AsyncFunction]",D5e="[object Function]",O5e="[object GeneratorFunction]",F5e="[object Proxy]";function BJ(e){if(!LJ(e))return!1;var t=FJ(e);return t==D5e||t==O5e||t==R5e||t==F5e}var M5e=mM["__core-js_shared__"];const kE=M5e;var cj=function(){var e=/[^.]+$/.exec(kE&&kE.keys&&kE.keys.IE_PROTO||"");return e?"Symbol(src)_1."+e:""}();function P5e(e){return!!cj&&cj in e}var L5e=Function.prototype,z5e=L5e.toString;function B5e(e){if(e!=null){try{return z5e.call(e)}catch{}try{return e+""}catch{}}return""}var W5e=/[\\^$.*+?()[\]{}|]/g,V5e=/^\[object .+?Constructor\]$/,U5e=Function.prototype,j5e=Object.prototype,G5e=U5e.toString,H5e=j5e.hasOwnProperty,q5e=RegExp("^"+G5e.call(H5e).replace(W5e,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");function K5e(e){if(!LJ(e)||P5e(e))return!1;var t=BJ(e)?q5e:V5e;return t.test(B5e(e))}function X5e(e,t){return e==null?void 0:e[t]}function yM(e,t){var n=X5e(e,t);return K5e(n)?n:void 0}function Y5e(e,t,n){switch(n.length){case 0:return e.call(t);case 1:return e.call(t,n[0]);case 2:return e.call(t,n[0],n[1]);case 3:return e.call(t,n[0],n[1],n[2])}return e.apply(t,n)}var J5e=800,Z5e=16,Q5e=Date.now;function e6e(e){var t=0,n=0;return function(){var r=Q5e(),s=Z5e-(r-n);if(n=r,s>0){if(++t>=J5e)return arguments[0]}else t=0;return e.apply(void 0,arguments)}}function t6e(e){return function(){return e}}var n6e=function(){try{var e=yM(Object,"defineProperty");return e({},"",{}),e}catch{}}();const dj=n6e;var r6e=dj?function(e,t){return dj(e,"toString",{configurable:!0,enumerable:!1,value:t6e(t),writable:!0})}:zJ;const s6e=r6e;var a6e=e6e(s6e);const i6e=a6e;function o6e(e,t,n,r){for(var s=e.length,a=n+(r?1:-1);r?a--:++a<s;)if(t(e[a],a,e))return a;return-1}function l6e(e){return e!==e}function u6e(e,t,n){for(var r=n-1,s=e.length;++r<s;)if(e[r]===t)return r;return-1}function bM(e,t,n){return t===t?u6e(e,t,n):o6e(e,l6e,n)}function c6e(e,t){var n=e==null?0:e.length;return!!n&&bM(e,t,0)>-1}function d6e(e,t){return e===t||e!==e&&t!==t}var hj=Math.max;function h6e(e,t,n){return t=hj(t===void 0?e.length-1:t,0),function(){for(var r=arguments,s=-1,a=hj(r.length-t,0),i=Array(a);++s<a;)i[s]=r[t+s];s=-1;for(var o=Array(t+1);++s<t;)o[s]=r[s];return o[t]=n(i),Y5e(e,this,o)}}function p6e(e,t){return i6e(h6e(e,t,zJ),e+"")}var f6e=9007199254740991;function m6e(e){return typeof e=="number"&&e>-1&&e%1==0&&e<=f6e}function g6e(e){return e!=null&&m6e(e.length)&&!BJ(e)}function y6e(e){return function(t){return e(t)}}var b6e=yM(Object,"create");const K1=b6e;function v6e(){this.__data__=K1?K1(null):{},this.size=0}function x6e(e){var t=this.has(e)&&delete this.__data__[e];return this.size-=t?1:0,t}var w6e="__lodash_hash_undefined__",k6e=Object.prototype,S6e=k6e.hasOwnProperty;function I6e(e){var t=this.__data__;if(K1){var n=t[e];return n===w6e?void 0:n}return S6e.call(t,e)?t[e]:void 0}var C6e=Object.prototype,N6e=C6e.hasOwnProperty;function T6e(e){var t=this.__data__;return K1?t[e]!==void 0:N6e.call(t,e)}var $6e="__lodash_hash_undefined__";function E6e(e,t){var n=this.__data__;return this.size+=this.has(e)?0:1,n[e]=K1&&t===void 0?$6e:t,this}function Vh(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Vh.prototype.clear=v6e;Vh.prototype.delete=x6e;Vh.prototype.get=I6e;Vh.prototype.has=T6e;Vh.prototype.set=E6e;function _6e(){this.__data__=[],this.size=0}function DN(e,t){for(var n=e.length;n--;)if(d6e(e[n][0],t))return n;return-1}var A6e=Array.prototype,R6e=A6e.splice;function D6e(e){var t=this.__data__,n=DN(t,e);if(n<0)return!1;var r=t.length-1;return n==r?t.pop():R6e.call(t,n,1),--this.size,!0}function O6e(e){var t=this.__data__,n=DN(t,e);return n<0?void 0:t[n][1]}function F6e(e){return DN(this.__data__,e)>-1}function M6e(e,t){var n=this.__data__,r=DN(n,e);return r<0?(++this.size,n.push([e,t])):n[r][1]=t,this}function Ay(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Ay.prototype.clear=_6e;Ay.prototype.delete=D6e;Ay.prototype.get=O6e;Ay.prototype.has=F6e;Ay.prototype.set=M6e;var P6e=yM(mM,"Map");const L6e=P6e;function z6e(){this.size=0,this.__data__={hash:new Vh,map:new(L6e||Ay),string:new Vh}}function B6e(e){var t=typeof e;return t=="string"||t=="number"||t=="symbol"||t=="boolean"?e!=="__proto__":e===null}function ON(e,t){var n=e.__data__;return B6e(t)?n[typeof t=="string"?"string":"hash"]:n.map}function W6e(e){var t=ON(this,e).delete(e);return this.size-=t?1:0,t}function V6e(e){return ON(this,e).get(e)}function U6e(e){return ON(this,e).has(e)}function j6e(e,t){var n=ON(this,e),r=n.size;return n.set(e,t),this.size+=n.size==r?0:1,this}function Ry(e){var t=-1,n=e==null?0:e.length;for(this.clear();++t<n;){var r=e[t];this.set(r[0],r[1])}}Ry.prototype.clear=z6e;Ry.prototype.delete=W6e;Ry.prototype.get=V6e;Ry.prototype.has=U6e;Ry.prototype.set=j6e;function G6e(e){return e==null?"":gM(e)}function H6e(e,t,n){var r=-1,s=e.length;t<0&&(t=-t>s?0:s+t),n=n>s?s:n,n<0&&(n+=s),s=t>n?0:n-t>>>0,t>>>=0;for(var a=Array(s);++r<s;)a[r]=e[r+t];return a}function q6e(e,t,n){var r=e.length;return n=n===void 0?r:n,!t&&n>=r?e:H6e(e,t,n)}var K6e="\\ud800-\\udfff",X6e="\\u0300-\\u036f",Y6e="\\ufe20-\\ufe2f",J6e="\\u20d0-\\u20ff",Z6e=X6e+Y6e+J6e,Q6e="\\ufe0e\\ufe0f",eGe="\\u200d",tGe=RegExp("["+eGe+K6e+Z6e+Q6e+"]");function nGe(e){return tGe.test(e)}function rGe(e){return e.split("")}var WJ="\\ud800-\\udfff",sGe="\\u0300-\\u036f",aGe="\\ufe20-\\ufe2f",iGe="\\u20d0-\\u20ff",oGe=sGe+aGe+iGe,lGe="\\ufe0e\\ufe0f",uGe="["+WJ+"]",JA="["+oGe+"]",ZA="\\ud83c[\\udffb-\\udfff]",cGe="(?:"+JA+"|"+ZA+")",VJ="[^"+WJ+"]",UJ="(?:\\ud83c[\\udde6-\\uddff]){2}",jJ="[\\ud800-\\udbff][\\udc00-\\udfff]",dGe="\\u200d",GJ=cGe+"?",HJ="["+lGe+"]?",hGe="(?:"+dGe+"(?:"+[VJ,UJ,jJ].join("|")+")"+HJ+GJ+")*",pGe=HJ+GJ+hGe,fGe="(?:"+[VJ+JA+"?",JA,UJ,jJ,uGe].join("|")+")",mGe=RegExp(ZA+"(?="+ZA+")|"+fGe+pGe,"g");function gGe(e){return e.match(mGe)||[]}function pj(e){return nGe(e)?gGe(e):rGe(e)}var yGe="__lodash_hash_undefined__";function bGe(e){return this.__data__.set(e,yGe),this}function vGe(e){return this.__data__.has(e)}function jS(e){var t=-1,n=e==null?0:e.length;for(this.__data__=new Ry;++t<n;)this.add(e[t])}jS.prototype.add=jS.prototype.push=bGe;jS.prototype.has=vGe;function xGe(e,t){return e.has(t)}function wGe(e){return MJ(e)&&g6e(e)}function kGe(e,t,n){for(var r=-1,s=e==null?0:e.length;++r<s;)if(n(t,e[r]))return!0;return!1}var SGe=200;function IGe(e,t,n,r){var s=-1,a=c6e,i=!0,o=e.length,l=[],u=t.length;if(!o)return l;n&&(t=PJ(t,y6e(n))),r?(a=kGe,i=!1):t.length>=SGe&&(a=xGe,i=!1,t=new jS(t));e:for(;++s<o;){var c=e[s],d=n==null?c:n(c);if(c=r||c!==0?c:0,i&&d===d){for(var h=u;h--;)if(t[h]===d)continue e;l.push(c)}else a(t,d,r)||l.push(c)}return l}function CGe(e,t){for(var n=e.length;n--&&bM(t,e[n],0)>-1;);return n}function NGe(e,t){for(var n=-1,r=e.length;++n<r&&bM(t,e[n],0)>-1;);return n}function fj(e,t,n){if(e=G6e(e),e&&(n||t===void 0))return A5e(e);if(!e||!(t=gM(t)))return e;var r=pj(e),s=pj(t),a=NGe(r,s),i=CGe(r,s)+1;return q6e(r,a,i).join("")}var TGe=p6e(function(e,t){return wGe(e)?IGe(e,t):[]});const $Ge=TGe;var FN={},MN={};Object.defineProperty(MN,"__esModule",{value:!0});MN.bodyRegExps={xml:/&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,html4:/&notin;|&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g,html5:/&centerdot;|&copysr;|&divideontimes;|&gtcc;|&gtcir;|&gtdot;|&gtlPar;|&gtquest;|&gtrapprox;|&gtrarr;|&gtrdot;|&gtreqless;|&gtreqqless;|&gtrless;|&gtrsim;|&ltcc;|&ltcir;|&ltdot;|&lthree;|&ltimes;|&ltlarr;|&ltquest;|&ltrPar;|&ltri;|&ltrie;|&ltrif;|&notin;|&notinE;|&notindot;|&notinva;|&notinvb;|&notinvc;|&notni;|&notniva;|&notnivb;|&notnivc;|&parallel;|&timesb;|&timesbar;|&timesd;|&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g};MN.namedReferences={xml:{entities:{"&lt;":"<","&gt;":">","&quot;":'"',"&apos;":"'","&amp;":"&"},characters:{"<":"&lt;",">":"&gt;",'"':"&quot;","'":"&apos;","&":"&amp;"}},html4:{entities:{"&apos;":"'","&nbsp":"","&nbsp;":"","&iexcl":"","&iexcl;":"","&cent":"","&cent;":"","&pound":"","&pound;":"","&curren":"","&curren;":"","&yen":"","&yen;":"","&brvbar":"","&brvbar;":"","&sect":"","&sect;":"","&uml":"","&uml;":"","&copy":"","&copy;":"","&ordf":"","&ordf;":"","&laquo":"","&laquo;":"","&not":"","&not;":"","&shy":"","&shy;":"","&reg":"","&reg;":"","&macr":"","&macr;":"","&deg":"","&deg;":"","&plusmn":"","&plusmn;":"","&sup2":"","&sup2;":"","&sup3":"","&sup3;":"","&acute":"","&acute;":"","&micro":"","&micro;":"","&para":"","&para;":"","&middot":"","&middot;":"","&cedil":"","&cedil;":"","&sup1":"","&sup1;":"","&ordm":"","&ordm;":"","&raquo":"","&raquo;":"","&frac14":"","&frac14;":"","&frac12":"","&frac12;":"","&frac34":"","&frac34;":"","&iquest":"","&iquest;":"","&Agrave":"","&Agrave;":"","&Aacute":"","&Aacute;":"","&Acirc":"","&Acirc;":"","&Atilde":"","&Atilde;":"","&Auml":"","&Auml;":"","&Aring":"","&Aring;":"","&AElig":"","&AElig;":"","&Ccedil":"","&Ccedil;":"","&Egrave":"","&Egrave;":"","&Eacute":"","&Eacute;":"","&Ecirc":"","&Ecirc;":"","&Euml":"","&Euml;":"","&Igrave":"","&Igrave;":"","&Iacute":"","&Iacute;":"","&Icirc":"","&Icirc;":"","&Iuml":"","&Iuml;":"","&ETH":"","&ETH;":"","&Ntilde":"","&Ntilde;":"","&Ograve":"","&Ograve;":"","&Oacute":"","&Oacute;":"","&Ocirc":"","&Ocirc;":"","&Otilde":"","&Otilde;":"","&Ouml":"","&Ouml;":"","&times":"","&times;":"","&Oslash":"","&Oslash;":"","&Ugrave":"","&Ugrave;":"","&Uacute":"","&Uacute;":"","&Ucirc":"","&Ucirc;":"","&Uuml":"","&Uuml;":"","&Yacute":"","&Yacute;":"","&THORN":"","&THORN;":"","&szlig":"","&szlig;":"","&agrave":"","&agrave;":"","&aacute":"","&aacute;":"","&acirc":"","&acirc;":"","&atilde":"","&atilde;":"","&auml":"","&auml;":"","&aring":"","&aring;":"","&aelig":"","&aelig;":"","&ccedil":"","&ccedil;":"","&egrave":"","&egrave;":"","&eacute":"","&eacute;":"","&ecirc":"","&ecirc;":"","&euml":"","&euml;":"","&igrave":"","&igrave;":"","&iacute":"","&iacute;":"","&icirc":"","&icirc;":"","&iuml":"","&iuml;":"","&eth":"","&eth;":"","&ntilde":"","&ntilde;":"","&ograve":"","&ograve;":"","&oacute":"","&oacute;":"","&ocirc":"","&ocirc;":"","&otilde":"","&otilde;":"","&ouml":"","&ouml;":"","&divide":"","&divide;":"","&oslash":"","&oslash;":"","&ugrave":"","&ugrave;":"","&uacute":"","&uacute;":"","&ucirc":"","&ucirc;":"","&uuml":"","&uuml;":"","&yacute":"","&yacute;":"","&thorn":"","&thorn;":"","&yuml":"","&yuml;":"","&quot":'"',"&quot;":'"',"&amp":"&","&amp;":"&","&lt":"<","&lt;":"<","&gt":">","&gt;":">","&OElig;":"","&oelig;":"","&Scaron;":"","&scaron;":"","&Yuml;":"","&circ;":"","&tilde;":"","&ensp;":"","&emsp;":"","&thinsp;":"","&zwnj;":"","&zwj;":"","&lrm;":"","&rlm;":"","&ndash;":"","&mdash;":"","&lsquo;":"","&rsquo;":"","&sbquo;":"","&ldquo;":"","&rdquo;":"","&bdquo;":"","&dagger;":"","&Dagger;":"","&permil;":"","&lsaquo;":"","&rsaquo;":"","&euro;":"","&fnof;":"","&Alpha;":"","&Beta;":"","&Gamma;":"","&Delta;":"","&Epsilon;":"","&Zeta;":"","&Eta;":"","&Theta;":"","&Iota;":"","&Kappa;":"","&Lambda;":"","&Mu;":"","&Nu;":"","&Xi;":"","&Omicron;":"","&Pi;":"","&Rho;":"","&Sigma;":"","&Tau;":"","&Upsilon;":"","&Phi;":"","&Chi;":"","&Psi;":"","&Omega;":"","&alpha;":"","&beta;":"","&gamma;":"","&delta;":"","&epsilon;":"","&zeta;":"","&eta;":"","&theta;":"","&iota;":"","&kappa;":"","&lambda;":"","&mu;":"","&nu;":"","&xi;":"","&omicron;":"","&pi;":"","&rho;":"","&sigmaf;":"","&sigma;":"","&tau;":"","&upsilon;":"","&phi;":"","&chi;":"","&psi;":"","&omega;":"","&thetasym;":"","&upsih;":"","&piv;":"","&bull;":"","&hellip;":"","&prime;":"","&Prime;":"","&oline;":"","&frasl;":"","&weierp;":"","&image;":"","&real;":"","&trade;":"","&alefsym;":"","&larr;":"","&uarr;":"","&rarr;":"","&darr;":"","&harr;":"","&crarr;":"","&lArr;":"","&uArr;":"","&rArr;":"","&dArr;":"","&hArr;":"","&forall;":"","&part;":"","&exist;":"","&empty;":"","&nabla;":"","&isin;":"","&notin;":"","&ni;":"","&prod;":"","&sum;":"","&minus;":"","&lowast;":"","&radic;":"","&prop;":"","&infin;":"","&ang;":"","&and;":"","&or;":"","&cap;":"","&cup;":"","&int;":"","&there4;":"","&sim;":"","&cong;":"","&asymp;":"","&ne;":"","&equiv;":"","&le;":"","&ge;":"","&sub;":"","&sup;":"","&nsub;":"","&sube;":"","&supe;":"","&oplus;":"","&otimes;":"","&perp;":"","&sdot;":"","&lceil;":"","&rceil;":"","&lfloor;":"","&rfloor;":"","&lang;":"","&rang;":"","&loz;":"","&spades;":"","&clubs;":"","&hearts;":"","&diams;":""},characters:{"'":"&apos;","":"&nbsp;","":"&iexcl;","":"&cent;","":"&pound;","":"&curren;","":"&yen;","":"&brvbar;","":"&sect;","":"&uml;","":"&copy;",:"&ordf;","":"&laquo;","":"&not;","":"&shy;","":"&reg;","":"&macr;","":"&deg;","":"&plusmn;","":"&sup2;","":"&sup3;","":"&acute;",:"&micro;","":"&para;","":"&middot;","":"&cedil;","":"&sup1;",:"&ordm;","":"&raquo;","":"&frac14;","":"&frac12;","":"&frac34;","":"&iquest;",:"&Agrave;",:"&Aacute;",:"&Acirc;",:"&Atilde;",:"&Auml;",:"&Aring;",:"&AElig;",:"&Ccedil;",:"&Egrave;",:"&Eacute;",:"&Ecirc;",:"&Euml;",:"&Igrave;",:"&Iacute;",:"&Icirc;",:"&Iuml;",:"&ETH;",:"&Ntilde;",:"&Ograve;",:"&Oacute;",:"&Ocirc;",:"&Otilde;",:"&Ouml;","":"&times;",:"&Oslash;",:"&Ugrave;",:"&Uacute;",:"&Ucirc;",:"&Uuml;",:"&Yacute;",:"&THORN;",:"&szlig;",:"&agrave;",:"&aacute;",:"&acirc;",:"&atilde;",:"&auml;",:"&aring;",:"&aelig;",:"&ccedil;",:"&egrave;",:"&eacute;",:"&ecirc;",:"&euml;",:"&igrave;",:"&iacute;",:"&icirc;",:"&iuml;",:"&eth;",:"&ntilde;",:"&ograve;",:"&oacute;",:"&ocirc;",:"&otilde;",:"&ouml;","":"&divide;",:"&oslash;",:"&ugrave;",:"&uacute;",:"&ucirc;",:"&uuml;",:"&yacute;",:"&thorn;",:"&yuml;",'"':"&quot;","&":"&amp;","<":"&lt;",">":"&gt;",:"&OElig;",:"&oelig;",:"&Scaron;",:"&scaron;",:"&Yuml;","":"&circ;","":"&tilde;","":"&ensp;","":"&emsp;","":"&thinsp;","":"&zwnj;","":"&zwj;","":"&lrm;","":"&rlm;","":"&ndash;","":"&mdash;","":"&lsquo;","":"&rsquo;","":"&sbquo;","":"&ldquo;","":"&rdquo;","":"&bdquo;","":"&dagger;","":"&Dagger;","":"&permil;","":"&lsaquo;","":"&rsaquo;","":"&euro;",:"&fnof;",:"&Alpha;",:"&Beta;",:"&Gamma;",:"&Delta;",:"&Epsilon;",:"&Zeta;",:"&Eta;",:"&Theta;",:"&Iota;",:"&Kappa;",:"&Lambda;",:"&Mu;",:"&Nu;",:"&Xi;",:"&Omicron;",:"&Pi;",:"&Rho;",:"&Sigma;",:"&Tau;",:"&Upsilon;",:"&Phi;",:"&Chi;",:"&Psi;",:"&Omega;",:"&alpha;",:"&beta;",:"&gamma;",:"&delta;",:"&epsilon;",:"&zeta;",:"&eta;",:"&theta;",:"&iota;",:"&kappa;",:"&lambda;",:"&mu;",:"&nu;",:"&xi;",:"&omicron;",:"&pi;",:"&rho;",:"&sigmaf;",:"&sigma;",:"&tau;",:"&upsilon;",:"&phi;",:"&chi;",:"&psi;",:"&omega;",:"&thetasym;",:"&upsih;",:"&piv;","":"&bull;","":"&hellip;","":"&prime;","":"&Prime;","":"&oline;","":"&frasl;","":"&weierp;",:"&image;",:"&real;","":"&trade;",:"&alefsym;","":"&larr;","":"&uarr;","":"&rarr;","":"&darr;","":"&harr;","":"&crarr;","":"&lArr;","":"&uArr;","":"&rArr;","":"&dArr;","":"&hArr;","":"&forall;","":"&part;","":"&exist;","":"&empty;","":"&nabla;","":"&isin;","":"&notin;","":"&ni;","":"&prod;","":"&sum;","":"&minus;","":"&lowast;","":"&radic;","":"&prop;","":"&infin;","":"&ang;","":"&and;","":"&or;","":"&cap;","":"&cup;","":"&int;","":"&there4;","":"&sim;","":"&cong;","":"&asymp;","":"&ne;","":"&equiv;","":"&le;","":"&ge;","":"&sub;","":"&sup;","":"&nsub;","":"&sube;","":"&supe;","":"&oplus;","":"&otimes;","":"&perp;","":"&sdot;","":"&lceil;","":"&rceil;","":"&lfloor;","":"&rfloor;","":"&lang;","":"&rang;","":"&loz;","":"&spades;","":"&clubs;","":"&hearts;","":"&diams;"}},html5:{entities:{"&AElig":"","&AElig;":"","&AMP":"&","&AMP;":"&","&Aacute":"","&Aacute;":"","&Abreve;":"","&Acirc":"","&Acirc;":"","&Acy;":"","&Afr;":"","&Agrave":"","&Agrave;":"","&Alpha;":"","&Amacr;":"","&And;":"","&Aogon;":"","&Aopf;":"","&ApplyFunction;":"","&Aring":"","&Aring;":"","&Ascr;":"","&Assign;":"","&Atilde":"","&Atilde;":"","&Auml":"","&Auml;":"","&Backslash;":"","&Barv;":"","&Barwed;":"","&Bcy;":"","&Because;":"","&Bernoullis;":"","&Beta;":"","&Bfr;":"","&Bopf;":"","&Breve;":"","&Bscr;":"","&Bumpeq;":"","&CHcy;":"","&COPY":"","&COPY;":"","&Cacute;":"","&Cap;":"","&CapitalDifferentialD;":"","&Cayleys;":"","&Ccaron;":"","&Ccedil":"","&Ccedil;":"","&Ccirc;":"","&Cconint;":"","&Cdot;":"","&Cedilla;":"","&CenterDot;":"","&Cfr;":"","&Chi;":"","&CircleDot;":"","&CircleMinus;":"","&CirclePlus;":"","&CircleTimes;":"","&ClockwiseContourIntegral;":"","&CloseCurlyDoubleQuote;":"","&CloseCurlyQuote;":"","&Colon;":"","&Colone;":"","&Congruent;":"","&Conint;":"","&ContourIntegral;":"","&Copf;":"","&Coproduct;":"","&CounterClockwiseContourIntegral;":"","&Cross;":"","&Cscr;":"","&Cup;":"","&CupCap;":"","&DD;":"","&DDotrahd;":"","&DJcy;":"","&DScy;":"","&DZcy;":"","&Dagger;":"","&Darr;":"","&Dashv;":"","&Dcaron;":"","&Dcy;":"","&Del;":"","&Delta;":"","&Dfr;":"","&DiacriticalAcute;":"","&DiacriticalDot;":"","&DiacriticalDoubleAcute;":"","&DiacriticalGrave;":"`","&DiacriticalTilde;":"","&Diamond;":"","&DifferentialD;":"","&Dopf;":"","&Dot;":"","&DotDot;":"","&DotEqual;":"","&DoubleContourIntegral;":"","&DoubleDot;":"","&DoubleDownArrow;":"","&DoubleLeftArrow;":"","&DoubleLeftRightArrow;":"","&DoubleLeftTee;":"","&DoubleLongLeftArrow;":"","&DoubleLongLeftRightArrow;":"","&DoubleLongRightArrow;":"","&DoubleRightArrow;":"","&DoubleRightTee;":"","&DoubleUpArrow;":"","&DoubleUpDownArrow;":"","&DoubleVerticalBar;":"","&DownArrow;":"","&DownArrowBar;":"","&DownArrowUpArrow;":"","&DownBreve;":"","&DownLeftRightVector;":"","&DownLeftTeeVector;":"","&DownLeftVector;":"","&DownLeftVectorBar;":"","&DownRightTeeVector;":"","&DownRightVector;":"","&DownRightVectorBar;":"","&DownTee;":"","&DownTeeArrow;":"","&Downarrow;":"","&Dscr;":"","&Dstrok;":"","&ENG;":"","&ETH":"","&ETH;":"","&Eacute":"","&Eacute;":"","&Ecaron;":"","&Ecirc":"","&Ecirc;":"","&Ecy;":"","&Edot;":"","&Efr;":"","&Egrave":"","&Egrave;":"","&Element;":"","&Emacr;":"","&EmptySmallSquare;":"","&EmptyVerySmallSquare;":"","&Eogon;":"","&Eopf;":"","&Epsilon;":"","&Equal;":"","&EqualTilde;":"","&Equilibrium;":"","&Escr;":"","&Esim;":"","&Eta;":"","&Euml":"","&Euml;":"","&Exists;":"","&ExponentialE;":"","&Fcy;":"","&Ffr;":"","&FilledSmallSquare;":"","&FilledVerySmallSquare;":"","&Fopf;":"","&ForAll;":"","&Fouriertrf;":"","&Fscr;":"","&GJcy;":"","&GT":">","&GT;":">","&Gamma;":"","&Gammad;":"","&Gbreve;":"","&Gcedil;":"","&Gcirc;":"","&Gcy;":"","&Gdot;":"","&Gfr;":"","&Gg;":"","&Gopf;":"","&GreaterEqual;":"","&GreaterEqualLess;":"","&GreaterFullEqual;":"","&GreaterGreater;":"","&GreaterLess;":"","&GreaterSlantEqual;":"","&GreaterTilde;":"","&Gscr;":"","&Gt;":"","&HARDcy;":"","&Hacek;":"","&Hat;":"^","&Hcirc;":"","&Hfr;":"","&HilbertSpace;":"","&Hopf;":"","&HorizontalLine;":"","&Hscr;":"","&Hstrok;":"","&HumpDownHump;":"","&HumpEqual;":"","&IEcy;":"","&IJlig;":"","&IOcy;":"","&Iacute":"","&Iacute;":"","&Icirc":"","&Icirc;":"","&Icy;":"","&Idot;":"","&Ifr;":"","&Igrave":"","&Igrave;":"","&Im;":"","&Imacr;":"","&ImaginaryI;":"","&Implies;":"","&Int;":"","&Integral;":"","&Intersection;":"","&InvisibleComma;":"","&InvisibleTimes;":"","&Iogon;":"","&Iopf;":"","&Iota;":"","&Iscr;":"","&Itilde;":"","&Iukcy;":"","&Iuml":"","&Iuml;":"","&Jcirc;":"","&Jcy;":"","&Jfr;":"","&Jopf;":"","&Jscr;":"","&Jsercy;":"","&Jukcy;":"","&KHcy;":"","&KJcy;":"","&Kappa;":"","&Kcedil;":"","&Kcy;":"","&Kfr;":"","&Kopf;":"","&Kscr;":"","&LJcy;":"","&LT":"<","&LT;":"<","&Lacute;":"","&Lambda;":"","&Lang;":"","&Laplacetrf;":"","&Larr;":"","&Lcaron;":"","&Lcedil;":"","&Lcy;":"","&LeftAngleBracket;":"","&LeftArrow;":"","&LeftArrowBar;":"","&LeftArrowRightArrow;":"","&LeftCeiling;":"","&LeftDoubleBracket;":"","&LeftDownTeeVector;":"","&LeftDownVector;":"","&LeftDownVectorBar;":"","&LeftFloor;":"","&LeftRightArrow;":"","&LeftRightVector;":"","&LeftTee;":"","&LeftTeeArrow;":"","&LeftTeeVector;":"","&LeftTriangle;":"","&LeftTriangleBar;":"","&LeftTriangleEqual;":"","&LeftUpDownVector;":"","&LeftUpTeeVector;":"","&LeftUpVector;":"","&LeftUpVectorBar;":"","&LeftVector;":"","&LeftVectorBar;":"","&Leftarrow;":"","&Leftrightarrow;":"","&LessEqualGreater;":"","&LessFullEqual;":"","&LessGreater;":"","&LessLess;":"","&LessSlantEqual;":"","&LessTilde;":"","&Lfr;":"","&Ll;":"","&Lleftarrow;":"","&Lmidot;":"","&LongLeftArrow;":"","&LongLeftRightArrow;":"","&LongRightArrow;":"","&Longleftarrow;":"","&Longleftrightarrow;":"","&Longrightarrow;":"","&Lopf;":"","&LowerLeftArrow;":"","&LowerRightArrow;":"","&Lscr;":"","&Lsh;":"","&Lstrok;":"","&Lt;":"","&Map;":"","&Mcy;":"","&MediumSpace;":"","&Mellintrf;":"","&Mfr;":"","&MinusPlus;":"","&Mopf;":"","&Mscr;":"","&Mu;":"","&NJcy;":"","&Nacute;":"","&Ncaron;":"","&Ncedil;":"","&Ncy;":"","&NegativeMediumSpace;":"","&NegativeThickSpace;":"","&NegativeThinSpace;":"","&NegativeVeryThinSpace;":"","&NestedGreaterGreater;":"","&NestedLessLess;":"","&NewLine;":`
`,"&Nfr;":"","&NoBreak;":"","&NonBreakingSpace;":"","&Nopf;":"","&Not;":"","&NotCongruent;":"","&NotCupCap;":"","&NotDoubleVerticalBar;":"","&NotElement;":"","&NotEqual;":"","&NotEqualTilde;":"","&NotExists;":"","&NotGreater;":"","&NotGreaterEqual;":"","&NotGreaterFullEqual;":"","&NotGreaterGreater;":"","&NotGreaterLess;":"","&NotGreaterSlantEqual;":"","&NotGreaterTilde;":"","&NotHumpDownHump;":"","&NotHumpEqual;":"","&NotLeftTriangle;":"","&NotLeftTriangleBar;":"","&NotLeftTriangleEqual;":"","&NotLess;":"","&NotLessEqual;":"","&NotLessGreater;":"","&NotLessLess;":"","&NotLessSlantEqual;":"","&NotLessTilde;":"","&NotNestedGreaterGreater;":"","&NotNestedLessLess;":"","&NotPrecedes;":"","&NotPrecedesEqual;":"","&NotPrecedesSlantEqual;":"","&NotReverseElement;":"","&NotRightTriangle;":"","&NotRightTriangleBar;":"","&NotRightTriangleEqual;":"","&NotSquareSubset;":"","&NotSquareSubsetEqual;":"","&NotSquareSuperset;":"","&NotSquareSupersetEqual;":"","&NotSubset;":"","&NotSubsetEqual;":"","&NotSucceeds;":"","&NotSucceedsEqual;":"","&NotSucceedsSlantEqual;":"","&NotSucceedsTilde;":"","&NotSuperset;":"","&NotSupersetEqual;":"","&NotTilde;":"","&NotTildeEqual;":"","&NotTildeFullEqual;":"","&NotTildeTilde;":"","&NotVerticalBar;":"","&Nscr;":"","&Ntilde":"","&Ntilde;":"","&Nu;":"","&OElig;":"","&Oacute":"","&Oacute;":"","&Ocirc":"","&Ocirc;":"","&Ocy;":"","&Odblac;":"","&Ofr;":"","&Ograve":"","&Ograve;":"","&Omacr;":"","&Omega;":"","&Omicron;":"","&Oopf;":"","&OpenCurlyDoubleQuote;":"","&OpenCurlyQuote;":"","&Or;":"","&Oscr;":"","&Oslash":"","&Oslash;":"","&Otilde":"","&Otilde;":"","&Otimes;":"","&Ouml":"","&Ouml;":"","&OverBar;":"","&OverBrace;":"","&OverBracket;":"","&OverParenthesis;":"","&PartialD;":"","&Pcy;":"","&Pfr;":"","&Phi;":"","&Pi;":"","&PlusMinus;":"","&Poincareplane;":"","&Popf;":"","&Pr;":"","&Precedes;":"","&PrecedesEqual;":"","&PrecedesSlantEqual;":"","&PrecedesTilde;":"","&Prime;":"","&Product;":"","&Proportion;":"","&Proportional;":"","&Pscr;":"","&Psi;":"","&QUOT":'"',"&QUOT;":'"',"&Qfr;":"","&Qopf;":"","&Qscr;":"","&RBarr;":"","&REG":"","&REG;":"","&Racute;":"","&Rang;":"","&Rarr;":"","&Rarrtl;":"","&Rcaron;":"","&Rcedil;":"","&Rcy;":"","&Re;":"","&ReverseElement;":"","&ReverseEquilibrium;":"","&ReverseUpEquilibrium;":"","&Rfr;":"","&Rho;":"","&RightAngleBracket;":"","&RightArrow;":"","&RightArrowBar;":"","&RightArrowLeftArrow;":"","&RightCeiling;":"","&RightDoubleBracket;":"","&RightDownTeeVector;":"","&RightDownVector;":"","&RightDownVectorBar;":"","&RightFloor;":"","&RightTee;":"","&RightTeeArrow;":"","&RightTeeVector;":"","&RightTriangle;":"","&RightTriangleBar;":"","&RightTriangleEqual;":"","&RightUpDownVector;":"","&RightUpTeeVector;":"","&RightUpVector;":"","&RightUpVectorBar;":"","&RightVector;":"","&RightVectorBar;":"","&Rightarrow;":"","&Ropf;":"","&RoundImplies;":"","&Rrightarrow;":"","&Rscr;":"","&Rsh;":"","&RuleDelayed;":"","&SHCHcy;":"","&SHcy;":"","&SOFTcy;":"","&Sacute;":"","&Sc;":"","&Scaron;":"","&Scedil;":"","&Scirc;":"","&Scy;":"","&Sfr;":"","&ShortDownArrow;":"","&ShortLeftArrow;":"","&ShortRightArrow;":"","&ShortUpArrow;":"","&Sigma;":"","&SmallCircle;":"","&Sopf;":"","&Sqrt;":"","&Square;":"","&SquareIntersection;":"","&SquareSubset;":"","&SquareSubsetEqual;":"","&SquareSuperset;":"","&SquareSupersetEqual;":"","&SquareUnion;":"","&Sscr;":"","&Star;":"","&Sub;":"","&Subset;":"","&SubsetEqual;":"","&Succeeds;":"","&SucceedsEqual;":"","&SucceedsSlantEqual;":"","&SucceedsTilde;":"","&SuchThat;":"","&Sum;":"","&Sup;":"","&Superset;":"","&SupersetEqual;":"","&Supset;":"","&THORN":"","&THORN;":"","&TRADE;":"","&TSHcy;":"","&TScy;":"","&Tab;":"	","&Tau;":"","&Tcaron;":"","&Tcedil;":"","&Tcy;":"","&Tfr;":"","&Therefore;":"","&Theta;":"","&ThickSpace;":"","&ThinSpace;":"","&Tilde;":"","&TildeEqual;":"","&TildeFullEqual;":"","&TildeTilde;":"","&Topf;":"","&TripleDot;":"","&Tscr;":"","&Tstrok;":"","&Uacute":"","&Uacute;":"","&Uarr;":"","&Uarrocir;":"","&Ubrcy;":"","&Ubreve;":"","&Ucirc":"","&Ucirc;":"","&Ucy;":"","&Udblac;":"","&Ufr;":"","&Ugrave":"","&Ugrave;":"","&Umacr;":"","&UnderBar;":"_","&UnderBrace;":"","&UnderBracket;":"","&UnderParenthesis;":"","&Union;":"","&UnionPlus;":"","&Uogon;":"","&Uopf;":"","&UpArrow;":"","&UpArrowBar;":"","&UpArrowDownArrow;":"","&UpDownArrow;":"","&UpEquilibrium;":"","&UpTee;":"","&UpTeeArrow;":"","&Uparrow;":"","&Updownarrow;":"","&UpperLeftArrow;":"","&UpperRightArrow;":"","&Upsi;":"","&Upsilon;":"","&Uring;":"","&Uscr;":"","&Utilde;":"","&Uuml":"","&Uuml;":"","&VDash;":"","&Vbar;":"","&Vcy;":"","&Vdash;":"","&Vdashl;":"","&Vee;":"","&Verbar;":"","&Vert;":"","&VerticalBar;":"","&VerticalLine;":"|","&VerticalSeparator;":"","&VerticalTilde;":"","&VeryThinSpace;":"","&Vfr;":"","&Vopf;":"","&Vscr;":"","&Vvdash;":"","&Wcirc;":"","&Wedge;":"","&Wfr;":"","&Wopf;":"","&Wscr;":"","&Xfr;":"","&Xi;":"","&Xopf;":"","&Xscr;":"","&YAcy;":"","&YIcy;":"","&YUcy;":"","&Yacute":"","&Yacute;":"","&Ycirc;":"","&Ycy;":"","&Yfr;":"","&Yopf;":"","&Yscr;":"","&Yuml;":"","&ZHcy;":"","&Zacute;":"","&Zcaron;":"","&Zcy;":"","&Zdot;":"","&ZeroWidthSpace;":"","&Zeta;":"","&Zfr;":"","&Zopf;":"","&Zscr;":"","&aacute":"","&aacute;":"","&abreve;":"","&ac;":"","&acE;":"","&acd;":"","&acirc":"","&acirc;":"","&acute":"","&acute;":"","&acy;":"","&aelig":"","&aelig;":"","&af;":"","&afr;":"","&agrave":"","&agrave;":"","&alefsym;":"","&aleph;":"","&alpha;":"","&amacr;":"","&amalg;":"","&amp":"&","&amp;":"&","&and;":"","&andand;":"","&andd;":"","&andslope;":"","&andv;":"","&ang;":"","&ange;":"","&angle;":"","&angmsd;":"","&angmsdaa;":"","&angmsdab;":"","&angmsdac;":"","&angmsdad;":"","&angmsdae;":"","&angmsdaf;":"","&angmsdag;":"","&angmsdah;":"","&angrt;":"","&angrtvb;":"","&angrtvbd;":"","&angsph;":"","&angst;":"","&angzarr;":"","&aogon;":"","&aopf;":"","&ap;":"","&apE;":"","&apacir;":"","&ape;":"","&apid;":"","&apos;":"'","&approx;":"","&approxeq;":"","&aring":"","&aring;":"","&ascr;":"","&ast;":"*","&asymp;":"","&asympeq;":"","&atilde":"","&atilde;":"","&auml":"","&auml;":"","&awconint;":"","&awint;":"","&bNot;":"","&backcong;":"","&backepsilon;":"","&backprime;":"","&backsim;":"","&backsimeq;":"","&barvee;":"","&barwed;":"","&barwedge;":"","&bbrk;":"","&bbrktbrk;":"","&bcong;":"","&bcy;":"","&bdquo;":"","&becaus;":"","&because;":"","&bemptyv;":"","&bepsi;":"","&bernou;":"","&beta;":"","&beth;":"","&between;":"","&bfr;":"","&bigcap;":"","&bigcirc;":"","&bigcup;":"","&bigodot;":"","&bigoplus;":"","&bigotimes;":"","&bigsqcup;":"","&bigstar;":"","&bigtriangledown;":"","&bigtriangleup;":"","&biguplus;":"","&bigvee;":"","&bigwedge;":"","&bkarow;":"","&blacklozenge;":"","&blacksquare;":"","&blacktriangle;":"","&blacktriangledown;":"","&blacktriangleleft;":"","&blacktriangleright;":"","&blank;":"","&blk12;":"","&blk14;":"","&blk34;":"","&block;":"","&bne;":"=","&bnequiv;":"","&bnot;":"","&bopf;":"","&bot;":"","&bottom;":"","&bowtie;":"","&boxDL;":"","&boxDR;":"","&boxDl;":"","&boxDr;":"","&boxH;":"","&boxHD;":"","&boxHU;":"","&boxHd;":"","&boxHu;":"","&boxUL;":"","&boxUR;":"","&boxUl;":"","&boxUr;":"","&boxV;":"","&boxVH;":"","&boxVL;":"","&boxVR;":"","&boxVh;":"","&boxVl;":"","&boxVr;":"","&boxbox;":"","&boxdL;":"","&boxdR;":"","&boxdl;":"","&boxdr;":"","&boxh;":"","&boxhD;":"","&boxhU;":"","&boxhd;":"","&boxhu;":"","&boxminus;":"","&boxplus;":"","&boxtimes;":"","&boxuL;":"","&boxuR;":"","&boxul;":"","&boxur;":"","&boxv;":"","&boxvH;":"","&boxvL;":"","&boxvR;":"","&boxvh;":"","&boxvl;":"","&boxvr;":"","&bprime;":"","&breve;":"","&brvbar":"","&brvbar;":"","&bscr;":"","&bsemi;":"","&bsim;":"","&bsime;":"","&bsol;":"\\","&bsolb;":"","&bsolhsub;":"","&bull;":"","&bullet;":"","&bump;":"","&bumpE;":"","&bumpe;":"","&bumpeq;":"","&cacute;":"","&cap;":"","&capand;":"","&capbrcup;":"","&capcap;":"","&capcup;":"","&capdot;":"","&caps;":"","&caret;":"","&caron;":"","&ccaps;":"","&ccaron;":"","&ccedil":"","&ccedil;":"","&ccirc;":"","&ccups;":"","&ccupssm;":"","&cdot;":"","&cedil":"","&cedil;":"","&cemptyv;":"","&cent":"","&cent;":"","&centerdot;":"","&cfr;":"","&chcy;":"","&check;":"","&checkmark;":"","&chi;":"","&cir;":"","&cirE;":"","&circ;":"","&circeq;":"","&circlearrowleft;":"","&circlearrowright;":"","&circledR;":"","&circledS;":"","&circledast;":"","&circledcirc;":"","&circleddash;":"","&cire;":"","&cirfnint;":"","&cirmid;":"","&cirscir;":"","&clubs;":"","&clubsuit;":"","&colon;":":","&colone;":"","&coloneq;":"","&comma;":",","&commat;":"@","&comp;":"","&compfn;":"","&complement;":"","&complexes;":"","&cong;":"","&congdot;":"","&conint;":"","&copf;":"","&coprod;":"","&copy":"","&copy;":"","&copysr;":"","&crarr;":"","&cross;":"","&cscr;":"","&csub;":"","&csube;":"","&csup;":"","&csupe;":"","&ctdot;":"","&cudarrl;":"","&cudarrr;":"","&cuepr;":"","&cuesc;":"","&cularr;":"","&cularrp;":"","&cup;":"","&cupbrcap;":"","&cupcap;":"","&cupcup;":"","&cupdot;":"","&cupor;":"","&cups;":"","&curarr;":"","&curarrm;":"","&curlyeqprec;":"","&curlyeqsucc;":"","&curlyvee;":"","&curlywedge;":"","&curren":"","&curren;":"","&curvearrowleft;":"","&curvearrowright;":"","&cuvee;":"","&cuwed;":"","&cwconint;":"","&cwint;":"","&cylcty;":"","&dArr;":"","&dHar;":"","&dagger;":"","&daleth;":"","&darr;":"","&dash;":"","&dashv;":"","&dbkarow;":"","&dblac;":"","&dcaron;":"","&dcy;":"","&dd;":"","&ddagger;":"","&ddarr;":"","&ddotseq;":"","&deg":"","&deg;":"","&delta;":"","&demptyv;":"","&dfisht;":"","&dfr;":"","&dharl;":"","&dharr;":"","&diam;":"","&diamond;":"","&diamondsuit;":"","&diams;":"","&die;":"","&digamma;":"","&disin;":"","&div;":"","&divide":"","&divide;":"","&divideontimes;":"","&divonx;":"","&djcy;":"","&dlcorn;":"","&dlcrop;":"","&dollar;":"$","&dopf;":"","&dot;":"","&doteq;":"","&doteqdot;":"","&dotminus;":"","&dotplus;":"","&dotsquare;":"","&doublebarwedge;":"","&downarrow;":"","&downdownarrows;":"","&downharpoonleft;":"","&downharpoonright;":"","&drbkarow;":"","&drcorn;":"","&drcrop;":"","&dscr;":"","&dscy;":"","&dsol;":"","&dstrok;":"","&dtdot;":"","&dtri;":"","&dtrif;":"","&duarr;":"","&duhar;":"","&dwangle;":"","&dzcy;":"","&dzigrarr;":"","&eDDot;":"","&eDot;":"","&eacute":"","&eacute;":"","&easter;":"","&ecaron;":"","&ecir;":"","&ecirc":"","&ecirc;":"","&ecolon;":"","&ecy;":"","&edot;":"","&ee;":"","&efDot;":"","&efr;":"","&eg;":"","&egrave":"","&egrave;":"","&egs;":"","&egsdot;":"","&el;":"","&elinters;":"","&ell;":"","&els;":"","&elsdot;":"","&emacr;":"","&empty;":"","&emptyset;":"","&emptyv;":"","&emsp13;":"","&emsp14;":"","&emsp;":"","&eng;":"","&ensp;":"","&eogon;":"","&eopf;":"","&epar;":"","&eparsl;":"","&eplus;":"","&epsi;":"","&epsilon;":"","&epsiv;":"","&eqcirc;":"","&eqcolon;":"","&eqsim;":"","&eqslantgtr;":"","&eqslantless;":"","&equals;":"=","&equest;":"","&equiv;":"","&equivDD;":"","&eqvparsl;":"","&erDot;":"","&erarr;":"","&escr;":"","&esdot;":"","&esim;":"","&eta;":"","&eth":"","&eth;":"","&euml":"","&euml;":"","&euro;":"","&excl;":"!","&exist;":"","&expectation;":"","&exponentiale;":"","&fallingdotseq;":"","&fcy;":"","&female;":"","&ffilig;":"","&fflig;":"","&ffllig;":"","&ffr;":"","&filig;":"","&fjlig;":"fj","&flat;":"","&fllig;":"","&fltns;":"","&fnof;":"","&fopf;":"","&forall;":"","&fork;":"","&forkv;":"","&fpartint;":"","&frac12":"","&frac12;":"","&frac13;":"","&frac14":"","&frac14;":"","&frac15;":"","&frac16;":"","&frac18;":"","&frac23;":"","&frac25;":"","&frac34":"","&frac34;":"","&frac35;":"","&frac38;":"","&frac45;":"","&frac56;":"","&frac58;":"","&frac78;":"","&frasl;":"","&frown;":"","&fscr;":"","&gE;":"","&gEl;":"","&gacute;":"","&gamma;":"","&gammad;":"","&gap;":"","&gbreve;":"","&gcirc;":"","&gcy;":"","&gdot;":"","&ge;":"","&gel;":"","&geq;":"","&geqq;":"","&geqslant;":"","&ges;":"","&gescc;":"","&gesdot;":"","&gesdoto;":"","&gesdotol;":"","&gesl;":"","&gesles;":"","&gfr;":"","&gg;":"","&ggg;":"","&gimel;":"","&gjcy;":"","&gl;":"","&glE;":"","&gla;":"","&glj;":"","&gnE;":"","&gnap;":"","&gnapprox;":"","&gne;":"","&gneq;":"","&gneqq;":"","&gnsim;":"","&gopf;":"","&grave;":"`","&gscr;":"","&gsim;":"","&gsime;":"","&gsiml;":"","&gt":">","&gt;":">","&gtcc;":"","&gtcir;":"","&gtdot;":"","&gtlPar;":"","&gtquest;":"","&gtrapprox;":"","&gtrarr;":"","&gtrdot;":"","&gtreqless;":"","&gtreqqless;":"","&gtrless;":"","&gtrsim;":"","&gvertneqq;":"","&gvnE;":"","&hArr;":"","&hairsp;":"","&half;":"","&hamilt;":"","&hardcy;":"","&harr;":"","&harrcir;":"","&harrw;":"","&hbar;":"","&hcirc;":"","&hearts;":"","&heartsuit;":"","&hellip;":"","&hercon;":"","&hfr;":"","&hksearow;":"","&hkswarow;":"","&hoarr;":"","&homtht;":"","&hookleftarrow;":"","&hookrightarrow;":"","&hopf;":"","&horbar;":"","&hscr;":"","&hslash;":"","&hstrok;":"","&hybull;":"","&hyphen;":"","&iacute":"","&iacute;":"","&ic;":"","&icirc":"","&icirc;":"","&icy;":"","&iecy;":"","&iexcl":"","&iexcl;":"","&iff;":"","&ifr;":"","&igrave":"","&igrave;":"","&ii;":"","&iiiint;":"","&iiint;":"","&iinfin;":"","&iiota;":"","&ijlig;":"","&imacr;":"","&image;":"","&imagline;":"","&imagpart;":"","&imath;":"","&imof;":"","&imped;":"","&in;":"","&incare;":"","&infin;":"","&infintie;":"","&inodot;":"","&int;":"","&intcal;":"","&integers;":"","&intercal;":"","&intlarhk;":"","&intprod;":"","&iocy;":"","&iogon;":"","&iopf;":"","&iota;":"","&iprod;":"","&iquest":"","&iquest;":"","&iscr;":"","&isin;":"","&isinE;":"","&isindot;":"","&isins;":"","&isinsv;":"","&isinv;":"","&it;":"","&itilde;":"","&iukcy;":"","&iuml":"","&iuml;":"","&jcirc;":"","&jcy;":"","&jfr;":"","&jmath;":"","&jopf;":"","&jscr;":"","&jsercy;":"","&jukcy;":"","&kappa;":"","&kappav;":"","&kcedil;":"","&kcy;":"","&kfr;":"","&kgreen;":"","&khcy;":"","&kjcy;":"","&kopf;":"","&kscr;":"","&lAarr;":"","&lArr;":"","&lAtail;":"","&lBarr;":"","&lE;":"","&lEg;":"","&lHar;":"","&lacute;":"","&laemptyv;":"","&lagran;":"","&lambda;":"","&lang;":"","&langd;":"","&langle;":"","&lap;":"","&laquo":"","&laquo;":"","&larr;":"","&larrb;":"","&larrbfs;":"","&larrfs;":"","&larrhk;":"","&larrlp;":"","&larrpl;":"","&larrsim;":"","&larrtl;":"","&lat;":"","&latail;":"","&late;":"","&lates;":"","&lbarr;":"","&lbbrk;":"","&lbrace;":"{","&lbrack;":"[","&lbrke;":"","&lbrksld;":"","&lbrkslu;":"","&lcaron;":"","&lcedil;":"","&lceil;":"","&lcub;":"{","&lcy;":"","&ldca;":"","&ldquo;":"","&ldquor;":"","&ldrdhar;":"","&ldrushar;":"","&ldsh;":"","&le;":"","&leftarrow;":"","&leftarrowtail;":"","&leftharpoondown;":"","&leftharpoonup;":"","&leftleftarrows;":"","&leftrightarrow;":"","&leftrightarrows;":"","&leftrightharpoons;":"","&leftrightsquigarrow;":"","&leftthreetimes;":"","&leg;":"","&leq;":"","&leqq;":"","&leqslant;":"","&les;":"","&lescc;":"","&lesdot;":"","&lesdoto;":"","&lesdotor;":"","&lesg;":"","&lesges;":"","&lessapprox;":"","&lessdot;":"","&lesseqgtr;":"","&lesseqqgtr;":"","&lessgtr;":"","&lesssim;":"","&lfisht;":"","&lfloor;":"","&lfr;":"","&lg;":"","&lgE;":"","&lhard;":"","&lharu;":"","&lharul;":"","&lhblk;":"","&ljcy;":"","&ll;":"","&llarr;":"","&llcorner;":"","&llhard;":"","&lltri;":"","&lmidot;":"","&lmoust;":"","&lmoustache;":"","&lnE;":"","&lnap;":"","&lnapprox;":"","&lne;":"","&lneq;":"","&lneqq;":"","&lnsim;":"","&loang;":"","&loarr;":"","&lobrk;":"","&longleftarrow;":"","&longleftrightarrow;":"","&longmapsto;":"","&longrightarrow;":"","&looparrowleft;":"","&looparrowright;":"","&lopar;":"","&lopf;":"","&loplus;":"","&lotimes;":"","&lowast;":"","&lowbar;":"_","&loz;":"","&lozenge;":"","&lozf;":"","&lpar;":"(","&lparlt;":"","&lrarr;":"","&lrcorner;":"","&lrhar;":"","&lrhard;":"","&lrm;":"","&lrtri;":"","&lsaquo;":"","&lscr;":"","&lsh;":"","&lsim;":"","&lsime;":"","&lsimg;":"","&lsqb;":"[","&lsquo;":"","&lsquor;":"","&lstrok;":"","&lt":"<","&lt;":"<","&ltcc;":"","&ltcir;":"","&ltdot;":"","&lthree;":"","&ltimes;":"","&ltlarr;":"","&ltquest;":"","&ltrPar;":"","&ltri;":"","&ltrie;":"","&ltrif;":"","&lurdshar;":"","&luruhar;":"","&lvertneqq;":"","&lvnE;":"","&mDDot;":"","&macr":"","&macr;":"","&male;":"","&malt;":"","&maltese;":"","&map;":"","&mapsto;":"","&mapstodown;":"","&mapstoleft;":"","&mapstoup;":"","&marker;":"","&mcomma;":"","&mcy;":"","&mdash;":"","&measuredangle;":"","&mfr;":"","&mho;":"","&micro":"","&micro;":"","&mid;":"","&midast;":"*","&midcir;":"","&middot":"","&middot;":"","&minus;":"","&minusb;":"","&minusd;":"","&minusdu;":"","&mlcp;":"","&mldr;":"","&mnplus;":"","&models;":"","&mopf;":"","&mp;":"","&mscr;":"","&mstpos;":"","&mu;":"","&multimap;":"","&mumap;":"","&nGg;":"","&nGt;":"","&nGtv;":"","&nLeftarrow;":"","&nLeftrightarrow;":"","&nLl;":"","&nLt;":"","&nLtv;":"","&nRightarrow;":"","&nVDash;":"","&nVdash;":"","&nabla;":"","&nacute;":"","&nang;":"","&nap;":"","&napE;":"","&napid;":"","&napos;":"","&napprox;":"","&natur;":"","&natural;":"","&naturals;":"","&nbsp":"","&nbsp;":"","&nbump;":"","&nbumpe;":"","&ncap;":"","&ncaron;":"","&ncedil;":"","&ncong;":"","&ncongdot;":"","&ncup;":"","&ncy;":"","&ndash;":"","&ne;":"","&neArr;":"","&nearhk;":"","&nearr;":"","&nearrow;":"","&nedot;":"","&nequiv;":"","&nesear;":"","&nesim;":"","&nexist;":"","&nexists;":"","&nfr;":"","&ngE;":"","&nge;":"","&ngeq;":"","&ngeqq;":"","&ngeqslant;":"","&nges;":"","&ngsim;":"","&ngt;":"","&ngtr;":"","&nhArr;":"","&nharr;":"","&nhpar;":"","&ni;":"","&nis;":"","&nisd;":"","&niv;":"","&njcy;":"","&nlArr;":"","&nlE;":"","&nlarr;":"","&nldr;":"","&nle;":"","&nleftarrow;":"","&nleftrightarrow;":"","&nleq;":"","&nleqq;":"","&nleqslant;":"","&nles;":"","&nless;":"","&nlsim;":"","&nlt;":"","&nltri;":"","&nltrie;":"","&nmid;":"","&nopf;":"","&not":"","&not;":"","&notin;":"","&notinE;":"","&notindot;":"","&notinva;":"","&notinvb;":"","&notinvc;":"","&notni;":"","&notniva;":"","&notnivb;":"","&notnivc;":"","&npar;":"","&nparallel;":"","&nparsl;":"","&npart;":"","&npolint;":"","&npr;":"","&nprcue;":"","&npre;":"","&nprec;":"","&npreceq;":"","&nrArr;":"","&nrarr;":"","&nrarrc;":"","&nrarrw;":"","&nrightarrow;":"","&nrtri;":"","&nrtrie;":"","&nsc;":"","&nsccue;":"","&nsce;":"","&nscr;":"","&nshortmid;":"","&nshortparallel;":"","&nsim;":"","&nsime;":"","&nsimeq;":"","&nsmid;":"","&nspar;":"","&nsqsube;":"","&nsqsupe;":"","&nsub;":"","&nsubE;":"","&nsube;":"","&nsubset;":"","&nsubseteq;":"","&nsubseteqq;":"","&nsucc;":"","&nsucceq;":"","&nsup;":"","&nsupE;":"","&nsupe;":"","&nsupset;":"","&nsupseteq;":"","&nsupseteqq;":"","&ntgl;":"","&ntilde":"","&ntilde;":"","&ntlg;":"","&ntriangleleft;":"","&ntrianglelefteq;":"","&ntriangleright;":"","&ntrianglerighteq;":"","&nu;":"","&num;":"#","&numero;":"","&numsp;":"","&nvDash;":"","&nvHarr;":"","&nvap;":"","&nvdash;":"","&nvge;":"","&nvgt;":">","&nvinfin;":"","&nvlArr;":"","&nvle;":"","&nvlt;":"<","&nvltrie;":"","&nvrArr;":"","&nvrtrie;":"","&nvsim;":"","&nwArr;":"","&nwarhk;":"","&nwarr;":"","&nwarrow;":"","&nwnear;":"","&oS;":"","&oacute":"","&oacute;":"","&oast;":"","&ocir;":"","&ocirc":"","&ocirc;":"","&ocy;":"","&odash;":"","&odblac;":"","&odiv;":"","&odot;":"","&odsold;":"","&oelig;":"","&ofcir;":"","&ofr;":"","&ogon;":"","&ograve":"","&ograve;":"","&ogt;":"","&ohbar;":"","&ohm;":"","&oint;":"","&olarr;":"","&olcir;":"","&olcross;":"","&oline;":"","&olt;":"","&omacr;":"","&omega;":"","&omicron;":"","&omid;":"","&ominus;":"","&oopf;":"","&opar;":"","&operp;":"","&oplus;":"","&or;":"","&orarr;":"","&ord;":"","&order;":"","&orderof;":"","&ordf":"","&ordf;":"","&ordm":"","&ordm;":"","&origof;":"","&oror;":"","&orslope;":"","&orv;":"","&oscr;":"","&oslash":"","&oslash;":"","&osol;":"","&otilde":"","&otilde;":"","&otimes;":"","&otimesas;":"","&ouml":"","&ouml;":"","&ovbar;":"","&par;":"","&para":"","&para;":"","&parallel;":"","&parsim;":"","&parsl;":"","&part;":"","&pcy;":"","&percnt;":"%","&period;":".","&permil;":"","&perp;":"","&pertenk;":"","&pfr;":"","&phi;":"","&phiv;":"","&phmmat;":"","&phone;":"","&pi;":"","&pitchfork;":"","&piv;":"","&planck;":"","&planckh;":"","&plankv;":"","&plus;":"+","&plusacir;":"","&plusb;":"","&pluscir;":"","&plusdo;":"","&plusdu;":"","&pluse;":"","&plusmn":"","&plusmn;":"","&plussim;":"","&plustwo;":"","&pm;":"","&pointint;":"","&popf;":"","&pound":"","&pound;":"","&pr;":"","&prE;":"","&prap;":"","&prcue;":"","&pre;":"","&prec;":"","&precapprox;":"","&preccurlyeq;":"","&preceq;":"","&precnapprox;":"","&precneqq;":"","&precnsim;":"","&precsim;":"","&prime;":"","&primes;":"","&prnE;":"","&prnap;":"","&prnsim;":"","&prod;":"","&profalar;":"","&profline;":"","&profsurf;":"","&prop;":"","&propto;":"","&prsim;":"","&prurel;":"","&pscr;":"","&psi;":"","&puncsp;":"","&qfr;":"","&qint;":"","&qopf;":"","&qprime;":"","&qscr;":"","&quaternions;":"","&quatint;":"","&quest;":"?","&questeq;":"","&quot":'"',"&quot;":'"',"&rAarr;":"","&rArr;":"","&rAtail;":"","&rBarr;":"","&rHar;":"","&race;":"","&racute;":"","&radic;":"","&raemptyv;":"","&rang;":"","&rangd;":"","&range;":"","&rangle;":"","&raquo":"","&raquo;":"","&rarr;":"","&rarrap;":"","&rarrb;":"","&rarrbfs;":"","&rarrc;":"","&rarrfs;":"","&rarrhk;":"","&rarrlp;":"","&rarrpl;":"","&rarrsim;":"","&rarrtl;":"","&rarrw;":"","&ratail;":"","&ratio;":"","&rationals;":"","&rbarr;":"","&rbbrk;":"","&rbrace;":"}","&rbrack;":"]","&rbrke;":"","&rbrksld;":"","&rbrkslu;":"","&rcaron;":"","&rcedil;":"","&rceil;":"","&rcub;":"}","&rcy;":"","&rdca;":"","&rdldhar;":"","&rdquo;":"","&rdquor;":"","&rdsh;":"","&real;":"","&realine;":"","&realpart;":"","&reals;":"","&rect;":"","&reg":"","&reg;":"","&rfisht;":"","&rfloor;":"","&rfr;":"","&rhard;":"","&rharu;":"","&rharul;":"","&rho;":"","&rhov;":"","&rightarrow;":"","&rightarrowtail;":"","&rightharpoondown;":"","&rightharpoonup;":"","&rightleftarrows;":"","&rightleftharpoons;":"","&rightrightarrows;":"","&rightsquigarrow;":"","&rightthreetimes;":"","&ring;":"","&risingdotseq;":"","&rlarr;":"","&rlhar;":"","&rlm;":"","&rmoust;":"","&rmoustache;":"","&rnmid;":"","&roang;":"","&roarr;":"","&robrk;":"","&ropar;":"","&ropf;":"","&roplus;":"","&rotimes;":"","&rpar;":")","&rpargt;":"","&rppolint;":"","&rrarr;":"","&rsaquo;":"","&rscr;":"","&rsh;":"","&rsqb;":"]","&rsquo;":"","&rsquor;":"","&rthree;":"","&rtimes;":"","&rtri;":"","&rtrie;":"","&rtrif;":"","&rtriltri;":"","&ruluhar;":"","&rx;":"","&sacute;":"","&sbquo;":"","&sc;":"","&scE;":"","&scap;":"","&scaron;":"","&sccue;":"","&sce;":"","&scedil;":"","&scirc;":"","&scnE;":"","&scnap;":"","&scnsim;":"","&scpolint;":"","&scsim;":"","&scy;":"","&sdot;":"","&sdotb;":"","&sdote;":"","&seArr;":"","&searhk;":"","&searr;":"","&searrow;":"","&sect":"","&sect;":"","&semi;":";","&seswar;":"","&setminus;":"","&setmn;":"","&sext;":"","&sfr;":"","&sfrown;":"","&sharp;":"","&shchcy;":"","&shcy;":"","&shortmid;":"","&shortparallel;":"","&shy":"","&shy;":"","&sigma;":"","&sigmaf;":"","&sigmav;":"","&sim;":"","&simdot;":"","&sime;":"","&simeq;":"","&simg;":"","&simgE;":"","&siml;":"","&simlE;":"","&simne;":"","&simplus;":"","&simrarr;":"","&slarr;":"","&smallsetminus;":"","&smashp;":"","&smeparsl;":"","&smid;":"","&smile;":"","&smt;":"","&smte;":"","&smtes;":"","&softcy;":"","&sol;":"/","&solb;":"","&solbar;":"","&sopf;":"","&spades;":"","&spadesuit;":"","&spar;":"","&sqcap;":"","&sqcaps;":"","&sqcup;":"","&sqcups;":"","&sqsub;":"","&sqsube;":"","&sqsubset;":"","&sqsubseteq;":"","&sqsup;":"","&sqsupe;":"","&sqsupset;":"","&sqsupseteq;":"","&squ;":"","&square;":"","&squarf;":"","&squf;":"","&srarr;":"","&sscr;":"","&ssetmn;":"","&ssmile;":"","&sstarf;":"","&star;":"","&starf;":"","&straightepsilon;":"","&straightphi;":"","&strns;":"","&sub;":"","&subE;":"","&subdot;":"","&sube;":"","&subedot;":"","&submult;":"","&subnE;":"","&subne;":"","&subplus;":"","&subrarr;":"","&subset;":"","&subseteq;":"","&subseteqq;":"","&subsetneq;":"","&subsetneqq;":"","&subsim;":"","&subsub;":"","&subsup;":"","&succ;":"","&succapprox;":"","&succcurlyeq;":"","&succeq;":"","&succnapprox;":"","&succneqq;":"","&succnsim;":"","&succsim;":"","&sum;":"","&sung;":"","&sup1":"","&sup1;":"","&sup2":"","&sup2;":"","&sup3":"","&sup3;":"","&sup;":"","&supE;":"","&supdot;":"","&supdsub;":"","&supe;":"","&supedot;":"","&suphsol;":"","&suphsub;":"","&suplarr;":"","&supmult;":"","&supnE;":"","&supne;":"","&supplus;":"","&supset;":"","&supseteq;":"","&supseteqq;":"","&supsetneq;":"","&supsetneqq;":"","&supsim;":"","&supsub;":"","&supsup;":"","&swArr;":"","&swarhk;":"","&swarr;":"","&swarrow;":"","&swnwar;":"","&szlig":"","&szlig;":"","&target;":"","&tau;":"","&tbrk;":"","&tcaron;":"","&tcedil;":"","&tcy;":"","&tdot;":"","&telrec;":"","&tfr;":"","&there4;":"","&therefore;":"","&theta;":"","&thetasym;":"","&thetav;":"","&thickapprox;":"","&thicksim;":"","&thinsp;":"","&thkap;":"","&thksim;":"","&thorn":"","&thorn;":"","&tilde;":"","&times":"","&times;":"","&timesb;":"","&timesbar;":"","&timesd;":"","&tint;":"","&toea;":"","&top;":"","&topbot;":"","&topcir;":"","&topf;":"","&topfork;":"","&tosa;":"","&tprime;":"","&trade;":"","&triangle;":"","&triangledown;":"","&triangleleft;":"","&trianglelefteq;":"","&triangleq;":"","&triangleright;":"","&trianglerighteq;":"","&tridot;":"","&trie;":"","&triminus;":"","&triplus;":"","&trisb;":"","&tritime;":"","&trpezium;":"","&tscr;":"","&tscy;":"","&tshcy;":"","&tstrok;":"","&twixt;":"","&twoheadleftarrow;":"","&twoheadrightarrow;":"","&uArr;":"","&uHar;":"","&uacute":"","&uacute;":"","&uarr;":"","&ubrcy;":"","&ubreve;":"","&ucirc":"","&ucirc;":"","&ucy;":"","&udarr;":"","&udblac;":"","&udhar;":"","&ufisht;":"","&ufr;":"","&ugrave":"","&ugrave;":"","&uharl;":"","&uharr;":"","&uhblk;":"","&ulcorn;":"","&ulcorner;":"","&ulcrop;":"","&ultri;":"","&umacr;":"","&uml":"","&uml;":"","&uogon;":"","&uopf;":"","&uparrow;":"","&updownarrow;":"","&upharpoonleft;":"","&upharpoonright;":"","&uplus;":"","&upsi;":"","&upsih;":"","&upsilon;":"","&upuparrows;":"","&urcorn;":"","&urcorner;":"","&urcrop;":"","&uring;":"","&urtri;":"","&uscr;":"","&utdot;":"","&utilde;":"","&utri;":"","&utrif;":"","&uuarr;":"","&uuml":"","&uuml;":"","&uwangle;":"","&vArr;":"","&vBar;":"","&vBarv;":"","&vDash;":"","&vangrt;":"","&varepsilon;":"","&varkappa;":"","&varnothing;":"","&varphi;":"","&varpi;":"","&varpropto;":"","&varr;":"","&varrho;":"","&varsigma;":"","&varsubsetneq;":"","&varsubsetneqq;":"","&varsupsetneq;":"","&varsupsetneqq;":"","&vartheta;":"","&vartriangleleft;":"","&vartriangleright;":"","&vcy;":"","&vdash;":"","&vee;":"","&veebar;":"","&veeeq;":"","&vellip;":"","&verbar;":"|","&vert;":"|","&vfr;":"","&vltri;":"","&vnsub;":"","&vnsup;":"","&vopf;":"","&vprop;":"","&vrtri;":"","&vscr;":"","&vsubnE;":"","&vsubne;":"","&vsupnE;":"","&vsupne;":"","&vzigzag;":"","&wcirc;":"","&wedbar;":"","&wedge;":"","&wedgeq;":"","&weierp;":"","&wfr;":"","&wopf;":"","&wp;":"","&wr;":"","&wreath;":"","&wscr;":"","&xcap;":"","&xcirc;":"","&xcup;":"","&xdtri;":"","&xfr;":"","&xhArr;":"","&xharr;":"","&xi;":"","&xlArr;":"","&xlarr;":"","&xmap;":"","&xnis;":"","&xodot;":"","&xopf;":"","&xoplus;":"","&xotime;":"","&xrArr;":"","&xrarr;":"","&xscr;":"","&xsqcup;":"","&xuplus;":"","&xutri;":"","&xvee;":"","&xwedge;":"","&yacute":"","&yacute;":"","&yacy;":"","&ycirc;":"","&ycy;":"","&yen":"","&yen;":"","&yfr;":"","&yicy;":"","&yopf;":"","&yscr;":"","&yucy;":"","&yuml":"","&yuml;":"","&zacute;":"","&zcaron;":"","&zcy;":"","&zdot;":"","&zeetrf;":"","&zeta;":"","&zfr;":"","&zhcy;":"","&zigrarr;":"","&zopf;":"","&zscr;":"","&zwj;":"","&zwnj;":""},characters:{:"&AElig;","&":"&amp;",:"&Aacute;",:"&Abreve;",:"&Acirc;",:"&Acy;","":"&Afr;",:"&Agrave;",:"&Alpha;",:"&Amacr;","":"&And;",:"&Aogon;","":"&Aopf;","":"&af;",:"&angst;","":"&Ascr;","":"&coloneq;",:"&Atilde;",:"&Auml;","":"&ssetmn;","":"&Barv;","":"&doublebarwedge;",:"&Bcy;","":"&because;",:"&bernou;",:"&Beta;","":"&Bfr;","":"&Bopf;","":"&breve;","":"&bump;",:"&CHcy;","":"&copy;",:"&Cacute;","":"&Cap;","":"&DD;",:"&Cfr;",:"&Ccaron;",:"&Ccedil;",:"&Ccirc;","":"&Cconint;",:"&Cdot;","":"&cedil;","":"&middot;",:"&Chi;","":"&odot;","":"&ominus;","":"&oplus;","":"&otimes;","":"&cwconint;","":"&rdquor;","":"&rsquor;","":"&Proportion;","":"&Colone;","":"&equiv;","":"&DoubleContourIntegral;","":"&oint;",:"&complexes;","":"&coprod;","":"&awconint;","":"&Cross;","":"&Cscr;","":"&Cup;","":"&asympeq;","":"&DDotrahd;",:"&DJcy;",:"&DScy;",:"&DZcy;","":"&ddagger;","":"&Darr;","":"&DoubleLeftTee;",:"&Dcaron;",:"&Dcy;","":"&nabla;",:"&Delta;","":"&Dfr;","":"&acute;","":"&dot;","":"&dblac;","`":"&grave;","":"&tilde;","":"&diamond;","":"&dd;","":"&Dopf;","":"&uml;","":"&DotDot;","":"&esdot;","":"&dArr;","":"&lArr;","":"&iff;","":"&xlArr;","":"&xhArr;","":"&xrArr;","":"&rArr;","":"&vDash;","":"&uArr;","":"&vArr;","":"&spar;","":"&downarrow;","":"&DownArrowBar;","":"&duarr;","":"&DownBreve;","":"&DownLeftRightVector;","":"&DownLeftTeeVector;","":"&lhard;","":"&DownLeftVectorBar;","":"&DownRightTeeVector;","":"&rightharpoondown;","":"&DownRightVectorBar;","":"&top;","":"&mapstodown;","":"&Dscr;",:"&Dstrok;",:"&ENG;",:"&ETH;",:"&Eacute;",:"&Ecaron;",:"&Ecirc;",:"&Ecy;",:"&Edot;","":"&Efr;",:"&Egrave;","":"&isinv;",:"&Emacr;","":"&EmptySmallSquare;","":"&EmptyVerySmallSquare;",:"&Eogon;","":"&Eopf;",:"&Epsilon;","":"&Equal;","":"&esim;","":"&rlhar;",:"&expectation;","":"&Esim;",:"&Eta;",:"&Euml;","":"&exist;","":"&exponentiale;",:"&Fcy;","":"&Ffr;","":"&FilledSmallSquare;","":"&squf;","":"&Fopf;","":"&forall;",:"&Fscr;",:"&GJcy;",">":"&gt;",:"&Gamma;",:"&Gammad;",:"&Gbreve;",:"&Gcedil;",:"&Gcirc;",:"&Gcy;",:"&Gdot;","":"&Gfr;","":"&ggg;","":"&Gopf;","":"&geq;","":"&gtreqless;","":"&geqq;","":"&GreaterGreater;","":"&gtrless;","":"&ges;","":"&gtrsim;","":"&Gscr;","":"&gg;",:"&HARDcy;","":"&caron;","^":"&Hat;",:"&Hcirc;",:"&Poincareplane;",:"&hamilt;",:"&quaternions;","":"&boxh;",:"&Hstrok;","":"&bumpeq;",:"&IEcy;",:"&IJlig;",:"&IOcy;",:"&Iacute;",:"&Icirc;",:"&Icy;",:"&Idot;",:"&imagpart;",:"&Igrave;",:"&Imacr;","":"&ii;","":"&Int;","":"&int;","":"&xcap;","":"&ic;","":"&it;",:"&Iogon;","":"&Iopf;",:"&Iota;",:"&imagline;",:"&Itilde;",:"&Iukcy;",:"&Iuml;",:"&Jcirc;",:"&Jcy;","":"&Jfr;","":"&Jopf;","":"&Jscr;",:"&Jsercy;",:"&Jukcy;",:"&KHcy;",:"&KJcy;",:"&Kappa;",:"&Kcedil;",:"&Kcy;","":"&Kfr;","":"&Kopf;","":"&Kscr;",:"&LJcy;","<":"&lt;",:"&Lacute;",:"&Lambda;","":"&Lang;",:"&lagran;","":"&twoheadleftarrow;",:"&Lcaron;",:"&Lcedil;",:"&Lcy;","":"&langle;","":"&slarr;","":"&larrb;","":"&lrarr;","":"&lceil;","":"&lobrk;","":"&LeftDownTeeVector;","":"&downharpoonleft;","":"&LeftDownVectorBar;","":"&lfloor;","":"&leftrightarrow;","":"&LeftRightVector;","":"&dashv;","":"&mapstoleft;","":"&LeftTeeVector;","":"&vltri;","":"&LeftTriangleBar;","":"&trianglelefteq;","":"&LeftUpDownVector;","":"&LeftUpTeeVector;","":"&upharpoonleft;","":"&LeftUpVectorBar;","":"&lharu;","":"&LeftVectorBar;","":"&lesseqgtr;","":"&leqq;","":"&lg;","":"&LessLess;","":"&les;","":"&lsim;","":"&Lfr;","":"&Ll;","":"&lAarr;",:"&Lmidot;","":"&xlarr;","":"&xharr;","":"&xrarr;","":"&Lopf;","":"&swarrow;","":"&searrow;","":"&lsh;",:"&Lstrok;","":"&ll;","":"&Map;",:"&Mcy;","":"&MediumSpace;",:"&phmmat;","":"&Mfr;","":"&mp;","":"&Mopf;",:"&Mu;",:"&NJcy;",:"&Nacute;",:"&Ncaron;",:"&Ncedil;",:"&Ncy;","":"&ZeroWidthSpace;","\n":"&NewLine;","":"&Nfr;","":"&NoBreak;","":"&nbsp;",:"&naturals;","":"&Not;","":"&nequiv;","":"&NotCupCap;","":"&nspar;","":"&notinva;","":"&ne;","":"&nesim;","":"&nexists;","":"&ngtr;","":"&ngeq;","":"&ngeqq;","":"&nGtv;","":"&ntgl;","":"&nges;","":"&ngsim;","":"&nbump;","":"&nbumpe;","":"&ntriangleleft;","":"&NotLeftTriangleBar;","":"&ntrianglelefteq;","":"&nlt;","":"&nleq;","":"&ntlg;","":"&nLtv;","":"&nles;","":"&nlsim;","":"&NotNestedGreaterGreater;","":"&NotNestedLessLess;","":"&nprec;","":"&npreceq;","":"&nprcue;","":"&notniva;","":"&ntriangleright;","":"&NotRightTriangleBar;","":"&ntrianglerighteq;","":"&NotSquareSubset;","":"&nsqsube;","":"&NotSquareSuperset;","":"&nsqsupe;","":"&vnsub;","":"&nsubseteq;","":"&nsucc;","":"&nsucceq;","":"&nsccue;","":"&NotSucceedsTilde;","":"&vnsup;","":"&nsupseteq;","":"&nsim;","":"&nsimeq;","":"&ncong;","":"&napprox;","":"&nsmid;","":"&Nscr;",:"&Ntilde;",:"&Nu;",:"&OElig;",:"&Oacute;",:"&Ocirc;",:"&Ocy;",:"&Odblac;","":"&Ofr;",:"&Ograve;",:"&Omacr;",:"&ohm;",:"&Omicron;","":"&Oopf;","":"&ldquo;","":"&lsquo;","":"&Or;","":"&Oscr;",:"&Oslash;",:"&Otilde;","":"&Otimes;",:"&Ouml;","":"&oline;","":"&OverBrace;","":"&tbrk;","":"&OverParenthesis;","":"&part;",:"&Pcy;","":"&Pfr;",:"&Phi;",:"&Pi;","":"&pm;",:"&primes;","":"&Pr;","":"&prec;","":"&preceq;","":"&preccurlyeq;","":"&prsim;","":"&Prime;","":"&prod;","":"&vprop;","":"&Pscr;",:"&Psi;",'"':"&quot;","":"&Qfr;",:"&rationals;","":"&Qscr;","":"&drbkarow;","":"&reg;",:"&Racute;","":"&Rang;","":"&twoheadrightarrow;","":"&Rarrtl;",:"&Rcaron;",:"&Rcedil;",:"&Rcy;",:"&realpart;","":"&niv;","":"&lrhar;","":"&duhar;",:"&Rho;","":"&rangle;","":"&srarr;","":"&rarrb;","":"&rlarr;","":"&rceil;","":"&robrk;","":"&RightDownTeeVector;","":"&downharpoonright;","":"&RightDownVectorBar;","":"&rfloor;","":"&vdash;","":"&mapsto;","":"&RightTeeVector;","":"&vrtri;","":"&RightTriangleBar;","":"&trianglerighteq;","":"&RightUpDownVector;","":"&RightUpTeeVector;","":"&upharpoonright;","":"&RightUpVectorBar;","":"&rightharpoonup;","":"&RightVectorBar;",:"&reals;","":"&RoundImplies;","":"&rAarr;",:"&realine;","":"&rsh;","":"&RuleDelayed;",:"&SHCHcy;",:"&SHcy;",:"&SOFTcy;",:"&Sacute;","":"&Sc;",:"&Scaron;",:"&Scedil;",:"&Scirc;",:"&Scy;","":"&Sfr;","":"&uparrow;",:"&Sigma;","":"&compfn;","":"&Sopf;","":"&radic;","":"&square;","":"&sqcap;","":"&sqsubset;","":"&sqsubseteq;","":"&sqsupset;","":"&sqsupseteq;","":"&sqcup;","":"&Sscr;","":"&sstarf;","":"&Subset;","":"&subseteq;","":"&succ;","":"&succeq;","":"&succcurlyeq;","":"&succsim;","":"&sum;","":"&Supset;","":"&supset;","":"&supseteq;",:"&THORN;","":"&trade;",:"&TSHcy;",:"&TScy;","	":"&Tab;",:"&Tau;",:"&Tcaron;",:"&Tcedil;",:"&Tcy;","":"&Tfr;","":"&therefore;",:"&Theta;","":"&ThickSpace;","":"&thinsp;","":"&thksim;","":"&simeq;","":"&cong;","":"&thkap;","":"&Topf;","":"&tdot;","":"&Tscr;",:"&Tstrok;",:"&Uacute;","":"&Uarr;","":"&Uarrocir;",:"&Ubrcy;",:"&Ubreve;",:"&Ucirc;",:"&Ucy;",:"&Udblac;","":"&Ufr;",:"&Ugrave;",:"&Umacr;",_:"&lowbar;","":"&UnderBrace;","":"&bbrk;","":"&UnderParenthesis;","":"&xcup;","":"&uplus;",:"&Uogon;","":"&Uopf;","":"&UpArrowBar;","":"&udarr;","":"&varr;","":"&udhar;","":"&perp;","":"&mapstoup;","":"&nwarrow;","":"&nearrow;",:"&upsih;",:"&Upsilon;",:"&Uring;","":"&Uscr;",:"&Utilde;",:"&Uuml;","":"&VDash;","":"&Vbar;",:"&Vcy;","":"&Vdash;","":"&Vdashl;","":"&xvee;","":"&Vert;","":"&smid;","|":"&vert;","":"&VerticalSeparator;","":"&wreath;","":"&hairsp;","":"&Vfr;","":"&Vopf;","":"&Vscr;","":"&Vvdash;",:"&Wcirc;","":"&xwedge;","":"&Wfr;","":"&Wopf;","":"&Wscr;","":"&Xfr;",:"&Xi;","":"&Xopf;","":"&Xscr;",:"&YAcy;",:"&YIcy;",:"&YUcy;",:"&Yacute;",:"&Ycirc;",:"&Ycy;","":"&Yfr;","":"&Yopf;","":"&Yscr;",:"&Yuml;",:"&ZHcy;",:"&Zacute;",:"&Zcaron;",:"&Zcy;",:"&Zdot;",:"&Zeta;",:"&zeetrf;",:"&integers;","":"&Zscr;",:"&aacute;",:"&abreve;","":"&mstpos;","":"&acE;","":"&acd;",:"&acirc;",:"&acy;",:"&aelig;","":"&afr;",:"&agrave;",:"&aleph;",:"&alpha;",:"&amacr;","":"&amalg;","":"&wedge;","":"&andand;","":"&andd;","":"&andslope;","":"&andv;","":"&angle;","":"&ange;","":"&measuredangle;","":"&angmsdaa;","":"&angmsdab;","":"&angmsdac;","":"&angmsdad;","":"&angmsdae;","":"&angmsdaf;","":"&angmsdag;","":"&angmsdah;","":"&angrt;","":"&angrtvb;","":"&angrtvbd;","":"&angsph;","":"&angzarr;",:"&aogon;","":"&aopf;","":"&apE;","":"&apacir;","":"&approxeq;","":"&apid;","'":"&apos;",:"&aring;","":"&ascr;","*":"&midast;",:"&atilde;",:"&auml;","":"&awint;","":"&bNot;","":"&bcong;","":"&bepsi;","":"&bprime;","":"&bsim;","":"&bsime;","":"&barvee;","":"&barwedge;","":"&bbrktbrk;",:"&bcy;","":"&ldquor;","":"&bemptyv;",:"&beta;",:"&beth;","":"&twixt;","":"&bfr;","":"&xcirc;","":"&xodot;","":"&xoplus;","":"&xotime;","":"&xsqcup;","":"&starf;","":"&xdtri;","":"&xutri;","":"&xuplus;","":"&rbarr;","":"&lozf;","":"&utrif;","":"&dtrif;","":"&ltrif;","":"&rtrif;","":"&blank;","":"&blk12;","":"&blk14;","":"&blk34;","":"&block;","=":"&bne;","":"&bnequiv;","":"&bnot;","":"&bopf;","":"&bowtie;","":"&boxDL;","":"&boxDR;","":"&boxDl;","":"&boxDr;","":"&boxH;","":"&boxHD;","":"&boxHU;","":"&boxHd;","":"&boxHu;","":"&boxUL;","":"&boxUR;","":"&boxUl;","":"&boxUr;","":"&boxV;","":"&boxVH;","":"&boxVL;","":"&boxVR;","":"&boxVh;","":"&boxVl;","":"&boxVr;","":"&boxbox;","":"&boxdL;","":"&boxdR;","":"&boxdl;","":"&boxdr;","":"&boxhD;","":"&boxhU;","":"&boxhd;","":"&boxhu;","":"&minusb;","":"&plusb;","":"&timesb;","":"&boxuL;","":"&boxuR;","":"&boxul;","":"&boxur;","":"&boxv;","":"&boxvH;","":"&boxvL;","":"&boxvR;","":"&boxvh;","":"&boxvl;","":"&boxvr;","":"&brvbar;","":"&bscr;","":"&bsemi;","\\":"&bsol;","":"&bsolb;","":"&bsolhsub;","":"&bullet;","":"&bumpE;",:"&cacute;","":"&cap;","":"&capand;","":"&capbrcup;","":"&capcap;","":"&capcup;","":"&capdot;","":"&caps;","":"&caret;","":"&ccaps;",:"&ccaron;",:"&ccedil;",:"&ccirc;","":"&ccups;","":"&ccupssm;",:"&cdot;","":"&cemptyv;","":"&cent;","":"&cfr;",:"&chcy;","":"&checkmark;",:"&chi;","":"&cir;","":"&cirE;","":"&circ;","":"&cire;","":"&olarr;","":"&orarr;","":"&oS;","":"&oast;","":"&ocir;","":"&odash;","":"&cirfnint;","":"&cirmid;","":"&cirscir;","":"&clubsuit;",":":"&colon;",",":"&comma;","@":"&commat;","":"&complement;","":"&congdot;","":"&copf;","":"&copysr;","":"&crarr;","":"&cross;","":"&cscr;","":"&csub;","":"&csube;","":"&csup;","":"&csupe;","":"&ctdot;","":"&cudarrl;","":"&cudarrr;","":"&curlyeqprec;","":"&curlyeqsucc;","":"&curvearrowleft;","":"&cularrp;","":"&cup;","":"&cupbrcap;","":"&cupcap;","":"&cupcup;","":"&cupdot;","":"&cupor;","":"&cups;","":"&curvearrowright;","":"&curarrm;","":"&cuvee;","":"&cuwed;","":"&curren;","":"&cwint;","":"&cylcty;","":"&dHar;","":"&dagger;",:"&daleth;","":"&hyphen;","":"&rBarr;",:"&dcaron;",:"&dcy;","":"&downdownarrows;","":"&eDDot;","":"&deg;",:"&delta;","":"&demptyv;","":"&dfisht;","":"&dfr;","":"&diams;",:"&gammad;","":"&disin;","":"&divide;","":"&divonx;",:"&djcy;","":"&llcorner;","":"&dlcrop;",$:"&dollar;","":"&dopf;","":"&eDot;","":"&minusd;","":"&plusdo;","":"&sdotb;","":"&lrcorner;","":"&drcrop;","":"&dscr;",:"&dscy;","":"&dsol;",:"&dstrok;","":"&dtdot;","":"&triangledown;","":"&dwangle;",:"&dzcy;","":"&dzigrarr;",:"&eacute;","":"&easter;",:"&ecaron;","":"&eqcirc;",:"&ecirc;","":"&eqcolon;",:"&ecy;",:"&edot;","":"&fallingdotseq;","":"&efr;","":"&eg;",:"&egrave;","":"&eqslantgtr;","":"&egsdot;","":"&el;","":"&elinters;",:"&ell;","":"&eqslantless;","":"&elsdot;",:"&emacr;","":"&varnothing;","":"&emsp13;","":"&emsp14;","":"&emsp;",:"&eng;","":"&ensp;",:"&eogon;","":"&eopf;","":"&epar;","":"&eparsl;","":"&eplus;",:"&epsilon;","":"&varepsilon;","=":"&equals;","":"&questeq;","":"&equivDD;","":"&eqvparsl;","":"&risingdotseq;","":"&erarr;",:"&escr;",:"&eta;",:"&eth;",:"&euml;","":"&euro;","!":"&excl;",:"&fcy;","":"&female;",:"&ffilig;",:"&fflig;",:"&ffllig;","":"&ffr;",:"&filig;",fj:"&fjlig;","":"&flat;",:"&fllig;","":"&fltns;",:"&fnof;","":"&fopf;","":"&pitchfork;","":"&forkv;","":"&fpartint;","":"&half;","":"&frac13;","":"&frac14;","":"&frac15;","":"&frac16;","":"&frac18;","":"&frac23;","":"&frac25;","":"&frac34;","":"&frac35;","":"&frac38;","":"&frac45;","":"&frac56;","":"&frac58;","":"&frac78;","":"&frasl;","":"&sfrown;","":"&fscr;","":"&gtreqqless;",:"&gacute;",:"&gamma;","":"&gtrapprox;",:"&gbreve;",:"&gcirc;",:"&gcy;",:"&gdot;","":"&gescc;","":"&gesdot;","":"&gesdoto;","":"&gesdotol;","":"&gesl;","":"&gesles;","":"&gfr;",:"&gimel;",:"&gjcy;","":"&glE;","":"&gla;","":"&glj;","":"&gneqq;","":"&gnapprox;","":"&gneq;","":"&gnsim;","":"&gopf;",:"&gscr;","":"&gsime;","":"&gsiml;","":"&gtcc;","":"&gtcir;","":"&gtrdot;","":"&gtlPar;","":"&gtquest;","":"&gtrarr;","":"&gvnE;",:"&hardcy;","":"&harrcir;","":"&leftrightsquigarrow;",:"&plankv;",:"&hcirc;","":"&heartsuit;","":"&mldr;","":"&hercon;","":"&hfr;","":"&searhk;","":"&swarhk;","":"&hoarr;","":"&homtht;","":"&larrhk;","":"&rarrhk;","":"&hopf;","":"&horbar;","":"&hscr;",:"&hstrok;","":"&hybull;",:"&iacute;",:"&icirc;",:"&icy;",:"&iecy;","":"&iexcl;","":"&ifr;",:"&igrave;","":"&qint;","":"&tint;","":"&iinfin;","":"&iiota;",:"&ijlig;",:"&imacr;",:"&inodot;","":"&imof;",:"&imped;","":"&incare;","":"&infin;","":"&infintie;","":"&intercal;","":"&intlarhk;","":"&iprod;",:"&iocy;",:"&iogon;","":"&iopf;",:"&iota;","":"&iquest;","":"&iscr;","":"&isinE;","":"&isindot;","":"&isins;","":"&isinsv;",:"&itilde;",:"&iukcy;",:"&iuml;",:"&jcirc;",:"&jcy;","":"&jfr;","":"&jmath;","":"&jopf;","":"&jscr;",:"&jsercy;",:"&jukcy;",:"&kappa;",:"&varkappa;",:"&kcedil;",:"&kcy;","":"&kfr;",:"&kgreen;",:"&khcy;",:"&kjcy;","":"&kopf;","":"&kscr;","":"&lAtail;","":"&lBarr;","":"&lesseqqgtr;","":"&lHar;",:"&lacute;","":"&laemptyv;",:"&lambda;","":"&langd;","":"&lessapprox;","":"&laquo;","":"&larrbfs;","":"&larrfs;","":"&looparrowleft;","":"&larrpl;","":"&larrsim;","":"&leftarrowtail;","":"&lat;","":"&latail;","":"&late;","":"&lates;","":"&lbarr;","":"&lbbrk;","{":"&lcub;","[":"&lsqb;","":"&lbrke;","":"&lbrksld;","":"&lbrkslu;",:"&lcaron;",:"&lcedil;",:"&lcy;","":"&ldca;","":"&ldrdhar;","":"&ldrushar;","":"&ldsh;","":"&leq;","":"&llarr;","":"&lthree;","":"&lescc;","":"&lesdot;","":"&lesdoto;","":"&lesdotor;","":"&lesg;","":"&lesges;","":"&ltdot;","":"&lfisht;","":"&lfr;","":"&lgE;","":"&lharul;","":"&lhblk;",:"&ljcy;","":"&llhard;","":"&lltri;",:"&lmidot;","":"&lmoustache;","":"&lneqq;","":"&lnapprox;","":"&lneq;","":"&lnsim;","":"&loang;","":"&loarr;","":"&xmap;","":"&rarrlp;","":"&lopar;","":"&lopf;","":"&loplus;","":"&lotimes;","":"&lowast;","":"&lozenge;","(":"&lpar;","":"&lparlt;","":"&lrhard;","":"&lrm;","":"&lrtri;","":"&lsaquo;","":"&lscr;","":"&lsime;","":"&lsimg;","":"&sbquo;",:"&lstrok;","":"&ltcc;","":"&ltcir;","":"&ltimes;","":"&ltlarr;","":"&ltquest;","":"&ltrPar;","":"&triangleleft;","":"&lurdshar;","":"&luruhar;","":"&lvnE;","":"&mDDot;","":"&strns;","":"&male;","":"&maltese;","":"&marker;","":"&mcomma;",:"&mcy;","":"&mdash;","":"&mfr;","":"&mho;",:"&micro;","":"&midcir;","":"&minus;","":"&minusdu;","":"&mlcp;","":"&models;","":"&mopf;","":"&mscr;",:"&mu;","":"&mumap;","":"&nGg;","":"&nGt;","":"&nlArr;","":"&nhArr;","":"&nLl;","":"&nLt;","":"&nrArr;","":"&nVDash;","":"&nVdash;",:"&nacute;","":"&nang;","":"&napE;","":"&napid;",:"&napos;","":"&natural;","":"&ncap;",:"&ncaron;",:"&ncedil;","":"&ncongdot;","":"&ncup;",:"&ncy;","":"&ndash;","":"&neArr;","":"&nearhk;","":"&nedot;","":"&toea;","":"&nfr;","":"&nleftrightarrow;","":"&nhpar;","":"&nis;","":"&nisd;",:"&njcy;","":"&nleqq;","":"&nleftarrow;","":"&nldr;","":"&nopf;","":"&not;","":"&notinE;","":"&notindot;","":"&notinvb;","":"&notinvc;","":"&notnivb;","":"&notnivc;","":"&nparsl;","":"&npart;","":"&npolint;","":"&nrightarrow;","":"&nrarrc;","":"&nrarrw;","":"&nscr;","":"&nsub;","":"&nsubseteqq;","":"&nsup;","":"&nsupseteqq;",:"&ntilde;",:"&nu;","#":"&num;","":"&numero;","":"&numsp;","":"&nvDash;","":"&nvHarr;","":"&nvap;","":"&nvdash;","":"&nvge;",">":"&nvgt;","":"&nvinfin;","":"&nvlArr;","":"&nvle;","<":"&nvlt;","":"&nvltrie;","":"&nvrArr;","":"&nvrtrie;","":"&nvsim;","":"&nwArr;","":"&nwarhk;","":"&nwnear;",:"&oacute;",:"&ocirc;",:"&ocy;",:"&odblac;","":"&odiv;","":"&odsold;",:"&oelig;","":"&ofcir;","":"&ofr;","":"&ogon;",:"&ograve;","":"&ogt;","":"&ohbar;","":"&olcir;","":"&olcross;","":"&olt;",:"&omacr;",:"&omega;",:"&omicron;","":"&omid;","":"&oopf;","":"&opar;","":"&operp;","":"&vee;","":"&ord;",:"&oscr;",:"&ordf;",:"&ordm;","":"&origof;","":"&oror;","":"&orslope;","":"&orv;",:"&oslash;","":"&osol;",:"&otilde;","":"&otimesas;",:"&ouml;","":"&ovbar;","":"&para;","":"&parsim;","":"&parsl;",:"&pcy;","%":"&percnt;",".":"&period;","":"&permil;","":"&pertenk;","":"&pfr;",:"&phi;",:"&varphi;","":"&phone;",:"&pi;",:"&varpi;",:"&planckh;","+":"&plus;","":"&plusacir;","":"&pluscir;","":"&plusdu;","":"&pluse;","":"&plussim;","":"&plustwo;","":"&pointint;","":"&popf;","":"&pound;","":"&prE;","":"&precapprox;","":"&prnap;","":"&prnE;","":"&prnsim;","":"&prime;","":"&profalar;","":"&profline;","":"&profsurf;","":"&prurel;","":"&pscr;",:"&psi;","":"&puncsp;","":"&qfr;","":"&qopf;","":"&qprime;","":"&qscr;","":"&quatint;","?":"&quest;","":"&rAtail;","":"&rHar;","":"&race;",:"&racute;","":"&raemptyv;","":"&rangd;","":"&range;","":"&raquo;","":"&rarrap;","":"&rarrbfs;","":"&rarrc;","":"&rarrfs;","":"&rarrpl;","":"&rarrsim;","":"&rightarrowtail;","":"&rightsquigarrow;","":"&ratail;","":"&ratio;","":"&rbbrk;","}":"&rcub;","]":"&rsqb;","":"&rbrke;","":"&rbrksld;","":"&rbrkslu;",:"&rcaron;",:"&rcedil;",:"&rcy;","":"&rdca;","":"&rdldhar;","":"&rdsh;","":"&rect;","":"&rfisht;","":"&rfr;","":"&rharul;",:"&rho;",:"&varrho;","":"&rrarr;","":"&rthree;","":"&ring;","":"&rlm;","":"&rmoustache;","":"&rnmid;","":"&roang;","":"&roarr;","":"&ropar;","":"&ropf;","":"&roplus;","":"&rotimes;",")":"&rpar;","":"&rpargt;","":"&rppolint;","":"&rsaquo;","":"&rscr;","":"&rtimes;","":"&triangleright;","":"&rtriltri;","":"&ruluhar;","":"&rx;",:"&sacute;","":"&scE;","":"&succapprox;",:"&scaron;",:"&scedil;",:"&scirc;","":"&succneqq;","":"&succnapprox;","":"&succnsim;","":"&scpolint;",:"&scy;","":"&sdot;","":"&sdote;","":"&seArr;","":"&sect;",";":"&semi;","":"&tosa;","":"&sext;","":"&sfr;","":"&sharp;",:"&shchcy;",:"&shcy;","":"&shy;",:"&sigma;",:"&varsigma;","":"&simdot;","":"&simg;","":"&simgE;","":"&siml;","":"&simlE;","":"&simne;","":"&simplus;","":"&simrarr;","":"&smashp;","":"&smeparsl;","":"&ssmile;","":"&smt;","":"&smte;","":"&smtes;",:"&softcy;","/":"&sol;","":"&solb;","":"&solbar;","":"&sopf;","":"&spadesuit;","":"&sqcaps;","":"&sqcups;","":"&sscr;","":"&star;","":"&subset;","":"&subseteqq;","":"&subdot;","":"&subedot;","":"&submult;","":"&subsetneqq;","":"&subsetneq;","":"&subplus;","":"&subrarr;","":"&subsim;","":"&subsub;","":"&subsup;","":"&sung;","":"&sup1;","":"&sup2;","":"&sup3;","":"&supseteqq;","":"&supdot;","":"&supdsub;","":"&supedot;","":"&suphsol;","":"&suphsub;","":"&suplarr;","":"&supmult;","":"&supsetneqq;","":"&supsetneq;","":"&supplus;","":"&supsim;","":"&supsub;","":"&supsup;","":"&swArr;","":"&swnwar;",:"&szlig;","":"&target;",:"&tau;",:"&tcaron;",:"&tcedil;",:"&tcy;","":"&telrec;","":"&tfr;",:"&theta;",:"&vartheta;",:"&thorn;","":"&times;","":"&timesbar;","":"&timesd;","":"&topbot;","":"&topcir;","":"&topf;","":"&topfork;","":"&tprime;","":"&utri;","":"&trie;","":"&tridot;","":"&triminus;","":"&triplus;","":"&trisb;","":"&tritime;","":"&trpezium;","":"&tscr;",:"&tscy;",:"&tshcy;",:"&tstrok;","":"&uHar;",:"&uacute;",:"&ubrcy;",:"&ubreve;",:"&ucirc;",:"&ucy;",:"&udblac;","":"&ufisht;","":"&ufr;",:"&ugrave;","":"&uhblk;","":"&ulcorner;","":"&ulcrop;","":"&ultri;",:"&umacr;",:"&uogon;","":"&uopf;",:"&upsilon;","":"&uuarr;","":"&urcorner;","":"&urcrop;",:"&uring;","":"&urtri;","":"&uscr;","":"&utdot;",:"&utilde;",:"&uuml;","":"&uwangle;","":"&vBar;","":"&vBarv;","":"&vangrt;","":"&vsubne;","":"&vsubnE;","":"&vsupne;","":"&vsupnE;",:"&vcy;","":"&veebar;","":"&veeeq;","":"&vellip;","":"&vfr;","":"&vopf;","":"&vscr;","":"&vzigzag;",:"&wcirc;","":"&wedbar;","":"&wedgeq;","":"&wp;","":"&wfr;","":"&wopf;","":"&wscr;","":"&xfr;",:"&xi;","":"&xnis;","":"&xopf;","":"&xscr;",:"&yacute;",:"&yacy;",:"&ycirc;",:"&ycy;","":"&yen;","":"&yfr;",:"&yicy;","":"&yopf;","":"&yscr;",:"&yucy;",:"&yuml;",:"&zacute;",:"&zcaron;",:"&zcy;",:"&zdot;",:"&zeta;","":"&zfr;",:"&zhcy;","":"&zigrarr;","":"&zopf;","":"&zscr;","":"&zwj;","":"&zwnj;"}}};var vM={};Object.defineProperty(vM,"__esModule",{value:!0});vM.numericUnicodeMap={0:65533,128:8364,130:8218,131:402,132:8222,133:8230,134:8224,135:8225,136:710,137:8240,138:352,139:8249,140:338,142:381,145:8216,146:8217,147:8220,148:8221,149:8226,150:8211,151:8212,152:732,153:8482,154:353,155:8250,156:339,158:382,159:376};var Dy={};Object.defineProperty(Dy,"__esModule",{value:!0});Dy.fromCodePoint=String.fromCodePoint||function(e){return String.fromCharCode(Math.floor((e-65536)/1024)+55296,(e-65536)%1024+56320)};Dy.getCodePoint=String.prototype.codePointAt?function(e,t){return e.codePointAt(t)}:function(e,t){return(e.charCodeAt(t)-55296)*1024+e.charCodeAt(t+1)-56320+65536};Dy.highSurrogateFrom=55296;Dy.highSurrogateTo=56319;var Og=mr&&mr.__assign||function(){return Og=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++){t=arguments[n];for(var s in t)Object.prototype.hasOwnProperty.call(t,s)&&(e[s]=t[s])}return e},Og.apply(this,arguments)};Object.defineProperty(FN,"__esModule",{value:!0});var o1=MN,qJ=vM,xM=Dy,wM=Og(Og({},o1.namedReferences),{all:o1.namedReferences.html5}),EGe={specialChars:/[<>'"&]/g,nonAscii:/[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g,nonAsciiPrintable:/[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g,nonAsciiPrintableOnly:/[\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g,extensive:/[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/g},_Ge={mode:"specialChars",level:"all",numeric:"decimal"};function AGe(e,t){var c=t===void 0?_Ge:t,d=c.mode,n=d===void 0?"specialChars":d,r=c.numeric,s=r===void 0?"decimal":r,a=c.level,i=a===void 0?"all":a;if(!e)return"";var o=EGe[n],l=wM[i].characters,u=s==="hexadecimal";o.lastIndex=0;var c=o.exec(e),d;if(c){d="";var r=0;do{r!==c.index&&(d+=e.substring(r,c.index));var a=c[0],h=l[a];if(!h){var p=a.length>1?xM.getCodePoint(a,0):a.charCodeAt(0);h=(u?"&#x"+p.toString(16):"&#"+p)+";"}d+=h,r=c.index+a.length}while(c=o.exec(e));r!==e.length&&(d+=e.substring(r))}else d=e;return d}FN.encode=AGe;var RGe={scope:"body",level:"all"},SE=/&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g,IE=/&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g,mj={xml:{strict:SE,attribute:IE,body:o1.bodyRegExps.xml},html4:{strict:SE,attribute:IE,body:o1.bodyRegExps.html4},html5:{strict:SE,attribute:IE,body:o1.bodyRegExps.html5}},DGe=Og(Og({},mj),{all:mj.html5}),kM=String.fromCharCode,KJ=kM(65533),OGe={level:"all"};function FGe(e,t){var r=(t===void 0?OGe:t).level,n=r===void 0?"all":r;if(!e)return"";var r=e;e[e.length-1];{var s=wM[n].entities[e];if(s)r=s;else if(e[0]==="&"&&e[1]==="#"){var a=e[2],i=a=="x"||a=="X"?parseInt(e.substr(3),16):parseInt(e.substr(2));r=i>=1114111?KJ:i>65535?xM.fromCodePoint(i):kM(qJ.numericUnicodeMap[i]||i)}}return r}FN.decodeEntity=FGe;function MGe(e,t){var n=t===void 0?RGe:t,r=n.level,s=r===void 0?"all":r,a=n.scope,i=a===void 0?s==="xml"?"strict":"body":a;if(!e)return"";var o=DGe[s][i],l=wM[s].entities,u=i==="attribute",c=i==="strict";o.lastIndex=0;var d=o.exec(e),h;if(d){h="";var p=0;do{p!==d.index&&(h+=e.substring(p,d.index));var f=d[0],m=f,g=f[f.length-1];if(u&&g==="=")m=f;else if(c&&g!==";")m=f;else{var y=l[f];if(y)m=y;else if(f[0]==="&"&&f[1]==="#"){var b=f[2],x=b=="x"||b=="X"?parseInt(f.substr(3),16):parseInt(f.substr(2));m=x>=1114111?KJ:x>65535?xM.fromCodePoint(x):kM(qJ.numericUnicodeMap[x]||x)}}h+=m,p=d.index+f.length}while(d=o.exec(e));p!==e.length&&(h+=e.substring(p))}else h=e;return h}var gj=FN.decode=MGe;/**
 * @name ranges-sort
 * @fileoverview Sort string index ranges
 * @version 6.0.11
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-sort/}
 */var PGe={strictlyTwoElementsInRangeArrays:!1,progressFn:null};function GS(e,t){if(!Array.isArray(e)||!e.length)return e;let n={...PGe,...t},r,s;if(n.strictlyTwoElementsInRangeArrays&&!e.every((o,l)=>!Array.isArray(o)||o.length!==2?(r=l,s=o.length,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_03] The first argument should be an array and must consist of arrays which are natural number indexes representing TWO string index ranges. However, ${r}th range (${JSON.stringify(e[r],null,4)}) has not two but ${s} elements!`);if(!e.every((o,l)=>!Array.isArray(o)||!Number.isInteger(o[0])||o[0]<0||!Number.isInteger(o[1])||o[1]<0?(r=l,!1):!0))throw new TypeError(`ranges-sort: [THROW_ID_04] The first argument should be an array and must consist of arrays which are natural number indexes representing string index ranges. However, ${r}th range (${JSON.stringify(e[r],null,4)}) does not consist of only natural numbers!`);let a=e.length**2,i=0;return Array.from(e).sort((o,l)=>(n.progressFn&&(i+=1,n.progressFn(Math.floor(i*100/a))),o[0]===l[0]?o[1]<l[1]?-1:o[1]>l[1]?1:0:o[0]<l[0]?-1:1))}/**
 * @name ranges-merge
 * @fileoverview Merge and sort string index ranges
 * @version 9.0.15
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-merge/}
 */var yj={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function LGe(e,t){function n(u){return!!u&&typeof u=="object"&&!Array.isArray(u)}if(!Array.isArray(e)||!e.length)return null;let r;if(t)if(n(t)){if(r={...yj,...t},r.progressFn&&n(r.progressFn)&&!Object.keys(r.progressFn).length)r.progressFn=null;else if(r.progressFn&&typeof r.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] opts.progressFn must be a function! It was given of a type: "${typeof r.progressFn}", equal to ${JSON.stringify(r.progressFn,null,4)}`);if(![1,2,"1","2"].includes(r.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof r.mergeType}", equal to ${JSON.stringify(r.mergeType,null,4)}`);if(typeof r.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] opts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof r.joinRangesThatTouchEdges}", equal to ${JSON.stringify(r.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else r={...yj};let s=e.filter(u=>Array.isArray(u)).map(u=>[...u]).filter(u=>u[2]!==void 0||u[0]!==u[1]),a,i,o;r.progressFn?a=GS(s,{progressFn:u=>{o=Math.floor(u/5),o!==i&&(i=o,r.progressFn(o))}}):a=GS(s);let l=a.length-1;for(let u=l;u>0;u--)r.progressFn&&(o=Math.floor((1-u/l)*78)+21,o!==i&&o>i&&(i=o,r.progressFn(o))),(a[u][0]<=a[u-1][0]||!r.joinRangesThatTouchEdges&&a[u][0]<a[u-1][1]||r.joinRangesThatTouchEdges&&a[u][0]<=a[u-1][1])&&(a[u-1][0]=Math.min(a[u][0],a[u-1][0]),a[u-1][1]=Math.max(a[u][1],a[u-1][1]),a[u][2]!==void 0&&(a[u-1][0]>=a[u][0]||a[u-1][1]<=a[u][1])&&a[u-1][2]!==null&&(a[u][2]===null&&a[u-1][2]!==null?a[u-1][2]=null:a[u-1][2]!=null?+r.mergeType==2&&a[u-1][0]===a[u][0]?a[u-1][2]=a[u][2]:a[u-1][2]+=a[u][2]:a[u-1][2]=a[u][2]),a.splice(u,1),u=a.length);return a.length?a:null}var zGe=!0,CE="Invariant failed";function BGe(e,t){if(!e){if(zGe)throw new Error(CE);var n=typeof t=="function"?t():t,r=n?"".concat(CE,": ").concat(n):CE;throw new Error(r)}}/**
 * @name ranges-apply
 * @fileoverview Take an array of string index ranges, delete/replace the string according to them
 * @version 7.0.15
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-apply/}
 */function WGe(e,t,n){let r=0,s=0;if(arguments.length===0)throw new Error("ranges-apply: [THROW_ID_01] inputs missing!");if(typeof e!="string")throw new TypeError(`ranges-apply: [THROW_ID_02] first input argument must be a string! Currently it's: ${typeof e}, equal to: ${JSON.stringify(e,null,4)}`);if(t&&!Array.isArray(t))throw new TypeError(`ranges-apply: [THROW_ID_03] second input argument must be an array (or null)! Currently it's: ${typeof t}, equal to: ${JSON.stringify(t,null,4)}`);if(n&&typeof n!="function")throw new TypeError(`ranges-apply: [THROW_ID_04] the third input argument must be a function (or falsey)! Currently it's: ${typeof n}, equal to: ${JSON.stringify(n,null,4)}`);if(!(t!=null&&t.filter(c=>c).length))return e;let a;Array.isArray(t)&&Number.isInteger(t[0])&&Number.isInteger(t[1])?a=[Array.from(t)]:a=Array.from(t);let i=a.length,o=0;a.filter(c=>c).forEach((c,d)=>{if(n&&(r=Math.floor(o/i*10),r!==s&&(s=r,n(r))),!Array.isArray(c))throw new TypeError(`ranges-apply: [THROW_ID_05] ranges array, second input arg., has ${d}th element not an array: ${JSON.stringify(c,null,4)}, which is ${typeof c}`);if(!Number.isInteger(c[0])){if(!Number.isInteger(+c[0])||+c[0]<0)throw new TypeError(`ranges-apply: [THROW_ID_06] ranges array, second input arg. has ${d}th element, array ${JSON.stringify(c,null,0)}. Its first element is not an integer, string index, but ${typeof c[0]}, equal to: ${JSON.stringify(c[0],null,4)}.`);a[d][0]=+a[d][0]}if(!Number.isInteger(c[1])){if(!Number.isInteger(+c[1])||+c[1]<0)throw new TypeError(`ranges-apply: [THROW_ID_07] ranges array, second input arg. has ${d}th element, array ${JSON.stringify(c,null,0)}. Its second element is not an integer, string index, but ${typeof c[1]}, equal to: ${JSON.stringify(c[1],null,4)}.`);a[d][1]=+a[d][1]}o+=1});let l=LGe(a,{progressFn:c=>{n&&(r=10+Math.floor(c/10),r!==s&&(s=r,n(r)))}});BGe(l);let u=l.length;if(u>0){let c=e.slice(l[u-1][1]);e=l.reduce((d,h,p,f)=>{n&&(r=20+Math.floor(p/u*80),r!==s&&(s=r,n(r)));let m=p===0?0:f[p-1][1],g=f[p][0];return`${d}${e.slice(m,g)}${f[p][2]||""}`},""),e+=c}return e}/**
 * @name string-collapse-leading-whitespace
 * @fileoverview Collapse the leading and trailing whitespace of a string
 * @version 7.0.7
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-collapse-leading-whitespace/}
 */function NE(e,t=1){let n="";function r(a){return Array.from(a).reverse().join("")}function s(a,i,o){let l=o?`
`:"\r",u=o?"\r":`
`;if(!a)return a;let c=0,d="";for(let h=0,p=a.length;h<p;h++)(a[h]===l||a[h]===u&&a[h-1]!==l)&&c++,`\r
`.includes(a[h])||a[h]===n?a[h]===n?d+=a[h]:a[h]===l?c<=i&&(d+=a[h],a[h+1]===u&&(d+=a[h+1],h++)):a[h]===u&&(a==null?void 0:a[h-1])!==l&&c<=i&&(d+=a[h]):!a[h+1]&&!c&&(d+=" ");return d}if(typeof e=="string"&&e.length){let a=1;typeof+t=="number"&&Number.isInteger(+t)&&+t>=0&&(a=+t);let i="",o="";if(!e.trim())i=e;else if(!e[0].trim()){for(let l=0,u=e.length;l<u;l++)if(e[l].trim()){i=e.slice(0,l);break}}if(e.trim()&&(e.slice(-1).trim()===""||e.slice(-1)===n)){for(let l=e.length;l--;)if(e[l].trim()){o=e.slice(l+1);break}}return`${s(i,a,!1)}${e.trim()}${r(s(r(o),a,!0))}`}return e}/**
 * @name ranges-push
 * @fileoverview Gather string index ranges
 * @version 7.0.15
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/ranges-push/}
 */var bj={mergeType:1,progressFn:null,joinRangesThatTouchEdges:!0};function VGe(e,t){function n(u){return!!u&&typeof u=="object"&&!Array.isArray(u)}if(!Array.isArray(e)||!e.length)return null;let r;if(t)if(n(t)){if(r={...bj,...t},r.progressFn&&n(r.progressFn)&&!Object.keys(r.progressFn).length)r.progressFn=null;else if(r.progressFn&&typeof r.progressFn!="function")throw new Error(`ranges-merge: [THROW_ID_01] resolvedOpts.progressFn must be a function! It was given of a type: "${typeof r.progressFn}", equal to ${JSON.stringify(r.progressFn,null,4)}`);if(![1,2,"1","2"].includes(r.mergeType))throw new Error(`ranges-merge: [THROW_ID_02] resolvedOpts.mergeType was customised to a wrong thing! It was given of a type: "${typeof r.mergeType}", equal to ${JSON.stringify(r.mergeType,null,4)}`);if(typeof r.joinRangesThatTouchEdges!="boolean")throw new Error(`ranges-merge: [THROW_ID_04] resolvedOpts.joinRangesThatTouchEdges was customised to a wrong thing! It was given of a type: "${typeof r.joinRangesThatTouchEdges}", equal to ${JSON.stringify(r.joinRangesThatTouchEdges,null,4)}`)}else throw new Error(`emlint: [THROW_ID_03] the second input argument must be a plain object. It was given as:
${JSON.stringify(t,null,4)} (type ${typeof t})`);else r={...bj};let s=e.filter(u=>Array.isArray(u)).map(u=>[...u]).filter(u=>u[2]!==void 0||u[0]!==u[1]),a,i,o;r.progressFn?a=GS(s,{progressFn:u=>{o=Math.floor(u/5),o!==i&&(i=o,r.progressFn(o))}}):a=GS(s);let l=a.length-1;for(let u=l;u>0;u--)r.progressFn&&(o=Math.floor((1-u/l)*78)+21,o!==i&&o>i&&(i=o,r.progressFn(o))),(a[u][0]<=a[u-1][0]||!r.joinRangesThatTouchEdges&&a[u][0]<a[u-1][1]||r.joinRangesThatTouchEdges&&a[u][0]<=a[u-1][1])&&(a[u-1][0]=Math.min(a[u][0],a[u-1][0]),a[u-1][1]=Math.max(a[u][1],a[u-1][1]),a[u][2]!==void 0&&(a[u-1][0]>=a[u][0]||a[u-1][1]<=a[u][1])&&a[u-1][2]!==null&&(a[u][2]===null&&a[u-1][2]!==null?a[u-1][2]=null:a[u-1][2]!=null?+r.mergeType==2&&a[u-1][0]===a[u][0]?a[u-1][2]=a[u][2]:a[u-1][2]+=a[u][2]:a[u-1][2]=a[u][2]),a.splice(u,1),u=a.length);return a.length?a:null}var UGe={limitToBeAddedWhitespace:!1,limitLinebreaksCount:1,mergeType:1},jGe=class{constructor(e){k$(this,"ranges");k$(this,"opts");let t={...UGe,...e};if(t.mergeType&&t.mergeType!==1&&t.mergeType!==2)if(km(t.mergeType)&&t.mergeType.trim()==="1")t.mergeType=1;else if(km(t.mergeType)&&t.mergeType.trim()==="2")t.mergeType=2;else throw new Error(`ranges-push: [THROW_ID_02] opts.mergeType was customised to a wrong thing! It was given of a type: "${typeof t.mergeType}", equal to ${JSON.stringify(t.mergeType,null,4)}`);this.opts=t,this.ranges=[]}add(e,t,n){var a;if(e==null&&t==null)return;if(Lu(e)&&!Lu(t)){if(Array.isArray(e)){if(e.length){if(e.some(i=>Array.isArray(i))){e.forEach(i=>{Array.isArray(i)&&this.add(...i)});return}e.length&&Pu(+e[0])&&Pu(+e[1])&&this.add(...e)}return}throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_12] the first input argument, "from" is set (${JSON.stringify(e,null,0)}) but second-one, "to" is not (${JSON.stringify(t,null,0)})`)}else if(!Lu(e)&&Lu(t))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_13] the second input argument, "to" is set (${JSON.stringify(t,null,0)}) but first-one, "from" is not (${JSON.stringify(e,null,0)})`);let r=+e,s=+t;if(Pu(n)&&(n=String(n)),Pu(r)&&Pu(s)){if(Lu(n)&&!km(n)&&!Pu(n))throw new TypeError(`ranges-push/Ranges/add(): [THROW_ID_08] The third argument, the value to add, was given not as string but ${typeof n}, equal to:
${JSON.stringify(n,null,4)}`);if(Lu(this.ranges)&&Array.isArray(this.last())&&r===this.last()[1]){if(this.last()[1]=s,this.last()[2],this.last()[2]!==null&&Lu(n)){let i=this.last()[2]&&this.last()[2].length&&(!((a=this.opts)!=null&&a.mergeType)||this.opts.mergeType===1)?`${this.last()[2]}${n}`:n;this.opts.limitToBeAddedWhitespace&&(i=NE(i,this.opts.limitLinebreaksCount)),km(i)&&!i.length||(this.last()[2]=i)}}else{this.ranges||(this.ranges=[]);let i=n!==void 0&&!(km(n)&&!n.length)?[r,s,n&&this.opts.limitToBeAddedWhitespace?NE(n,this.opts.limitLinebreaksCount):n]:[r,s];this.ranges.push(i)}}else throw Pu(r)&&r>=0?new TypeError(`ranges-push/Ranges/add(): [THROW_ID_10] "to" value, the second input argument, must be a natural number or zero! Currently it's of a type "${typeof s}" equal to: ${JSON.stringify(s,null,4)}`):new TypeError(`ranges-push/Ranges/add(): [THROW_ID_09] "from" value, the first input argument, must be a natural number or zero! Currently it's of a type "${typeof r}" equal to: ${JSON.stringify(r,null,4)}`)}push(e,t,n){this.add(e,t,n)}current(){return Array.isArray(this.ranges)&&this.ranges.length?(this.ranges=VGe(this.ranges,{mergeType:this.opts.mergeType}),this.ranges&&this.opts.limitToBeAddedWhitespace?this.ranges.map(e=>Lu(e[2])?[e[0],e[1],NE(e[2],this.opts.limitLinebreaksCount)]:e):this.ranges):null}wipe(){this.ranges=[]}replace(e){if(Array.isArray(e)&&e.length)if(Array.isArray(e[0])&&Pu(e[0][0]))this.ranges=Array.from(e);else throw new Error(`ranges-push/Ranges/replace(): [THROW_ID_11] Single range was given but we expected array of arrays! The first element, ${JSON.stringify(e[0],null,4)} should be an array and its first element should be an integer, a string index.`);else this.ranges=[]}last(){return Array.isArray(this.ranges)&&this.ranges.length?this.ranges[this.ranges.length-1]:null}};/**
 * @name string-left-right
 * @fileoverview Looks up the first non-whitespace character to the left/right of a given index
 * @version 6.0.17
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-left-right/}
 */DJ();var TE="";function GGe({str:e,idx:t=0,stopAtNewlines:n=!1,stopAtRawNbsp:r=!1}){if(typeof e!="string"||!e.length||((!t||typeof t!="number")&&(t=0),!e[t+1]))return null;if(e[t+1]&&(e[t+1].trim()||n&&`
\r`.includes(e[t+1])||r&&e[t+1]===TE))return t+1;if(e[t+2]&&(e[t+2].trim()||n&&`
\r`.includes(e[t+2])||r&&e[t+2]===TE))return t+2;for(let s=t+1,a=e.length;s<a;s++)if(e[s].trim()||n&&`
\r`.includes(e[s])||r&&e[s]===TE)return s;return null}function Jo(e,t=0){return GGe({str:e,idx:t,stopAtNewlines:!1,stopAtRawNbsp:!1})}/**
 * @name string-strip-html
 * @fileoverview Strip HTML tags from strings. No parser, accepts mixed sources.
 * @version 13.4.6
 * @author Roy Revelt, Codsen Ltd
 * @license MIT
 * {@link https://codsen.com/os/string-strip-html/}
 */function HGe(e){return/[-_A-Za-z0-9]/.test(e)}function vj(e,t){if(!e)return[];if(Array.isArray(e))return e.filter(n=>typeof n=="string"&&n.trim());if(typeof e=="string")return e.trim()?[e]:[];throw new TypeError(`string-strip-html/stripHtml(): [THROW_ID_05] ${t} must be array containing zero or more strings or something falsey. Currently it's equal to: ${e}, that a type of ${typeof e}.`)}function Pk(e,t,n,r){for(let s=t,a=e.length;s<a;s++){if(e.startsWith(n,s))return!0;if(e.startsWith(r,s))return!1}return!1}function xj(e,t,n){var r,s,a,i,o,l,u;return e!=null&&e.quotes,(r=e==null?void 0:e.quotes)!=null&&r.value&&Pk(t,n+1,e.quotes.value,">"),(s=e==null?void 0:e.quotes)==null||s.next,Pk(t,((a=e==null?void 0:e.quotes)==null?void 0:a.next)-1,(i=e==null?void 0:e.quotes)==null?void 0:i.value,">"),!(e!=null&&e.quotes)||!Pk(t,n+1,e.quotes.value,">")&&((o=e==null?void 0:e.quotes)==null?void 0:o.next)!==-1&&Pk(t,((l=e==null?void 0:e.quotes)==null?void 0:l.next)-1,(u=e==null?void 0:e.quotes)==null?void 0:u.value,">")}function qGe(e,t){return(t.match(new RegExp(e,"g"))||[]).length}var wv=new Set(["!doctype","abbr","address","area","article","aside","audio","base","bdi","bdo","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","doctype","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","math","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","param","picture","pre","progress","rb","rp","rt","rtc","ruby","samp","script","section","select","slot","small","source","span","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","ul","var","video","wbr","xml"]),$E=new Set(["a","b","i","p","q","s","u"]),EE=new Set([".",",",";","!","?"]),wj=new Set([".",",","?",";",")","",'"',""]),KGe=new Set(["a","abbr","acronym","audio","b","bdi","bdo","big","button","canvas","cite","code","data","datalist","del","dfn","em","embed","i","iframe","input","ins","kbd","label","map","mark","meter","noscript","object","output","picture","progress","q","ruby","s","samp","select","slot","small","span","strong","sub","sup","svg","template","textarea","time","u","tt","var","video","wbr"]),kj={ignoreTags:[],ignoreTagsWithTheirContents:[],onlyStripTags:[],stripTogetherWithTheirContents:["script","style","xml"],skipHtmlDecoding:!1,trimOnlySpaces:!1,stripRecognisedHTMLOnly:!1,dumpLinkHrefsNearby:{enabled:!1,putOnNewLine:!1,wrapHeads:"",wrapTails:""},ignoreIndentations:!1,cb:null,reportProgressFunc:null,reportProgressFuncFrom:0,reportProgressFuncTo:100};function ts(e,t){var D,B,V,K,G,U,q,Q,ee,ae,ye;let n=Date.now(),r=[],s=[],a=[],i=[],o={};function l(){o={attributes:[]}}l();let u=null,c=null,d=null,h=!1,p={},f={tagName:"",hrefValue:"",openingTagEnds:void 0},m="",g=!1,y=null,b=!0;function x(j,ce,be){if(Array.isArray(ce.stripTogetherWithTheirContents)&&(ce.stripTogetherWithTheirContents.includes(o.name)||ce.stripTogetherWithTheirContents.includes("*")))if(o.slashPresent&&Array.isArray(r)&&r.some(ke=>ke.name===o.name)){for(let ke=r.length;ke--;)if(r[ke].name===o.name){i=i.filter(([Pe,ie])=>(Pe<r[ke].lastOpeningBracketAt||Pe>=j+1)&&(ie<=r[ke].lastOpeningBracketAt||ie>j+1));let Ae=j+1;o.lastClosingBracketAt&&(Ae=o.lastClosingBracketAt+1),i.push([r[ke].lastOpeningBracketAt,Ae]),wj.has(e[j])&&ce.cb?ce.cb({tag:o,deleteFrom:r[ke].lastOpeningBracketAt,deleteTo:j+1,insert:null,rangesArr:be,proposedReturn:[r[ke].lastOpeningBracketAt,j,null]}):ce.cb&&ce.cb({tag:o,deleteFrom:r[ke].lastOpeningBracketAt,deleteTo:j,insert:"",rangesArr:be,proposedReturn:[r[ke].lastOpeningBracketAt,j,""]}),r.splice(ke,1);break}}else o.slashPresent||r.push(o);else Array.isArray(ce.ignoreTagsWithTheirContents)&&I(j,ce,o)&&(b=!1)}function v(j,ce,be,ke,Ae,Pe){var ve;if(Array.isArray(E.current())&&typeof be=="number"&&E.current()[0][0]===0&&E.current()[0][1]>=be)return"";if(e.length===ke&&Pe&&!((ve=C==null?void 0:C.dumpLinkHrefsNearby)!=null&&ve.enabled))return null;let ie="";if(Number.isInteger(be)&&be<Ae&&(ie+=j.slice(be,Ae)),Number.isInteger(ke)&&ke>Pe+1){let pe=j.slice(Pe+1,ke);ke&&!Jo(e,ke-1)&&(pe=pe.trimEnd()),pe.includes(`
`)&&k(ke,j)?ie+=" ":ie+=pe}let Te=!wj.has(j[ce]),Le=j[ke-1]!==">"||!j[be].trim(),$e=!['"',"("].includes(j[Ae-1]),ge=![";",".",":","!"].includes(j[ce]);if((Te||Le&&$e&&ge)&&(Le||$e)&&j[ce]!=="!"&&(!KGe.has(o.name)||typeof be=="number"&&be<Ae||typeof ke=="number"&&ke>Pe+1)){let pe=ie.match(/\n/g);return Array.isArray(pe)&&pe.length?pe.length===1?`
`:pe.length===2?`

`:`


`:" "}return""}function w(j,ce){var be,ke;if((be=j.dumpLinkHrefsNearby)!=null&&be.enabled&&f.tagName&&f.tagName===o.name&&o.lastOpeningBracketAt&&(f.openingTagEnds&&o.lastOpeningBracketAt>f.openingTagEnds||!f.openingTagEnds)&&(g=!0),g){let Ae=(ke=j.dumpLinkHrefsNearby)!=null&&ke.putOnNewLine?`

`:"";m=`${Ae}${f.hrefValue}`,(typeof ce!="number"||Jo(e,ce-1))&&(m+=Ae)}}function k(j,ce){return ce?ce[j]==="<"&&ce[j+1]!=="%":e[j]==="<"&&e[j+1]!=="%"}function S(j){return e[j]===">"&&e[j-1]!=="%"}function I(j,ce,be){if(ce.ignoreTagsWithTheirContents.includes("*"))return!0;let ke=e.indexOf(`<${be.name}`,j),Ae=e.indexOf(`</${be.name}`,j);return!be.slashPresent&&Ae===-1||be.slashPresent&&!s.some(Pe=>Pe.name===be.name)||Ae>-1&&ke>-1&&ke<Ae?!1:ce.ignoreTagsWithTheirContents.includes(be.name)}if(typeof e!="string")throw new TypeError(`string-strip-html/stripHtml(): [THROW_ID_01] Input must be string! Currently it's: ${(typeof e).toLowerCase()}, equal to:
${JSON.stringify(e,null,4)}`);if(t)if(YA(t)){if(t.reportProgressFunc&&typeof t.reportProgressFunc!="function")throw new Error(`string-strip-html/stripHtml(): [THROW_ID_03] The Optional Options Object's key reportProgressFunc, callback function, should be a function but it was given as type ${typeof t.reportProgressFunc}, equal to ${JSON.stringify(t.reportProgressFunc,null,4)}`);if(typeof t.dumpLinkHrefsNearby=="boolean"&&t.dumpLinkHrefsNearby!=null)throw new Error(`string-strip-html/stripHtml(): [THROW_ID_04] The Optional Options Object's key should be a plain object but it was given as type ${typeof t.dumpLinkHrefsNearby}, equal to ${JSON.stringify(t.dumpLinkHrefsNearby,null,4)}`)}else throw new TypeError(`string-strip-html/stripHtml(): [THROW_ID_02] Optional Options Object must be a plain object! Currently it's: ${(typeof t).toLowerCase()}, equal to:
${JSON.stringify(t,null,4)}`);function $(){g&&(f={tagName:"",hrefValue:"",openingTagEnds:void 0},g=!1)}let C={...kj,...t,dumpLinkHrefsNearby:Object.assign({},kj.dumpLinkHrefsNearby,t==null?void 0:t.dumpLinkHrefsNearby)};if(u5e(C,"returnRangesOnly"))throw new TypeError("string-strip-html/stripHtml(): [THROW_ID_05] The Optional Options Object's key returnRangesOnly has been removed from the API since v.5 release.");if(C.reportProgressFunc){if(typeof C.reportProgressFuncFrom!="number")throw new Error(`string-strip-html/stripHtml(): [THROW_ID_06] The Optional Options Object's key reportProgressFuncFrom, callback function's "from" range, should be a number but it was given as type ${typeof C.reportProgressFuncFrom}, equal to ${JSON.stringify(C.reportProgressFuncFrom,null,4)}`);if(typeof C.reportProgressFuncTo!="number")throw new Error(`string-strip-html/stripHtml(): [THROW_ID_07] The Optional Options Object's key reportProgressFuncTo, callback function's "to" range, should be a number but it was given as type ${typeof C.reportProgressFuncTo}, equal to ${JSON.stringify(C.reportProgressFuncTo,null,4)}`)}C.ignoreTags=vj(C.ignoreTags,"resolvedOpts.ignoreTags"),C.onlyStripTags=vj(C.onlyStripTags,"resolvedOpts.onlyStripTags");let T=!!C.onlyStripTags.length;C.onlyStripTags.length&&C.ignoreTags.length&&(C.onlyStripTags=$Ge(C.onlyStripTags,...C.ignoreTags)),C.stripTogetherWithTheirContents?typeof C.stripTogetherWithTheirContents=="string"&&C.stripTogetherWithTheirContents.length&&(C.stripTogetherWithTheirContents=[C.stripTogetherWithTheirContents]):C.stripTogetherWithTheirContents=[];let N={};if(C.stripTogetherWithTheirContents&&Array.isArray(C.stripTogetherWithTheirContents)&&C.stripTogetherWithTheirContents.length&&!C.stripTogetherWithTheirContents.every((j,ce)=>typeof j!="string"?(N.el=j,N.i=ce,!1):!0))throw new TypeError(`string-strip-html/stripHtml(): [THROW_ID_08] Optional Options Object's key stripTogetherWithTheirContents was set to contain not just string elements! For example, element at index ${N.i} has a value ${N.el} which is not string but ${(typeof N.el).toLowerCase()}.`);C.cb||(C.cb=({rangesArr:j,proposedReturn:ce})=>{ce&&j.push(...ce)});let E=new jGe({limitToBeAddedWhitespace:!0,limitLinebreaksCount:2});if(!C.skipHtmlDecoding)for(;e!==gj(e,{scope:"strict"});)e=gj(e,{scope:"strict"});let _=!1,R=!1,z=0,W=0,F=e.length,L=Math.floor(F/2);for(let j=0;j<F;j++){if(C.reportProgressFunc&&(F>1e3&&F<2e3?j===L&&C.reportProgressFunc(Math.floor((C.reportProgressFuncTo-C.reportProgressFuncFrom)/2)):F>=2e3&&(z=C.reportProgressFuncFrom+Math.floor(j/F*(C.reportProgressFuncTo-C.reportProgressFuncFrom)),z!==W&&(W=z,C.reportProgressFunc(z)))),Object.keys(o).length>1&&o.lastClosingBracketAt&&o.lastClosingBracketAt<j&&e[j]!==" "&&y===null&&(y=j),!_&&e[j]==="%"&&e[j-1]==="{"&&e.includes("%}",j+1)){d=null;let ce=e.indexOf("%}",j)-1;if(ce>j){j=ce;continue}}if(!_&&S(j)&&(!o||Object.keys(o).length<2)&&j>1){for(let ce=j;ce--;)if(e[ce-1]===void 0||S(ce)){let be=e[ce-1]===void 0?ce:ce+1,ke=e.slice(be,j+1)||"";if((ke.includes("/>")||ke.includes("/ >")||ke.includes('="')||ke.includes("='"))&&e!==`<${fj(ke.trim(),"/>")}>`&&[...wv].some(Ae=>fj(ke.trim().split(/\s+/).filter(Pe=>Pe.trim()).filter((Pe,ie)=>ie===0),"/>").toLowerCase()===Ae)&&ts(`<${ke.trim()}>`,C).result===""){(!a.length||a[a.length-1][0]!==o.lastOpeningBracketAt)&&a.push([be,j+1]),(!i.length||i[i.length-1][0]!==o.lastOpeningBracketAt)&&i.push([be,j+1]);let Ae=v(e,j,be,j+1,be,j+1),Pe=j+1;if(e[Pe]&&!e[Pe].trim()){for(let ie=Pe;ie<F;ie++)if(e[ie].trim()){Pe=ie;break}}C.cb({tag:o,deleteFrom:be,deleteTo:Pe,insert:Ae,rangesArr:E,proposedReturn:[be,Pe,Ae]})}break}}if(!R&&e[j]==="/"&&!((D=o.quotes)!=null&&D.value)&&Number.isInteger(o.lastOpeningBracketAt)&&!Number.isInteger(o.lastClosingBracketAt)&&(o.slashPresent=j),e[j]==='"'||e[j]==="'")if(!R&&o.nameStarts&&((B=o==null?void 0:o.quotes)==null?void 0:B.value)===e[j]){p.valueEnds=j,p.value=e.slice(p.valueStarts,j),o.attributes.push(p),p={},delete o.quotes;let ce;(V=C.dumpLinkHrefsNearby)!=null&&V.enabled&&!r.length&&o.attributes.some(be=>{var ke,Ae;if(typeof be.name=="string"&&be.name.toLowerCase()==="href")return ce=`${((ke=C.dumpLinkHrefsNearby)==null?void 0:ke.wrapHeads)||""}${be.value}${((Ae=C.dumpLinkHrefsNearby)==null?void 0:Ae.wrapTails)||""}`,!0})&&(f={tagName:o.name,hrefValue:ce,openingTagEnds:void 0})}else!R&&!o.quotes&&o.nameStarts&&(o.quotes={},o.quotes.value=e[j],o.quotes.start=j,o.quotes.next=e.indexOf(e[j],j+1),p.nameStarts&&p.nameEnds&&p.nameEnds<j&&p.nameStarts<j&&!p.valueStarts&&(p.name=e.slice(p.nameStarts,p.nameEnds)));if(o.nameStarts!==void 0&&o.nameEnds===void 0&&(!e[j].trim()||!HGe(e[j]))){if(o.nameEnds=j,o.name=e.slice(o.nameStarts,o.nameEnds+(!S(j)&&e[j]!=="/"&&e[j+1]===void 0?1:0)),e[o.nameStarts-1]!=="!"&&!o.name.replace(/-/g,"").length||/^\d+$/.test(o.name[0])){o={};continue}if(typeof o.name=="string"&&o.name.toLowerCase()==="doctype"&&(R=!0),k(j)){w(C);let ce=v(e,j,o.leftOuterWhitespace,j,o.lastOpeningBracketAt,j);(C.stripTogetherWithTheirContents.includes(o.name)||C.stripTogetherWithTheirContents.includes("*"))&&(i=i.filter(([be,ke])=>!(be===o.leftOuterWhitespace&&ke===j))),C.cb({tag:o,deleteFrom:o.leftOuterWhitespace,deleteTo:j,insert:`${ce}${m}${ce}`,rangesArr:E,proposedReturn:[o.leftOuterWhitespace,j,`${ce}${m}${ce}`]}),$(),x(j,C,E)}}if((K=o.quotes)!=null&&K.start&&o.quotes.start<j&&!o.quotes.end&&p.nameEnds&&p.equalsAt&&!p.valueStarts&&(p.valueStarts=j),!o.quotes&&p.nameEnds&&e[j]==="="&&!p.valueStarts&&!p.equalsAt&&(p.equalsAt=j),!o.quotes&&p.nameStarts&&p.nameEnds&&!p.valueStarts&&e[j].trim()&&e[j]!=="="&&(o.attributes.push(p),p={}),!o.quotes&&p.nameStarts&&!p.nameEnds&&(R&&`'"`.includes(e[p.nameStarts])?p.nameStarts<j&&e[j]===e[p.nameStarts]&&(p.nameEnds=j+1,p.name=e.slice(p.nameStarts,p.nameEnds)):e[j].trim()?e[j]==="="?p.equalsAt||(p.nameEnds=j,p.equalsAt=j,p.name=e.slice(p.nameStarts,p.nameEnds)):e[j]==="/"||S(j)?(p.nameEnds=j,p.name=e.slice(p.nameStarts,p.nameEnds),o.attributes.push(p),p={}):k(j)&&(p.nameEnds=j,p.name=e.slice(p.nameStarts,p.nameEnds),o.attributes.push(p),p={}):(p.nameEnds=j,p.name=e.slice(p.nameStarts,p.nameEnds))),!o.quotes&&o.nameEnds<j&&!e[j-1].trim()&&e[j].trim()&&!"<>/!".includes(e[j])&&!p.nameStarts&&!o.lastClosingBracketAt&&(p.nameStarts=j),o.lastOpeningBracketAt!==null&&o.lastOpeningBracketAt<j&&e[j]==="/"&&o.onlyPlausible&&(o.onlyPlausible=!1),o.lastOpeningBracketAt!==null&&o.lastOpeningBracketAt<j&&e[j]!=="/"&&(o.onlyPlausible===void 0&&((!e[j].trim()||k(j))&&!o.slashPresent?o.onlyPlausible=!0:o.onlyPlausible=!1),e[j].trim()&&o.nameStarts===void 0&&!k(j)&&e[j]!=="/"&&!S(j)&&e[j]!=="!"&&(o.nameStarts=j,o.nameContainsLetters=!1)),o.nameStarts&&!o.quotes&&typeof e[j]=="string"&&e[j].toLowerCase()!==e[j].toUpperCase()&&(o.nameContainsLetters=!0),S(j)&&(xj(o,e,j)||o.quotes.value&&typeof o.lastOpeningBracketAt=="number"&&qGe(o.quotes.value,e.slice(o.lastOpeningBracketAt,j))%2===1&&!e.slice(o.lastOpeningBracketAt+1,j).includes("<")&&!e.slice(o.lastOpeningBracketAt+1,j).includes(">"))&&o.lastOpeningBracketAt!==void 0&&(o.lastClosingBracketAt=j,y=null,Object.keys(p).length&&(o.attributes.push(p),p={}),(G=C.dumpLinkHrefsNearby)!=null&&G.enabled&&f.tagName&&!f.openingTagEnds&&(f.openingTagEnds=j)),(!R||e[j]===">")&&o.lastOpeningBracketAt!==void 0){if(o.lastClosingBracketAt===void 0){if(o.lastOpeningBracketAt<j&&!k(j)&&(e[j+1]===void 0||k(j+1)&&!((U=o==null?void 0:o.quotes)!=null&&U.value))&&o.nameContainsLetters&&typeof o.nameStarts=="number"){if(o.name=e.slice(o.nameStarts,o.nameEnds||j+1).toLowerCase(),(!a.length||a[a.length-1][0]!==o.lastOpeningBracketAt)&&a.push([o.lastOpeningBracketAt,j+1]),C.ignoreTags.includes(o.name)||I(j,C,o)||!wv.has(o.name)&&(o.onlyPlausible||C.stripRecognisedHTMLOnly)){o={},p={};continue}if((wv.has(o.name)||$E.has(o.name))&&(o.onlyPlausible===!1||o.onlyPlausible===!0&&o.attributes.length)||e[j+1]===void 0){w(C);let ce=v(e,j,o.leftOuterWhitespace,j+1,o.lastOpeningBracketAt,o.lastClosingBracketAt);_&&o.name==="script"&&o.slashPresent&&(_=!1);let be;ce===null||m===null?be=null:be=`${ce}${m}${ce}`,C.cb({tag:o,deleteFrom:o.leftOuterWhitespace,deleteTo:j+1,insert:be,rangesArr:E,proposedReturn:[o.leftOuterWhitespace,j+1,be]}),$(),x(j,C,E)}if(!i.length||i[i.length-1][0]!==o.lastOpeningBracketAt&&i[i.length-1][1]!==j+1)if(C.stripTogetherWithTheirContents.includes(o.name)||C.stripTogetherWithTheirContents.includes("*")){let ce;for(let be=r.length;be--;)r[be].name===o.name&&(ce=r[be]);ce?(i=i.filter(([be])=>be!==ce.lastOpeningBracketAt),i.push([ce.lastOpeningBracketAt,j+1])):i.push([o.lastOpeningBracketAt,j+1])}else i.push([o.lastOpeningBracketAt,j+1])}}else if(j>o.lastClosingBracketAt&&e[j].trim()||e[j+1]===void 0||C.ignoreIndentations&&`\r
`.includes(e[j])){let ce=o.lastClosingBracketAt===j?j+1:j;C.trimOnlySpaces&&ce===F-1&&y!==null&&y<j&&(ce=y),(!a.length||a[a.length-1][0]!==o.lastOpeningBracketAt)&&a.push([o.lastOpeningBracketAt,o.lastClosingBracketAt+1]);let be=C.ignoreTags.includes(o.name),ke=I(j,C,o);if(!b||C.stripRecognisedHTMLOnly&&typeof o.name=="string"&&!wv.has(o.name.toLowerCase())&&!$E.has(o.name.toLowerCase())||!T&&(be||ke)||T&&!C.onlyStripTags.includes(o.name)||C.ignoreTagsWithTheirContents.includes(o.name)){if(ke)if(o.slashPresent){for(let Ae=s.length;Ae--;)if(s[Ae].name===o.name){s.splice(Ae,1);break}s.length||(b=!0)}else b&&(b=!1),s.push(o);C.cb({tag:o,deleteFrom:null,deleteTo:null,insert:null,rangesArr:E,proposedReturn:null}),o={},p={}}else if(!o.onlyPlausible||o.attributes.length===0&&o.name&&(wv.has(o.name.toLowerCase())||$E.has(o.name.toLowerCase()))||(q=o.attributes)!=null&&q.some(Ae=>Ae.equalsAt)){(!i.length||i[i.length-1][0]!==o.lastOpeningBracketAt)&&i.push([o.lastOpeningBracketAt,o.lastClosingBracketAt+1]);let Ae=v(e,j,o.leftOuterWhitespace,ce,o.lastOpeningBracketAt,o.lastClosingBracketAt);m="",g=!1,w(C,ce);let Pe;typeof m=="string"&&m.length?(Pe=`${Ae}${m}${Ae===`

`?`
`:Ae}`,ce===o.lastClosingBracketAt+1&&(!e[ce]||!EE.has(e[ce]))&&(Pe+=" "),o.leftOuterWhitespace===o.lastOpeningBracketAt&&E.last()&&E.last()[1]<o.lastOpeningBracketAt&&(!((Q=C==null?void 0:C.dumpLinkHrefsNearby)!=null&&Q.putOnNewLine)||!EE.has(e[ce]))&&(Pe=" "+Pe)):Pe=Ae,Pe!==null&&(o.leftOuterWhitespace===0||!Jo(e,ce-1))&&(!((ee=C.dumpLinkHrefsNearby)!=null&&ee.enabled)||o.name!=="a")&&(Pe=void 0);let ie=0;if(g&&EE.has(e[ce])){(ae=C.dumpLinkHrefsNearby)!=null&&ae.putOnNewLine&&(Pe=`${e[ce]}${Pe||""}`);let Te=Jo(e,ce);Te&&(Pe!=null&&Pe.endsWith(`
`))?ie+=Te-j:(!Te||Te>j)&&ie++}C.cb({tag:o,deleteFrom:o.leftOuterWhitespace,deleteTo:ce+ie,insert:Pe,rangesArr:E,proposedReturn:[o.leftOuterWhitespace,ce+ie,Pe]}),$(),x(j,C,E)}else o={};S(j)||(o={})}R&&(R=!1)}if((!_||e[j]==="<"&&Jo(e,Jo(e,j))&&e[Jo(e,j)]==="/"&&e.startsWith("script",Jo(e,Jo(e,j))))&&k(j)&&!k(j-1)&&!`'"`.includes(e[j+1])&&(!`'"`.includes(e[j+2])||/\w/.test(e[j+1]))&&!(e[j+1]==="c"&&e[j+2]===":")&&!(e[j+1]==="f"&&e[j+2]==="m"&&e[j+3]==="t"&&e[j+4]===":")&&!(e[j+1]==="s"&&e[j+2]==="q"&&e[j+3]==="l"&&e[j+4]===":")&&!(e[j+1]==="x"&&e[j+2]===":")&&!(e[j+1]==="f"&&e[j+2]==="n"&&e[j+3]===":")&&xj(o,e,j)){if(S(Jo(e,j)))continue;if(o.nameEnds&&o.nameEnds<j&&!o.lastClosingBracketAt&&(o.onlyPlausible===!0&&((ye=o.attributes)!=null&&ye.length)||o.onlyPlausible===!1)){let ce=v(e,j,o.leftOuterWhitespace,j,o.lastOpeningBracketAt,j);C.cb({tag:o,deleteFrom:o.leftOuterWhitespace,deleteTo:j,insert:ce,rangesArr:E,proposedReturn:[o.leftOuterWhitespace,j,ce]}),x(j,C,E),o={},p={}}if(o.lastOpeningBracketAt!==void 0&&o.onlyPlausible&&o.name&&!o.quotes&&(o.lastOpeningBracketAt=void 0,o.name=void 0,o.onlyPlausible=!1),(o.lastOpeningBracketAt===void 0||!o.onlyPlausible)&&!o.quotes&&(o.lastOpeningBracketAt=j,o.slashPresent=!1,o.attributes=[],u===null?o.leftOuterWhitespace=j:C.trimOnlySpaces&&u===0?o.leftOuterWhitespace=c||j:o.leftOuterWhitespace=u,`${e[j+1]}${e[j+2]}${e[j+3]}`=="!--"||`${e[j+1]}${e[j+2]}${e[j+3]}${e[j+4]}${e[j+5]}${e[j+6]}${e[j+7]}${e[j+8]}`=="![CDATA[")){let ce=!0;e[j+2]==="-"&&(ce=!1);let be;for(let ke=j;ke<F;ke++)if((!be&&ce&&`${e[ke-2]}${e[ke-1]}${e[ke]}`=="]]>"||!ce&&`${e[ke-2]}${e[ke-1]}${e[ke]}`=="-->")&&(be=ke),be&&(be<ke&&e[ke].trim()||e[ke+1]===void 0)){let Ae=ke;(e[ke+1]===void 0&&!e[ke].trim()||e[ke]===">")&&(Ae+=1),(!a.length||a[a.length-1][0]!==o.lastOpeningBracketAt)&&a.push([o.lastOpeningBracketAt,be+1]),(!i.length||i[i.length-1][0]!==o.lastOpeningBracketAt)&&i.push([o.lastOpeningBracketAt,be+1]);let Pe=v(e,ke,o.leftOuterWhitespace,Ae,o.lastOpeningBracketAt,be);C.cb({tag:o,deleteFrom:o.leftOuterWhitespace,deleteTo:Ae,insert:Pe,rangesArr:E,proposedReturn:[o.leftOuterWhitespace,Ae,Pe]}),j=ke-1,e[ke]===">"&&(j=ke),o={},p={};break}}}!e[j].trim()||e[j].charCodeAt(0)===847?(u===null&&(u=j,o.lastOpeningBracketAt!==void 0&&o.lastOpeningBracketAt<j&&o.nameStarts&&o.nameStarts<o.lastOpeningBracketAt&&j===o.lastOpeningBracketAt+1&&!r.some(ce=>ce.name===o.name)&&(o.onlyPlausible=!0,o.name=void 0,o.nameStarts=void 0)),(e[j]===`
`||e[j]==="\r")&&(d=j,h&&(h=!1))):(u!==null&&(!o.quotes&&p.equalsAt>u-1&&p.nameEnds&&p.equalsAt>p.nameEnds&&e[j]!=='"'&&e[j]!=="'"&&(YA(p)&&o.attributes.push(p),p={},o.equalsSpottedAt=void 0),u=null),h||(h=!0,b&&!_&&typeof d=="number"&&j&&d<j-1&&(e.slice(d+1,j).trim()?d=null:C.ignoreIndentations||E.push([d+1,j])))),e[j]===" "?c===null&&(c=j):c!==null&&(c=null),o.name==="script"&&(_=!o.slashPresent)}if(e&&!C.ignoreIndentations&&(C.trimOnlySpaces&&e[0]===" "||!C.trimOnlySpaces&&!e[0].trim()))for(let j=0;j<F;j++)if(C.trimOnlySpaces&&e[j]!==" "||!C.trimOnlySpaces&&e[j].trim()){E.push([0,j]);break}else e[j+1]||E.push([0,j+1]);if(e&&(C.trimOnlySpaces&&e[~-e.length]===" "||!C.trimOnlySpaces&&!e[~-e.length].trim())){for(let j=e.length;j--;)if(C.trimOnlySpaces&&e[j]!==" "||!C.trimOnlySpaces&&e[j].trim()){E.push([j+1,F]);break}}let O=E.current();if(!(t!=null&&t.cb)&&O&&(O[0]&&!O[0][0]&&(O[0][1],E.ranges[0]=[E.ranges[0][0],E.ranges[0][1]]),O[O.length-1]&&O[O.length-1][1]===e.length&&(O[O.length-1][0],E.ranges))){let j=E.ranges[E.ranges.length-1][0];e[j-1]&&(C.trimOnlySpaces&&e[j-1]===" "||!C.trimOnlySpaces&&!e[j-1].trim())&&(j-=1);let ce=E.ranges[E.ranges.length-1][2];E.ranges[E.ranges.length-1]=[j,E.ranges[E.ranges.length-1][1]],ce!=null&&ce.trim()&&E.ranges[E.ranges.length-1].push(ce.trimEnd())}return{log:{timeTakenInMilliseconds:Date.now()-n},result:WGe(e,E.current()),ranges:E.current(),allTagLocations:a,filteredTagLocations:i}}function PN(e){return Dr({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeMiterlimit:"10",strokeWidth:"32",d:"M448 256c0-106-86-192-192-192S64 150 64 256s86 192 192 192 192-86 192-192z"}},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M250.26 166.05L256 288l5.73-121.95a5.74 5.74 0 00-5.79-6h0a5.74 5.74 0 00-5.68 6z"}},{tag:"path",attr:{d:"M256 367.91a20 20 0 1120-20 20 20 0 01-20 20z"}}]})(e)}function ml(e){return Dr({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M384 224v184a40 40 0 01-40 40H104a40 40 0 01-40-40V168a40 40 0 0140-40h167.48"}},{tag:"path",attr:{d:"M459.94 53.25a16.06 16.06 0 00-23.22-.56L424.35 65a8 8 0 000 11.31l11.34 11.32a8 8 0 0011.34 0l12.06-12c6.1-6.09 6.67-16.01.85-22.38zM399.34 90L218.82 270.2a9 9 0 00-2.31 3.93L208.16 299a3.91 3.91 0 004.86 4.86l24.85-8.35a9 9 0 003.93-2.31L422 112.66a9 9 0 000-12.66l-9.95-10a9 9 0 00-12.71 0z"}}]})(e)}function Fg(e){return Dr({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{fill:"none",strokeLinejoin:"round",strokeWidth:"32",d:"M336 264.13V436c0 24.3-19.05 44-42.95 44H107c-23.95 0-43-19.7-43-44V172a44.26 44.26 0 0144-44h94.12a24.55 24.55 0 0117.49 7.36l109.15 111a25.4 25.4 0 017.24 17.77z"}},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M200 128v108a28.34 28.34 0 0028 28h108"}},{tag:"path",attr:{fill:"none",strokeLinejoin:"round",strokeWidth:"32",d:"M176 128V76a44.26 44.26 0 0144-44h94a24.83 24.83 0 0117.61 7.36l109.15 111A25.09 25.09 0 01448 168v172c0 24.3-19.05 44-42.95 44H344"}},{tag:"path",attr:{fill:"none",strokeLinecap:"round",strokeLinejoin:"round",strokeWidth:"32",d:"M312 32v108a28.34 28.34 0 0028 28h108"}}]})(e)}function LN(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{d:"M4 6h2v12H4zm4 7h8.586l-4.293 4.293 1.414 1.414L20.414 12l-6.707-6.707-1.414 1.414L16.586 11H8z"}}]})(e)}function zN(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{d:"M18 6h2v12h-2zm-2 5H7.414l4.293-4.293-1.414-1.414L3.586 12l6.707 6.707 1.414-1.414L7.414 13H16z"}}]})(e)}function _E(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{d:"M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"}},{tag:"circle",attr:{cx:"8.5",cy:"10.5",r:"1.5"}},{tag:"circle",attr:{cx:"15.493",cy:"10.493",r:"1.493"}},{tag:"path",attr:{d:"M12 18c4 0 5-4 5-4H7s1 4 5 4z"}}]})(e)}function Ux(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{d:"M12 16c1.671 0 3-1.331 3-3s-1.329-3-3-3-3 1.331-3 3 1.329 3 3 3z"}},{tag:"path",attr:{d:"M20.817 11.186a8.94 8.94 0 0 0-1.355-3.219 9.053 9.053 0 0 0-2.43-2.43 8.95 8.95 0 0 0-3.219-1.355 9.028 9.028 0 0 0-1.838-.18V2L8 5l3.975 3V6.002c.484-.002.968.044 1.435.14a6.961 6.961 0 0 1 2.502 1.053 7.005 7.005 0 0 1 1.892 1.892A6.967 6.967 0 0 1 19 13a7.032 7.032 0 0 1-.55 2.725 7.11 7.11 0 0 1-.644 1.188 7.2 7.2 0 0 1-.858 1.039 7.028 7.028 0 0 1-3.536 1.907 7.13 7.13 0 0 1-2.822 0 6.961 6.961 0 0 1-2.503-1.054 7.002 7.002 0 0 1-1.89-1.89A6.996 6.996 0 0 1 5 13H3a9.02 9.02 0 0 0 1.539 5.034 9.096 9.096 0 0 0 2.428 2.428A8.95 8.95 0 0 0 12 22a9.09 9.09 0 0 0 1.814-.183 9.014 9.014 0 0 0 3.218-1.355 8.886 8.886 0 0 0 1.331-1.099 9.228 9.228 0 0 0 1.1-1.332A8.952 8.952 0 0 0 21 13a9.09 9.09 0 0 0-.183-1.814z"}}]})(e)}function Sj(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{d:"M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"}},{tag:"circle",attr:{cx:"8.5",cy:"10.5",r:"1.5"}},{tag:"circle",attr:{cx:"15.493",cy:"10.493",r:"1.493"}},{tag:"path",attr:{d:"M12 14c-3 0-4 3-4 3h8s-1-3-4-3z"}}]})(e)}function Ij(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{d:"M12 2C6.486 2 2 6.486 2 12s4.486 10 10 10 10-4.486 10-10S17.514 2 12 2zm0 18c-4.411 0-8-3.589-8-8s3.589-8 8-8 8 3.589 8 8-3.589 8-8 8z"}},{tag:"path",attr:{d:"M14.829 14.828a4.055 4.055 0 0 1-1.272.858 4.002 4.002 0 0 1-4.875-1.45l-1.658 1.119a6.063 6.063 0 0 0 1.621 1.62 5.963 5.963 0 0 0 2.148.903 6.042 6.042 0 0 0 2.415 0 5.972 5.972 0 0 0 2.148-.903c.313-.212.612-.458.886-.731.272-.271.52-.571.734-.889l-1.658-1.119a4.017 4.017 0 0 1-.489.592z"}},{tag:"circle",attr:{cx:"8.5",cy:"10.5",r:"1.5"}},{tag:"circle",attr:{cx:"15.493",cy:"10.493",r:"1.493"}}]})(e)}function ac(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"}},{tag:"path",attr:{d:"M3 4V1h2v3h3v2H5v3H3V6H0V4h3zm3 6V7h3V4h7l1.83 2H21c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H5c-1.1 0-2-.9-2-2V10h3zm7 9c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-3.2-5c0 1.77 1.43 3.2 3.2 3.2s3.2-1.43 3.2-3.2-1.43-3.2-3.2-3.2-3.2 1.43-3.2 3.2z"}}]})(e)}function BN(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0V0z"}},{tag:"path",attr:{d:"M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM8 9h8v10H8V9zm7.5-5l-1-1h-5l-1 1H5v2h14V4h-3.5z"}}]})(e)}function HS(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24"},child:[{tag:"path",attr:{fill:"none",d:"M0 0h24v24H0z"}},{tag:"path",attr:{d:"M20 9V7c0-1.1-.9-2-2-2h-3c0-1.66-1.34-3-3-3S9 3.34 9 5H6c-1.1 0-2 .9-2 2v2c-1.66 0-3 1.34-3 3s1.34 3 3 3v4c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-4c1.66 0 3-1.34 3-3s-1.34-3-3-3zm-2 10H6V7h12v12zm-9-6c-.83 0-1.5-.67-1.5-1.5S8.17 10 9 10s1.5.67 1.5 1.5S9.83 13 9 13zm7.5-1.5c0 .83-.67 1.5-1.5 1.5s-1.5-.67-1.5-1.5.67-1.5 1.5-1.5 1.5.67 1.5 1.5zM8 15h8v2H8v-2z"}}]})(e)}const XGe=()=>{const[e,t]=Z.useState(bi().toISOString().slice(0,19)),[n,r]=Z.useState(!0),[s,a]=Z.useState(),[i,o]=Z.useState(""),[l,u]=Z.useState(""),[c,d]=Z.useState(!1),[h,p]=Z.useState([]),[f,m]=Z.useState([]),[g,y]=Z.useState([]),[b,x]=Z.useState(""),[v,w]=Z.useState(!1),[k,S]=Z.useState(!1),[I,$]=Z.useState(!1),[C,T]=Z.useState(!0),[N,E]=Z.useState(!1),[_,R]=Z.useState(!1),[z,W]=Z.useState(""),[F,L]=Z.useState("No Action"),[O,D]=Z.useState("confirmation"),[B,V]=Z.useState(),[K,G]=Z.useState(""),[U,q]=Z.useState(""),Q=Z.useRef(null),ee=Z.useRef(null),ae=Z.useRef(null);Z.useEffect(()=>{ie()},[]),Z.useEffect(()=>{if(k){let ve=[];for(let pe of h)pe.createdAt!=null&&e.slice(0,10)===pe.createdAt.toString().slice(0,10)&&ve.push(pe.createdAt.toString().slice(0,19));y(ve)}},[e]),Z.useEffect(()=>{let ve=0;return n==!0?ve=setInterval(()=>{t(bi().toISOString().slice(0,19))},1e3):clearInterval(ve),()=>clearInterval(ve)},[n]),Z.useEffect(()=>{if(k===!1){const ve=i.trim().toLowerCase();for(let pe of h)if(pe.journalTitle.trim().toLowerCase()===ve){T(!1);break}else T(!0)}},[i]),Z.useEffect(()=>{if(k===!0){const ve=h.find(ze=>ze._id===s),pe=i.trim(),Ie=l.trim();pe!==(ve==null?void 0:ve.journalTitle)||Ie!==ve.journalEntry?E(!1):E(!0)}},[i,l]),Z.useEffect(()=>{console.log("Attempting to load model..."),(async()=>{await RJ,console.log(fF());const pe=await _S("https://tpd20seu.projects.cmp.uea.ac.uk/journal/models/TFJSBinaryNeuralNetworkClassifier/model.json");V(pe),console.log("Fetch journal model completed :)")})()},[]);const ye={toolbar:[[{size:["small",!1,"large","huge"]}],["bold","italic","underline"],[{list:"ordered"},{list:"bullet"}],["clean"]]},j=["size","bold","italic","underline","list","bullet","clean"];function ce(){o(""),a(""),u(""),r(!0),$(!1),S(!1),L("No Action"),D("confirmation"),G(""),q(""),E(!1)}async function be(ve){ve.preventDefault(),d(!0);let pe={journalTitle:"",journalEntry:"",stressStatus:"",stressProb:""},Ie="",ze="";if(O==="manualPrediction")K==="Stressed"?Ie="Not Stressed (Manual)":Ie="Stressed (Manual)",ze="100%",pe=Pe(Ie,ze);else if(!I){const Ye=await Ae();Ye&&(Ie=Ye.status,ze=Ye.prob,pe=Pe(Ie,ze))}k?k&&I?(await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/journal/${s}`,{method:"DELETE",headers:{"Content-Type":"application/json"},credentials:"include"}),console.log(`DELETE request with journal '${i}' was sent successfully to the server!`),W(`Journal entry titled '${i}' has been deleted!`)):k&&(await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/journal/${s}`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify(pe),credentials:"include"}),console.log(`PATCH request with journal '${pe.journalTitle}' was sent successfully to the server!`),W(`The journal entry titled '${i.trim()}' has been edited successfully!

Our model has marked the entry as ${Ie} with a probability of ${ze}`)):(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/journal",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(pe),credentials:"include"}),console.log(`POST request with journal '${pe.journalTitle}' was sent successfully to the server!`),W(`New journal entry titled '${i.trim()}' has been created successfully!

Our model has marked the entry as ${Ie} with a probability of ${ze}`)),ie(),d(!1),D("understand"),R(!0)}function ke(ve){return ve[0]>ve[1]?0:1}async function Ae(){try{d(!0);const ve=await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/journal/journalEntryPreProcessing",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({journalEntry:ts(l).result.trim()}),credentials:"include"});if(!ve.ok)throw new Error(`Error: ${ve.status}`);const Ie=(await ve.json()).preProcessedJournalEntry.inputEntryTransformed,ze=v2(Ie,[1,Ie[0].length]),Ye=B.predict(ze);console.log("prediction = "),console.log(Ye);const Je=Ye.arraySync()[0];console.log("scores ="),console.log(Je);const Ke=ke(Je),Ue=Ke===1?"Stressed":"Not Stressed",Xe=`${(Je[Ke]*100).toFixed(2)}%`;return G(Ue),q(Xe),ze.dispose(),Ye.dispose(),d(!1),{status:Ue,prob:Xe}}catch(ve){console.log("error occurred"),console.error("Error:",ve)}}function Pe(ve,pe){return{journalTitle:i.trim(),journalEntry:l.trim(),stressStatus:ve,stressProb:pe}}async function ie(){const pe=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/journal",{method:"Get",credentials:"include"})).json();Array.isArray(pe)&&pe[0].hasOwnProperty("journalTitle")&&pe.length!=0?(p(pe),m(pe)):(p([]),m([]))}function Te(ve){if(!ee.current||!ae.current)return;let pe=0;for(const ze of h)if(ze._id===s){pe=h.indexOf(ze);break}let Ie;ve==="prev"?h[pe-1]===void 0?(x("No more previous journals exist!"),ee.current.disabled=!0):(Ie=h[pe-1],ee.current.disabled=!1,ae.current.disabled=!1):ve==="next"&&(h[pe+1]===void 0?(x("No more following journals exist!"),ae.current.disabled=!0):(Ie=h[pe+1],ae.current.disabled=!1,ee.current.disabled=!1)),Ie&&(G(Ie.stressStatus),q(Ie.stressProb),a(Ie._id),o(Ie.journalTitle),u(Ie.journalEntry),x(""),Ie.createdAt!=null&&t(Ie.createdAt.toString().slice(0,19)))}function Le(ve){const pe=ve.target.innerText;for(let Ie of h)pe===Ie.journalTitle&&(G(Ie.stressStatus),q(Ie.stressProb),a(Ie._id),o(Ie.journalTitle),u(Ie.journalEntry),x(""),r(!1),Ie.createdAt!=null&&t(Ie.createdAt.toString().slice(0,19)),S(!0),E(!0),w(!1))}Z.useEffect(()=>{$e()},[v,f]);function $e(){const ve=Q.current;let pe=null;if(ve)for(let Ie of ve.rows){const ze=Ie.cells[0];pe===null||ze.innerText!==pe.innerText?pe=ze:(pe.rowSpan++,ze.remove())}}async function ge(ve){const pe=ve.target.value.trim();if(pe==="")m(h);else{const Ie=h.filter(ze=>ze.journalTitle.toLowerCase().includes(pe.toLowerCase()));m(Ie)}}return A.jsxs(A.Fragment,{children:[c&&A.jsxs("div",{id:"loadingSpinnerContainer",children:[A.jsx(ly,{visible:!0,height:"80",width:"80",color:"#FED362",ariaLabel:"tail-spin-loading",radius:"1",wrapperStyle:{},wrapperClass:""}),A.jsx("h2",{children:"Processing Request...."})]}),!c&&A.jsxs(A.Fragment,{children:[A.jsx(nr,{id:"invalidEntryTooltip",place:"top",content:"Your journal entry must have a title and content"}),A.jsx(nr,{id:"invalidEntryTooltip2",place:"top",content:"Your journal entry title must be unique"}),A.jsx(nr,{id:"entryNotSubmitted",place:"top",content:k?"The changes to this journal have not been submitted yet":"This journal has not been submitted yet"}),A.jsx(nr,{id:"manualPredictionTooltip",place:"top",content:"Click here if the stress prediction of this journal is incorrect"}),A.jsx("h1",{children:"Mood Journal"}),A.jsx("p",{className:"infoP",children:"Your personal brain dump! A page for writing journal entries about your day, your mood, or anything else on your mind :)"}),A.jsx("p",{className:"infoP",children:"The journal model will make stress predictions in the browser on your device."}),A.jsx("hr",{}),!v&&A.jsxs("form",{id:"journalForm",onSubmit:be,children:[A.jsx(x0,{header:z,dialogShow:_,dialogConfirmation:O,onConfirm:()=>{F==="Delete"&&$(!0),R(!1)},onCancel:()=>{R(!1)},onUnderstand:()=>{ce(),R(!1)},onManualPrediction:()=>{R(!1)}}),A.jsxs("div",{id:"journalModeContainer",children:[k?A.jsx("h2",{children:"View, Edit, or Delete Entry"}):A.jsx("h2",{children:"Create New Entry"}),K!==""&&U!==""&&A.jsxs("div",{id:"manualPredictionContainer","data-tooltip-id":"manualPredictionTooltip",onClick:()=>{W(`If you believe that our model has made an incorrect prediction on your selfie, please click the confirm button.

Your selfie will be marked with the correct stress status and this entry will be used to help train our model in the future.`),D("manualPrediction"),R(!0)},children:[A.jsx("p",{id:"manualPredictionP",children:"Wrong?"}),A.jsx(PN,{})]})]}),A.jsxs("div",{id:"journalTopContainer",children:[A.jsxs("div",{id:"journalTopEntryTitleContainer",children:[A.jsxs("label",{id:"entryTitleLbl",htmlFor:"Title",children:[N&&A.jsx("h3",{id:"entryTitleSubmittedH3",children:" Entry Title:"}),!N&&A.jsx("h3",{id:"entryTitleNotSubmittedH3","data-tooltip-id":"entryNotSubmitted",children:"Entry Title:*"})]}),A.jsx("input",{type:"text",id:"entryTitleTxt",placeholder:"Enter title for your journal entry...",name:"Title",maxLength:50,value:i,onChange:ve=>{o(ve.target.value)}}),A.jsx("label",{id:"stressLbl",children:K===""||U===""?A.jsx("h3",{children:"Stress Status Unknown"}):A.jsx("h3",{id:K==="Stressed"?"stressed":"notStressed",children:`${K} - ${U}`})})]}),A.jsxs("div",{id:"journalTopControlsContainer",children:[!k&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"journalPredictStressBtn",className:"journalTopControlBtn",onClick:()=>{Ae()},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Predict Stress",A.jsx(HS,{id:"journalPredictStressIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"submit",id:"journalCreateBtn",className:"journalTopControlBtn",onClick:ve=>{ve.preventDefault(),W("Are you happy with submitting your entry?"),R(!0)},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Submit New Entry",A.jsx(ml,{id:"journalSubmitBtnArrow",className:"journalTopControlBtnIcon"})]})]}),k&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"journalResetBtn",className:"journalTopControlBtn",onClick:()=>{for(let ve of h)s===ve._id&&(o(ve.journalTitle),u(ve.journalEntry),G(ve.stressStatus),q(ve.stressProb))},children:["Reset Changes",A.jsx(Ux,{id:"journalResetBtnIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"submit",id:"journalDeleteBtn",className:"journalTopControlBtn",onClick:ve=>{ve.preventDefault(),W("Are you sure you want to delete this journal?"),L("Delete"),R(!0)},children:["Delete Journal",A.jsx(BN,{id:"journalDeleteBtnIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"journalPredictStressBtn",className:"journalTopControlBtn",onClick:()=>{Ae()},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Predict Stress",A.jsx(HS,{id:"journalPredictStressIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"submit",id:"journalSaveBtn",className:"journalTopControlBtn",onClick:ve=>{ve.preventDefault(),W("Are you sure you want to save the changes made to this journal?"),R(!0)},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Submit Entry Changes",A.jsx(ml,{id:"journalSubmitBtnArrow",className:"journalTopControlBtnIcon"})]})]})]})]}),A.jsx("div",{id:"quillJournalContainer",children:A.jsx(AJ,{id:"entryArea",theme:"snow",modules:ye,formats:j,value:l,onChange:u,placeholder:"Begin your journal entry..."})}),A.jsxs("div",{id:"journalBottomContainer",children:[k&&A.jsxs("h3",{id:"entryNumberLbl",children:["Entries for this day: ",g.indexOf(e)+1,"/",g.length]}),A.jsxs("div",{id:"journalBottomControlsContainer",children:[k&&A.jsxs("button",{type:"button",id:"cancelEditBtn",className:"journalBottomControlBtn",onClick:()=>{a(""),u(""),o(""),x(""),r(!0),S(!1),E(!1),w(!1),q(""),G("")},children:["Create New Entry",A.jsx(ml,{id:"createNewJournalBtnIcon"})]}),k&&A.jsxs("button",{type:"button",id:"journalPrevEntryBtn",ref:ee,className:"journalBottomControlBtn",onClick:()=>{Te("prev")},children:[A.jsx(zN,{className:"journalDateArrow"}),"Prev Entry"]}),A.jsx("div",{id:"dateLbl",children:e.replace("T",`
`)}),k&&A.jsxs("button",{type:"button",id:"journalNextEntryBtn",ref:ae,className:"journalBottomControlBtn",onClick:()=>{Te("next")},children:["Next Entry",A.jsx(LN,{className:"journalDateArrow"})]}),A.jsxs("button",{type:"button",id:"journalEntryDateBtn",className:"journalBottomControlBtn",onClick:()=>{a(""),u(""),o(""),x(""),r(!1),S(!1),w(!0),E(!0)},children:["View Old Entries",A.jsx(Fg,{id:"viewOldEntriesIcon"})]})]}),A.jsx("p",{id:"prevNextErrorMessageP",children:b})]})]}),v&&A.jsxs("div",{id:"viewJournalEntriesContainer",children:[A.jsxs("table",{id:"viewJournalEntriesTable",ref:Q,children:[A.jsx("caption",{children:A.jsxs("div",{id:"viewJournalEntriesTitleContainer",children:[A.jsxs("h2",{id:"viewJournalEntriesTitleH2",children:["Your Old Journal Entries ",A.jsx(Fg,{id:"viewOldEntriesIcon"})]}),A.jsx(iy,{placeholder:"Search table by title...",onChange:ve=>{ge(ve)}}),f.length===0&&A.jsx("p",{children:"No entry titles matching the searched term were found :/"})]})}),A.jsx("thead",{children:A.jsxs("tr",{children:[A.jsx("th",{children:"Date"}),A.jsx("th",{children:"Time"}),A.jsx("th",{children:"Title (Click to edit)"}),A.jsx("th",{children:"Stress"})]})}),A.jsx("tbody",{children:f.map((ve,pe)=>{var Ie,ze;return A.jsxs("tr",{children:[A.jsx("td",{"data-cell":"Journal Date",children:(Ie=ve.createdAt)==null?void 0:Ie.toString().slice(0,10)}),A.jsx("td",{"data-cell":"Journal Time",children:(ze=ve.createdAt)==null?void 0:ze.toString().slice(11,19)}),A.jsx("td",{"data-cell":"Journal Title",children:A.jsx("div",{className:"journalTitleCell",onClick:Ye=>Le(Ye),children:ve.journalTitle})}),A.jsx("td",{"data-cell":"Journal Stress",className:ve.stressStatus==="Stressed"?"stressedCell":"notStressedCell",children:`${ve.stressStatus} - ${ve.stressProb}`})]},pe)})})]}),A.jsx("div",{id:"viewJournalEntriesBottomContainer",children:A.jsxs("button",{type:"button",id:"createNewJournalBtn",onClick:()=>{a(""),u(""),o(""),r(!0),S(!1),w(!1),q(""),G("")},children:["Create New Entry",A.jsx(ml,{id:"createNewJournalBtnIcon"})]})})]})]})]})},YGe=()=>{const[e,t]=Z.useState(bi().toISOString().slice(0,19)),[n,r]=Z.useState(!0),[s,a]=Z.useState(),[i,o]=Z.useState(""),[l,u]=Z.useState(""),[c,d]=Z.useState(!1),[h,p]=Z.useState([]),[f,m]=Z.useState([]),[g,y]=Z.useState([]),[b,x]=Z.useState(""),[v,w]=Z.useState(!1),[k,S]=Z.useState(!1),[I,$]=Z.useState(!1),[C,T]=Z.useState(!0),[N,E]=Z.useState(!1),[_,R]=Z.useState(!1),[z,W]=Z.useState(""),[F,L]=Z.useState("No Action"),[O,D]=Z.useState("confirmation"),[B,V]=Z.useState(""),[K,G]=Z.useState(""),U=Z.useRef(null),q=Z.useRef(null),Q=Z.useRef(null);Z.useEffect(()=>{Ae()},[]),Z.useEffect(()=>{if(k){let $e=[];for(let ge of h)ge.createdAt!=null&&e.slice(0,10)===ge.createdAt.toString().slice(0,10)&&$e.push(ge.createdAt.toString().slice(0,19));y($e)}},[e]),Z.useEffect(()=>{let $e=0;return n==!0?$e=setInterval(()=>{t(bi().toISOString().slice(0,19))},1e3):clearInterval($e),()=>clearInterval($e)},[n]),Z.useEffect(()=>{if(k===!1){const $e=i.trim().toLowerCase();for(let ge of h)if(ge.journalTitle.trim().toLowerCase()===$e){T(!1);break}else T(!0)}},[i]),Z.useEffect(()=>{if(k===!0){const $e=h.find(pe=>pe._id===s),ge=i.trim(),ve=l.trim();ge!==($e==null?void 0:$e.journalTitle)||ve!==$e.journalEntry?E(!1):E(!0)}},[i,l]);const ee={toolbar:[[{size:["small",!1,"large","huge"]}],["bold","italic","underline"],[{list:"ordered"},{list:"bullet"}],["clean"]]},ae=["size","bold","italic","underline","list","bullet","clean"];function ye(){o(""),a(""),u(""),r(!0),$(!1),S(!1),L("No Action"),D("confirmation"),V(""),G(""),E(!1)}async function j(){k&&I&&(await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/journal/${s}`,{method:"DELETE",headers:{"Content-Type":"application/json"},credentials:"include"}),console.log(`DELETE request with journal '${i}' was sent successfully to the server!`),W(`Journal entry titled '${i}' has been deleted!`),Ae(),d(!1),D("understand"),R(!0))}async function ce($e){if($e.preventDefault(),d(!0),k&&I){await j();return}let ge={journalTitle:"",journalEntry:"",stressStatus:"",stressProb:""},ve="",pe="";if(O==="manualPrediction")B==="Stressed"?ve="Not Stressed (Manual)":ve="Stressed (Manual)",pe="100%",ge=ke(ve,pe);else if(!I){const Ie=await be(!0);Ie&&(ve=Ie.stressState,pe=Ie.stressProb,ge=ke(ve,pe))}k?k&&(await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/journal/${s}`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify(ge),credentials:"include"}),console.log(`PATCH request with journal '${ge.journalTitle}' was sent successfully to the server!`),W(`The journal entry titled '${i.trim()}' has been edited successfully!

Our model has marked the entry as ${ve} with a probability of ${pe}`)):(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/journal",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(ge),credentials:"include"}),console.log(`POST request with journal '${ge.journalTitle}' was sent successfully to the server!`),W(`New journal entry titled '${i.trim()}' has been created successfully!

Our model has marked the entry as ${ve} with a probability of ${pe}`)),Ae(),d(!1),D("understand"),R(!0)}async function be($e){try{d(!0);const ve=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/journal/journalEntryPrediction",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({journalEntry:ts(l).result.trim()}),credentials:"include"})).json();if(V(ve.predictedJournalEntry.stressState),G(ve.predictedJournalEntry.stressProb),d(!1),$e)return{stressState:ve.predictedJournalEntry.stressState,stressProb:ve.predictedJournalEntry.stressProb}}catch(ge){console.log("error occurred"),console.error("Error:",ge)}}function ke($e,ge){return{journalTitle:i.trim(),journalEntry:l.trim(),stressStatus:$e,stressProb:ge}}async function Ae(){const ge=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/journal",{method:"Get",credentials:"include"})).json();Array.isArray(ge)&&ge[0].hasOwnProperty("journalTitle")&&ge.length!=0?(p(ge),m(ge)):(p([]),m([]))}function Pe($e){if(!q.current||!Q.current)return;let ge=0;for(const pe of h)if(pe._id===s){ge=h.indexOf(pe);break}let ve;$e==="prev"?h[ge-1]===void 0?(x("No more previous journals exist!"),q.current.disabled=!0):(ve=h[ge-1],q.current.disabled=!1,Q.current.disabled=!1):$e==="next"&&(h[ge+1]===void 0?(x("No more following journals exist!"),Q.current.disabled=!0):(ve=h[ge+1],Q.current.disabled=!1,q.current.disabled=!1)),ve&&(V(ve.stressStatus),G(ve.stressProb),a(ve._id),o(ve.journalTitle),u(ve.journalEntry),x(""),ve.createdAt!=null&&t(ve.createdAt.toString().slice(0,19)))}function ie($e){const ge=$e.target.innerText;for(let ve of h)ge===ve.journalTitle&&(V(ve.stressStatus),G(ve.stressProb),a(ve._id),o(ve.journalTitle),u(ve.journalEntry),x(""),r(!1),ve.createdAt!=null&&t(ve.createdAt.toString().slice(0,19)),S(!0),E(!0),w(!1))}Z.useEffect(()=>{Te()},[v,f]);function Te(){const $e=U.current;let ge=null;if($e)for(let ve of $e.rows){const pe=ve.cells[0];ge===null||pe.innerText!==ge.innerText?ge=pe:(ge.rowSpan++,pe.remove())}}async function Le($e){const ge=$e.target.value.trim();if(ge==="")m(h);else{const ve=h.filter(pe=>pe.journalTitle.toLowerCase().includes(ge.toLowerCase()));m(ve)}}return A.jsxs(A.Fragment,{children:[c&&A.jsxs("div",{id:"loadingSpinnerContainer",children:[A.jsx(ly,{visible:!0,height:"80",width:"80",color:"#FED362",ariaLabel:"tail-spin-loading",radius:"1",wrapperStyle:{},wrapperClass:""}),A.jsx("h2",{children:"Processing Request...."})]}),!c&&A.jsxs(A.Fragment,{children:[A.jsx(nr,{id:"invalidEntryTooltip",place:"top",content:"Your journal entry must have a title and content"}),A.jsx(nr,{id:"invalidEntryTooltip2",place:"top",content:"Your journal entry title must be unique"}),A.jsx(nr,{id:"entryNotSubmitted",place:"top",content:k?"The changes to this journal have not been submitted yet":"This journal has not been submitted yet"}),A.jsx(nr,{id:"manualPredictionTooltip",place:"top",content:"Click here if the stress prediction of this journal is incorrect"}),A.jsx("h1",{children:"Mood Journal"}),A.jsx("p",{className:"infoP",children:"Your personal brain dump! A page for writing journal entries about your day, your mood, or anything else on your mind :)"}),A.jsx("p",{className:"infoP",children:"The journal model will make stress predictions in the backend on our server as your device does not support frontend browser predictions."}),A.jsx("hr",{}),!v&&A.jsxs("form",{id:"journalForm",onSubmit:ce,children:[A.jsx(x0,{header:z,dialogShow:_,dialogConfirmation:O,onConfirm:()=>{F==="Delete"&&$(!0),R(!1)},onCancel:()=>{R(!1)},onUnderstand:()=>{ye(),R(!1)},onManualPrediction:()=>{R(!1)}}),A.jsxs("div",{id:"journalModeContainer",children:[k?A.jsx("h2",{children:"View, Edit, or Delete Entry"}):A.jsx("h2",{children:"Create New Entry"}),B!==""&&K!==""&&A.jsxs("div",{id:"manualPredictionContainer","data-tooltip-id":"manualPredictionTooltip",onClick:()=>{W(`If you believe that our model has made an incorrect prediction on your entry, please click the confirm button.

Your entry will be marked with the correct stress status and this entry will be used to help train our model in the future.`),D("manualPrediction"),R(!0)},children:[A.jsx("p",{id:"manualPredictionP",children:"Wrong?"}),A.jsx(PN,{})]})]}),A.jsxs("div",{id:"journalTopContainer",children:[A.jsxs("div",{id:"journalTopEntryTitleContainer",children:[A.jsxs("label",{id:"entryTitleLbl",htmlFor:"Title",children:[N&&A.jsx("h3",{id:"entryTitleSubmittedH3",children:" Entry Title:"}),!N&&A.jsx("h3",{id:"entryTitleNotSubmittedH3","data-tooltip-id":"entryNotSubmitted",children:"Entry Title:*"})]}),A.jsx("input",{type:"text",id:"entryTitleTxt",placeholder:"Enter title for your journal entry...",name:"Title",maxLength:50,value:i,onChange:$e=>{o($e.target.value)}}),A.jsx("label",{id:"stressLbl",children:B===""||K===""?A.jsx("h3",{children:"Stress Status Unknown"}):A.jsx("h3",{id:B==="Stressed"?"stressed":"notStressed",children:`${B} - ${K}`})})]}),A.jsxs("div",{id:"journalTopControlsContainer",children:[!k&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"journalPredictStressBtn",className:"journalTopControlBtn",onClick:()=>{be(!1)},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Predict Stress",A.jsx(HS,{id:"journalPredictStressIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"submit",id:"journalCreateBtn",className:"journalTopControlBtn",onClick:$e=>{$e.preventDefault(),W("Are you happy with submitting your entry?"),R(!0)},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Submit New Entry",A.jsx(ml,{id:"journalSubmitBtnArrow",className:"journalTopControlBtnIcon"})]})]}),k&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"journalResetBtn",className:"journalTopControlBtn",onClick:()=>{for(let $e of h)s===$e._id&&(o($e.journalTitle),u($e.journalEntry),V($e.stressStatus),G($e.stressProb))},children:["Reset Changes",A.jsx(Ux,{id:"journalResetBtnIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"submit",id:"journalDeleteBtn",className:"journalTopControlBtn",onClick:$e=>{$e.preventDefault(),W("Are you sure you want to delete this journal?"),L("Delete"),R(!0)},children:["Delete Journal",A.jsx(BN,{id:"journalDeleteBtnIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"journalPredictStressBtn",className:"journalTopControlBtn",onClick:()=>{be(!1)},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Predict Stress",A.jsx(HS,{id:"journalPredictStressIcon",className:"journalTopControlBtnIcon"})]}),A.jsxs("button",{type:"submit",id:"journalSaveBtn",className:"journalTopControlBtn",onClick:$e=>{$e.preventDefault(),W("Are you sure you want to save the changes made to this journal?"),R(!0)},disabled:i===""||ts(l).result===""||C===!1,"data-tooltip-id":i===""||ts(l).result.trim()===""?"invalidEntryTooltip":C===!1?"invalidEntryTooltip2":"nothing",children:["Submit Entry Changes",A.jsx(ml,{id:"journalSubmitBtnArrow",className:"journalTopControlBtnIcon"})]})]})]})]}),A.jsx("div",{id:"quillJournalContainer",children:A.jsx(AJ,{id:"entryArea",theme:"snow",modules:ee,formats:ae,value:l,onChange:u,placeholder:"Begin your journal entry..."})}),A.jsxs("div",{id:"journalBottomContainer",children:[k&&A.jsxs("h3",{id:"entryNumberLbl",children:["Entries for this day: ",g.indexOf(e)+1,"/",g.length]}),A.jsxs("div",{id:"journalBottomControlsContainer",children:[k&&A.jsxs("button",{type:"button",id:"cancelEditBtn",className:"journalBottomControlBtn",onClick:()=>{a(""),u(""),o(""),x(""),r(!0),S(!1),E(!1),w(!1),G(""),V("")},children:["Create New Entry",A.jsx(ml,{id:"createNewJournalBtnIcon"})]}),k&&A.jsxs("button",{type:"button",id:"journalPrevEntryBtn",ref:q,className:"journalBottomControlBtn",onClick:()=>{Pe("prev")},children:[A.jsx(zN,{className:"journalDateArrow"}),"Prev Entry"]}),A.jsx("div",{id:"dateLbl",children:e.replace("T",`
`)}),k&&A.jsxs("button",{type:"button",id:"journalNextEntryBtn",ref:Q,className:"journalBottomControlBtn",onClick:()=>{Pe("next")},children:["Next Entry",A.jsx(LN,{className:"journalDateArrow"})]}),A.jsxs("button",{type:"button",id:"journalEntryDateBtn",className:"journalBottomControlBtn",onClick:()=>{a(""),u(""),o(""),x(""),r(!1),S(!1),w(!0),E(!0)},children:["View Old Entries",A.jsx(Fg,{id:"viewOldEntriesIcon"})]})]}),A.jsx("p",{id:"prevNextErrorMessageP",children:b})]})]}),v&&A.jsxs("div",{id:"viewJournalEntriesContainer",children:[A.jsxs("table",{id:"viewJournalEntriesTable",ref:U,children:[A.jsx("caption",{children:A.jsxs("div",{id:"viewJournalEntriesTitleContainer",children:[A.jsxs("h2",{id:"viewJournalEntriesTitleH2",children:["Your Old Journal Entries ",A.jsx(Fg,{id:"viewOldEntriesIcon"})]}),A.jsx(iy,{placeholder:"Search table by title...",onChange:$e=>{Le($e)}}),f.length===0&&A.jsx("p",{children:"No entry titles matching the searched term were found :/"})]})}),A.jsx("thead",{children:A.jsxs("tr",{children:[A.jsx("th",{children:"Date"}),A.jsx("th",{children:"Time"}),A.jsx("th",{children:"Title (Click to edit)"}),A.jsx("th",{children:"Stress"})]})}),A.jsx("tbody",{children:f.map(($e,ge)=>{var ve,pe;return A.jsxs("tr",{children:[A.jsx("td",{"data-cell":"Journal Date",children:(ve=$e.createdAt)==null?void 0:ve.toString().slice(0,10)}),A.jsx("td",{"data-cell":"Journal Time",children:(pe=$e.createdAt)==null?void 0:pe.toString().slice(11,19)}),A.jsx("td",{"data-cell":"Journal Title",children:A.jsx("div",{className:"journalTitleCell",onClick:Ie=>ie(Ie),children:$e.journalTitle})}),A.jsx("td",{"data-cell":"Journal Stress",className:$e.stressStatus==="Stressed"?"stressedCell":"notStressedCell",children:`${$e.stressStatus} - ${$e.stressProb}`})]},ge)})})]}),A.jsx("div",{id:"viewJournalEntriesBottomContainer",children:A.jsxs("button",{type:"button",id:"createNewJournalBtn",onClick:()=>{a(""),u(""),o(""),r(!0),S(!1),w(!1),G(""),V("")},children:["Create New Entry",A.jsx(ml,{id:"createNewJournalBtnIcon"})]})})]})]})]})};var JGe=Object.defineProperty,ZGe=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),SM=(e,t)=>{for(var n in t)JGe(e,n,{get:t[n],enumerable:!0})},QGe={};SM(QGe,{Abs:()=>Fy,Acos:()=>Tp,Acosh:()=>$p,AdadeltaOptimizer:()=>jP,AdagradOptimizer:()=>GP,AdamOptimizer:()=>HP,AdamaxOptimizer:()=>qP,Add:()=>fd,AddN:()=>Ep,All:()=>My,Any:()=>Py,ArgMax:()=>Ly,ArgMin:()=>zy,Asin:()=>_p,Asinh:()=>Ap,Atan:()=>Rp,Atan2:()=>Op,Atanh:()=>Dp,AvgPool:()=>Fp,AvgPool3D:()=>By,AvgPool3DGrad:()=>qx,AvgPoolGrad:()=>Hx,BackendWasm:()=>toe,BatchMatMul:()=>Mp,BatchToSpaceND:()=>Wy,Bincount:()=>Vy,BitwiseAnd:()=>Uy,BroadcastArgs:()=>Kx,BroadcastTo:()=>uZ,Callback:()=>ene,CallbackList:()=>Xee,Cast:()=>Pp,Ceil:()=>Lp,ClipByValue:()=>md,Complex:()=>GN,ComplexAbs:()=>Xx,Concat:()=>jy,Conv2D:()=>zp,Conv2DBackpropFilter:()=>HN,Conv2DBackpropInput:()=>Bp,Conv3D:()=>Wp,Conv3DBackpropFilterV2:()=>Gy,Conv3DBackpropInputV2:()=>Hy,Cos:()=>Vp,Cosh:()=>Up,CropAndResize:()=>Ky,Cumprod:()=>qy,Cumsum:()=>jp,CustomCallback:()=>Jee,DataStorage:()=>VN,DenseBincount:()=>Yx,DepthToSpace:()=>Xy,DepthwiseConv2dNative:()=>Gp,DepthwiseConv2dNativeBackpropFilter:()=>qN,DepthwiseConv2dNativeBackpropInput:()=>KN,Diag:()=>Jx,Dilation2D:()=>Hp,Dilation2DBackpropFilter:()=>Lg,Dilation2DBackpropInput:()=>Pg,Draw:()=>XN,ENV:()=>$M,EarlyStopping:()=>tne,Einsum:()=>YN,Elu:()=>Kp,EluGrad:()=>Yy,Environment:()=>oZ,Equal:()=>Jy,Erf:()=>Xp,Exp:()=>Yp,ExpandDims:()=>Zy,Expm1:()=>Jp,FFT:()=>JN,Fill:()=>Zx,FlipLeftRight:()=>Qy,Floor:()=>Zp,FloorDiv:()=>Qp,FromPixels:()=>YS,FusedBatchNorm:()=>ef,FusedConv2D:()=>jh,FusedDepthwiseConv2D:()=>Gh,GPGPUContext:()=>$2,GatherNd:()=>tb,GatherV2:()=>eb,GraphModel:()=>D4,Greater:()=>nb,GreaterEqual:()=>nf,History:()=>Yee,IFFT:()=>ZN,Identity:()=>rf,Imag:()=>QN,InputSpec:()=>Tr,IsFinite:()=>sf,IsInf:()=>af,IsNan:()=>of,KernelBackend:()=>jx,LRN:()=>df,LRNGrad:()=>ub,LayerVariable:()=>Wee,LayersModel:()=>iu,LeakyRelu:()=>lf,Less:()=>rb,LessEqual:()=>sb,LinSpace:()=>ab,Log:()=>uf,Log1p:()=>cf,LogSoftmax:()=>dZ,LogicalAnd:()=>ib,LogicalNot:()=>ob,LogicalOr:()=>lb,LogicalXor:()=>cZ,LowerBound:()=>jHe,MathBackendCPU:()=>M4,MathBackendWebGL:()=>cz,MatrixBandPart:()=>GHe,Max:()=>hf,MaxPool:()=>ff,MaxPool3D:()=>cb,MaxPool3DGrad:()=>ew,MaxPoolGrad:()=>Qx,MaxPoolWithArgmax:()=>tw,Maximum:()=>pf,Mean:()=>mf,Min:()=>gf,Minimum:()=>yf,MirrorPad:()=>bf,Mod:()=>vf,MomentumOptimizer:()=>KP,Multinomial:()=>db,Multiply:()=>xf,Neg:()=>hb,NonMaxSuppressionV3:()=>fb,NonMaxSuppressionV4:()=>mb,NonMaxSuppressionV5:()=>gb,NotEqual:()=>pb,OP_SCOPE_SUFFIX:()=>DM,OneHot:()=>wf,OnesLike:()=>yb,Optimizer:()=>Du,OptimizerConstructors:()=>xee,Pack:()=>bb,PadV2:()=>kf,Pool:()=>HHe,Pow:()=>Sf,Prelu:()=>If,Prod:()=>Cf,RMSPropOptimizer:()=>XP,RNN:()=>Ou,RaggedGather:()=>eT,RaggedRange:()=>tT,RaggedTensorToTensor:()=>nT,Range:()=>nw,Rank:()=>tR,Real:()=>rT,RealDiv:()=>qp,Reciprocal:()=>Nf,Reduction:()=>Ks,Relu:()=>Tf,Relu6:()=>_f,Reshape:()=>vb,ResizeBilinear:()=>Ef,ResizeBilinearGrad:()=>wb,ResizeNearestNeighbor:()=>$f,ResizeNearestNeighborGrad:()=>xb,Reverse:()=>Af,RotateWithOffset:()=>Mb,Round:()=>Rf,Rsqrt:()=>Df,SGDOptimizer:()=>LT,ScatterNd:()=>kb,SearchSorted:()=>Ib,Select:()=>Cb,Selu:()=>Of,Sequential:()=>JT,Sigmoid:()=>Lf,Sign:()=>Pf,Sin:()=>Ff,Sinh:()=>Mf,Slice:()=>Nb,Softmax:()=>Vf,Softplus:()=>zf,SpaceToBatchND:()=>Tb,SparseFillEmptyRows:()=>rw,SparseReshape:()=>Eb,SparseSegmentMean:()=>sw,SparseSegmentSum:()=>aw,SparseToDense:()=>_b,SplitV:()=>$b,Sqrt:()=>Bf,Square:()=>iw,SquaredDifference:()=>Uf,StaticRegexReplace:()=>ow,Step:()=>yd,StridedSlice:()=>Ab,StringNGrams:()=>lw,StringSplit:()=>uw,StringToHashBucketFast:()=>cw,Sub:()=>jf,Sum:()=>Wf,SymbolicTensor:()=>Vo,Tan:()=>Gf,Tanh:()=>Hf,Tensor:()=>Bt,TensorBuffer:()=>Er,TensorScatterUpdate:()=>Sb,Tile:()=>gd,TopK:()=>Rb,Transform:()=>Db,Transpose:()=>au,Unique:()=>dw,Unpack:()=>Ob,UnsortedSegmentSum:()=>hw,UpperBound:()=>qHe,Variable:()=>Hh,ZerosLike:()=>Fb,_FusedMatMul:()=>Uh,abs:()=>Ir,acos:()=>LM,acosh:()=>zM,add:()=>De,addN:()=>zZ,all:()=>lT,any:()=>e0,argMax:()=>Yh,argMin:()=>BM,asin:()=>WM,asinh:()=>VM,atan:()=>UM,atan2:()=>jM,atanh:()=>GM,avgPool:()=>_u,avgPool3d:()=>qM,backend:()=>OM,backend_util:()=>H,basicLSTMCell:()=>UZ,batchNorm:()=>qf,batchNorm2d:()=>KM,batchNorm3d:()=>XM,batchNorm4d:()=>YM,batchToSpaceND:()=>vw,bincount:()=>JM,bitwiseAnd:()=>jZ,booleanMaskAsync:()=>DQ,broadcastArgs:()=>GZ,broadcastTo:()=>gh,broadcast_util:()=>Pb,browser:()=>Rw,buffer:()=>zt,callbacks:()=>Vst,cast:()=>je,ceil:()=>ZM,clipByValue:()=>Fs,clone:()=>Nl,complex:()=>yu,concat:()=>In,concat1d:()=>QM,concat2d:()=>eP,concat3d:()=>tP,concat4d:()=>nP,constraints:()=>Gee,conv1d:()=>uT,conv2d:()=>ta,conv2dTranspose:()=>cT,conv3d:()=>sP,conv3dTranspose:()=>aP,copyRegisteredKernels:()=>JHe,cos:()=>xw,cosh:()=>dT,cosineWindow:()=>DT,cumprod:()=>r0,cumsum:()=>hT,customGrad:()=>Pl,data:()=>Cne,denseBincount:()=>eI,deprecationWarn:()=>CZ,depthToSpace:()=>iP,depthwiseConv2d:()=>Kf,deregisterOp:()=>Gst,device_util:()=>gw,diag:()=>qZ,dilation2d:()=>oP,disableDeprecationWarnings:()=>T8e,dispose:()=>_t,disposeVariables:()=>$8e,div:()=>ot,divNoNan:()=>lP,dot:()=>uP,dropout:()=>zP,einsum:()=>Kd,elu:()=>Lb,enableDebugMode:()=>N8e,enableProdMode:()=>C8e,enclosingPowerOfTwo:()=>BP,engine:()=>Fi,ensureShape:()=>XZ,env:()=>xe,equal:()=>Za,erf:()=>cP,euclideanNorm:()=>pP,exp:()=>Ms,expandDims:()=>is,expm1:()=>fP,eye:()=>pT,fft:()=>_w,fill:()=>Ka,findBackend:()=>O8e,findBackendFactory:()=>F8e,floor:()=>Bb,floorDiv:()=>oT,forceHalfFloat:()=>Xse,fused:()=>Hg,gather:()=>Wb,gatherND:()=>PQ,gather_util:()=>ZP,getBackend:()=>NZ,getGradient:()=>QA,getKernel:()=>J1,getKernelsForBackend:()=>JS,getThreadsCount:()=>XTt,gpgpu_util:()=>Nse,grad:()=>p7e,grads:()=>f7e,greater:()=>oa,greaterEqual:()=>Au,ifft:()=>Gg,imag:()=>ww,image:()=>di,inTopKAsync:()=>LQ,initializers:()=>Hee,input:()=>dte,io:()=>ws,irfft:()=>NT,isFinite:()=>mP,isInf:()=>gP,isNaN:()=>yP,keep:()=>Vr,kernel_impls:()=>Vl,layers:()=>qee,leakyRelu:()=>kw,less:()=>Wg,lessEqual:()=>vd,linalg:()=>UP,linspace:()=>eQ,loadGraphModel:()=>Jat,loadGraphModelSync:()=>Zat,loadLayersModel:()=>Lnt,localResponseNormalization:()=>bP,log:()=>Qa,log1p:()=>Sw,logSigmoid:()=>vP,logSoftmax:()=>mT,logSumExp:()=>Iw,logicalAnd:()=>eo,logicalNot:()=>Cw,logicalOr:()=>gT,logicalXor:()=>xP,losses:()=>YQ,lowerBound:()=>nQ,matMul:()=>Mt,math:()=>oee,max:()=>vi,maxPool:()=>Qr,maxPool3d:()=>wP,maxPoolWithArgmax:()=>rQ,maximum:()=>Wl,mean:()=>rr,memory:()=>QS,meshgrid:()=>sQ,metrics:()=>Jte,min:()=>Bg,minimum:()=>Vc,mirrorPad:()=>kP,mod:()=>SP,model:()=>Wnt,models:()=>Zte,moments:()=>Nw,movingAverage:()=>OQ,mul:()=>oe,multiRNNCell:()=>aQ,multinomial:()=>iQ,neg:()=>Fn,nextFrame:()=>QP,norm:()=>zb,notEqual:()=>ep,oneHot:()=>Vg,ones:()=>fa,onesLike:()=>ei,op:()=>se,outerProduct:()=>oQ,pad:()=>Ho,pad1d:()=>lQ,pad2d:()=>uQ,pad3d:()=>cQ,pad4d:()=>dQ,pool:()=>IP,pow:()=>bu,prelu:()=>$w,print:()=>PM,prod:()=>CP,profile:()=>E8e,raggedGather:()=>hQ,raggedRange:()=>pQ,raggedTensorToTensor:()=>fQ,rand:()=>mQ,randomGamma:()=>vQ,randomNormal:()=>bT,randomStandardNormal:()=>xQ,randomUniform:()=>xd,randomUniformInt:()=>wQ,range:()=>tp,ready:()=>R8e,real:()=>Ug,reciprocal:()=>_P,registerBackend:()=>iT,registerCallbackConstructor:()=>Unt,registerGradient:()=>hZ,registerKernel:()=>pw,registerOp:()=>jst,regularizers:()=>Qte,relu:()=>gn,relu6:()=>vT,removeBackend:()=>D8e,reshape:()=>le,reverse:()=>Ii,reverse1d:()=>kQ,reverse2d:()=>SQ,reverse3d:()=>IQ,reverse4d:()=>CQ,rfft:()=>Aw,round:()=>xT,rsqrt:()=>wT,scalar:()=>bt,scatterND:()=>FQ,scatter_util:()=>ET,searchSorted:()=>yT,selu:()=>kT,separableConv2d:()=>Vb,sequential:()=>Vnt,serialization:()=>Be,setBackend:()=>A8e,setPlatform:()=>M8e,setThreadsCount:()=>KTt,setWasmPath:()=>HTt,setWasmPaths:()=>qTt,setWebGLContext:()=>Yre,setdiff1dAsync:()=>NQ,shared:()=>P4,sigmoid:()=>qi,sign:()=>AP,signal:()=>XQ,sin:()=>ST,sinh:()=>IT,slice:()=>Kt,slice1d:()=>Ew,slice2d:()=>CT,slice3d:()=>Ub,slice4d:()=>jg,slice_util:()=>Hr,softmax:()=>wd,softplus:()=>Xf,spaceToBatchND:()=>Tw,sparse:()=>JQ,sparseToDense:()=>MQ,spectral:()=>KQ,split:()=>ya,sqrt:()=>Is,square:()=>kn,squaredDifference:()=>TT,squeeze:()=>kd,stack:()=>_r,step:()=>Yf,stridedSlice:()=>RP,string:()=>ZQ,sub:()=>nt,sum:()=>ct,sumOutType:()=>aT,tan:()=>DP,tanh:()=>Zh,tensor:()=>Js,tensor1d:()=>dn,tensor2d:()=>Tl,tensor3d:()=>$T,tensor4d:()=>Uc,tensor5d:()=>TQ,tensor6d:()=>$Q,tensorScatterUpdate:()=>_Q,tensor_util:()=>Do,test_util:()=>gQ,tidy:()=>ue,tile:()=>ja,time:()=>_8e,topk:()=>FP,train:()=>Vd,transpose:()=>Lt,truncatedNormal:()=>AT,unique:()=>MP,unregisterGradient:()=>YHe,unregisterKernel:()=>XHe,unsortedSegmentSum:()=>RT,unstack:()=>hr,upcastType:()=>ki,upperBound:()=>AQ,util:()=>M,valueAndGrad:()=>m7e,valueAndGrads:()=>g7e,variable:()=>PP,variableGrads:()=>tQ,version:()=>n$t,version_converter:()=>eit,version_core:()=>BJe,version_cpu:()=>tlt,version_layers:()=>kL,version_wasm:()=>YTt,version_webgl:()=>jmt,webgl:()=>Gmt,webgl_util:()=>Xre,where:()=>ds,whereAsync:()=>LP,zeros:()=>sr,zerosLike:()=>Xt});var eHe=Object.create,IM=Object.defineProperty,tHe=Object.getOwnPropertyDescriptor,nHe=Object.getOwnPropertyNames,rHe=Object.getPrototypeOf,sHe=Object.prototype.hasOwnProperty,Or=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),At=(e,t)=>{for(var n in t)IM(e,n,{get:t[n],enumerable:!0})},aHe=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of nHe(t))!sHe.call(e,s)&&s!==n&&IM(e,s,{get:()=>t[s],enumerable:!(r=tHe(t,s))||r.enumerable});return e},pd=(e,t,n)=>(n=e!=null?eHe(rHe(e)):{},aHe(t||!e||!e.__esModule?IM(n,"default",{value:e,enumerable:!0}):n,e)),iHe=Or((e,t)=>{t.exports=r;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function r(N,E,_){this.low=N|0,this.high=E|0,this.unsigned=!!_}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0});function s(N){return(N&&N.__isLong__)===!0}r.isLong=s;var a={},i={};function o(N,E){var _,R,z;return E?(N>>>=0,(z=0<=N&&N<256)&&(R=i[N],R)?R:(_=u(N,(N|0)<0?-1:0,!0),z&&(i[N]=_),_)):(N|=0,(z=-128<=N&&N<128)&&(R=a[N],R)?R:(_=u(N,N<0?-1:0,!1),z&&(a[N]=_),_))}r.fromInt=o;function l(N,E){if(isNaN(N))return E?v:x;if(E){if(N<0)return v;if(N>=g)return $}else{if(N<=-y)return C;if(N+1>=y)return I}return N<0?l(-N,E).neg():u(N%m|0,N/m|0,E)}r.fromNumber=l;function u(N,E,_){return new r(N,E,_)}r.fromBits=u;var c=Math.pow;function d(N,E,_){if(N.length===0)throw Error("empty string");if(N==="NaN"||N==="Infinity"||N==="+Infinity"||N==="-Infinity")return x;if(typeof E=="number"?(_=E,E=!1):E=!!E,_=_||10,_<2||36<_)throw RangeError("radix");var R;if((R=N.indexOf("-"))>0)throw Error("interior hyphen");if(R===0)return d(N.substring(1),E,_).neg();for(var z=l(c(_,8)),W=x,F=0;F<N.length;F+=8){var L=Math.min(8,N.length-F),O=parseInt(N.substring(F,F+L),_);if(L<8){var D=l(c(_,L));W=W.mul(D).add(l(O))}else W=W.mul(z),W=W.add(l(O))}return W.unsigned=E,W}r.fromString=d;function h(N,E){return typeof N=="number"?l(N,E):typeof N=="string"?d(N,E):u(N.low,N.high,typeof E=="boolean"?E:N.unsigned)}r.fromValue=h;var p=65536,f=1<<24,m=p*p,g=m*m,y=g/2,b=o(f),x=o(0);r.ZERO=x;var v=o(0,!0);r.UZERO=v;var w=o(1);r.ONE=w;var k=o(1,!0);r.UONE=k;var S=o(-1);r.NEG_ONE=S;var I=u(-1,2147483647,!1);r.MAX_VALUE=I;var $=u(-1,-1,!0);r.MAX_UNSIGNED_VALUE=$;var C=u(0,-2147483648,!1);r.MIN_VALUE=C;var T=r.prototype;T.toInt=function(){return this.unsigned?this.low>>>0:this.low},T.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},T.toString=function(N){if(N=N||10,N<2||36<N)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(C)){var E=l(N),_=this.div(E),R=_.mul(E).sub(this);return _.toString(N)+R.toInt().toString(N)}else return"-"+this.neg().toString(N);for(var z=l(c(N,6),this.unsigned),W=this,F="";;){var L=W.div(z),O=W.sub(L.mul(z)).toInt()>>>0,D=O.toString(N);if(W=L,W.isZero())return D+F;for(;D.length<6;)D="0"+D;F=""+D+F}},T.getHighBits=function(){return this.high},T.getHighBitsUnsigned=function(){return this.high>>>0},T.getLowBits=function(){return this.low},T.getLowBitsUnsigned=function(){return this.low>>>0},T.getNumBitsAbs=function(){if(this.isNegative())return this.eq(C)?64:this.neg().getNumBitsAbs();for(var N=this.high!=0?this.high:this.low,E=31;E>0&&!(N&1<<E);E--);return this.high!=0?E+33:E+1},T.isZero=function(){return this.high===0&&this.low===0},T.eqz=T.isZero,T.isNegative=function(){return!this.unsigned&&this.high<0},T.isPositive=function(){return this.unsigned||this.high>=0},T.isOdd=function(){return(this.low&1)===1},T.isEven=function(){return(this.low&1)===0},T.equals=function(N){return s(N)||(N=h(N)),this.unsigned!==N.unsigned&&this.high>>>31===1&&N.high>>>31===1?!1:this.high===N.high&&this.low===N.low},T.eq=T.equals,T.notEquals=function(N){return!this.eq(N)},T.neq=T.notEquals,T.ne=T.notEquals,T.lessThan=function(N){return this.comp(N)<0},T.lt=T.lessThan,T.lessThanOrEqual=function(N){return this.comp(N)<=0},T.lte=T.lessThanOrEqual,T.le=T.lessThanOrEqual,T.greaterThan=function(N){return this.comp(N)>0},T.gt=T.greaterThan,T.greaterThanOrEqual=function(N){return this.comp(N)>=0},T.gte=T.greaterThanOrEqual,T.ge=T.greaterThanOrEqual,T.compare=function(N){if(s(N)||(N=h(N)),this.eq(N))return 0;var E=this.isNegative(),_=N.isNegative();return E&&!_?-1:!E&&_?1:this.unsigned?N.high>>>0>this.high>>>0||N.high===this.high&&N.low>>>0>this.low>>>0?-1:1:this.sub(N).isNegative()?-1:1},T.comp=T.compare,T.negate=function(){return!this.unsigned&&this.eq(C)?C:this.not().add(w)},T.neg=T.negate,T.add=function(N){s(N)||(N=h(N));var E=this.high>>>16,_=this.high&65535,R=this.low>>>16,z=this.low&65535,W=N.high>>>16,F=N.high&65535,L=N.low>>>16,O=N.low&65535,D=0,B=0,V=0,K=0;return K+=z+O,V+=K>>>16,K&=65535,V+=R+L,B+=V>>>16,V&=65535,B+=_+F,D+=B>>>16,B&=65535,D+=E+W,D&=65535,u(V<<16|K,D<<16|B,this.unsigned)},T.subtract=function(N){return s(N)||(N=h(N)),this.add(N.neg())},T.sub=T.subtract,T.multiply=function(N){if(this.isZero())return x;if(s(N)||(N=h(N)),n){var E=n.mul(this.low,this.high,N.low,N.high);return u(E,n.get_high(),this.unsigned)}if(N.isZero())return x;if(this.eq(C))return N.isOdd()?C:x;if(N.eq(C))return this.isOdd()?C:x;if(this.isNegative())return N.isNegative()?this.neg().mul(N.neg()):this.neg().mul(N).neg();if(N.isNegative())return this.mul(N.neg()).neg();if(this.lt(b)&&N.lt(b))return l(this.toNumber()*N.toNumber(),this.unsigned);var _=this.high>>>16,R=this.high&65535,z=this.low>>>16,W=this.low&65535,F=N.high>>>16,L=N.high&65535,O=N.low>>>16,D=N.low&65535,B=0,V=0,K=0,G=0;return G+=W*D,K+=G>>>16,G&=65535,K+=z*D,V+=K>>>16,K&=65535,K+=W*O,V+=K>>>16,K&=65535,V+=R*D,B+=V>>>16,V&=65535,V+=z*O,B+=V>>>16,V&=65535,V+=W*L,B+=V>>>16,V&=65535,B+=_*D+R*O+z*L+W*F,B&=65535,u(K<<16|G,B<<16|V,this.unsigned)},T.mul=T.multiply,T.divide=function(N){if(s(N)||(N=h(N)),N.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&N.low===-1&&N.high===-1)return this;var E=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,N.low,N.high);return u(E,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?v:x;var _,R,z;if(this.unsigned){if(N.unsigned||(N=N.toUnsigned()),N.gt(this))return v;if(N.gt(this.shru(1)))return k;z=v}else{if(this.eq(C)){if(N.eq(w)||N.eq(S))return C;if(N.eq(C))return w;var W=this.shr(1);return _=W.div(N).shl(1),_.eq(x)?N.isNegative()?w:S:(R=this.sub(N.mul(_)),z=_.add(R.div(N)),z)}else if(N.eq(C))return this.unsigned?v:x;if(this.isNegative())return N.isNegative()?this.neg().div(N.neg()):this.neg().div(N).neg();if(N.isNegative())return this.div(N.neg()).neg();z=x}for(R=this;R.gte(N);){_=Math.max(1,Math.floor(R.toNumber()/N.toNumber()));for(var F=Math.ceil(Math.log(_)/Math.LN2),L=F<=48?1:c(2,F-48),O=l(_),D=O.mul(N);D.isNegative()||D.gt(R);)_-=L,O=l(_,this.unsigned),D=O.mul(N);O.isZero()&&(O=w),z=z.add(O),R=R.sub(D)}return z},T.div=T.divide,T.modulo=function(N){if(s(N)||(N=h(N)),n){var E=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,N.low,N.high);return u(E,n.get_high(),this.unsigned)}return this.sub(this.div(N).mul(N))},T.mod=T.modulo,T.rem=T.modulo,T.not=function(){return u(~this.low,~this.high,this.unsigned)},T.and=function(N){return s(N)||(N=h(N)),u(this.low&N.low,this.high&N.high,this.unsigned)},T.or=function(N){return s(N)||(N=h(N)),u(this.low|N.low,this.high|N.high,this.unsigned)},T.xor=function(N){return s(N)||(N=h(N)),u(this.low^N.low,this.high^N.high,this.unsigned)},T.shiftLeft=function(N){return s(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?u(this.low<<N,this.high<<N|this.low>>>32-N,this.unsigned):u(0,this.low<<N-32,this.unsigned)},T.shl=T.shiftLeft,T.shiftRight=function(N){return s(N)&&(N=N.toInt()),(N&=63)===0?this:N<32?u(this.low>>>N|this.high<<32-N,this.high>>N,this.unsigned):u(this.high>>N-32,this.high>=0?0:-1,this.unsigned)},T.shr=T.shiftRight,T.shiftRightUnsigned=function(N){if(s(N)&&(N=N.toInt()),N&=63,N===0)return this;var E=this.high;if(N<32){var _=this.low;return u(_>>>N|E<<32-N,E>>>N,this.unsigned)}else return N===32?u(E,0,this.unsigned):u(E>>>N-32,0,this.unsigned)},T.shru=T.shiftRightUnsigned,T.shr_u=T.shiftRightUnsigned,T.toSigned=function(){return this.unsigned?u(this.low,this.high,!1):this},T.toUnsigned=function(){return this.unsigned?this:u(this.low,this.high,!0)},T.toBytes=function(N){return N?this.toBytesLE():this.toBytesBE()},T.toBytesLE=function(){var N=this.high,E=this.low;return[E&255,E>>>8&255,E>>>16&255,E>>>24,N&255,N>>>8&255,N>>>16&255,N>>>24]},T.toBytesBE=function(){var N=this.high,E=this.low;return[N>>>24,N>>>16&255,N>>>8&255,N&255,E>>>24,E>>>16&255,E>>>8&255,E&255]},r.fromBytes=function(N,E,_){return _?r.fromBytesLE(N,E):r.fromBytesBE(N,E)},r.fromBytesLE=function(N,E){return new r(N[0]|N[1]<<8|N[2]<<16|N[3]<<24,N[4]|N[5]<<8|N[6]<<16|N[7]<<24,E)},r.fromBytesBE=function(N,E){return new r(N[4]<<24|N[5]<<16|N[6]<<8|N[7],N[0]<<24|N[1]<<16|N[2]<<8|N[3],E)}}),oHe=Or(()=>{}),lHe=Or(()=>{}),uHe=Or((e,t)=>{(function(n,r,s){function a(u){var c=this,d=l();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=d(" "),c.s1=d(" "),c.s2=d(" "),c.s0-=d(u),c.s0<0&&(c.s0+=1),c.s1-=d(u),c.s1<0&&(c.s1+=1),c.s2-=d(u),c.s2<0&&(c.s2+=1),d=null}function i(u,c){return c.c=u.c,c.s0=u.s0,c.s1=u.s1,c.s2=u.s2,c}function o(u,c){var d=new a(u),h=c&&c.state,p=d.next;return p.int32=function(){return d.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,h&&(typeof h=="object"&&i(h,d),p.state=function(){return i(d,{})}),p}function l(){var u=4022871197,c=function(d){d=String(d);for(var h=0;h<d.length;h++){u+=d.charCodeAt(h);var p=.02519603282416938*u;u=p>>>0,p-=u,p*=u,u=p>>>0,p-=u,u+=p*4294967296}return(u>>>0)*23283064365386963e-26};return c}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),cHe=Or((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var h=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^h^h>>>8},l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u}function o(l,u){var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),dHe=Or((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.next=function(){var h=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(h^h<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,l===(l|0)?u.x=l:c+=l;for(var d=0;d<c.length+64;d++)u.x^=c.charCodeAt(d)|0,d==c.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function i(l,u){return u.x=l.x,u.y=l.y,u.z=l.z,u.w=l.w,u.v=l.v,u.d=l.d,u}function o(l,u){var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),hHe=Or((e,t)=>{(function(n,r,s){function a(l){var u=this;u.next=function(){var d=u.x,h=u.i,p,f;return p=d[h],p^=p>>>7,f=p^p<<24,p=d[h+1&7],f^=p^p>>>10,p=d[h+3&7],f^=p^p>>>3,p=d[h+4&7],f^=p^p<<7,p=d[h+7&7],p=p^p<<13,f^=p^p<<9,d[h]=f,u.i=h+1&7,f};function c(d,h){var p,f=[];if(h===(h|0))f[0]=h;else for(h=""+h,p=0;p<h.length;++p)f[p&7]=f[p&7]<<15^h.charCodeAt(p)+f[p+1&7]<<13;for(;f.length<8;)f.push(0);for(p=0;p<8&&f[p]===0;++p);for(p==8?f[7]=-1:f[p],d.x=f,d.i=0,p=256;p>0;--p)d.next()}c(u,l)}function i(l,u){return u.x=l.x.slice(),u.i=l.i,u}function o(l,u){l==null&&(l=+new Date);var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(d.x&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),pHe=Or((e,t)=>{(function(n,r,s){function a(l){var u=this;u.next=function(){var d=u.w,h=u.X,p=u.i,f,m;return u.w=d=d+1640531527|0,m=h[p+34&127],f=h[p=p+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=h[p]=m^f,u.i=p,m+(d^d>>>16)|0};function c(d,h){var p,f,m,g,y,b=[],x=128;for(h===(h|0)?(f=h,h=null):(h=h+"\0",f=0,x=Math.max(x,h.length)),m=0,g=-32;g<x;++g)h&&(f^=h.charCodeAt((g+32)%h.length)),g===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,g>=0&&(y=y+1640531527|0,p=b[g&127]^=f+y,m=p==0?m+1:0);for(m>=128&&(b[(h&&h.length||0)&127]=-1),m=127,g=4*128;g>0;--g)f=b[m+34&127],p=b[m=m+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,b[m]=f^p;d.w=y,d.X=b,d.i=m}c(u,l)}function i(l,u){return u.i=l.i,u.w=l.w,u.X=l.X.slice(),u}function o(l,u){l==null&&(l=+new Date);var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(d.X&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),fHe=Or((e,t)=>{(function(n,r,s){function a(l){var u=this,c="";u.next=function(){var h=u.b,p=u.c,f=u.d,m=u.a;return h=h<<25^h>>>7^p,p=p-f|0,f=f<<24^f>>>8^m,m=m-h|0,u.b=h=h<<20^h>>>12^p,u.c=p=p-f|0,u.d=f<<16^p>>>16^m,u.a=m-h|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,l===Math.floor(l)?(u.a=l/4294967296|0,u.b=l|0):c+=l;for(var d=0;d<c.length+20;d++)u.b^=c.charCodeAt(d)|0,u.next()}function i(l,u){return u.a=l.a,u.b=l.b,u.c=l.c,u.d=l.d,u}function o(l,u){var c=new a(l),d=u&&u.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var p=c.next()>>>11,f=(c.next()>>>0)/4294967296,m=(p+f)/(1<<21);while(m===0);return m},h.int32=c.next,h.quick=h,d&&(typeof d=="object"&&i(d,c),h.state=function(){return i(c,{})}),h}r&&r.exports?r.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(e,typeof t=="object"&&t,typeof define=="function"&&define)}),mHe=Or(()=>{}),gHe=Or((e,t)=>{(function(n,r,s){var a=256,i=6,o=52,l="random",u=s.pow(a,i),c=s.pow(2,o),d=c*2,h=a-1,p;function f(w,k,S){var I=[];k=k==!0?{entropy:!0}:k||{};var $=b(y(k.entropy?[w,v(r)]:w??x(),3),I),C=new m(I),T=function(){for(var N=C.g(i),E=u,_=0;N<c;)N=(N+_)*a,E*=a,_=C.g(1);for(;N>=d;)N/=2,E/=2,_>>>=1;return(N+_)/E};return T.int32=function(){return C.g(4)|0},T.quick=function(){return C.g(4)/4294967296},T.double=T,b(v(C.S),r),(k.pass||S||function(N,E,_,R){return R&&(R.S&&g(R,C),N.state=function(){return g(C,{})}),_?(s[l]=N,E):N})(T,$,"global"in k?k.global:this==s,k.state)}function m(w){var k,S=w.length,I=this,$=0,C=I.i=I.j=0,T=I.S=[];for(S||(w=[S++]);$<a;)T[$]=$++;for($=0;$<a;$++)T[$]=T[C=h&C+w[$%S]+(k=T[$])],T[C]=k;(I.g=function(N){for(var E,_=0,R=I.i,z=I.j,W=I.S;N--;)E=W[R=h&R+1],_=_*a+W[h&(W[R]=W[z=h&z+E])+(W[z]=E)];return I.i=R,I.j=z,_})(a)}function g(w,k){return k.i=w.i,k.j=w.j,k.S=w.S.slice(),k}function y(w,k){var S=[],I=typeof w,$;if(k&&I=="object")for($ in w)try{S.push(y(w[$],k-1))}catch{}return S.length?S:I=="string"?w:w+"\0"}function b(w,k){for(var S=w+"",I,$=0;$<S.length;)k[h&$]=h&(I^=k[h&$]*19)+S.charCodeAt($++);return v(k)}function x(){try{var w;return p&&(w=p.randomBytes)?w=w(a):(w=new Uint8Array(a),(n.crypto||n.msCrypto).getRandomValues(w)),v(w)}catch{var k=n.navigator,S=k&&k.plugins;return[+new Date,n,S,n.screen,v(r)]}}function v(w){return String.fromCharCode.apply(0,w)}if(b(s.random(),r),typeof t=="object"&&t.exports){t.exports=f;try{p=mHe()}catch{}}else typeof define=="function"&&define.amd?define(function(){return f}):s["seed"+l]=f})(typeof self<"u"?self:e,[],Math)}),WN=Or((e,t)=>{var n=uHe(),r=cHe(),s=dHe(),a=hHe(),i=pHe(),o=fHe(),l=gHe();l.alea=n,l.xor128=r,l.xorwow=s,l.xorshift7=a,l.xor4096=i,l.tychei=o,t.exports=l}),XJ=Or(()=>{}),CM=Or(()=>{}),YJ=Or(()=>{}),yHe=Or(()=>{}),bHe=Or(()=>{}),vHe=Or(()=>{}),xHe=Or((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};function a(){return F.buffer!=Q&&be(F.buffer),ee}function i(){return F.buffer!=Q&&be(F.buffer),ae}function o(){return F.buffer!=Q&&be(F.buffer),ye}function l(){return F.buffer!=Q&&be(F.buffer),j}function u(){return F.buffer!=Q&&be(F.buffer),ce}var c=typeof s<"u"?s:{},d,h;c.ready=new Promise(function(te,Ne){d=te,h=Ne});var p;typeof process<"u"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var f=Object.assign({},c),m=(te,Ne)=>{throw Ne},g=typeof window=="object",y=typeof importScripts=="function",b=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=c.ENVIRONMENT_IS_PTHREAD||!1,v="";function w(te){return c.locateFile?c.locateFile(te,v):v+te}var k,S,I;function $(te){te instanceof pr||R("exiting due to exception: "+te)}if(b){var C=CM(),T=YJ();y?v=T.dirname(v)+"/":v=__dirname+"/",k=(Ne,qe)=>(Ne=An(Ne)?new URL(Ne):T.normalize(Ne),C.readFileSync(Ne,qe?void 0:"utf8")),I=Ne=>{var qe=k(Ne,!0);return qe.buffer||(qe=new Uint8Array(qe)),qe},S=(Ne,qe,Nt)=>{Ne=An(Ne)?new URL(Ne):T.normalize(Ne),C.readFile(Ne,function(Dt,Ft){Dt?Nt(Dt):qe(Ft.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Ne){if(!(Ne instanceof pr))throw Ne}),process.on("unhandledRejection",function(Ne){throw Ne}),m=(Ne,qe)=>{if(Le())throw process.exitCode=Ne,qe;$(qe),process.exit(Ne)},c.inspect=function(){return"[Emscripten Module object]"};let te;try{te=yHe()}catch(Ne){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),Ne}global.Worker=te.Worker}else(g||y)&&(y?v=self.location.href:typeof document<"u"&&document.currentScript&&(v=document.currentScript.src),typeof r<"u"&&r&&(v=r),v.indexOf("blob:")!==0?v=v.substr(0,v.replace(/[?#].*/,"").lastIndexOf("/")+1):v="",b||(k=te=>{var Ne=new XMLHttpRequest;return Ne.open("GET",te,!1),Ne.send(null),Ne.responseText},y&&(I=te=>{var Ne=new XMLHttpRequest;return Ne.open("GET",te,!1),Ne.responseType="arraybuffer",Ne.send(null),new Uint8Array(Ne.response)}),S=(te,Ne,qe)=>{var Nt=new XMLHttpRequest;Nt.open("GET",te,!0),Nt.responseType="arraybuffer",Nt.onload=()=>{if(Nt.status==200||Nt.status==0&&Nt.response){Ne(Nt.response);return}qe()},Nt.onerror=qe,Nt.send(null)}));b&&typeof performance>"u"&&(global.performance=bHe().performance);var N=console.log.bind(console),E=console.warn.bind(console);b&&(N=te=>C.writeSync(1,te+`
`),E=te=>C.writeSync(2,te+`
`));var _=c.print||N,R=c.printErr||E;Object.assign(c,f),f=null,c.arguments&&c.arguments,c.thisProgram&&c.thisProgram,c.quit&&(m=c.quit);var z;c.wasmBinary&&(z=c.wasmBinary);var W=c.noExitRuntime||!0;typeof WebAssembly!="object"&&Xe("no native wasm support detected");var F,L,O=!1,D;function B(te,Ne){te||Xe(Ne)}var V=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function K(te,Ne,qe){Ne>>>=0;for(var Nt=Ne+qe,Dt=Ne;te[Dt]&&!(Dt>=Nt);)++Dt;if(Dt-Ne>16&&te.buffer&&V)return V.decode(te.buffer instanceof SharedArrayBuffer?te.slice(Ne,Dt):te.subarray(Ne,Dt));for(var Ft="";Ne<Dt;){var it=te[Ne++];if(!(it&128)){Ft+=String.fromCharCode(it);continue}var wt=te[Ne++]&63;if((it&224)==192){Ft+=String.fromCharCode((it&31)<<6|wt);continue}var er=te[Ne++]&63;if((it&240)==224?it=(it&15)<<12|wt<<6|er:it=(it&7)<<18|wt<<12|er<<6|te[Ne++]&63,it<65536)Ft+=String.fromCharCode(it);else{var ai=it-65536;Ft+=String.fromCharCode(55296|ai>>10,56320|ai&1023)}}return Ft}function G(te,Ne){return te>>>=0,te?K(i(),te,Ne):""}function U(te,Ne,qe,Nt){if(qe>>>=0,!(Nt>0))return 0;for(var Dt=qe,Ft=qe+Nt-1,it=0;it<te.length;++it){var wt=te.charCodeAt(it);if(wt>=55296&&wt<=57343){var er=te.charCodeAt(++it);wt=65536+((wt&1023)<<10)|er&1023}if(wt<=127){if(qe>=Ft)break;Ne[qe++>>>0]=wt}else if(wt<=2047){if(qe+1>=Ft)break;Ne[qe++>>>0]=192|wt>>6,Ne[qe++>>>0]=128|wt&63}else if(wt<=65535){if(qe+2>=Ft)break;Ne[qe++>>>0]=224|wt>>12,Ne[qe++>>>0]=128|wt>>6&63,Ne[qe++>>>0]=128|wt&63}else{if(qe+3>=Ft)break;Ne[qe++>>>0]=240|wt>>18,Ne[qe++>>>0]=128|wt>>12&63,Ne[qe++>>>0]=128|wt>>6&63,Ne[qe++>>>0]=128|wt&63}}return Ne[qe>>>0]=0,qe-Dt}function q(te,Ne,qe){return U(te,i(),Ne,qe)}var Q,ee,ae,ye,j,ce;x&&(Q=c.buffer);function be(te){Q=te,c.HEAP8=ee=new Int8Array(te),c.HEAP16=new Int16Array(te),c.HEAP32=ye=new Int32Array(te),c.HEAPU8=ae=new Uint8Array(te),c.HEAPU16=new Uint16Array(te),c.HEAPU32=j=new Uint32Array(te),c.HEAPF32=new Float32Array(te),c.HEAPF64=ce=new Float64Array(te)}var ke=c.INITIAL_MEMORY||16777216;if(x)F=c.wasmMemory,Q=c.buffer;else if(c.wasmMemory)F=c.wasmMemory;else if(F=new WebAssembly.Memory({initial:ke/65536,maximum:65536,shared:!0}),!(F.buffer instanceof SharedArrayBuffer))throw R("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),b&&R("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and/or recent version)"),Error("bad memory");F&&(Q=F.buffer),ke=Q.byteLength,be(Q);var Ae,Pe=[],ie=[],Te=[];function Le(){return W}function $e(){if(c.preRun)for(typeof c.preRun=="function"&&(c.preRun=[c.preRun]);c.preRun.length;)pe(c.preRun.shift());rt(Pe)}function ge(){!x&&rt(ie)}function ve(){if(!x){if(c.postRun)for(typeof c.postRun=="function"&&(c.postRun=[c.postRun]);c.postRun.length;)ze(c.postRun.shift());rt(Te)}}function pe(te){Pe.unshift(te)}function Ie(te){ie.unshift(te)}function ze(te){Te.unshift(te)}var Ye=0,Je=null;function Ke(te){Ye++,c.monitorRunDependencies&&c.monitorRunDependencies(Ye)}function Ue(te){if(Ye--,c.monitorRunDependencies&&c.monitorRunDependencies(Ye),Ye==0&&Je){var Ne=Je;Je=null,Ne()}}function Xe(te){c.onAbort&&c.onAbort(te),te="Aborted("+te+")",R(te),O=!0,D=1,te+=". Build with -sASSERTIONS for more info.";var Ne=new WebAssembly.RuntimeError(te);throw h(Ne),Ne}var ut="data:application/octet-stream;base64,";function vt(te){return te.startsWith(ut)}function An(te){return te.startsWith("file://")}var Rt;Rt="tfjs-backend-wasm-threaded-simd.wasm",vt(Rt)||(Rt=w(Rt));function Bs(te){try{if(te==Rt&&z)return new Uint8Array(z);if(I)return I(te);throw"both async and sync fetching of the wasm failed"}catch(Ne){Xe(Ne)}}function Un(){if(!z&&(g||y)){if(typeof fetch=="function"&&!An(Rt))return fetch(Rt,{credentials:"same-origin"}).then(function(te){if(!te.ok)throw"failed to load wasm binary file at '"+Rt+"'";return te.arrayBuffer()}).catch(function(){return Bs(Rt)});if(S)return new Promise(function(te,Ne){S(Rt,function(qe){te(new Uint8Array(qe))},Ne)})}return Promise.resolve().then(function(){return Bs(Rt)})}function si(){var te={env:qz,wasi_snapshot_preview1:qz};function Ne(it,wt){var er=it.exports;if(c.asm=er,jn(c.asm._emscripten_tls_init),Ae=c.asm.__indirect_function_table,Ie(c.asm.__wasm_call_ctors),L=wt,!x){var ai=Re.unusedWorkers.length;Re.unusedWorkers.forEach(function(Gl){Re.loadWasmModuleToWorker(Gl,function(){--ai||Ue()})})}}x||Ke();function qe(it){Ne(it.instance,it.module)}function Nt(it){return Un().then(function(wt){return WebAssembly.instantiate(wt,te)}).then(function(wt){return wt}).then(it,function(wt){R("failed to asynchronously prepare wasm: "+wt),Xe(wt)})}function Dt(){return!z&&typeof WebAssembly.instantiateStreaming=="function"&&!vt(Rt)&&!An(Rt)&&!b&&typeof fetch=="function"?fetch(Rt,{credentials:"same-origin"}).then(function(it){var wt=WebAssembly.instantiateStreaming(it,te);return wt.then(qe,function(er){return R("wasm streaming compile failed: "+er),R("falling back to ArrayBuffer instantiation"),Nt(qe)})}):Nt(qe)}if(c.instantiateWasm)try{var Ft=c.instantiateWasm(te,Ne);return Ft}catch(it){R("Module.instantiateWasm callback failed with error: "+it),h(it)}return Dt().catch(h),{}}var _a={};function pr(te){this.name="ExitStatus",this.message="Program terminated with exit("+te+")",this.status=te}function Aa(te){var Ne=Re.pthreads[te];delete Re.pthreads[te],Ne.terminate(),v$(te),Re.runningWorkers.splice(Re.runningWorkers.indexOf(Ne),1),Ne.pthread_ptr=0}function jl(te){var Ne=Re.pthreads[te];Ne.postMessage({cmd:"cancel"})}function Ln(te){var Ne=Re.pthreads[te];B(Ne),Re.returnWorkerToPool(Ne)}function Mr(te){var Ne=Re.getNewWorker();if(!Ne)return 6;Re.runningWorkers.push(Ne),Re.pthreads[te.pthread_ptr]=Ne,Ne.pthread_ptr=te.pthread_ptr;var qe={cmd:"run",start_routine:te.startRoutine,arg:te.arg,pthread_ptr:te.pthread_ptr};return Ne.runPthread=()=>{b&&Ne.ref(),Ne.postMessage(qe,te.transferList),delete Ne.runPthread},Ne.loaded&&Ne.runPthread(),0}function It(te){if(x)return im(1,1,te);D=te,Le()||(Re.terminateAllThreads(),c.onExit&&c.onExit(te),O=!0),m(te,new pr(te))}function Ce(te,Ne){if(D=te,!Ne&&x)throw xt(te),"unwind";It(te)}var We=Ce;function gt(te){if(te instanceof pr||te=="unwind")return D;m(1,te)}var Re={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){x?Re.initWorker():Re.initMainThread()},initMainThread:function(){for(var te=8;te--;)Re.allocateUnusedWorker()},initWorker:function(){W=!1},setExitStatus:function(te){D=te},terminateAllThreads:function(){for(var te of Object.values(Re.pthreads))Re.returnWorkerToPool(te);for(var te of Re.unusedWorkers)te.terminate();Re.unusedWorkers=[]},returnWorkerToPool:function(te){var Ne=te.pthread_ptr;delete Re.pthreads[Ne],Re.unusedWorkers.push(te),Re.runningWorkers.splice(Re.runningWorkers.indexOf(te),1),te.pthread_ptr=0,b&&te.unref(),v$(Ne)},receiveObjectTransfer:function(te){},threadInitTLS:function(){Re.tlsInitFunctions.forEach(te=>te())},loadWasmModuleToWorker:function(te,Ne){te.onmessage=Ft=>{var it=Ft.data,wt=it.cmd;if(te.pthread_ptr&&(Re.currentProxiedOperationCallerThread=te.pthread_ptr),it.targetThread&&it.targetThread!=Yw()){var er=Re.pthreads[it.targetThread];er?er.postMessage(it,it.transferList):R('Internal error! Worker sent a message "'+wt+'" to target pthread '+it.targetThread+", but that thread no longer exists!"),Re.currentProxiedOperationCallerThread=void 0;return}wt==="processProxyingQueue"?am(it.queue):wt==="spawnThread"?Mr(it):wt==="cleanupThread"?Ln(it.thread):wt==="killThread"?Aa(it.thread):wt==="cancelThread"?jl(it.thread):wt==="loaded"?(te.loaded=!0,b&&te.unref(),Ne&&Ne(te),te.runPthread&&te.runPthread()):wt==="print"?_("Thread "+it.threadId+": "+it.text):wt==="printErr"?R("Thread "+it.threadId+": "+it.text):wt==="alert"?alert("Thread "+it.threadId+": "+it.text):it.target==="setimmediate"?te.postMessage(it):wt==="callHandler"?c[it.handler](...it.args):wt&&R("worker sent an unknown command "+wt),Re.currentProxiedOperationCallerThread=void 0},te.onerror=Ft=>{var it="worker sent an error!";throw R(it+" "+Ft.filename+":"+Ft.lineno+": "+Ft.message),Ft},b&&(te.on("message",function(Ft){te.onmessage({data:Ft})}),te.on("error",function(Ft){te.onerror(Ft)}),te.on("detachedExit",function(){}));var qe=[],Nt=["onExit","onAbort","print","printErr"];for(var Dt of Nt)c.hasOwnProperty(Dt)&&qe.push(Dt);te.postMessage({cmd:"load",handlers:qe,urlOrBlob:c.mainScriptUrlOrBlob||r,wasmMemory:F,wasmModule:L})},allocateUnusedWorker:function(){var te,Ne=w("tfjs-backend-wasm-threaded-simd.worker.js");te=new Worker(Ne),Re.unusedWorkers.push(te)},getNewWorker:function(){return Re.unusedWorkers.length==0&&(Re.allocateUnusedWorker(),Re.loadWasmModuleToWorker(Re.unusedWorkers[0])),Re.unusedWorkers.pop()}};c.PThread=Re;function rt(te){for(;te.length>0;)te.shift()(c)}function lt(){var te=Yw(),Ne=o()[te+52>>>2],qe=o()[te+56>>>2],Nt=Ne-qe;Zz(Ne,Nt),Jw(Ne)}c.establishStackSpace=lt;function xt(te){if(x)return im(2,0,te);try{We(te)}catch(Ne){gt(Ne)}}var yt=[];function on(te){var Ne=yt[te];return Ne||(te>=yt.length&&(yt.length=te+1),yt[te]=Ne=Ae.get(te)),Ne}function Qn(te,Ne){var qe=on(te)(Ne);Le()?Re.setExitStatus(qe):Jz(qe)}c.invokeEntryPoint=Qn;function jn(te){Re.tlsInitFunctions.push(te)}function Es(te){Kz(te,!y,1,!g),Re.threadInitTLS()}function hn(te){x?postMessage({cmd:"cleanupThread",thread:te}):Ln(te)}function Ko(te,Ne,qe,Nt){return x?im(3,1,te,Ne,qe,Nt):ms(te,Ne,qe,Nt)}function ms(te,Ne,qe,Nt){if(typeof SharedArrayBuffer>"u")return R("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Dt=[],Ft=0;if(x&&(Dt.length===0||Ft))return Ko(te,Ne,qe,Nt);var it={startRoutine:qe,pthread_ptr:te,arg:Nt,transferList:Dt};return x?(it.cmd="spawnThread",postMessage(it,Dt),0):Mr(it)}function lo(){return 65536}var _d=!0;function Xw(){return _d}function am(te){Atomics.store(o(),te>>2,1),Yw()&&Yz(te),Atomics.compareExchange(o(),te>>2,1,0)}c.executeNotifiedProxyingQueue=am;function $n(te,Ne,qe,Nt){if(te==Ne)setTimeout(()=>am(Nt));else if(x)postMessage({targetThread:te,cmd:"processProxyingQueue",queue:Nt});else{var Dt=Re.pthreads[te];if(!Dt)return;Dt.postMessage({cmd:"processProxyingQueue",queue:Nt})}return 1}function uo(te,Ne,qe){return-1}function sv(){Xe("")}function co(te){co.shown||(co.shown={}),co.shown[te]||(co.shown[te]=1,b&&(te="warning: "+te),R(te))}function g$(){b||y||co("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function av(){return Date.now()}function Vz(){return 4294901760}function Goe(){return Vz()}var y$;b?y$=()=>{var te=process.hrtime();return te[0]*1e3+te[1]/1e6}:y$=()=>performance.timeOrigin+performance.now();function Hoe(te,Ne,qe){i().copyWithin(te>>>0,Ne>>>0,Ne+qe>>>0)}function qoe(){return b?vHe().cpus().length:navigator.hardwareConcurrency}function Koe(te){var Ne=x$(),qe=te();return Jw(Ne),qe}function im(te,Ne){var qe=arguments.length-2,Nt=arguments;return Koe(()=>{for(var Dt=qe,Ft=Zw(Dt*8),it=Ft>>3,wt=0;wt<qe;wt++){var er=Nt[2+wt];u()[it+wt>>>0]=er}return Xz(te,Dt,Ft,Ne)})}var b$=[];function Xoe(te,Ne,qe){b$.length=Ne;for(var Nt=qe>>3,Dt=0;Dt<Ne;Dt++)b$[Dt]=u()[Nt+Dt>>>0];var Ft=te<0,it=Ft?_a[-te-1]:sle[te];return it.apply(null,b$)}function Yoe(te){try{return F.grow(te-Q.byteLength+65535>>>16),be(F.buffer),1}catch{}}function Joe(te){var Ne=i().length;if(te=te>>>0,te<=Ne)return!1;var qe=Vz();if(te>qe)return!1;let Nt=(er,ai)=>er+(ai-er%ai)%ai;for(var Dt=1;Dt<=4;Dt*=2){var Ft=Ne*(1+.2/Dt);Ft=Math.min(Ft,te+100663296);var it=Math.min(qe,Nt(Math.max(te,Ft),65536)),wt=Yoe(it);if(wt)return!0}return!1}function Zoe(){throw"unwind"}function Uz(te){return x?im(4,1,te):52}function jz(te,Ne,qe,Nt,Dt){return x?im(5,1,te,Ne,qe,Nt,Dt):70}var Qoe=[null,[],[]];function ele(te,Ne){var qe=Qoe[te];Ne===0||Ne===10?((te===1?_:R)(K(qe,0)),qe.length=0):qe.push(Ne)}function Gz(te,Ne,qe,Nt){if(x)return im(6,1,te,Ne,qe,Nt);for(var Dt=0,Ft=0;Ft<qe;Ft++){var it=l()[Ne>>>2],wt=l()[Ne+4>>>2];Ne+=8;for(var er=0;er<wt;er++)ele(te,i()[it+er>>>0]);Dt+=wt}return l()[Nt>>>2]=Dt,0}function Hz(te){var Ne=c["_"+te];return Ne}function tle(te,Ne){a().set(te,Ne>>>0)}function nle(te,Ne,qe,Nt,Dt){var Ft={string:ii=>{var om=0;if(ii!=null&&ii!==0){var tB=(ii.length<<2)+1;om=Zw(tB),q(ii,om,tB)}return om},array:ii=>{var om=Zw(ii.length);return tle(ii,om),om}};function it(ii){return Ne==="string"?G(ii):Ne==="boolean"?!!ii:ii}var wt=Hz(te),er=[],ai=0;if(Nt)for(var Gl=0;Gl<Nt.length;Gl++){var eB=Ft[qe[Gl]];eB?(ai===0&&(ai=x$()),er[Gl]=eB(Nt[Gl])):er[Gl]=Nt[Gl]}var w$=wt.apply(null,er);function ile(ii){return ai!==0&&Jw(ai),it(ii)}return w$=ile(w$),w$}function rle(te,Ne,qe,Nt){qe=qe||[];var Dt=qe.every(it=>it==="number"||it==="boolean"),Ft=Ne!=="string";return Ft&&Dt&&!Nt?Hz(te):function(){return nle(te,Ne,qe,arguments)}}Re.init();var sle=[null,It,xt,Ko,Uz,jz,Gz],qz={__emscripten_init_main_thread_js:Es,__emscripten_thread_cleanup:hn,__pthread_create_js:ms,_emscripten_default_pthread_stack_size:lo,_emscripten_get_now_is_monotonic:Xw,_emscripten_notify_task_queue:$n,_emscripten_set_offscreencanvas_size:uo,abort:sv,emscripten_check_blocking_allowed:g$,emscripten_date_now:av,emscripten_get_heap_max:Goe,emscripten_get_now:y$,emscripten_memcpy_big:Hoe,emscripten_num_logical_cores:qoe,emscripten_receive_on_main_thread_js:Xoe,emscripten_resize_heap:Joe,emscripten_unwind_to_js_event_loop:Zoe,exit:We,fd_close:Uz,fd_seek:jz,fd_write:Gz,memory:F||c.wasmMemory};si(),c.___wasm_call_ctors=function(){return(c.___wasm_call_ctors=c.asm.__wasm_call_ctors).apply(null,arguments)},c._init=function(){return(c._init=c.asm.init).apply(null,arguments)},c._init_with_threads_count=function(){return(c._init_with_threads_count=c.asm.init_with_threads_count).apply(null,arguments)},c._get_threads_count=function(){return(c._get_threads_count=c.asm.get_threads_count).apply(null,arguments)},c._register_tensor=function(){return(c._register_tensor=c.asm.register_tensor).apply(null,arguments)},c._dispose_data=function(){return(c._dispose_data=c.asm.dispose_data).apply(null,arguments)},c._dispose=function(){return(c._dispose=c.asm.dispose).apply(null,arguments)},c._Abs=function(){return(c._Abs=c.asm.Abs).apply(null,arguments)},c._Acos=function(){return(c._Acos=c.asm.Acos).apply(null,arguments)},c._Acosh=function(){return(c._Acosh=c.asm.Acosh).apply(null,arguments)},c._Add=function(){return(c._Add=c.asm.Add).apply(null,arguments)},c._AddN=function(){return(c._AddN=c.asm.AddN).apply(null,arguments)},c._All=function(){return(c._All=c.asm.All).apply(null,arguments)},c._Any=function(){return(c._Any=c.asm.Any).apply(null,arguments)},c._ArgMax=function(){return(c._ArgMax=c.asm.ArgMax).apply(null,arguments)},c._ArgMin=function(){return(c._ArgMin=c.asm.ArgMin).apply(null,arguments)},c._Asin=function(){return(c._Asin=c.asm.Asin).apply(null,arguments)},c._Asinh=function(){return(c._Asinh=c.asm.Asinh).apply(null,arguments)},c._Atan=function(){return(c._Atan=c.asm.Atan).apply(null,arguments)},c._Atan2=function(){return(c._Atan2=c.asm.Atan2).apply(null,arguments)},c._Atanh=function(){return(c._Atanh=c.asm.Atanh).apply(null,arguments)},c._AvgPool=function(){return(c._AvgPool=c.asm.AvgPool).apply(null,arguments)},c._AvgPool3D=function(){return(c._AvgPool3D=c.asm.AvgPool3D).apply(null,arguments)},c._AvgPool3DGrad=function(){return(c._AvgPool3DGrad=c.asm.AvgPool3DGrad).apply(null,arguments)},c._AvgPoolGrad=function(){return(c._AvgPoolGrad=c.asm.AvgPoolGrad).apply(null,arguments)},c._BatchMatMul=function(){return(c._BatchMatMul=c.asm.BatchMatMul).apply(null,arguments)},c._Bincount=function(){return(c._Bincount=c.asm.Bincount).apply(null,arguments)},c._BitwiseAnd=function(){return(c._BitwiseAnd=c.asm.BitwiseAnd).apply(null,arguments)},c._Ceil=function(){return(c._Ceil=c.asm.Ceil).apply(null,arguments)},c._ClipByValue=function(){return(c._ClipByValue=c.asm.ClipByValue).apply(null,arguments)},c._Conv2D=function(){return(c._Conv2D=c.asm.Conv2D).apply(null,arguments)},c._Conv2DBackpropInput=function(){return(c._Conv2DBackpropInput=c.asm.Conv2DBackpropInput).apply(null,arguments)},c._Conv3D=function(){return(c._Conv3D=c.asm.Conv3D).apply(null,arguments)},c._Conv3DBackpropFilterV2=function(){return(c._Conv3DBackpropFilterV2=c.asm.Conv3DBackpropFilterV2).apply(null,arguments)},c._Conv3DBackpropInputV2=function(){return(c._Conv3DBackpropInputV2=c.asm.Conv3DBackpropInputV2).apply(null,arguments)},c._Cos=function(){return(c._Cos=c.asm.Cos).apply(null,arguments)},c._Cosh=function(){return(c._Cosh=c.asm.Cosh).apply(null,arguments)},c._CropAndResize=function(){return(c._CropAndResize=c.asm.CropAndResize).apply(null,arguments)},c._Cumprod=function(){return(c._Cumprod=c.asm.Cumprod).apply(null,arguments)},c._Cumsum=function(){return(c._Cumsum=c.asm.Cumsum).apply(null,arguments)},c._DenseBincount=function(){return(c._DenseBincount=c.asm.DenseBincount).apply(null,arguments)},c._DepthToSpace=function(){return(c._DepthToSpace=c.asm.DepthToSpace).apply(null,arguments)},c._DepthwiseConv2dNative=function(){return(c._DepthwiseConv2dNative=c.asm.DepthwiseConv2dNative).apply(null,arguments)},c._Diag=function(){return(c._Diag=c.asm.Diag).apply(null,arguments)},c._Dilation2D=function(){return(c._Dilation2D=c.asm.Dilation2D).apply(null,arguments)},c._Dilation2DBackpropFilter=function(){return(c._Dilation2DBackpropFilter=c.asm.Dilation2DBackpropFilter).apply(null,arguments)},c._Dilation2DBackpropInput=function(){return(c._Dilation2DBackpropInput=c.asm.Dilation2DBackpropInput).apply(null,arguments)},c._Elu=function(){return(c._Elu=c.asm.Elu).apply(null,arguments)},c._EluGrad=function(){return(c._EluGrad=c.asm.EluGrad).apply(null,arguments)},c._Equal=function(){return(c._Equal=c.asm.Equal).apply(null,arguments)},c._Erf=function(){return(c._Erf=c.asm.Erf).apply(null,arguments)},c._Exp=function(){return(c._Exp=c.asm.Exp).apply(null,arguments)},c._Expm1=function(){return(c._Expm1=c.asm.Expm1).apply(null,arguments)},c._FlipLeftRight=function(){return(c._FlipLeftRight=c.asm.FlipLeftRight).apply(null,arguments)},c._Floor=function(){return(c._Floor=c.asm.Floor).apply(null,arguments)},c._FloorDiv=function(){return(c._FloorDiv=c.asm.FloorDiv).apply(null,arguments)},c._FusedBatchNorm=function(){return(c._FusedBatchNorm=c.asm.FusedBatchNorm).apply(null,arguments)},c._FusedConv2D=function(){return(c._FusedConv2D=c.asm.FusedConv2D).apply(null,arguments)},c._FusedDepthwiseConv2D=function(){return(c._FusedDepthwiseConv2D=c.asm.FusedDepthwiseConv2D).apply(null,arguments)},c._Gather=function(){return(c._Gather=c.asm.Gather).apply(null,arguments)},c._GatherNd=function(){return(c._GatherNd=c.asm.GatherNd).apply(null,arguments)},c._Greater=function(){return(c._Greater=c.asm.Greater).apply(null,arguments)},c._GreaterEqual=function(){return(c._GreaterEqual=c.asm.GreaterEqual).apply(null,arguments)},c._IsFinite=function(){return(c._IsFinite=c.asm.IsFinite).apply(null,arguments)},c._IsInf=function(){return(c._IsInf=c.asm.IsInf).apply(null,arguments)},c._IsNan=function(){return(c._IsNan=c.asm.IsNan).apply(null,arguments)},c._LRN=function(){return(c._LRN=c.asm.LRN).apply(null,arguments)},c._LRNGrad=function(){return(c._LRNGrad=c.asm.LRNGrad).apply(null,arguments)},c._LeakyRelu=function(){return(c._LeakyRelu=c.asm.LeakyRelu).apply(null,arguments)},c._Less=function(){return(c._Less=c.asm.Less).apply(null,arguments)},c._LessEqual=function(){return(c._LessEqual=c.asm.LessEqual).apply(null,arguments)},c._LinSpace=function(){return(c._LinSpace=c.asm.LinSpace).apply(null,arguments)},c._Log=function(){return(c._Log=c.asm.Log).apply(null,arguments)},c._Log1p=function(){return(c._Log1p=c.asm.Log1p).apply(null,arguments)},c._LogicalAnd=function(){return(c._LogicalAnd=c.asm.LogicalAnd).apply(null,arguments)},c._LogicalNot=function(){return(c._LogicalNot=c.asm.LogicalNot).apply(null,arguments)},c._LogicalOr=function(){return(c._LogicalOr=c.asm.LogicalOr).apply(null,arguments)},c._LogicalXor=function(){return(c._LogicalXor=c.asm.LogicalXor).apply(null,arguments)},c._Max=function(){return(c._Max=c.asm.Max).apply(null,arguments)},c._MaxPool=function(){return(c._MaxPool=c.asm.MaxPool).apply(null,arguments)},c._MaxPool3D=function(){return(c._MaxPool3D=c.asm.MaxPool3D).apply(null,arguments)},c._MaxPool3DGrad=function(){return(c._MaxPool3DGrad=c.asm.MaxPool3DGrad).apply(null,arguments)},c._MaxPoolGrad=function(){return(c._MaxPoolGrad=c.asm.MaxPoolGrad).apply(null,arguments)},c._MaxPoolWithArgmax=function(){return(c._MaxPoolWithArgmax=c.asm.MaxPoolWithArgmax).apply(null,arguments)},c._Maximum=function(){return(c._Maximum=c.asm.Maximum).apply(null,arguments)},c._Mean=function(){return(c._Mean=c.asm.Mean).apply(null,arguments)},c._Min=function(){return(c._Min=c.asm.Min).apply(null,arguments)},c._Minimum=function(){return(c._Minimum=c.asm.Minimum).apply(null,arguments)},c._MirrorPad=function(){return(c._MirrorPad=c.asm.MirrorPad).apply(null,arguments)},c._Mod=function(){return(c._Mod=c.asm.Mod).apply(null,arguments)},c._Multinomial=function(){return(c._Multinomial=c.asm.Multinomial).apply(null,arguments)},c._Multiply=function(){return(c._Multiply=c.asm.Multiply).apply(null,arguments)},c._Neg=function(){return(c._Neg=c.asm.Neg).apply(null,arguments)},c._NonMaxSuppressionV3=function(){return(c._NonMaxSuppressionV3=c.asm.NonMaxSuppressionV3).apply(null,arguments)},c._NonMaxSuppressionV4=function(){return(c._NonMaxSuppressionV4=c.asm.NonMaxSuppressionV4).apply(null,arguments)},c._NonMaxSuppressionV5=function(){return(c._NonMaxSuppressionV5=c.asm.NonMaxSuppressionV5).apply(null,arguments)},c._NotEqual=function(){return(c._NotEqual=c.asm.NotEqual).apply(null,arguments)},c._OneHot=function(){return(c._OneHot=c.asm.OneHot).apply(null,arguments)},c._PadV2=function(){return(c._PadV2=c.asm.PadV2).apply(null,arguments)},c._Pow=function(){return(c._Pow=c.asm.Pow).apply(null,arguments)},c._Prelu=function(){return(c._Prelu=c.asm.Prelu).apply(null,arguments)},c._Prod=function(){return(c._Prod=c.asm.Prod).apply(null,arguments)},c._RealDiv=function(){return(c._RealDiv=c.asm.RealDiv).apply(null,arguments)},c._Reciprocal=function(){return(c._Reciprocal=c.asm.Reciprocal).apply(null,arguments)},c._Relu=function(){return(c._Relu=c.asm.Relu).apply(null,arguments)},c._Relu6=function(){return(c._Relu6=c.asm.Relu6).apply(null,arguments)},c._ResizeBilinear=function(){return(c._ResizeBilinear=c.asm.ResizeBilinear).apply(null,arguments)},c._ResizeBilinearGrad=function(){return(c._ResizeBilinearGrad=c.asm.ResizeBilinearGrad).apply(null,arguments)},c._ResizeNearestNeighbor=function(){return(c._ResizeNearestNeighbor=c.asm.ResizeNearestNeighbor).apply(null,arguments)},c._ResizeNearestNeighborGrad=function(){return(c._ResizeNearestNeighborGrad=c.asm.ResizeNearestNeighborGrad).apply(null,arguments)},c._Reverse=function(){return(c._Reverse=c.asm.Reverse).apply(null,arguments)},c._RotateWithOffset=function(){return(c._RotateWithOffset=c.asm.RotateWithOffset).apply(null,arguments)},c._Round=function(){return(c._Round=c.asm.Round).apply(null,arguments)},c._Rsqrt=function(){return(c._Rsqrt=c.asm.Rsqrt).apply(null,arguments)},c._ScatterNd=function(){return(c._ScatterNd=c.asm.ScatterNd).apply(null,arguments)},c._SearchSorted=function(){return(c._SearchSorted=c.asm.SearchSorted).apply(null,arguments)},c._SelectV2=function(){return(c._SelectV2=c.asm.SelectV2).apply(null,arguments)},c._Selu=function(){return(c._Selu=c.asm.Selu).apply(null,arguments)},c._Sigmoid=function(){return(c._Sigmoid=c.asm.Sigmoid).apply(null,arguments)},c._Sign=function(){return(c._Sign=c.asm.Sign).apply(null,arguments)},c._Sin=function(){return(c._Sin=c.asm.Sin).apply(null,arguments)},c._Sinh=function(){return(c._Sinh=c.asm.Sinh).apply(null,arguments)},c._Softmax=function(){return(c._Softmax=c.asm.Softmax).apply(null,arguments)},c._Softplus=function(){return(c._Softplus=c.asm.Softplus).apply(null,arguments)},c._SparseFillEmptyRows=function(){return(c._SparseFillEmptyRows=c.asm.SparseFillEmptyRows).apply(null,arguments)},c._SparseReshape=function(){return(c._SparseReshape=c.asm.SparseReshape).apply(null,arguments)},c._SparseSegmentReduction=function(){return(c._SparseSegmentReduction=c.asm.SparseSegmentReduction).apply(null,arguments)},c._SparseToDense=function(){return(c._SparseToDense=c.asm.SparseToDense).apply(null,arguments)},c._Sqrt=function(){return(c._Sqrt=c.asm.Sqrt).apply(null,arguments)},c._Square=function(){return(c._Square=c.asm.Square).apply(null,arguments)},c._SquaredDifference=function(){return(c._SquaredDifference=c.asm.SquaredDifference).apply(null,arguments)},c._Step=function(){return(c._Step=c.asm.Step).apply(null,arguments)},c._StridedSlice=function(){return(c._StridedSlice=c.asm.StridedSlice).apply(null,arguments)},c._Sub=function(){return(c._Sub=c.asm.Sub).apply(null,arguments)},c._Sum=function(){return(c._Sum=c.asm.Sum).apply(null,arguments)},c._Tan=function(){return(c._Tan=c.asm.Tan).apply(null,arguments)},c._Tanh=function(){return(c._Tanh=c.asm.Tanh).apply(null,arguments)},c._TensorScatterUpdate=function(){return(c._TensorScatterUpdate=c.asm.TensorScatterUpdate).apply(null,arguments)},c._Tile=function(){return(c._Tile=c.asm.Tile).apply(null,arguments)},c._TopK=function(){return(c._TopK=c.asm.TopK).apply(null,arguments)},c._Transform=function(){return(c._Transform=c.asm.Transform).apply(null,arguments)},c._Transpose=function(){return(c._Transpose=c.asm.Transpose).apply(null,arguments)},c.__FusedMatMul=function(){return(c.__FusedMatMul=c.asm._FusedMatMul).apply(null,arguments)},c._malloc=function(){return(c._malloc=c.asm.malloc).apply(null,arguments)},c._free=function(){return(c._free=c.asm.free).apply(null,arguments)},c.__emscripten_tls_init=function(){return(c.__emscripten_tls_init=c.asm._emscripten_tls_init).apply(null,arguments)};var Yw=c._pthread_self=function(){return(Yw=c._pthread_self=c.asm.pthread_self).apply(null,arguments)};c.___errno_location=function(){return(c.___errno_location=c.asm.__errno_location).apply(null,arguments)};var Kz=c.__emscripten_thread_init=function(){return(Kz=c.__emscripten_thread_init=c.asm._emscripten_thread_init).apply(null,arguments)};c.__emscripten_thread_crashed=function(){return(c.__emscripten_thread_crashed=c.asm._emscripten_thread_crashed).apply(null,arguments)},c._emscripten_main_thread_process_queued_calls=function(){return(c._emscripten_main_thread_process_queued_calls=c.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},c._emscripten_main_browser_thread_id=function(){return(c._emscripten_main_browser_thread_id=c.asm.emscripten_main_browser_thread_id).apply(null,arguments)};var Xz=c._emscripten_run_in_main_runtime_thread_js=function(){return(Xz=c._emscripten_run_in_main_runtime_thread_js=c.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)};c._emscripten_dispatch_to_thread_=function(){return(c._emscripten_dispatch_to_thread_=c.asm.emscripten_dispatch_to_thread_).apply(null,arguments)};var Yz=c.__emscripten_proxy_execute_task_queue=function(){return(Yz=c.__emscripten_proxy_execute_task_queue=c.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},v$=c.__emscripten_thread_free_data=function(){return(v$=c.__emscripten_thread_free_data=c.asm._emscripten_thread_free_data).apply(null,arguments)},Jz=c.__emscripten_thread_exit=function(){return(Jz=c.__emscripten_thread_exit=c.asm._emscripten_thread_exit).apply(null,arguments)},Zz=c._emscripten_stack_set_limits=function(){return(Zz=c._emscripten_stack_set_limits=c.asm.emscripten_stack_set_limits).apply(null,arguments)},x$=c.stackSave=function(){return(x$=c.stackSave=c.asm.stackSave).apply(null,arguments)},Jw=c.stackRestore=function(){return(Jw=c.stackRestore=c.asm.stackRestore).apply(null,arguments)},Zw=c.stackAlloc=function(){return(Zw=c.stackAlloc=c.asm.stackAlloc).apply(null,arguments)};c.dynCall_iijjiiii=function(){return(c.dynCall_iijjiiii=c.asm.dynCall_iijjiiii).apply(null,arguments)},c.dynCall_jiji=function(){return(c.dynCall_jiji=c.asm.dynCall_jiji).apply(null,arguments)},c.keepRuntimeAlive=Le,c.wasmMemory=F,c.cwrap=rle,c.ExitStatus=pr,c.PThread=Re;var Qw;Je=function te(){Qw||Qz(),Qw||(Je=te)};function Qz(te){if(Ye>0)return;if(x){d(c),ge(),startWorker(c);return}if($e(),Ye>0)return;function Ne(){Qw||(Qw=!0,c.calledRun=!0,!O&&(ge(),d(c),c.onRuntimeInitialized&&c.onRuntimeInitialized(),ve()))}c.setStatus?(c.setStatus("Running..."),setTimeout(function(){setTimeout(function(){c.setStatus("")},1),Ne()},1)):Ne()}if(c.preInit)for(typeof c.preInit=="function"&&(c.preInit=[c.preInit]);c.preInit.length>0;)c.preInit.pop()();Qz();var ek;p&&(ek={uncaughtException:process.listeners("uncaughtException").filter(function(te){return!p.uncaughtException.indexOf(te)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(te){return!p.unhandledRejection.indexOf(te)>-1})});var tk;if(typeof WasmBackendModule<"u")tk=WasmBackendModule;else if(typeof s<"u")tk=s;else throw new Error("Could not find wasm module in post.js");if(ek){var ale=tk._dispose;tk._dispose=function(){ale(),ek.uncaughtException.forEach(function(te){process.removeListener("uncaughtException",te)}),ek.unhandledRejection.forEach(function(te){process.removeListener("unhandledRejection",te)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModuleThreadedSimd=n)}),wHe=Or((e,t)=>{t.exports.wasmWorkerContents=`"use strict";var Module={};var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";if(ENVIRONMENT_IS_NODE){var nodeWorkerThreads=require("worker_threads");var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",data=>onmessage({data:data}));var fs=require("fs");Object.assign(global,{self:global,require:require,Module:Module,location:{href:__filename},Worker:nodeWorkerThreads.Worker,importScripts:function(f){(0,eval)(fs.readFileSync(f,"utf8")+"//# sourceURL="+f)},postMessage:function(msg){parentPort.postMessage(msg)},performance:global.performance||{now:function(){return Date.now()}}})}var initializedJS=false;var pendingNotifiedProxyingQueues=[];function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");if(ENVIRONMENT_IS_NODE){fs.writeSync(2,text+"
");return}console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;self.alert=threadAlert;Module["instantiateWasm"]=(info,receiveInstance)=>{var instance=new WebAssembly.Instance(Module["wasmModule"],info);receiveInstance(instance);Module["wasmModule"]=null;return instance.exports};self.onunhandledrejection=e=>{throw e.reason??e};self.startWorker=instance=>{Module=instance;postMessage({"cmd":"loaded"})};self.onmessage=e=>{try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;for(const handler of e.data.handlers){Module[handler]=function(){postMessage({cmd:"callHandler",handler:handler,args:[...arguments]})}}Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob=="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module)}else if(e.data.cmd==="run"){Module["__emscripten_thread_init"](e.data.pthread_ptr,0,0,1);Module["establishStackSpace"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].threadInitTLS();if(!initializedJS){pendingNotifiedProxyingQueues.forEach(queue=>{Module["executeNotifiedProxyingQueue"](queue)});pendingNotifiedProxyingQueues=[];initializedJS=true}try{Module["invokeEntryPoint"](e.data.start_routine,e.data.arg)}catch(ex){if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["keepRuntimeAlive"]()){}else{Module["__emscripten_thread_exit"](ex.status)}}else{throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["__emscripten_thread_exit"](-1)}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processProxyingQueue"){if(initializedJS){Module["executeNotifiedProxyingQueue"](e.data.queue)}else{pendingNotifiedProxyingQueues.push(e.data.queue)}}else if(e.data.cmd){err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){if(Module["__emscripten_thread_crashed"]){Module["__emscripten_thread_crashed"]()}throw ex}};`}),kHe=Or((e,t)=>{var n=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(s){s=s||{};var a=typeof s<"u"?s:{},i,o;a.ready=new Promise(function(Ce,We){i=Ce,o=We});var l;typeof process<"u"&&process.listeners&&(l={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var u=Object.assign({},a),c=typeof window=="object",d=typeof importScripts=="function",h=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",p="";function f(Ce){return a.locateFile?a.locateFile(Ce,p):p+Ce}var m,g,y;if(h){var b=CM(),x=YJ();d?p=x.dirname(p)+"/":p=__dirname+"/",m=(Ce,We)=>(Ce=ke(Ce)?new URL(Ce):x.normalize(Ce),b.readFileSync(Ce,We?void 0:"utf8")),y=Ce=>{var We=m(Ce,!0);return We.buffer||(We=new Uint8Array(We)),We},g=(Ce,We,gt)=>{Ce=ke(Ce)?new URL(Ce):x.normalize(Ce),b.readFile(Ce,function(Re,rt){Re?gt(Re):We(rt.buffer)})},process.argv.length>1&&process.argv[1].replace(/\\/g,"/"),process.argv.slice(2),process.on("uncaughtException",function(Ce){if(!(Ce instanceof Le))throw Ce}),process.on("unhandledRejection",function(Ce){throw Ce}),a.inspect=function(){return"[Emscripten Module object]"}}else(c||d)&&(d?p=self.location.href:typeof document<"u"&&document.currentScript&&(p=document.currentScript.src),r&&(p=r),p.indexOf("blob:")!==0?p=p.substr(0,p.replace(/[?#].*/,"").lastIndexOf("/")+1):p="",m=Ce=>{var We=new XMLHttpRequest;return We.open("GET",Ce,!1),We.send(null),We.responseText},d&&(y=Ce=>{var We=new XMLHttpRequest;return We.open("GET",Ce,!1),We.responseType="arraybuffer",We.send(null),new Uint8Array(We.response)}),g=(Ce,We,gt)=>{var Re=new XMLHttpRequest;Re.open("GET",Ce,!0),Re.responseType="arraybuffer",Re.onload=()=>{if(Re.status==200||Re.status==0&&Re.response){We(Re.response);return}gt()},Re.onerror=gt,Re.send(null)});var v=a.print||console.log.bind(console),w=a.printErr||console.warn.bind(console);Object.assign(a,u),u=null,a.arguments&&a.arguments,a.thisProgram&&a.thisProgram,a.quit&&a.quit;var k;a.wasmBinary&&(k=a.wasmBinary),a.noExitRuntime,typeof WebAssembly!="object"&&j("no native wasm support detected");var S,I=!1,$=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function C(Ce,We,gt){We>>>=0;for(var Re=We+gt,rt=We;Ce[rt]&&!(rt>=Re);)++rt;if(rt-We>16&&Ce.buffer&&$)return $.decode(Ce.subarray(We,rt));for(var lt="";We<rt;){var xt=Ce[We++];if(!(xt&128)){lt+=String.fromCharCode(xt);continue}var yt=Ce[We++]&63;if((xt&224)==192){lt+=String.fromCharCode((xt&31)<<6|yt);continue}var on=Ce[We++]&63;if((xt&240)==224?xt=(xt&15)<<12|yt<<6|on:xt=(xt&7)<<18|yt<<12|on<<6|Ce[We++]&63,xt<65536)lt+=String.fromCharCode(xt);else{var Qn=xt-65536;lt+=String.fromCharCode(55296|Qn>>10,56320|Qn&1023)}}return lt}function T(Ce,We){return Ce>>>=0,Ce?C(z,Ce,We):""}function N(Ce,We,gt,Re){if(gt>>>=0,!(Re>0))return 0;for(var rt=gt,lt=gt+Re-1,xt=0;xt<Ce.length;++xt){var yt=Ce.charCodeAt(xt);if(yt>=55296&&yt<=57343){var on=Ce.charCodeAt(++xt);yt=65536+((yt&1023)<<10)|on&1023}if(yt<=127){if(gt>=lt)break;We[gt++>>>0]=yt}else if(yt<=2047){if(gt+1>=lt)break;We[gt++>>>0]=192|yt>>6,We[gt++>>>0]=128|yt&63}else if(yt<=65535){if(gt+2>=lt)break;We[gt++>>>0]=224|yt>>12,We[gt++>>>0]=128|yt>>6&63,We[gt++>>>0]=128|yt&63}else{if(gt+3>=lt)break;We[gt++>>>0]=240|yt>>18,We[gt++>>>0]=128|yt>>12&63,We[gt++>>>0]=128|yt>>6&63,We[gt++>>>0]=128|yt&63}}return We[gt>>>0]=0,gt-rt}function E(Ce,We,gt){return N(Ce,z,We,gt)}var _,R,z,W;function F(Ce){_=Ce,a.HEAP8=R=new Int8Array(Ce),a.HEAP16=new Int16Array(Ce),a.HEAP32=new Int32Array(Ce),a.HEAPU8=z=new Uint8Array(Ce),a.HEAPU16=new Uint16Array(Ce),a.HEAPU32=W=new Uint32Array(Ce),a.HEAPF32=new Float32Array(Ce),a.HEAPF64=new Float64Array(Ce)}a.INITIAL_MEMORY;var L=[],O=[],D=[];function B(){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)G(a.preRun.shift());$e(L)}function V(){$e(O)}function K(){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)q(a.postRun.shift());$e(D)}function G(Ce){L.unshift(Ce)}function U(Ce){O.unshift(Ce)}function q(Ce){D.unshift(Ce)}var Q=0,ee=null;function ae(Ce){Q++,a.monitorRunDependencies&&a.monitorRunDependencies(Q)}function ye(Ce){if(Q--,a.monitorRunDependencies&&a.monitorRunDependencies(Q),Q==0&&ee){var We=ee;ee=null,We()}}function j(Ce){a.onAbort&&a.onAbort(Ce),Ce="Aborted("+Ce+")",w(Ce),I=!0,Ce+=". Build with -sASSERTIONS for more info.";var We=new WebAssembly.RuntimeError(Ce);throw o(We),We}var ce="data:application/octet-stream;base64,";function be(Ce){return Ce.startsWith(ce)}function ke(Ce){return Ce.startsWith("file://")}var Ae;Ae="tfjs-backend-wasm.wasm",be(Ae)||(Ae=f(Ae));function Pe(Ce){try{if(Ce==Ae&&k)return new Uint8Array(k);if(y)return y(Ce);throw"both async and sync fetching of the wasm failed"}catch(We){j(We)}}function ie(){if(!k&&(c||d)){if(typeof fetch=="function"&&!ke(Ae))return fetch(Ae,{credentials:"same-origin"}).then(function(Ce){if(!Ce.ok)throw"failed to load wasm binary file at '"+Ae+"'";return Ce.arrayBuffer()}).catch(function(){return Pe(Ae)});if(g)return new Promise(function(Ce,We){g(Ae,function(gt){Ce(new Uint8Array(gt))},We)})}return Promise.resolve().then(function(){return Pe(Ae)})}function Te(){var Ce={env:Un,wasi_snapshot_preview1:Un};function We(xt,yt){var on=xt.exports;a.asm=on,S=a.asm.memory,F(S.buffer),a.asm.__indirect_function_table,U(a.asm.__wasm_call_ctors),ye()}ae();function gt(xt){We(xt.instance)}function Re(xt){return ie().then(function(yt){return WebAssembly.instantiate(yt,Ce)}).then(function(yt){return yt}).then(xt,function(yt){w("failed to asynchronously prepare wasm: "+yt),j(yt)})}function rt(){return!k&&typeof WebAssembly.instantiateStreaming=="function"&&!be(Ae)&&!ke(Ae)&&!h&&typeof fetch=="function"?fetch(Ae,{credentials:"same-origin"}).then(function(xt){var yt=WebAssembly.instantiateStreaming(xt,Ce);return yt.then(gt,function(on){return w("wasm streaming compile failed: "+on),w("falling back to ArrayBuffer instantiation"),Re(gt)})}):Re(gt)}if(a.instantiateWasm)try{var lt=a.instantiateWasm(Ce,We);return lt}catch(xt){w("Module.instantiateWasm callback failed with error: "+xt),o(xt)}return rt().catch(o),{}}function Le(Ce){this.name="ExitStatus",this.message="Program terminated with exit("+Ce+")",this.status=Ce}function $e(Ce){for(;Ce.length>0;)Ce.shift()(a)}function ge(){j("")}function ve(){return 4294901760}function pe(){return ve()}function Ie(Ce,We,gt){z.copyWithin(Ce>>>0,We>>>0,We+gt>>>0)}function ze(Ce){try{return S.grow(Ce-_.byteLength+65535>>>16),F(S.buffer),1}catch{}}function Ye(Ce){var We=z.length;Ce=Ce>>>0;var gt=ve();if(Ce>gt)return!1;let Re=(on,Qn)=>on+(Qn-on%Qn)%Qn;for(var rt=1;rt<=4;rt*=2){var lt=We*(1+.2/rt);lt=Math.min(lt,Ce+100663296);var xt=Math.min(gt,Re(Math.max(Ce,lt),65536)),yt=ze(xt);if(yt)return!0}return!1}function Je(Ce){return 52}function Ke(Ce,We,gt,Re,rt){return 70}var Ue=[null,[],[]];function Xe(Ce,We){var gt=Ue[Ce];We===0||We===10?((Ce===1?v:w)(C(gt,0)),gt.length=0):gt.push(We)}function ut(Ce,We,gt,Re){for(var rt=0,lt=0;lt<gt;lt++){var xt=W[We>>>2],yt=W[We+4>>>2];We+=8;for(var on=0;on<yt;on++)Xe(Ce,z[xt+on>>>0]);rt+=yt}return W[Re>>>2]=rt,0}function vt(Ce){var We=a["_"+Ce];return We}function An(Ce,We){R.set(Ce,We>>>0)}function Rt(Ce,We,gt,Re,rt){var lt={string:ms=>{var lo=0;if(ms!=null&&ms!==0){var _d=(ms.length<<2)+1;lo=pr(_d),E(ms,lo,_d)}return lo},array:ms=>{var lo=pr(ms.length);return An(ms,lo),lo}};function xt(ms){return We==="string"?T(ms):We==="boolean"?!!ms:ms}var yt=vt(Ce),on=[],Qn=0;if(Re)for(var jn=0;jn<Re.length;jn++){var Es=lt[gt[jn]];Es?(Qn===0&&(Qn=si()),on[jn]=Es(Re[jn])):on[jn]=Re[jn]}var hn=yt.apply(null,on);function Ko(ms){return Qn!==0&&_a(Qn),xt(ms)}return hn=Ko(hn),hn}function Bs(Ce,We,gt,Re){gt=gt||[];var rt=gt.every(xt=>xt==="number"||xt==="boolean"),lt=We!=="string";return lt&&rt&&!Re?vt(Ce):function(){return Rt(Ce,We,gt,arguments)}}var Un={abort:ge,emscripten_get_heap_max:pe,emscripten_memcpy_big:Ie,emscripten_resize_heap:Ye,fd_close:Je,fd_seek:Ke,fd_write:ut};Te(),a.___wasm_call_ctors=function(){return(a.___wasm_call_ctors=a.asm.__wasm_call_ctors).apply(null,arguments)},a._init=function(){return(a._init=a.asm.init).apply(null,arguments)},a._init_with_threads_count=function(){return(a._init_with_threads_count=a.asm.init_with_threads_count).apply(null,arguments)},a._get_threads_count=function(){return(a._get_threads_count=a.asm.get_threads_count).apply(null,arguments)},a._register_tensor=function(){return(a._register_tensor=a.asm.register_tensor).apply(null,arguments)},a._dispose_data=function(){return(a._dispose_data=a.asm.dispose_data).apply(null,arguments)},a._dispose=function(){return(a._dispose=a.asm.dispose).apply(null,arguments)},a._Abs=function(){return(a._Abs=a.asm.Abs).apply(null,arguments)},a._Acos=function(){return(a._Acos=a.asm.Acos).apply(null,arguments)},a._Acosh=function(){return(a._Acosh=a.asm.Acosh).apply(null,arguments)},a._Add=function(){return(a._Add=a.asm.Add).apply(null,arguments)},a._AddN=function(){return(a._AddN=a.asm.AddN).apply(null,arguments)},a._All=function(){return(a._All=a.asm.All).apply(null,arguments)},a._Any=function(){return(a._Any=a.asm.Any).apply(null,arguments)},a._ArgMax=function(){return(a._ArgMax=a.asm.ArgMax).apply(null,arguments)},a._ArgMin=function(){return(a._ArgMin=a.asm.ArgMin).apply(null,arguments)},a._Asin=function(){return(a._Asin=a.asm.Asin).apply(null,arguments)},a._Asinh=function(){return(a._Asinh=a.asm.Asinh).apply(null,arguments)},a._Atan=function(){return(a._Atan=a.asm.Atan).apply(null,arguments)},a._Atan2=function(){return(a._Atan2=a.asm.Atan2).apply(null,arguments)},a._Atanh=function(){return(a._Atanh=a.asm.Atanh).apply(null,arguments)},a._AvgPool=function(){return(a._AvgPool=a.asm.AvgPool).apply(null,arguments)},a._AvgPool3D=function(){return(a._AvgPool3D=a.asm.AvgPool3D).apply(null,arguments)},a._AvgPool3DGrad=function(){return(a._AvgPool3DGrad=a.asm.AvgPool3DGrad).apply(null,arguments)},a._AvgPoolGrad=function(){return(a._AvgPoolGrad=a.asm.AvgPoolGrad).apply(null,arguments)},a._BatchMatMul=function(){return(a._BatchMatMul=a.asm.BatchMatMul).apply(null,arguments)},a._Bincount=function(){return(a._Bincount=a.asm.Bincount).apply(null,arguments)},a._BitwiseAnd=function(){return(a._BitwiseAnd=a.asm.BitwiseAnd).apply(null,arguments)},a._Ceil=function(){return(a._Ceil=a.asm.Ceil).apply(null,arguments)},a._ClipByValue=function(){return(a._ClipByValue=a.asm.ClipByValue).apply(null,arguments)},a._Conv2D=function(){return(a._Conv2D=a.asm.Conv2D).apply(null,arguments)},a._Conv2DBackpropInput=function(){return(a._Conv2DBackpropInput=a.asm.Conv2DBackpropInput).apply(null,arguments)},a._Conv3D=function(){return(a._Conv3D=a.asm.Conv3D).apply(null,arguments)},a._Conv3DBackpropFilterV2=function(){return(a._Conv3DBackpropFilterV2=a.asm.Conv3DBackpropFilterV2).apply(null,arguments)},a._Conv3DBackpropInputV2=function(){return(a._Conv3DBackpropInputV2=a.asm.Conv3DBackpropInputV2).apply(null,arguments)},a._Cos=function(){return(a._Cos=a.asm.Cos).apply(null,arguments)},a._Cosh=function(){return(a._Cosh=a.asm.Cosh).apply(null,arguments)},a._CropAndResize=function(){return(a._CropAndResize=a.asm.CropAndResize).apply(null,arguments)},a._Cumprod=function(){return(a._Cumprod=a.asm.Cumprod).apply(null,arguments)},a._Cumsum=function(){return(a._Cumsum=a.asm.Cumsum).apply(null,arguments)},a._DenseBincount=function(){return(a._DenseBincount=a.asm.DenseBincount).apply(null,arguments)},a._DepthToSpace=function(){return(a._DepthToSpace=a.asm.DepthToSpace).apply(null,arguments)},a._DepthwiseConv2dNative=function(){return(a._DepthwiseConv2dNative=a.asm.DepthwiseConv2dNative).apply(null,arguments)},a._Diag=function(){return(a._Diag=a.asm.Diag).apply(null,arguments)},a._Dilation2D=function(){return(a._Dilation2D=a.asm.Dilation2D).apply(null,arguments)},a._Dilation2DBackpropFilter=function(){return(a._Dilation2DBackpropFilter=a.asm.Dilation2DBackpropFilter).apply(null,arguments)},a._Dilation2DBackpropInput=function(){return(a._Dilation2DBackpropInput=a.asm.Dilation2DBackpropInput).apply(null,arguments)},a._Elu=function(){return(a._Elu=a.asm.Elu).apply(null,arguments)},a._EluGrad=function(){return(a._EluGrad=a.asm.EluGrad).apply(null,arguments)},a._Equal=function(){return(a._Equal=a.asm.Equal).apply(null,arguments)},a._Erf=function(){return(a._Erf=a.asm.Erf).apply(null,arguments)},a._Exp=function(){return(a._Exp=a.asm.Exp).apply(null,arguments)},a._Expm1=function(){return(a._Expm1=a.asm.Expm1).apply(null,arguments)},a._FlipLeftRight=function(){return(a._FlipLeftRight=a.asm.FlipLeftRight).apply(null,arguments)},a._Floor=function(){return(a._Floor=a.asm.Floor).apply(null,arguments)},a._FloorDiv=function(){return(a._FloorDiv=a.asm.FloorDiv).apply(null,arguments)},a._FusedBatchNorm=function(){return(a._FusedBatchNorm=a.asm.FusedBatchNorm).apply(null,arguments)},a._FusedConv2D=function(){return(a._FusedConv2D=a.asm.FusedConv2D).apply(null,arguments)},a._FusedDepthwiseConv2D=function(){return(a._FusedDepthwiseConv2D=a.asm.FusedDepthwiseConv2D).apply(null,arguments)},a._Gather=function(){return(a._Gather=a.asm.Gather).apply(null,arguments)},a._GatherNd=function(){return(a._GatherNd=a.asm.GatherNd).apply(null,arguments)},a._Greater=function(){return(a._Greater=a.asm.Greater).apply(null,arguments)},a._GreaterEqual=function(){return(a._GreaterEqual=a.asm.GreaterEqual).apply(null,arguments)},a._IsFinite=function(){return(a._IsFinite=a.asm.IsFinite).apply(null,arguments)},a._IsInf=function(){return(a._IsInf=a.asm.IsInf).apply(null,arguments)},a._IsNan=function(){return(a._IsNan=a.asm.IsNan).apply(null,arguments)},a._LRN=function(){return(a._LRN=a.asm.LRN).apply(null,arguments)},a._LRNGrad=function(){return(a._LRNGrad=a.asm.LRNGrad).apply(null,arguments)},a._LeakyRelu=function(){return(a._LeakyRelu=a.asm.LeakyRelu).apply(null,arguments)},a._Less=function(){return(a._Less=a.asm.Less).apply(null,arguments)},a._LessEqual=function(){return(a._LessEqual=a.asm.LessEqual).apply(null,arguments)},a._LinSpace=function(){return(a._LinSpace=a.asm.LinSpace).apply(null,arguments)},a._Log=function(){return(a._Log=a.asm.Log).apply(null,arguments)},a._Log1p=function(){return(a._Log1p=a.asm.Log1p).apply(null,arguments)},a._LogicalAnd=function(){return(a._LogicalAnd=a.asm.LogicalAnd).apply(null,arguments)},a._LogicalNot=function(){return(a._LogicalNot=a.asm.LogicalNot).apply(null,arguments)},a._LogicalOr=function(){return(a._LogicalOr=a.asm.LogicalOr).apply(null,arguments)},a._LogicalXor=function(){return(a._LogicalXor=a.asm.LogicalXor).apply(null,arguments)},a._Max=function(){return(a._Max=a.asm.Max).apply(null,arguments)},a._MaxPool=function(){return(a._MaxPool=a.asm.MaxPool).apply(null,arguments)},a._MaxPool3D=function(){return(a._MaxPool3D=a.asm.MaxPool3D).apply(null,arguments)},a._MaxPool3DGrad=function(){return(a._MaxPool3DGrad=a.asm.MaxPool3DGrad).apply(null,arguments)},a._MaxPoolGrad=function(){return(a._MaxPoolGrad=a.asm.MaxPoolGrad).apply(null,arguments)},a._MaxPoolWithArgmax=function(){return(a._MaxPoolWithArgmax=a.asm.MaxPoolWithArgmax).apply(null,arguments)},a._Maximum=function(){return(a._Maximum=a.asm.Maximum).apply(null,arguments)},a._Mean=function(){return(a._Mean=a.asm.Mean).apply(null,arguments)},a._Min=function(){return(a._Min=a.asm.Min).apply(null,arguments)},a._Minimum=function(){return(a._Minimum=a.asm.Minimum).apply(null,arguments)},a._MirrorPad=function(){return(a._MirrorPad=a.asm.MirrorPad).apply(null,arguments)},a._Mod=function(){return(a._Mod=a.asm.Mod).apply(null,arguments)},a._Multinomial=function(){return(a._Multinomial=a.asm.Multinomial).apply(null,arguments)},a._Multiply=function(){return(a._Multiply=a.asm.Multiply).apply(null,arguments)},a._Neg=function(){return(a._Neg=a.asm.Neg).apply(null,arguments)},a._NonMaxSuppressionV3=function(){return(a._NonMaxSuppressionV3=a.asm.NonMaxSuppressionV3).apply(null,arguments)},a._NonMaxSuppressionV4=function(){return(a._NonMaxSuppressionV4=a.asm.NonMaxSuppressionV4).apply(null,arguments)},a._NonMaxSuppressionV5=function(){return(a._NonMaxSuppressionV5=a.asm.NonMaxSuppressionV5).apply(null,arguments)},a._NotEqual=function(){return(a._NotEqual=a.asm.NotEqual).apply(null,arguments)},a._OneHot=function(){return(a._OneHot=a.asm.OneHot).apply(null,arguments)},a._PadV2=function(){return(a._PadV2=a.asm.PadV2).apply(null,arguments)},a._Pow=function(){return(a._Pow=a.asm.Pow).apply(null,arguments)},a._Prelu=function(){return(a._Prelu=a.asm.Prelu).apply(null,arguments)},a._Prod=function(){return(a._Prod=a.asm.Prod).apply(null,arguments)},a._RealDiv=function(){return(a._RealDiv=a.asm.RealDiv).apply(null,arguments)},a._Reciprocal=function(){return(a._Reciprocal=a.asm.Reciprocal).apply(null,arguments)},a._Relu=function(){return(a._Relu=a.asm.Relu).apply(null,arguments)},a._Relu6=function(){return(a._Relu6=a.asm.Relu6).apply(null,arguments)},a._ResizeBilinear=function(){return(a._ResizeBilinear=a.asm.ResizeBilinear).apply(null,arguments)},a._ResizeBilinearGrad=function(){return(a._ResizeBilinearGrad=a.asm.ResizeBilinearGrad).apply(null,arguments)},a._ResizeNearestNeighbor=function(){return(a._ResizeNearestNeighbor=a.asm.ResizeNearestNeighbor).apply(null,arguments)},a._ResizeNearestNeighborGrad=function(){return(a._ResizeNearestNeighborGrad=a.asm.ResizeNearestNeighborGrad).apply(null,arguments)},a._Reverse=function(){return(a._Reverse=a.asm.Reverse).apply(null,arguments)},a._RotateWithOffset=function(){return(a._RotateWithOffset=a.asm.RotateWithOffset).apply(null,arguments)},a._Round=function(){return(a._Round=a.asm.Round).apply(null,arguments)},a._Rsqrt=function(){return(a._Rsqrt=a.asm.Rsqrt).apply(null,arguments)},a._ScatterNd=function(){return(a._ScatterNd=a.asm.ScatterNd).apply(null,arguments)},a._SearchSorted=function(){return(a._SearchSorted=a.asm.SearchSorted).apply(null,arguments)},a._SelectV2=function(){return(a._SelectV2=a.asm.SelectV2).apply(null,arguments)},a._Selu=function(){return(a._Selu=a.asm.Selu).apply(null,arguments)},a._Sigmoid=function(){return(a._Sigmoid=a.asm.Sigmoid).apply(null,arguments)},a._Sign=function(){return(a._Sign=a.asm.Sign).apply(null,arguments)},a._Sin=function(){return(a._Sin=a.asm.Sin).apply(null,arguments)},a._Sinh=function(){return(a._Sinh=a.asm.Sinh).apply(null,arguments)},a._Softmax=function(){return(a._Softmax=a.asm.Softmax).apply(null,arguments)},a._Softplus=function(){return(a._Softplus=a.asm.Softplus).apply(null,arguments)},a._SparseFillEmptyRows=function(){return(a._SparseFillEmptyRows=a.asm.SparseFillEmptyRows).apply(null,arguments)},a._SparseReshape=function(){return(a._SparseReshape=a.asm.SparseReshape).apply(null,arguments)},a._SparseSegmentReduction=function(){return(a._SparseSegmentReduction=a.asm.SparseSegmentReduction).apply(null,arguments)},a._SparseToDense=function(){return(a._SparseToDense=a.asm.SparseToDense).apply(null,arguments)},a._Sqrt=function(){return(a._Sqrt=a.asm.Sqrt).apply(null,arguments)},a._Square=function(){return(a._Square=a.asm.Square).apply(null,arguments)},a._SquaredDifference=function(){return(a._SquaredDifference=a.asm.SquaredDifference).apply(null,arguments)},a._Step=function(){return(a._Step=a.asm.Step).apply(null,arguments)},a._StridedSlice=function(){return(a._StridedSlice=a.asm.StridedSlice).apply(null,arguments)},a._Sub=function(){return(a._Sub=a.asm.Sub).apply(null,arguments)},a._Sum=function(){return(a._Sum=a.asm.Sum).apply(null,arguments)},a._Tan=function(){return(a._Tan=a.asm.Tan).apply(null,arguments)},a._Tanh=function(){return(a._Tanh=a.asm.Tanh).apply(null,arguments)},a._TensorScatterUpdate=function(){return(a._TensorScatterUpdate=a.asm.TensorScatterUpdate).apply(null,arguments)},a._Tile=function(){return(a._Tile=a.asm.Tile).apply(null,arguments)},a._TopK=function(){return(a._TopK=a.asm.TopK).apply(null,arguments)},a._Transform=function(){return(a._Transform=a.asm.Transform).apply(null,arguments)},a._Transpose=function(){return(a._Transpose=a.asm.Transpose).apply(null,arguments)},a.__FusedMatMul=function(){return(a.__FusedMatMul=a.asm._FusedMatMul).apply(null,arguments)},a._malloc=function(){return(a._malloc=a.asm.malloc).apply(null,arguments)},a._free=function(){return(a._free=a.asm.free).apply(null,arguments)},a.___errno_location=function(){return(a.___errno_location=a.asm.__errno_location).apply(null,arguments)};var si=a.stackSave=function(){return(si=a.stackSave=a.asm.stackSave).apply(null,arguments)},_a=a.stackRestore=function(){return(_a=a.stackRestore=a.asm.stackRestore).apply(null,arguments)},pr=a.stackAlloc=function(){return(pr=a.stackAlloc=a.asm.stackAlloc).apply(null,arguments)};a.dynCall_iijjiiii=function(){return(a.dynCall_iijjiiii=a.asm.dynCall_iijjiiii).apply(null,arguments)},a.dynCall_jiji=function(){return(a.dynCall_jiji=a.asm.dynCall_jiji).apply(null,arguments)},a.cwrap=Bs;var Aa;ee=function Ce(){Aa||jl(),Aa||(ee=Ce)};function jl(Ce){if(Q>0||(B(),Q>0))return;function We(){Aa||(Aa=!0,a.calledRun=!0,!I&&(V(),i(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),K()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),We()},1)):We()}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();jl();var Ln;l&&(Ln={uncaughtException:process.listeners("uncaughtException").filter(function(Ce){return!l.uncaughtException.indexOf(Ce)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Ce){return!l.unhandledRejection.indexOf(Ce)>-1})});var Mr;if(typeof s<"u")Mr=s;else if(typeof WasmBackendModuleThreadedSimd<"u")Mr=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Ln){var It=Mr._dispose;Mr._dispose=function(){It(),Ln.uncaughtException.forEach(function(Ce){process.removeListener("uncaughtException",Ce)}),Ln.unhandledRejection.forEach(function(Ce){process.removeListener("unhandledRejection",Ce)})}}return s.ready}})();typeof e=="object"&&typeof t=="object"?t.exports=n:typeof define=="function"&&define.amd?define([],function(){return n}):typeof e=="object"&&(e.WasmBackendModule=n)}),VN=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},jx=class{refCount(e){return Da("refCount")}incRef(e){return Da("incRef")}timerAvailable(){return!0}time(e){return Da("time")}read(e){return Da("read")}readSync(e){return Da("readSync")}readToGPU(e,t){return Da("readToGPU")}numDataIds(){return Da("numDataIds")}disposeData(e,t){return Da("disposeData")}write(e,t,n){return Da("write")}move(e,t,n,r,s){return Da("move")}createTensorFromGPUData(e,t,n){return Da("createTensorFromGPUData")}memory(){return Da("memory")}floatPrecision(){return Da("floatPrecision")}epsilon(){return this.floatPrecision()===32?1e-7:1e-4}dispose(){return Da("dispose")}};function Da(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function JJ(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,qS(e,t,n)}function SHe(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,r=0;for(;n>0;)r=Math.random()*n|0,n--,qS(e,n,r),qS(t,n,r)}function X1(e,t,n){return Math.max(e,Math.min(t,n))}function IHe(e){return e%2===0?e:e+1}function qS(e,t,n){let r=e[t];e[t]=e[n],e[n]=r}function CHe(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function NHe(e,t){let n=Math.random();return t*n+(1-n)*e}function THe(e,t){let n=0;for(let r=0;r<e.length;r++){let s=Number(e[r])-Number(t[r]);n+=s*s}return n}function J(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function aa(e,t,n=""){J($u(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Np(e){J(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function yn(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function $He(e){return e.length===0}function ZJ(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function $u(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Mg(e){return e%1===0}function EHe(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{let t=Math.exp(2*e);return(t-1)/(t+1)}}function _He(e){let t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function AHe(e){let t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return JJ(t),t}function l1(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function RHe(e,t=s=>0,n,r){return new Promise((s,a)=>{let i=0,o=()=>{if(e()){s();return}i++;let l=t(i);if(n!=null&&i>=n){a();return}r!=null?r(o,l):setTimeout(o,l)};o()})}function DHe(e,t){let n=1,r=-1;for(let a=0;a<e.length;++a)if(e[a]>=0)n*=e[a];else if(e[a]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${a}`);r=a}else if(e[a]<0)throw Error(`Shapes can not be < 0. Found ${e[a]} at dim ${a}`);if(r===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);let s=e.slice();return s[r]=t/n,s}function ao(e,t){let n=t.length;return e=e==null?t.map((r,s)=>s):[].concat(e),J(e.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),J(e.every(r=>Mg(r)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(r=>r<0?n+r:r)}function QJ(e,t){let n=[],r=[],s=t!=null&&Array.isArray(t)&&t.length===0,a=t==null||s?null:ao(t,e).sort(),i=0;for(let o=0;o<e.length;++o){if(a!=null){if(a[i]===o&&e[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(a[i]==null||a[i]>o)&&e[o]===1&&(n.push(e[o]),r.push(o)),a[i]<=o&&i++}e[o]!==1&&(n.push(e[o]),r.push(o))}return{newShape:n,keptDims:r}}function eZ(e,t){return NM(e,t)}function NM(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function tZ(e,t){for(let n=0;n<e.length;n++){let r=e[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function nZ(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function OHe(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function KS(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function rZ(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function ic(e){return typeof e=="string"||e instanceof String}function sZ(e){return typeof e=="boolean"}function aZ(e){return typeof e=="number"}function Gx(e){return Array.isArray(e)?Gx(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":aZ(e)?"float32":ic(e)?"string":sZ(e)?"bool":"float32"}function Pc(e){return!!(e&&e.constructor&&e.call&&e.apply)}function XS(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Oy(e){let t=e.length;if(t<2)return[];let n=new Array(t-1);n[t-2]=e[t-1];for(let r=t-3;r>=0;--r)n[r]=n[r+1]*e[r+1];return n}function iZ(e,t,n,r=!1){let s=new Array;if(t.length===1){let a=t[0]*(r?2:1);for(let i=0;i<a;i++)s[i]=n[e+i]}else{let a=t[0],i=t.slice(1),o=i.reduce((l,u)=>l*u)*(r?2:1);for(let l=0;l<a;l++)s[l]=iZ(e+l*o,i,n,r)}return s}function ng(e,t,n=!1){if(e.length===0)return t[0];let r=e.reduce((s,a)=>s*a)*(n?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return iZ(0,e,t,n)}function FHe(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function TM(e,t){let n=UN(e,t);for(let r=0;r<n.length;r++)n[r]=1;return n}function UN(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function MHe(e,t){let n=e.reduce((r,s)=>r*s,1);if(t==null||t==="float32")return ng(e,new Float32Array(n));if(t==="int32")return ng(e,new Int32Array(n));if(t==="bool")return ng(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function ri(e){e.forEach(t=>{J(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function PHe(e,t,n){if(t===0)return 0;if(t===1)return e[0];let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=n[s]*e[s];return r}function LHe(e,t,n){if(t===0)return[];if(t===1)return[e];let r=new Array(t);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(e/n[s]),e-=r[s]*n[s];return r[r.length-1]=e,r}function jN(e){return e&&e.then&&typeof e.then=="function"}var Cj="tfjsflags",oZ=class{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=zHe,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let r=this.urlFlags[e];xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(jN(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);Cj in e&&e[Cj].split(",").forEach(t=>{let[n,r]=t.split(":");this.urlFlags[n]=WHe(n,r)})}};function zHe(e){let t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(BHe(t,r[0],r[1]),r.join("="))),t}function BHe(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function WHe(e,t){let n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function xe(){return $M}var $M=null;function VHe(e){$M=e}var AE;function lZ(){if(AE==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");AE=e}return AE}function UHe(){let e=lZ();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function EM(e,t){let n=UHe();if(n.has(e))return n.get(e);{let r=t();return n.set(e,r),n.get(e)}}var Fy="Abs",Tp="Acos",$p="Acosh",fd="Add",Ep="AddN",My="All",Py="Any",Ly="ArgMax",zy="ArgMin",_p="Asin",Ap="Asinh",Rp="Atan",Dp="Atanh",Op="Atan2",Fp="AvgPool",Hx="AvgPoolGrad",By="AvgPool3D",qx="AvgPool3DGrad",Mp="BatchMatMul",Wy="BatchToSpaceND",Vy="Bincount",Uy="BitwiseAnd",uZ="BroadcastTo",Kx="BroadcastArgs",Pp="Cast",Lp="Ceil",md="ClipByValue",GN="Complex",Xx="ComplexAbs",jy="Concat",zp="Conv2D",HN="Conv2DBackpropFilter",Bp="Conv2DBackpropInput",Wp="Conv3D",Gy="Conv3DBackpropFilterV2",Hy="Conv3DBackpropInputV2",Vp="Cos",Up="Cosh",qy="Cumprod",jp="Cumsum",Ky="CropAndResize",Yx="DenseBincount",Xy="DepthToSpace",Gp="DepthwiseConv2dNative",qN="DepthwiseConv2dNativeBackpropFilter",KN="DepthwiseConv2dNativeBackpropInput",Jx="Diag",Hp="Dilation2D",Pg="Dilation2DBackpropInput",Lg="Dilation2DBackpropFilter",XN="Draw",qp="RealDiv",YN="Einsum",Kp="Elu",Yy="EluGrad",Xp="Erf",Jy="Equal",Yp="Exp",Zy="ExpandDims",Jp="Expm1",JN="FFT",Zx="Fill",Qy="FlipLeftRight",Zp="Floor",Qp="FloorDiv",ef="FusedBatchNorm",eb="GatherV2",tb="GatherNd",nb="Greater",nf="GreaterEqual",rf="Identity",ZN="IFFT",QN="Imag",sf="IsFinite",af="IsInf",of="IsNan",lf="LeakyRelu",rb="Less",sb="LessEqual",ab="LinSpace",uf="Log",cf="Log1p",ib="LogicalAnd",ob="LogicalNot",lb="LogicalOr",cZ="LogicalXor",dZ="LogSoftmax",jHe="LowerBound",df="LRN",ub="LRNGrad",GHe="MatrixBandPart",hf="Max",pf="Maximum",ff="MaxPool",Qx="MaxPoolGrad",cb="MaxPool3D",ew="MaxPool3DGrad",tw="MaxPoolWithArgmax",mf="Mean",gf="Min",yf="Minimum",bf="MirrorPad",vf="Mod",db="Multinomial",xf="Multiply",hb="Neg",pb="NotEqual",fb="NonMaxSuppressionV3",mb="NonMaxSuppressionV4",gb="NonMaxSuppressionV5",yb="OnesLike",wf="OneHot",bb="Pack",kf="PadV2",HHe="Pool",Sf="Pow",If="Prelu",Cf="Prod",eT="RaggedGather",tT="RaggedRange",nT="RaggedTensorToTensor",nw="Range",rT="Real",Nf="Reciprocal",Tf="Relu",vb="Reshape",$f="ResizeNearestNeighbor",xb="ResizeNearestNeighborGrad",Ef="ResizeBilinear",wb="ResizeBilinearGrad",_f="Relu6",Af="Reverse",Rf="Round",Df="Rsqrt",kb="ScatterNd",Sb="TensorScatterUpdate",Ib="SearchSorted",Cb="Select",Of="Selu",Nb="Slice",Ff="Sin",Mf="Sinh",Pf="Sign",Lf="Sigmoid",zf="Softplus",Bf="Sqrt",Wf="Sum",Tb="SpaceToBatchND",$b="SplitV",Vf="Softmax",rw="SparseFillEmptyRows",Eb="SparseReshape",sw="SparseSegmentMean",aw="SparseSegmentSum",_b="SparseToDense",Uf="SquaredDifference",iw="Square",ow="StaticRegexReplace",Ab="StridedSlice",lw="StringNGrams",uw="StringSplit",cw="StringToHashBucketFast",jf="Sub",Gf="Tan",Hf="Tanh",gd="Tile",Rb="TopK",Db="Transform",au="Transpose",dw="Unique",Ob="Unpack",hw="UnsortedSegmentSum",qHe="UpperBound",Fb="ZerosLike",yd="Step",YS="FromPixels",Mb="RotateWithOffset",Uh="_FusedMatMul",jh="FusedConv2D",Gh="FusedDepthwiseConv2D";function Zu(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.warn(...e)}function KHe(...e){xe().getBool("IS_TEST")||xe().getBool("PROD")||console.log(...e)}var zg=EM("kernelRegistry",()=>new Map),Y1=EM("gradRegistry",()=>new Map);function J1(e,t){let n=_M(e,t);return zg.get(n)}function QA(e){return Y1.get(e)}function JS(e){let t=zg.entries(),n=[];for(;;){let{done:r,value:s}=t.next();if(r)break;let[a,i]=s,[o]=a.split("_");o===e&&n.push(i)}return n}function pw(e){let{kernelName:t,backendName:n}=e,r=_M(t,n);zg.has(r)&&Zu(`The kernel '${t}' for backend '${n}' is already registered`),zg.set(r,e)}function hZ(e){let{kernelName:t}=e;Y1.has(t)&&xe().getBool("DEBUG")&&Zu(`Overriding the gradient for '${t}'`),Y1.set(t,e)}function XHe(e,t){let n=_M(e,t);if(!zg.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);zg.delete(n)}function YHe(e){if(!Y1.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Y1.delete(e)}function JHe(e,t){JS(e).forEach(n=>{let r=Object.assign({},n,{backendName:t});pw(r)})}function _M(e,t){return`${t}_${e}`}var M={};At(M,{arraysEqual:()=>$u,arraysEqualWithNull:()=>ZJ,assert:()=>J,assertNonNegativeIntegerDimensions:()=>ri,assertNonNull:()=>Np,assertShapesMatch:()=>aa,bytesFromStringArray:()=>rZ,bytesPerElement:()=>KS,checkConversionForErrors:()=>tZ,clamp:()=>X1,computeStrides:()=>Oy,convertBackendValuesAndArrayBuffer:()=>FHe,createScalarValue:()=>r8e,createShuffledIndices:()=>AHe,decodeString:()=>ZS,distSquared:()=>THe,encodeString:()=>mw,fetch:()=>a8e,fingerPrint64:()=>n8e,flatten:()=>Lc,getArrayFromDType:()=>NM,getTypedArrayFromDType:()=>eZ,hasEncodingLoss:()=>OHe,hexToLong:()=>fw,indexToLoc:()=>LHe,inferDtype:()=>Gx,inferFromImplicitShape:()=>DHe,isBoolean:()=>sZ,isFunction:()=>Pc,isInt:()=>Mg,isNumber:()=>aZ,isPromise:()=>jN,isScalarShape:()=>$He,isString:()=>ic,isTypedArray:()=>as,isValidDtype:()=>nZ,locToIndex:()=>PHe,makeOnesTypedArray:()=>TM,makeZerosNestedTypedArray:()=>MHe,makeZerosTypedArray:()=>UN,nearestDivisor:()=>XS,nearestLargerEven:()=>IHe,now:()=>Z1,parseAxisParam:()=>ao,randUniform:()=>NHe,repeatedTry:()=>RHe,rightPad:()=>l1,shuffle:()=>JJ,shuffleCombo:()=>SHe,sizeFromShape:()=>yn,sizeToSquarishShape:()=>_He,squeezeShape:()=>QJ,sum:()=>CHe,swap:()=>qS,tanh:()=>EHe,toNestedArray:()=>ng,toTypedArray:()=>sT});function pZ(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var Nj=pd(iHe()),qd=Nj.default||Nj;function fw(e){return qd.fromString(e,!0,16)}var fZ=fw("c3a5c85c97cb3127"),Wd=fw("b492b66fbe98f273"),Hs=fw("9ae16a3b2f90404f");function eR(e){return e.xor(e.shru(47))}function mZ(e,t,n){let r=e.slice(t,t+n);return qd.fromBytes(Array.from(r),!0,!0)}function On(e,t){return mZ(e,t,8)}function Tj(e,t){return mZ(e,t,4)}function ss(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Ic(e,t,n=fw("9ddfea08eb382d69")){let r=e.xor(t).mul(n);r=r.xor(r.shru(47));let s=t.xor(r).mul(n);return s=s.xor(s.shru(47)),s=s.mul(n),s}function ZHe(e,t,n,r,s,a){s=s.add(e),a=ss(a.add(s).add(r),21);let i=s;return s=s.add(t),s=s.add(n),a=a.add(ss(s,44)),[s.add(r),a.add(i)]}function Lk(e,t,n,r){return ZHe(On(e,t),On(e,t+8),On(e,t+16),On(e,t+24),n,r)}function QHe(e,t=e.length){if(t>=8){let n=Hs.add(t*2),r=On(e,0).add(Hs),s=On(e,t-8),a=ss(s,37).mul(n).add(r),i=ss(r,25).add(s).mul(n);return Ic(a,i,n)}if(t>=4){let n=Hs.add(t*2),r=Tj(e,0);return Ic(r.shl(3).add(t),Tj(e,t-4),n)}if(t>0){let n=e[0],r=e[t>>1],s=e[t-1],a=n+(r<<8),i=t+(s<<2);return eR(Hs.mul(a).xor(fZ.mul(i))).mul(Hs)}return Hs}function e8e(e,t=e.length){let n=Hs.add(t*2),r=On(e,0).mul(Wd),s=On(e,8),a=On(e,t-8).mul(n),i=On(e,t-16).mul(Hs);return Ic(ss(r.add(s),43).add(ss(a,30)).add(i),r.add(ss(s.add(Hs),18)).add(a),n)}function t8e(e,t=e.length){let n=Hs.add(t*2),r=On(e,0).mul(Hs),s=On(e,8),a=On(e,t-8).mul(n),i=On(e,t-16).mul(Hs),o=ss(r.add(s),43).add(ss(a,30)).add(i),l=Ic(o,r.add(ss(s.add(Hs),18)).add(a),n),u=On(e,16).mul(n),c=On(e,24),d=o.add(On(e,t-32)).mul(n),h=l.add(On(e,t-24)).mul(n);return Ic(ss(u.add(c),43).add(ss(d,30)).add(h),u.add(ss(c.add(r),18)).add(d),n)}function n8e(e,t=e.length){let n=qd.fromNumber(81,!0);if(t<=32)return t<=16?QHe(e,t):e8e(e,t);if(t<=64)return t8e(e,t);let r=n,s=n.mul(Wd).add(113),a=eR(s.mul(Hs).add(113)).mul(Hs),i=[qd.UZERO,qd.UZERO],o=[qd.UZERO,qd.UZERO];r=r.mul(Hs).add(On(e,0));let l=0,u=(t-1>>6)*64,c=u+(t-1&63)-63;do r=ss(r.add(s).add(i[0]).add(On(e,l+8)),37).mul(Wd),s=ss(s.add(i[1]).add(On(e,l+48)),42).mul(Wd),r=r.xor(o[1]),s=s.add(i[0]).add(On(e,l+40)),a=ss(a.add(o[0]),33).mul(Wd),i=Lk(e,l,i[1].mul(Wd),r.add(o[0])),o=Lk(e,l+32,a.add(o[1]),s.add(On(e,l+16))),[a,r]=[r,a],l+=64;while(l!==u);let d=Wd.add(a.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),i[0]=i[0].add(o[0]),o[0]=o[0].add(i[0]),r=ss(r.add(s).add(i[0]).add(On(e,l+8)),37).mul(d),s=ss(s.add(i[1]).add(On(e,l+48)),42).mul(d),r=r.xor(o[1].mul(9)),s=s.add(i[0].mul(9).add(On(e,l+40))),a=ss(a.add(o[0]),33).mul(d),i=Lk(e,l,i[1].mul(d),r.add(o[0])),o=Lk(e,l+32,a.add(o[1]),s.add(On(e,l+16))),[a,r]=[r,a],Ic(Ic(i[0],o[0],d).add(eR(s).mul(fZ)).add(a),Ic(i[1],o[1],d).add(r),d)}function r8e(e,t){return t==="string"?mw(e):sT([e],t)}function s8e(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function sT(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Lc(e)),xe().getBool("DEBUG")&&tZ(e,t),s8e(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){let n=new Uint8Array(e.length);for(let r=0;r<n.length;++r)Math.round(e[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${t}`)}function Z1(){return xe().platform.now()}function a8e(e,t){return xe().platform.fetch(e,t)}function mw(e,t="utf-8"){return t=t||"utf-8",xe().platform.encode(e,t)}function ZS(e,t="utf-8"){return t=t||"utf-8",xe().platform.decode(e,t)}function as(e){return xe().platform.isTypedArray!=null?xe().platform.isTypedArray(e):pZ(e)}function Lc(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||jN(e)||e==null||as(e)&&n)t.push(e);else if(Array.isArray(e)||as(e))for(let r=0;r<e.length;++r)Lc(e[r],t,n);else{let r=-1;for(let s of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Lc(e[s],t,n)}return t}var i8e=class{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new l8e)}profileKernel(e,t,n){let r,s=()=>{r=n()},a,i=Z1();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let o of r)o.dataSync();a=Promise.resolve({kernelMs:Z1()-i})}if(xe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<r.length;o++){let l=r[o];l.data().then(u=>{o8e(u,l.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:a.then(o=>o.kernelMs),extraInfo:a.then(o=>o.getExtraProfileInfo!=null?o.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:r,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),r,a]).then(o=>{this.logger.logKernelProfile(t,i,o[0],o[1],s,o[2])})})}};function o8e(e,t,n){if(t!=="float32")return!1;for(let r=0;r<e.length;r++){let s=e[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${n}'`),!0}return!1}var l8e=class{logKernelProfile(e,t,n,r,s,a){let i=typeof r=="number"?l1(`${r}ms`,9):r.error,o=l1(e,25),l=t.rank,u=t.size,c=l1(t.shape.toString(),14),d="";for(let h in s){let p=s[h];if(p!=null){let f=p.shape||t.shape,m=f.length;d+=`${h}: ${m}D ${m>0?f:""} `}}console.log(`%c${o}	%c${i}	%c${l}D ${c}	%c${u}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function u8e(e,t,n){let r={},s={};for(let l=0;l<t.length;l++)r[t[l].id]=!0;for(let l=0;l<e.length;l++){let u=e[l],c=u.inputs;for(let d in c){let h=c[d],p=!1;for(let f=0;f<t.length;f++)if(r[h.id]){u.outputs.forEach(m=>r[m.id]=!0),p=!0,s[u.id]=!0;break}if(p)break}}let a={};a[n.id]=!0;let i={};for(let l=e.length-1;l>=0;l--){let u=e[l],c=u.inputs;for(let d=0;d<u.outputs.length;d++)if(a[u.outputs[d].id]){for(let h in c)a[c[h].id]=!0,i[u.id]=!0;break}}let o=[];for(let l=0;l<e.length;l++){let u=e[l];if(s[u.id]&&i[u.id]){let c={};for(let h in u.inputs){let p=u.inputs[h];r[p.id]&&(c[h]=p)}let d=Object.assign({},u);d.inputs=c,d.outputs=u.outputs,o.push(d)}}return o}function c8e(e,t,n,r){for(let s=t.length-1;s>=0;s--){let a=t[s],i=[];if(a.outputs.forEach(l=>{let u=e[l.id];u!=null?i.push(u):i.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);let o=a.gradient(i);for(let l in a.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);let u=n(()=>o[l]());if(u.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${u.dtype}'`);let c=a.inputs[l];if(!$u(u.shape,c.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${l}' has shape '${u.shape}', which does not match the shape of the input '${c.shape}'`);if(e[c.id]==null)e[c.id]=u;else{let d=e[c.id];e[c.id]=r(d,u),d.dispose()}}}}var $j=20,kv=3,RE=7;function d8e(e,t,n,r){let s=Oy(t),a=h8e(e,t,n,s),i=t.length,o=w2(e,t,n,s,a),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${i}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map(u=>"    "+u).join(`
`)),l.join(`
`)}function h8e(e,t,n,r){let s=yn(t),a=r[r.length-1],i=new Array(a).fill(0),o=t.length,l=n==="complex64"?Bv(e):e;if(o>1)for(let u=0;u<s/a;u++){let c=u*a;for(let d=0;d<a;d++)i[d]=Math.max(i[d],zv(l[c+d],0,n).length)}return i}function zv(e,t,n){let r;return Array.isArray(e)?r=`${parseFloat(e[0].toFixed(RE))} + ${parseFloat(e[1].toFixed(RE))}j`:ic(e)?r=`'${e}'`:n==="bool"?r=gZ(e):r=parseFloat(e.toFixed(RE)).toString(),l1(r,t)}function gZ(e){return e===0?"false":"true"}function w2(e,t,n,r,s,a=!0){let i=n==="complex64"?2:1,o=t[0],l=t.length;if(l===0){if(n==="complex64"){let m=Bv(e);return[zv(m[0],0,n)]}return n==="bool"?[gZ(e[0])]:[e[0].toString()]}if(l===1){if(o>$j){let m=kv*i,g=Array.from(e.slice(0,m)),y=Array.from(e.slice((o-kv)*i,o*i));return n==="complex64"&&(g=Bv(g),y=Bv(y)),["["+g.map((b,x)=>zv(b,s[x],n)).join(", ")+", ..., "+y.map((b,x)=>zv(b,s[o-kv+x],n)).join(", ")+"]"]}return["["+(n==="complex64"?Bv(e):Array.from(e)).map((m,g)=>zv(m,s[g],n)).join(", ")+"]"]}let u=t.slice(1),c=r.slice(1),d=r[0]*i,h=[];if(o>$j){for(let m=0;m<kv;m++){let g=m*d,y=g+d;h.push(...w2(e.slice(g,y),u,n,c,s,!1))}h.push("...");for(let m=o-kv;m<o;m++){let g=m*d,y=g+d;h.push(...w2(e.slice(g,y),u,n,c,s,m===o-1))}}else for(let m=0;m<o;m++){let g=m*d,y=g+d;h.push(...w2(e.slice(g,y),u,n,c,s,m===o-1))}let p=l===2?",":"";h[0]="["+(o>0?h[0]+p:"");for(let m=1;m<h.length-1;m++)h[m]=" "+h[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(a?"":f),h}function Bv(e){let t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}var Er=class{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=yn(e),n!=null){let r=n.length;J(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||NM(t,this.size),this.strides=Oy(e)}set(e,...t){t.length===0&&(t=[0]),J(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let r of e){if(r<0||r>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Co().makeTensor(this.values,this.shape,this.dtype)}},Co=null,Sm=null;function p8e(e){Co=e}function f8e(e){Sm=e}var Bt=class{constructor(e,t,n,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=yn(e),this.strides=Oy(e),this.dataId=n,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Sm.buffer(this.shape,this.dtype,e)}bufferSync(){return Sm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return ng(this.shape,e,this.dtype==="complex64")}arraySync(){return ng(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Co().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>ZS(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Co().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Co().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>ZS(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Co().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Co().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Sm.print(this,e)}clone(){return this.throwIfDisposed(),Sm.clone(this)}toString(e=!1){let t=this.dataSync();return d8e(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Sm.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Co().makeVariable(this,e,t,n)}};Object.defineProperty(Bt,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function Fe(){return EM("Tensor",()=>Bt)}Fe();var Hh=class extends Bt{constructor(e,t,n,r){super(e.shape,e.dtype,e.dataId,r),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!$u(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Co().disposeTensor(this),this.dataId=e.dataId,Co().incRef(this,null)}dispose(){Co().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Hh,Symbol.hasInstance,{value:e=>e instanceof Bt&&e.assign!=null&&e.assign instanceof Function});var Do={};At(Do,{assertTypesMatch:()=>vZ,getTensorsInContainer:()=>AM,isTensorInList:()=>g8e,makeTypesMatch:()=>or});var tR;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(tR||(tR={}));var nR;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(nR||(nR={}));var rR;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(rR||(rR={}));var sR;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(sR||(sR={}));var aR;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(aR||(aR={}));var m8e={float32:sR,int32:nR,bool:rR,complex64:aR};function ki(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return m8e[e][t]}function aT(e){return ki(e,"int32")}function yZ(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function bZ(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function or(e,t){if(e.dtype===t.dtype)return[e,t];let n=ki(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function vZ(e,t){J(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function g8e(e,t){return t.some(n=>n.id===e.id)}function AM(e){let t=[];return xZ(e,t,new Set),t}function xZ(e,t,n){if(e==null)return;if(e instanceof Bt){t.push(e);return}if(!y8e(e))return;let r=e;for(let s in r){let a=r[s];n.has(a)||(n.add(a),xZ(a,t,n))}}function y8e(e){return Array.isArray(e)||typeof e=="object"}function DE(e){return e.kernelName!=null}var Ej=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},RM=class iR{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Ej}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,r=1){return t in this.registryFactory?(Zu(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:n,asyncInit:r}=this.initializeBackend(t);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new i8e(this.backendInstance),!0}setupRegisteredKernels(){JS(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){JS(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let r=n.factory();if(r&&!(r instanceof jx)&&typeof r.then=="function"){let s=++this.pendingBackendInitId,a=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[t]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,Zu(`Initialization of backend ${t} failed`),Zu(i.stack||i.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return Zu(`Initialization of backend ${t} failed`),Zu(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let n=0;n<t.length;n++){let r=t[n],{success:s,asyncInit:a}=this.initializeBackend(r);if(a||s)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){let r=this.state.tensorInfo.get(n),s=r.backend,a=this.readSync(n),i=s.refCount(n);s.disposeData(n,!0),r.backend=t,t.move(n,a,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let r=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=n(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,n,r){t();try{let s=r();return n(),s}catch(s){throw n(),s}}nextTensorId(){return iR.nextTensorId++}nextVariableId(){return iR.nextVariableId++}clone(t){let n=ne.runKernel(rf,{x:t}),r={x:t},s=i=>({x:()=>{let o="float32",l={x:i},u={dtype:o};return ne.runKernel(Pp,l,u)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[n],s,a,{}),n}runKernel(t,n,r){if(this.backendName==null&&this.backend,J1(t,this.backendName)==null)throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,r){let s=this.backend.numDataIds(),a=0;r.forEach(l=>{a+=l.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=s-n-a-i;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${t}'`)}runKernelFunc(t){let n,r=[],s=this.isTapeOn(),a=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l,u=DE(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(DE(t)){let{kernelName:f,inputs:m,attrs:g}=t;this.backendName==null&&this.backend;let y=J1(f,this.backendName);J(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{let b=this.backend.numDataIds();l=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});let x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,x);let v=x.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(s){let w=this.getTensorsForGradient(f,m,v);r=this.saveTensorsForBackwardMode(w)}return v}}else{let{forwardFunc:f}=t,m=g=>{s&&(r=g.map(y=>this.keep(this.clone(y))))};o=()=>{let g=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));let y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(u,g,y),y}}let{inputs:c,attrs:d}=t,h=DE(t)?null:t.backwardsFunc,p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=o():(p=this.profiler.profileKernel(u,c,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),n=p.outputs)}),s&&this.addTapeNode(u,c,n,h,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:u,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(c).map(f=>c[f]!=null?c[f].shape:null),outputShapes:n.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,n,r){let s=QA(t);if(s!=null){let a=s.inputsToSave||[],i=s.outputsToSave||[],o;s.saveAllInputs?(J(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(n).map(u=>n[u])):o=a.map(u=>n[u]);let l=r.filter((u,c)=>i[c]);return o.concat(l)}return[]}makeTensor(t,n,r,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let a=t;r==="string"&&ic(t[0])&&(a=t.map(l=>mw(l)));let i=s.write(a,n,r),o=new Bt(n,r,i,this.nextTensorId());if(this.trackTensor(o,s),r==="string"){let l=this.state.tensorInfo.get(i),u=rZ(a);this.state.numBytes+=u-l.bytes,l.bytes=u}return o}makeTensorFromDataId(t,n,r,s){r=r||"float32";let a={dataId:t,shape:n,dtype:r};return this.makeTensorFromTensorInfo(a,s)}makeTensorFromTensorInfo(t,n){let{dataId:r,shape:s,dtype:a}=t,i=new Bt(s,a,r,this.nextTensorId());return this.trackTensor(i,n),i}makeVariable(t,n=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let a=new Hh(t,n,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*KS(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Hh||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let r=t.size*KS(t.dtype);this.state.numBytes-=r}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,r,s,a,i){let o={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:r,saved:a},l=QA(t);l!=null&&(s=l.gradFunc),s!=null&&(o.gradient=u=>(u=u.map((c,d)=>{if(c==null){let h=r[d],p=UN(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return c}),s(u.length>1?u:u[0],a,i))),this.state.activeTape.push(o)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){let n=AM(t),r=new Set(n.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){let i=this.state.activeScope.track[a];!i.kept&&!r.has(i.id)&&i.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(a=>{!a.kept&&a.scopeId===s.id&&this.track(a)})}gradients(t,n,r,s=!1){if(J(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);let a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));J(a instanceof Bt,()=>"The result y returned by f() must be a tensor.");let i=u8e(this.state.activeTape,n,a);if(!s&&i.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let o={};o[a.id]=r??b8e(a.shape),c8e(o,i,u=>this.tidy(u),v8e);let l=n.map(u=>o[u.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(u=>{for(let c of u.saved)c.dispose()}),this.state.activeTape=null),{value:a,grads:l}})}customGrad(t){return J(Pc(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{J(n.every(o=>o instanceof Bt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r,s={};n.forEach((o,l)=>{s[l]=o});let a=(o,l)=>(r=t(...n,l),J(r.value instanceof Bt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),J(Pc(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(o,l)=>{let u=r.gradFunc(o,l),c=Array.isArray(u)?u:[u];J(c.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),J(c.every(h=>h instanceof Bt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let d={};return c.forEach((h,p)=>{d[p]=()=>h}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:i,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){let n=Z1(),r=await this.backend.time(t);return r.wallMs=Z1()-n,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Ej;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};RM.nextTensorId=0;RM.nextVariableId=0;function b8e(e){let t=TM(yn(e),"float32");return ne.makeTensor(t,e,"float32")}function wZ(){let e=lZ();if(e._tfengine==null){let t=new oZ(e);e._tfengine=new RM(t)}return VHe(e._tfengine.ENV),p8e(()=>e._tfengine),e._tfengine}var ne=wZ();function v8e(e,t){let n={a:e,b:t};return ne.runKernel(fd,n)}var gw={};At(gw,{isBrowser:()=>kZ,isMobile:()=>k8e,mockIsMobile:()=>w8e});function x8e(){return typeof navigator<"u"&&navigator!=null}var oR;function w8e(e){oR=e}function k8e(e){if(oR!==void 0)return oR;if(e||x8e()){if(e||(e=navigator),e.product==="ReactNative")return!0;let t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){let n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function kZ(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var wa=xe();wa.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});wa.registerFlag("IS_BROWSER",()=>kZ());wa.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");wa.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));wa.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));wa.registerFlag("PROD",()=>!1);wa.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>wa.getBool("DEBUG"));wa.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);wa.registerFlag("IS_TEST",()=>!1);wa.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>wa.getBool("DEBUG"));wa.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);wa.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);wa.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Ml(e,t){let n=e;if(as(e))return t==="string"?[]:[e.length];if(yZ(e)){let s=e.channels||"RGBA";return[e.height,e.width*s.length]}else if(bZ(e))return[e.buffer.size/(t==null?4:KS(t))];if(!Array.isArray(e))return[];let r=[];for(;Array.isArray(n)||as(n)&&t!=="string";)r.push(n.length),n=n[0];return Array.isArray(e)&&xe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&SZ(e,r,[]),r}function SZ(e,t,n){if(n=n||[],!Array.isArray(e)&&!as(e)){J(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}J(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),J(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);let r=t.slice(1);for(let s=0;s<e.length;++s)SZ(e[s],r,n.concat(s))}function _j(e,t,n,r){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${e} tensor, but got ${t} tensor`)}}function X(e,t,n,r="numeric"){if(e instanceof Fe())return _j(r,e.dtype,t,n),e;let s=Gx(e);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),_j(r,s,t,n),e==null||!as(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){let o=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${o}'`)}let a=Ml(e,s);!as(e)&&!Array.isArray(e)&&(e=[e]);let i=s!=="string"?sT(e,s):Lc(e,[],!0);return ne.makeTensor(i,a,s)}function Q1(e,t,n,r="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((s,a)=>X(s,`${t}[${a}]`,n,r))}var DM="__op";function se(e){let t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0],r=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+DM;let s=(...a)=>{ne.startScope(n);try{let i=r(...a);return jN(i)&&console.error("Cannot return a Promise inside of tidy."),ne.endScope(i),i}catch(i){throw ne.endScope(null),i}};return Object.defineProperty(s,"name",{value:n,configurable:!0}),s}function S8e(e,t){let n=X(e,"real","complex"),r=X(t,"imag","complex");aa(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);let s={real:n,imag:r};return ne.runKernel(GN,s)}var yu=se({complex_:S8e});function bd(e,t,n,r){if(r==null)r=Gx(e);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(bZ(e)||yZ(e)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return ne.backend.createTensorFromGPUData(e,t||n,r)}if(!as(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){ri(t);let s=yn(t),a=yn(n);J(s===a,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${a}`);for(let i=0;i<n.length;++i){let o=n[i],l=i===n.length-1?o!==yn(t.slice(i)):!0;J(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!as(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=r!=="string"?sT(e,r):Lc(e,[],!0),ne.makeTensor(e,t,r)}function Js(e,t,n){let r=Ml(e,n);return bd(e,t,r,n)}var qh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},Eu=class IZ{static join(t){return new IZ(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>as(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let r=0;r<t.length;r++){let s=t[r];r!==t.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);let a=n+s.byteLength;this.shards.push({buffer:s,start:n,end:a}),n=a}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);let r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);let s=n-t,a=new ArrayBuffer(s),i=new Uint8Array(a),o=0;for(let l=r;l<this.shards.length;l++){let u=this.shards[l],c=t+o-u.start,d=o,h=Math.min(n,u.end)-u.start,p=new Uint8Array(u.buffer,c,h-c);if(i.set(p,d),o+=p.length,n<u.end)break}return a}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(s){return t<s.start?-1:t>=s.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;let r=I8e(this.shards,n);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}};function I8e(e,t){let n=0,r=e.length;for(;n<=r;){let s=Math.floor((r-n)/2)+n,a=t(e[s]);if(a===0)return s;a<0?r=s:n=s+1}return-1}function C8e(){xe().set("PROD",!0)}function N8e(){xe().set("DEBUG",!0)}function T8e(){xe().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function CZ(e){xe().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function $8e(){ne.disposeVariables()}function Fi(){return ne}function QS(){return ne.memory()}function E8e(e){return ne.profile(e)}function ue(e,t){return ne.tidy(e,t)}function _t(e){AM(e).forEach(t=>t.dispose())}function Vr(e){return ne.keep(e)}function _8e(e){return ne.time(e)}function A8e(e){return ne.setBackend(e)}function R8e(){return ne.ready()}function NZ(){return ne.backendName}function D8e(e){ne.removeBackend(e)}function O8e(e){return ne.findBackend(e)}function F8e(e){return ne.findBackendFactory(e)}function iT(e,t,n=1){return ne.registerBackend(e,t,n)}function OM(){return ne.backend}function M8e(e,t){xe().setPlatform(e,t)}var zc=4;async function P8e(e,t){let n=[],r=[],s=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<s.length;++i){let o=s[i],l=Array.isArray(e)?e[i].tensor:e[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);let u={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){let c=new Promise(async d=>{let h=await l.bytes(),p=h.reduce((g,y)=>g+y.length,0)+zc*h.length,f=new Uint8Array(p),m=0;for(let g=0;g<h.length;g++){let y=h[g],b=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(b,m),m+=zc,f.set(y,m),m+=y.length}d(f)});r.push(c)}else r.push(l.data());t!=null&&(u.group=t),n.push(u)}let a=await Promise.all(r);return{data:B8e(a),specs:n}}function TZ(e,t){let n=new Eu(e),r={},s=0;for(let a of t){let i=L8e(a,(o,l)=>n.slice(s+o,s+l));r[a.name]=$Z(a,n.slice(s,s+i)),s+=i}return r}function L8e(e,t){let n=yn(e.shape),r;if("quantization"in e){let s=e.quantization;r=qh[s.dtype]}else if(e.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=zc+new Uint32Array(t(s,s+zc))[0];return s}else r=qh[e.dtype];return n*r}async function z8e(e,t){let n=yn(e.shape),r;if("quantization"in e){let s=e.quantization;r=qh[s.dtype]}else if(e.dtype==="string"){let s=0;for(let a=0;a<n;a++)s+=zc+new Uint32Array(await t(s,s+zc))[0];return s}else r=qh[e.dtype];return n*r}function $Z(e,t){let n=e.name,r=e.dtype,s=e.shape,a=yn(s),i,o=0;if("quantization"in e){let l=e.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error(`Weight ${e.name} with quantization ${l.dtype} doesn't have corresponding metadata min and scale.`)}else if(l.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${e.name} is quantized with ${l.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${l.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let u=qh[l.dtype],c=l.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){i=new Float32Array(c.length);for(let d=0;d<c.length;d++){let h=c[d];i[d]=h*l.scale+l.min}}else if(l.dtype==="float16")i=q8e()(c);else throw new Error(`Unsupported quantization type ${l.dtype} for weight type float32.`);else if(r==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error(`Unsupported quantization type ${l.dtype} for weight type int32.`);i=new Int32Array(c.length);for(let d=0;d<c.length;d++){let h=c[d];i[d]=Math.round(h*l.scale+l.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*u}else if(r==="string"){let l=yn(e.shape);i=[];for(let u=0;u<l;u++){let c=new Uint32Array(t.slice(o,o+zc))[0];o+=zc;let d=new Uint8Array(t.slice(o,o+c));i.push(d),o+=c}}else{let l=qh[r];if(r==="float32")i=new Float32Array(t);else if(r==="int32")i=new Int32Array(t);else if(r==="bool")i=new Uint8Array(t);else if(r==="complex64"){i=new Float32Array(t);let u=new Float32Array(i.length/2),c=new Float32Array(i.length/2);for(let f=0;f<u.length;f++)u[f]=i[f*2],c[f]=i[f*2+1];let d=Js(u,s,"float32"),h=Js(c,s,"float32"),p=yu(d,h);return d.dispose(),h.dispose(),p}else throw new Error(`Unsupported dtype in weight '${n}': ${r}`);o+=a*l}return Js(i,s,r)}async function Aj(e,t,n){let r=new Uint8Array(t);for(;r.byteLength<n;){let{done:s,value:a}=await e.read();if(s&&a==null){let o=n-r.byteLength;throw new Error(`Reader is done but ${o} bytes are still expected`)}let i=new Uint8Array(r.length+a.byteLength);i.set(r,0),i.set(new Uint8Array(a),r.length),r=i}return r.buffer}async function EZ(e,t){let n={},r=e.getReader(),s=new ArrayBuffer(0);for(let a of t){let i=await z8e(a,async(u,c)=>(s=await Aj(r,s,c),s.slice(u,c)));s=await Aj(r,s,i);let o=s.slice(0,i);s=s.slice(i);let l=$Z(a,o);if(n[a.name]=l,NZ()==="webgpu"){let u=OM();"uploadToGPU"in u&&yn(l.shape)>=xe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&u.uploadToGPU(l.dataId)}}return n}function B8e(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0,n=[];e.forEach(a=>{if(t+=a.byteLength,n.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});let r=new Uint8Array(t),s=0;return n.forEach(a=>{r.set(new Uint8Array(a.buffer),s),s+=a.byteLength}),r.buffer}var FM=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Rj(e){return FM?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function W8e(e){if(FM)return Buffer.from(e).toString("base64");let t=new Uint8Array(e),n="";for(let r=0,s=t.length;r<s;r++)n+=String.fromCharCode(t[r]);return btoa(n)}function V8e(e){if(FM){let r=Buffer.from(e,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}let t=atob(e),n=new Uint8Array(t.length);for(let r=0;r<t.length;++r)n.set([t.charCodeAt(r)],r);return n.buffer}function U8e(e){return Eu.join(e)}function Dj(e){let t="/";for(e=e.trim();e.endsWith(t);)e=e.slice(0,e.length-1);let n=e.split(t);return n[n.length-1]}function _Z(e,t){let n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function AZ(e,t,n){let r={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(r.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=n}return e.signature!=null&&(r.signature=e.signature),e.userDefinedMetadata!=null&&(r.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(r.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(r.initializerSignature=e.initializerSignature),r}async function MM(e,t){let n,r;return e.weightsManifest!=null&&([n,r]=await t(e.weightsManifest)),AZ(e,n,r)}function yw(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:Rj(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Rj(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new Eu(e.weightData).byteLength}}function lR(e){let t=[];for(let n of e)t.push(...n.weights);return t}function j8e(){let e=n=>{let r=n<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function G8e(){let e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function H8e(){let e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function q8e(){let e=j8e(),t=G8e(),n=H8e();return r=>{let s=new ArrayBuffer(4*r.length),a=new Uint32Array(s);for(let i=0;i<r.length;i++){let o=r[i],l=e[n[o>>10]+(o&1023)]+t[o>>10];a[i]=l}return new Float32Array(s)}}var Si=class go{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return go.instance==null&&(go.instance=new go),go.instance}static registerSaveRouter(t){go.getInstance().saveRouters.push(t)}static registerLoadRouter(t){go.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return go.getHandlers(t,"save")}static getLoadHandlers(t,n){return go.getHandlers(t,"load",n)}static getHandlers(t,n,r){let s=[];return(n==="load"?go.getInstance().loadRouters:go.getInstance().saveRouters).forEach(a=>{let i=a(t,r);i!==null&&s.push(i)}),s}},K8e=e=>Si.registerSaveRouter(e),X8e=e=>Si.registerLoadRouter(e),Y8e=e=>Si.getSaveHandlers(e),J8e=(e,t)=>Si.getLoadHandlers(e,t),uR="tensorflowjs",cR=1,ah="models_store",oc="model_info_store";function RZ(){if(!xe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function dR(e){let t=e.result;t.createObjectStore(ah,{keyPath:"modelPath"}),t.createObjectStore(oc,{keyPath:"modelPath"})}var Kh=class{constructor(e){if(this.indexedDB=RZ(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,r)=>{let s=this.indexedDB.open(uR,cR);s.onupgradeneeded=()=>dR(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(ah,"readonly"),o=i.objectStore(ah).get(this.modelPath);o.onsuccess=()=>{if(o.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(o.result.modelArtifacts)},o.onerror=l=>(a.close(),r(o.error)),i.oncomplete=()=>a.close()}else{t.weightData=Eu.join(t.weightData);let i=yw(t),o=a.transaction(oc,"readwrite"),l=o.objectStore(oc),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(d){return r(d)}let c;u.onsuccess=()=>{c=a.transaction(ah,"readwrite");let d=c.objectStore(ah),h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i})}catch(p){return r(p)}h.onsuccess=()=>n({modelArtifactsInfo:i}),h.onerror=p=>{l=o.objectStore(oc);let f=l.delete(this.modelPath);f.onsuccess=()=>(a.close(),r(h.error)),f.onerror=m=>(a.close(),r(h.error))}},u.onerror=d=>(a.close(),r(u.error)),o.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}}},s.onerror=a=>r(s.error)})}};Kh.URL_SCHEME="indexeddb://";var DZ=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Kh.URL_SCHEME)?Z8e(e.slice(Kh.URL_SCHEME.length)):null;Si.registerSaveRouter(DZ);Si.registerLoadRouter(DZ);function Z8e(e){return new Kh(e)}function Q8e(e){return e.startsWith(Kh.URL_SCHEME)?e.slice(Kh.URL_SCHEME.length):e}var eqe=class{constructor(){this.indexedDB=RZ()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(uR,cR);n.onupgradeneeded=()=>dR(n),n.onsuccess=()=>{let r=n.result,s=r.transaction(oc,"readonly"),a=s.objectStore(oc).getAll();a.onsuccess=()=>{let i={};for(let o of a.result)i[o.modelPath]=o.modelArtifactsInfo;e(i)},a.onerror=i=>(r.close(),t(a.error)),s.oncomplete=()=>r.close()},n.onerror=r=>t(n.error)})}async removeModel(e){return e=Q8e(e),new Promise((t,n)=>{let r=this.indexedDB.open(uR,cR);r.onupgradeneeded=()=>dR(r),r.onsuccess=()=>{let s=r.result,a=s.transaction(oc,"readwrite"),i=a.objectStore(oc),o=i.get(e),l;o.onsuccess=()=>{if(o.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let u=i.delete(e),c=()=>{l=s.transaction(ah,"readwrite");let d=l.objectStore(ah).delete(e);d.onsuccess=()=>t(o.result.modelArtifactsInfo),d.onerror=h=>n(o.error)};u.onsuccess=c,u.onerror=d=>(c(),s.close(),n(o.error))}},o.onerror=u=>(s.close(),n(o.error)),a.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},r.onerror=s=>n(r.error)})}},eu="/",Im="tensorflowjs_models",OZ="info",tqe="model_topology",nqe="weight_specs",rqe="weight_data",sqe="model_metadata";function FZ(e){return{info:[Im,e,OZ].join(eu),topology:[Im,e,tqe].join(eu),weightSpecs:[Im,e,nqe].join(eu),weightData:[Im,e,rqe].join(eu),modelMetadata:[Im,e,sqe].join(eu)}}function MZ(e){for(let t of Object.values(e))window.localStorage.removeItem(t)}function aqe(e){let t=e.split(eu);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(eu)}function iqe(e){return e.startsWith(Xh.URL_SCHEME)?e.slice(Xh.URL_SCHEME.length):e}var Xh=class{constructor(e){if(!xe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=FZ(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),r=yw(e),s=Eu.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,W8e(s));let a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw MZ(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=V8e(a),t}};Xh.URL_SCHEME="localstorage://";var PZ=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Xh.URL_SCHEME)?oqe(e.slice(Xh.URL_SCHEME.length)):null;Si.registerSaveRouter(PZ);Si.registerLoadRouter(PZ);function oqe(e){return new Xh(e)}var lqe=class{constructor(){J(xe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),J(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Im+eu,n=eu+OZ;for(let r=0;r<this.LS.length;++r){let s=this.LS.key(r);if(s.startsWith(t)&&s.endsWith(n)){let a=aqe(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=iqe(e);let t=FZ(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return MZ(t),n}},rg="://",Bc=class Vu{constructor(){this.managers={}}static getInstance(){return Vu.instance==null&&(Vu.instance=new Vu),Vu.instance}static registerManager(t,n){J(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(rg)&&(t=t.slice(0,t.indexOf(rg))),J(t.length>0,()=>"scheme must not be an empty string.");let r=Vu.getInstance();J(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=n}static getManager(t){let n=Vu.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(Vu.getInstance().managers)}};function k2(e){if(e.indexOf(rg)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Bc.getSchemes().join(",")}`);return{scheme:e.split(rg)[0],path:e.split(rg)[1]}}async function LZ(e,t,n=!1){J(e!==t,()=>`Old path and new path are the same: '${e}'`);let r=Si.getLoadHandlers(e);J(r.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),J(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${e}.`);let s=r[0],a=Si.getSaveHandlers(t);J(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),J(a.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);let i=a[0],o=k2(e).scheme,l=k2(e).path,u=o===k2(e).scheme,c=await s.load();n&&u&&await Bc.getManager(o).removeModel(l);let d=await i.save(c);return n&&!u&&await Bc.getManager(o).removeModel(l),d.modelArtifactsInfo}async function uqe(){let e=Bc.getSchemes(),t={};for(let n of e){let r=await Bc.getManager(n).listModels();for(let s in r){let a=n+rg+s;t[a]=r[s]}}return t}async function cqe(e){let t=k2(e);return Bc.getManager(t.scheme).removeModel(t.path)}async function dqe(e,t){return LZ(e,t,!1)}async function hqe(e,t){return LZ(e,t,!0)}var pqe=class{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!xe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let r=this.functionRefs[n.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return pZ(e)}};if(xe().get("IS_BROWSER")){xe().setPlatform("browser",new pqe);try{Bc.registerManager(Xh.URL_SCHEME,new lqe)}catch{}try{Bc.registerManager(Kh.URL_SCHEME,new eqe)}catch{}}var fqe={importFetch:()=>oHe()},OE,mqe=class{constructor(){this.util=lHe(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return xe().global.fetch!=null?xe().global.fetch(e,t):(OE==null&&(OE=fqe.importFetch()),OE(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}};xe().get("IS_NODE")&&!xe().get("IS_BROWSER")&&xe().setPlatform("node",new mqe);function zt(e,t="float32",n){return t=t||"float32",ri(e),new Er(e,t,n)}function gqe(e,t){let n=X(e,"x","cast");if(!nZ(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");let r={x:n},s={dtype:t};return ne.runKernel(Pp,r,s)}var je=se({cast_:gqe});function yqe(e){let t={x:X(e,"x","clone","string_or_numeric")};return ne.runKernel(rf,t)}var Nl=se({clone_:yqe});function PM(e,t=!1){console.log(e.toString(t))}wZ();var bqe={buffer:zt,cast:je,clone:Nl,print:PM};f8e(bqe);function vqe(e,t){let n=X(e,"a","add"),r=X(t,"b","add");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(fd,s)}var De=se({add_:vqe});function xqe(e,t){let n=X(e,"a","floorDiv"),r=X(t,"b","floorDiv");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(Qp,s)}var oT=se({floorDiv_:xqe});function wqe(e,t){let n=X(e,"a","div"),r=X(t,"b","div");if([n,r]=or(n,r),n.dtype==="int32"&&r.dtype==="int32")return oT(n,r);let s={a:n,b:r},a={};return ne.runKernel(qp,s,a)}var ot=se({div_:wqe});function kqe(e,t){let n=X(e,"a","mul"),r=X(t,"b","mul");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(xf,s)}var oe=se({mul_:kqe});function Sqe(e){let t=X(e,"x","abs");if(t.dtype==="complex64"){let n={x:t};return ne.runKernel(Xx,n)}else{let n={x:t};return ne.runKernel(Fy,n)}}var Ir=se({abs_:Sqe});function Iqe(e){let t={x:X(e,"x","acos")};return ne.runKernel(Tp,t)}var LM=se({acos_:Iqe});function Cqe(e){let t={x:X(e,"x","acosh")};return ne.runKernel($p,t)}var zM=se({acosh_:Cqe});function Nqe(e){J(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors"),J(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);let t=e.map((s,a)=>X(s,`tensors${a}`,"addN")),n=t[0];t.forEach(s=>{if(s.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(s=>{if(!$u(s.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let r=t;return ne.runKernel(Ep,r)}var zZ=se({addN_:Nqe});function Tqe(e,t=null,n=!1){let r={x:X(e,"x","all","bool")},s={axis:t,keepDims:n};return ne.runKernel(My,r,s)}var lT=se({all_:Tqe});function $qe(e,t=null,n=!1){let r={x:X(e,"x","any","bool")},s={axis:t,keepDims:n};return ne.runKernel(Py,r,s)}var e0=se({any_:$qe});function Eqe(e,t=0){let n={x:X(e,"x","argMax")},r={axis:t};return ne.runKernel(Ly,n,r)}var Yh=se({argMax_:Eqe});function _qe(e,t=0){let n={x:X(e,"x","argMin")},r={axis:t};return ne.runKernel(zy,n,r)}var BM=se({argMin_:_qe});function Aqe(e){let t={x:X(e,"x","asin")};return ne.runKernel(_p,t)}var WM=se({asin_:Aqe});function Rqe(e){let t={x:X(e,"x","asinh")};return ne.runKernel(Ap,t)}var VM=se({asinh_:Rqe});function Dqe(e){let t={x:X(e,"x","atan")};return ne.runKernel(Rp,t)}var UM=se({atan_:Dqe});function Oqe(e,t){let n=X(e,"a","atan2"),r=X(t,"b","atan2");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(Op,s)}var jM=se({atan2_:Oqe});function Fqe(e){let t={x:X(e,"x","atanh")};return ne.runKernel(Dp,t)}var GM=se({atanh_:Fqe});function Mqe(e,t,n,r,s="NHWC",a){let i=e[3],o=[...t,i],l=VZ(s);return bw(e,o,n,a,r,null,null,l)}function BZ(e,t,n,r,s,a,i="channelsLast"){let[o,l]=t0(t),u;if(i==="channelsLast")u=[o,l,e[3],e[3]];else if(i==="channelsFirst")u=[o,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return bw(e,u,n,r,s,a,!1,i)}function Pqe(e,t,n,r,s,a,i="NDHWC"){let[o,l,u]=hR(t),c,d;if(i==="NDHWC")d="channelsLast",c=[o,l,u,e[4],e[4]];else if(i==="NCDHW")d="channelsFirst",c=[o,l,u,e[1],e[1]];else throw new Error(`Unknown dataFormat ${i}`);return WZ(e,c,n,r,s,!1,d,a)}function bw(e,t,n,r,s,a,i=!1,o="channelsLast"){let[l,u,c,d]=[-1,-1,-1,-1];if(o==="channelsLast")[l,u,c,d]=e;else if(o==="channelsFirst")[l,d,u,c]=e;else throw new Error(`Unknown dataFormat ${o}`);let[h,p,,f]=t,[m,g]=t0(n),[y,b]=t0(r),x=sg(h,y),v=sg(p,b),{padInfo:w,outHeight:k,outWidth:S}=Bqe(s,u,c,m,g,x,v,a,o),I=i?f*d:f,$;return o==="channelsFirst"?$=[l,I,k,S]:o==="channelsLast"&&($=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:d,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:h,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:y,dilationWidth:b,inShape:e,outShape:$,filterShape:t}}function WZ(e,t,n,r,s,a=!1,i="channelsLast",o){let[l,u,c,d,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[l,u,c,d,h]=e;else if(i==="channelsFirst")[l,h,u,c,d]=e;else throw new Error(`Unknown dataFormat ${i}`);let[p,f,m,,g]=t,[y,b,x]=hR(n),[v,w,k]=hR(r),S=sg(p,v),I=sg(f,w),$=sg(m,k),{padInfo:C,outDepth:T,outHeight:N,outWidth:E}=Wqe(s,u,c,d,y,b,x,S,I,$,o),_=a?g*h:g,R;return i==="channelsFirst"?R=[l,_,T,N,E]:i==="channelsLast"&&(R=[l,T,N,E,_]),{batchSize:l,dataFormat:i,inDepth:u,inHeight:c,inWidth:d,inChannels:h,outDepth:T,outHeight:N,outWidth:E,outChannels:_,padInfo:C,strideDepth:y,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:$,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:R,filterShape:t}}function Lqe(e,t,n,r,s){r==null&&(r=HM(e,t,n));let a=e[0],i=e[1],o=n0((a-t+2*r)/n+1,s),l=n0((i-t+2*r)/n+1,s);return[o,l]}function zqe(e,t,n,r,s,a){s==null&&(s=HM(e,t[0],r[0]));let i=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*s>=t[o]&&(i[o]=n0((e[o]-t[o]+2*s)/r[o]+1,a));return i}function HM(e,t,n,r=1){let s=sg(t,r);return Math.floor((e[0]*(n-1)-n+s)/2)}function t0(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function hR(e){return typeof e=="number"?[e,e,e]:e}function sg(e,t){return t<=1?e:e+(e-1)*(t-1)}function Bqe(e,t,n,r,s,a,i,o,l){let u,c,d;if(typeof e=="number"){u={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};let h=Lqe([t,n],a,r,e,o);c=h[0],d=h[1]}else if(e==="same"){c=Math.ceil(t/r),d=Math.ceil(n/s);let h=Math.max(0,(c-1)*r+a-t),p=Math.max(0,(d-1)*s+i-n),f=Math.floor(h/2),m=h-f,g=Math.floor(p/2),y=p-g;u={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(e==="valid")u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-a+1)/r),d=Math.ceil((n-i+1)/s);else if(typeof e=="object"){let h=l==="channelsLast"?e[1][0]:e[2][0],p=l==="channelsLast"?e[1][1]:e[2][1],f=l==="channelsLast"?e[2][0]:e[3][0],m=l==="channelsLast"?e[2][1]:e[3][1];u={top:h,bottom:p,left:f,right:m,type:h===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},c=n0((t-a+h+p)/r+1,o),d=n0((n-i+f+m)/s+1,o)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outHeight:c,outWidth:d}}function Wqe(e,t,n,r,s,a,i,o,l,u,c){let d,h,p,f;if(e==="valid"&&(e=0),typeof e=="number"){d={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};let m=zqe([t,n,r,1],[o,l,u],1,[s,a,i],e,c);h=m[0],p=m[1],f=m[2]}else if(e==="same"){h=Math.ceil(t/s),p=Math.ceil(n/a),f=Math.ceil(r/i);let m=(h-1)*s+o-t,g=(p-1)*a+l-n,y=(f-1)*i+u-r,b=Math.floor(m/2),x=m-b,v=Math.floor(g/2),w=g-v,k=Math.floor(y/2),S=y-k;d={top:v,bottom:w,left:k,right:S,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:d,outDepth:h,outHeight:p,outWidth:f}}function n0(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Wc(e){let[t,n,r]=t0(e);return t===1&&n===1&&r===1}function Bl(e,t){return Wc(e)||Wc(t)}function Jh(e){return t0(e).every(t=>t>0)}function VZ(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function ia(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")J(Mg(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(s=>{J(Mg(s),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${s}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function Vqe(e,t){let n={x:X(e,"x","reshape","string_or_numeric")},r={shape:t};return ne.runKernel(vb,n,r)}var le=se({reshape_:Vqe});function Uqe(e,t,n,r,s){let a=X(e,"x","avgPool","float32"),i=1;J(Bl(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let o=a,l=!1;a.rank===3&&(l=!0,o=le(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ia("avgPool",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=ne.runKernel(Fp,u,c);return d=je(d,a.dtype),l?le(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var _u=se({avgPool_:Uqe});function jqe(e,t,n,r,s,a="NDHWC"){let i=X(e,"x","avgPool3d","float32"),o=i,l=!1;i.rank===4&&(l=!0,o=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),J(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),J(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),J(typeof n=="number"&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`),ia("avgPool3d",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=ne.runKernel(By,u,c);return d=je(d,o.dtype),l?le(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var qM=se({avgPool3d_:jqe});function Gqe(e,t=0){J(e.length>=1,()=>"Pass at least one tensor to concat");let n=Q1(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),n.length===1)return Nl(n[0]);let r=n,s={axis:t};return ne.runKernel(jy,r,s)}var In=se({concat_:Gqe});function Hqe(e,t,n=!1,r=!1){let s=X(e,"a","matMul"),a=X(t,"b","matMul");[s,a]=or(s,a);let i={a:s,b:a},o={transposeA:n,transposeB:r};return ne.runKernel(Mp,i,o)}var Mt=se({matMul_:Hqe});function qqe(e){let t={x:X(e,"x","sigmoid","float32")};return ne.runKernel(Lf,t)}var qi=se({sigmoid_:qqe});function Kqe(e,t,n){let r=X(e,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");let s={x:r},a={begin:t,size:n};return ne.runKernel(Nb,s,a)}var Kt=se({slice_:Kqe});function Xqe(e){let t={x:X(e,"x","tanh","float32")};return ne.runKernel(Hf,t)}var Zh=se({tanh_:Xqe});function Yqe(e,t,n,r,s,a){let i=X(e,"forgetBias","basicLSTMCell"),o=X(t,"lstmKernel","basicLSTMCell"),l=X(n,"lstmBias","basicLSTMCell"),u=X(r,"data","basicLSTMCell"),c=X(s,"c","basicLSTMCell"),d=X(a,"h","basicLSTMCell"),h=In([u,d],1),p=Mt(h,o),f=De(p,l),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=Kt(f,[0,0],y),x=Kt(f,[0,g],y),v=Kt(f,[0,g*2],y),w=Kt(f,[0,g*3],y),k=De(oe(qi(b),Zh(x)),oe(c,qi(De(i,v)))),S=oe(Zh(k),qi(w));return[k,S]}var UZ=se({basicLSTMCell_:Yqe});function Jqe(e,t,n){let r=X(e,"x","batchToSpaceND"),s=t.reduce((o,l)=>o*l);J(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),J(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`),J(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let a={x:r},i={blockShape:t,crops:n};return ne.runKernel(Wy,a,i)}var vw=se({batchToSpaceND_:Jqe});function Zqe(e){let t;return e.rank===0||e.rank===1?t=le(e,[1,1,1,e.size]):e.rank===2?t=le(e,[1,1,e.shape[0],e.shape[1]]):e.rank===3?t=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]):t=e,t}function Qqe(e,t,n,r,s,a){a==null&&(a=.001);let i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm"),u;s!=null&&(u=X(s,"scale","batchNorm"));let c;r!=null&&(c=X(r,"offset","batchNorm")),J(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),J(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),J(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:Zqe(i),scale:u,offset:c,mean:o,variance:l},h={varianceEpsilon:a},p=ne.runKernel(ef,d,h);return le(p,i.shape)}var qf=se({batchNorm_:Qqe});function e9e(e,t,n,r,s,a){let i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm"),u;s!=null&&(u=X(s,"scale","batchNorm"));let c;return r!=null&&(c=X(r,"offset","batchNorm")),J(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),J(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),J(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`),qf(i,o,l,c,u,a)}var KM=se({batchNorm2d_:e9e});function t9e(e,t,n,r,s,a){let i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm"),u;s!=null&&(u=X(s,"scale","batchNorm"));let c;return r!=null&&(c=X(r,"offset","batchNorm")),J(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),J(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),J(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`),qf(i,o,l,c,u,a)}var XM=se({batchNorm3d_:t9e});function n9e(e,t,n,r,s,a){let i=X(e,"x","batchNorm"),o=X(t,"mean","batchNorm"),l=X(n,"variance","batchNorm"),u;s!=null&&(u=X(s,"scale","batchNorm"));let c;return r!=null&&(c=X(r,"offset","batchNorm")),J(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),J(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),J(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&J(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`),c!=null&&J(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`),qf(i,o,l,c,u,a)}var YM=se({batchNorm4d_:n9e});function r9e(e,t,n){let r=X(e,"x","bincount"),s=X(t,"weights","bincount");J(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),J(n>=0,()=>`size must be non-negative, but got ${n}.`),J(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);let a={x:r,weights:s},i={size:n};return ne.runKernel(Vy,a,i)}var JM=se({bincount_:r9e});function s9e(e,t){let n=X(e,"x","bitwiseAnd"),r=X(t,"y","bitwiseAnd");if(!$u(n.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${n.shape}, y: ${r.shape}`);if(n.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${n.dtype} and type of y: ${r.dtype}`);let s={a:n,b:r};return ne.runKernel(Uy,s)}var jZ=se({bitwiseAnd_:s9e});function a9e(e,t){let n=X(e,"s0","broadcastArgs","int32"),r=X(t,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);let s={s0:n,s1:r};return ne.runKernel(Kx,s)}var GZ=se({broadcastArgs_:a9e});function i9e(e,t){let n=X(e,"broadcastTo","x"),r=n.shape;if(ri(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){let l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=le(n,l)}let s=n.shape,a=Array.from(t);for(let l=t.length-1;l>=0;l--)if(s[l]===t[l])a[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(a.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return Nl(n);let i={x:n},o={reps:a};return ne.runKernel(gd,i,o)}var gh=se({broadcastTo_:i9e});function o9e(e){let t={x:X(e,"x","ceil","float32")};return ne.runKernel(Lp,t)}var ZM=se({ceil_:o9e});function Ka(e,t,n){ri(e),n=n||Gx(t);let r={shape:e,value:t,dtype:n};return ne.runKernel(Zx,{},r)}function l9e(e,t,n){let r=X(e,"x","clipByValue");if(J(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`),t===n)return Ka(r.shape,t,r.dtype);let s={x:r},a={clipValueMin:t,clipValueMax:n};return ne.runKernel(md,s,a)}var Fs=se({clipByValue_:l9e});function u9e(e){return In(e,0)}var QM=se({concat1d_:u9e});function c9e(e,t){return In(e,t)}var eP=se({concat2d_:c9e});function d9e(e,t){return In(e,t)}var tP=se({concat3d_:d9e});function h9e(e,t){return In(e,t)}var nP=se({concat4d_:h9e});function p9e(e,t,n,r,s="NHWC",a=[1,1],i){let o=X(e,"x","conv2d","float32"),l=X(t,"filter","conv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(u.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`),J(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ia("conv2d",r,i);let d=s==="NHWC"?u.shape[3]:u.shape[1];J(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),J(Bl(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),J(Jh(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),J(Jh(n),()=>"Error in conv2D: Strides should be larger than 0.");let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ne.runKernel(zp,h,p);return c?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var ta=se({conv2d_:p9e});function f9e(e,t,n,r,s="NWC",a=1,i){let o=X(e,"x","conv1d"),l=X(t,"filter","conv1d"),u=o,c=!1;o.rank===2&&(c=!0,u=le(o,[1,o.shape[0],o.shape[1]])),J(u.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`),J(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ia("conv1d",r,i),J(u.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`),J(Bl(n,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${a}'`),J(Jh(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),J(Jh(n),()=>"Error in conv1D: Stride should be larger than 0."),J(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let d=le(l,[1,l.shape[0],l.shape[1],l.shape[2]]),h=le(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=ta(h,d,[1,n],r,"NHWC",[1,a],i);return c?le(p,[p.shape[2],p.shape[3]]):le(p,[p.shape[0],p.shape[2],p.shape[3]])}var uT=se({conv1d_:f9e});function m9e(e,t,n,r,s,a="NHWC",i){J(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e,l=t,u=!1;t.rank===3&&(u=!0,l=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),J(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),J(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),J(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);let c=a==="NHWC"?o[3]:o[1],d=a==="NHWC"?l.shape[3]:l.shape[1];J(c===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`),J(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),ia("conv2dDerInput",s,i);let h={dy:l,filter:n},p={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,inputShape:o},f=ne.runKernel(Bp,h,p);return u?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var rP=se({conv2DBackpropInput_:m9e});function g9e(e,t,n,r,s,a){let i=X(e,"x","conv2dTranspose"),o=X(t,"filter","conv2dTranspose");return rP(n,i,o,r,s,"NHWC",a)}var cT=se({conv2dTranspose_:g9e});function y9e(e,t,n,r,s="NDHWC",a=[1,1,1]){let i=X(e,"x","conv3d"),o=X(t,"filter","conv3d"),l=i,u=!1;i.rank===4&&(u=!0,l=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),J(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),J(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),J(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),J(Bl(n,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),J(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),J(Jh(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),J(Jh(n),()=>"Error in conv3D: Strides should be larger than 0.");let c={x:l,filter:o},d={strides:n,pad:r,dataFormat:s,dilations:a},h=ne.runKernel(Wp,c,d);return u?le(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var sP=se({conv3d_:y9e});function b9e(e,t,n,r,s){J(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e,i=t,o=!1;t.rank===4&&(o=!0,i=le(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),a=[1,e[0],e[1],e[2],e[3]]);let l=a[4],u=i.shape[4];J(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),J(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),J(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),J(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),J(u===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`);let c={dy:i,filter:n},d={pad:s,strides:r,inputShape:a},h=ne.runKernel(Hy,c,d);return o?le(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}var HZ=se({conv3DBackpropInput_:b9e});function v9e(e,t,n,r,s){let a=X(e,"x","conv3dTranspose"),i=X(t,"filter","conv3dTranspose");return HZ(n,a,i,r,s)}var aP=se({conv3dTranspose_:v9e});function x9e(e){let t={x:X(e,"x","cos","float32")};return ne.runKernel(Vp,t)}var xw=se({cos_:x9e});function w9e(e){let t={x:X(e,"x","cosh","float32")};return ne.runKernel(Up,t)}var dT=se({cosh_:w9e});function k9e(e,t=0,n=!1,r=!1){let s={x:X(e,"x","cumprod")},a={axis:t,exclusive:n,reverse:r};return ne.runKernel(qy,s,a)}var r0=se({cumprod_:k9e});function S9e(e,t=0,n=!1,r=!1){let s={x:X(e,"x","cumsum")},a={axis:t,exclusive:n,reverse:r};return ne.runKernel(jp,s,a)}var hT=se({cumsum_:S9e});function I9e(e,t,n,r=!1){let s=X(e,"x","denseBincount"),a=X(t,"weights","denseBincount");J(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),J(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),J(n>=0,()=>`size must be non-negative, but got ${n}.`),J(a.size===s.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${a.shape}.`);let i={x:s,weights:a},o={size:n,binaryOutput:r};return ne.runKernel(Yx,i,o)}var eI=se({denseBincount_:I9e});function C9e(e,t,n="NHWC"){let r=X(e,"x","depthToSpace","float32"),s=n==="NHWC"?r.shape[1]:r.shape[2],a=n==="NHWC"?r.shape[2]:r.shape[3],i=n==="NHWC"?r.shape[3]:r.shape[1];J(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),J(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${r.shape}`),J(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t} for depthToSpace with input shape
        ${r.shape}`),J(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${r.shape}`);let o={x:r},l={blockSize:t,dataFormat:n};return ne.runKernel(Xy,o,l)}var iP=se({depthToSpace_:C9e});function N9e(e,t,n,r,s="NHWC",a=[1,1],i){let o=X(e,"x","depthwiseConv2d","float32"),l=X(t,"filter","depthwiseConv2d","float32"),u=o,c=!1;o.rank===3&&(c=!0,u=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(u.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`),J(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);let d=s==="NHWC"?u.shape[3]:u.shape[1];J(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),ia("depthwiseConv2d",r,i);let h={x:u,filter:l},p={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i},f=ne.runKernel(Gp,h,p);return c?le(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Kf=se({depthwiseConv2d_:N9e});function T9e(e){let t={x:X(e,"x","diag")};return ne.runKernel(Jx,t)}var qZ=se({diag_:T9e});function $9e(e,t,n,r,s=[1,1],a="NHWC"){let i=X(e,"x","dilation2d"),o=X(t,"filter","dilation2d");J(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),J(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),J(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let l=i,u=!1;i.rank===3&&(l=le(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=!0),J(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);let c={x:l,filter:o},d={strides:n,pad:r,dilations:s},h=ne.runKernel(Hp,c,d);return u?le(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var oP=se({dilation2d_:$9e}),Pb={};At(Pb,{assertAndGetBroadcastShape:()=>Nn,getBroadcastDims:()=>KZ,getReductionAxes:()=>Rr});function KZ(e,t){let n=e.length,r=[];for(let s=0;s<n;s++){let a=n-1-s,i=e[a]||1;(t[t.length-1-s]||1)>1&&i===1&&r.unshift(a)}return r}function Rr(e,t){let n=[];for(let r=0;r<t.length;r++){let s=e[e.length-r-1],a=t.length-r-1,i=t[a];(s==null||s===1&&i>1)&&n.unshift(a)}return n}function Nn(e,t){let n=Math.max(e.length,t.length),r=new Array(n);for(let s=0;s<n;s++){let a=e[e.length-s-1];a==null&&(a=1);let i=t[t.length-s-1];if(i==null&&(i=1),a===1)r[n-s-1]=i;else if(i===1)r[n-s-1]=a;else if(a!==i){let o=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(o)}else r[n-s-1]=a}return r}function E9e(e,t){let n=X(e,"a","equal","string_or_numeric"),r=X(t,"b","equal","string_or_numeric");[n,r]=or(n,r),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(Jy,s)}var Za=se({equal_:E9e});function _9e(e,t,n){let r=X(t,"a","where"),s=X(n,"b","where"),a=X(e,"condition","where","bool"),i=Nn(Nn(a.shape,r.shape),s.shape),o=gh(a,i),l=gh(r,i),u=gh(s,i),c={condition:o,t:l,e:u};return ne.runKernel(Cb,c)}var ds=se({where_:_9e});function A9e(e){let t={x:X(e,"x","zerosLike")};return ne.runKernel(Fb,t)}var Xt=se({zerosLike_:A9e});function R9e(e,t){let n=X(e,"a","div"),r=X(t,"b","div");[n,r]=or(n,r);let s=ot(n,r),a=Xt(s),i=Za(r,a);return ds(i,a,s)}var lP=se({divNoNan_:R9e});function D9e(e,t){let n=X(e,"t1","dot"),r=X(t,"t2","dot");J((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);let s=n.rank===1?n.size:n.shape[1],a=r.rank===1?r.size:r.shape[0];if(J(s===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${a}.`),n.rank===1&&r.rank===1){let i=le(n,[1,-1]),o=le(r,[-1,1]),l=Mt(i,o);return le(l,[])}else if(n.rank===1&&r.rank===2){let i=le(n,[1,-1]),o=le(r,[r.shape[0],r.shape[1]]),l=Mt(i,o);return le(l,[l.size])}else if(n.rank===2&&r.rank===1){let i=le(r,[-1,1]),o=Mt(n,i);return le(o,[o.size])}else{let i=le(r,[r.shape[0],r.shape[1]]);return Mt(n,i)}}var uP=se({dot_:D9e});function O9e(e,...t){let n=t.map((s,a)=>X(s,`tensors${a}`,"einsum")),r={equation:e};return ne.runKernel(YN,n,r)}var Kd=se({einsum_:O9e});function F9e(e){let t={x:X(e,"x","elu","float32")};return ne.runKernel(Kp,t)}var Lb=se({elu_:F9e});function M9e(e,t){let n=X(e,"x","ensureShape","string_or_numeric");if(!ZJ(n.shape,t))throw new Error(`EnsureShape: Shape of tensor ${n.shape} is not compatible with expected shape ${t}`);return e}var XZ=se({ensureShape_:M9e});function P9e(e){let t=X(e,"x","erf");J(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=je(t,"float32"));let n={x:t};return ne.runKernel(Xp,n)}var cP=se({erf_:P9e});function dP(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function YZ(e,t,n){let r=e.length+t.length,s=[],a=0,i=0;for(let o=0;o<r;o++)n.indexOf(o)===-1?s.push(e[a++]):s.push(t[i++]);return s}function JZ(e,t){let n=[],r=e.length;for(let a=0;a<r;a++)t.indexOf(a)===-1&&n.push(e[a]);let s=t.map(a=>e[a]);return[n,s]}function Qh(e,t){let n=t.map(r=>1);return YZ(e,n,t)}function L9e(e,t,n){J(dP(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function ZZ(e,t){if(dP(e,t))return null;let n=[];for(let r=0;r<t;++r)e.indexOf(r)===-1&&n.push(r);return e.forEach(r=>n.push(r)),n}function hP(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function z9e(e,t){let n=[];for(let r=t-e;r<t;++r)n.push(r);return n}function B9e(e,t=null,n=!1){let r={x:X(e,"x","max")},s={reductionIndices:t,keepDims:n};return ne.runKernel(hf,r,s)}var vi=se({max_:B9e});function W9e(e,t=null,n=!1){let r={x:X(e,"x","min")},s={axis:t,keepDims:n};return ne.runKernel(gf,r,s)}var Bg=se({min_:W9e});function V9e(e,t){let n=X(e,"base","pow"),r=X(t,"exp","pow");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(Sf,s)}var bu=se({pow_:V9e});function bt(e,t){if((as(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&as(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return bd(e,[],[],t)}function U9e(e){let t={x:X(e,"x","sqrt","float32")};return ne.runKernel(Bf,t)}var Is=se({sqrt_:U9e});function j9e(e){let t=X(e,"x","square"),n={};return ne.runKernel("Square",{x:t},n)}var kn=se({square_:j9e});function G9e(e,t=null,n=!1){let r=X(e,"x","sum");r.dtype==="bool"&&(r=je(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return ne.runKernel(Wf,s,a)}var ct=se({sum_:G9e});function H9e(e,t="euclidean",n=null,r=!1){e=X(e,"x","norm");let s=QZ(e,t,n),a=s.shape;if(r){let i=ao(n,e.shape);a=Qh(s.shape,i)}return le(s,a)}function QZ(e,t,n=null){if(e.rank===0)return Ir(e);if(e.rank!==1&&n===null)return QZ(le(e,[-1]),t,n);if(e.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(t===1)return ct(Ir(e),n);if(t===1/0)return vi(Ir(e),n);if(t===-1/0)return Bg(Ir(e),n);if(t==="euclidean"||t===2)return Is(ct(bu(Ir(e),bt(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1)return vi(ct(Ir(e),n[0]),n[1]-1);if(t===1/0)return vi(ct(Ir(e),n[1]),n[0]);if(t===-1/0)return Bg(ct(Ir(e),n[1]),n[0]);if(t==="fro"||t==="euclidean")return Is(ct(kn(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}var zb=se({norm_:H9e});function q9e(e,t=null,n=!1){return zb(e,"euclidean",t,n)}var pP=se({euclideanNorm_:q9e});function K9e(e){let t={x:X(e,"x","exp")};return ne.runKernel(Yp,t)}var Ms=se({exp_:K9e});function X9e(e,t=0){let n=X(e,"x","expandDims","string_or_numeric");J(t<=n.rank,()=>"Axis must be <= rank of the tensor");let r={input:n},s={dim:t};return ne.runKernel(Zy,r,s)}var is=se({expandDims_:X9e});function Y9e(e){let t={x:X(e,"x","expm1")};return ne.runKernel(Jp,t)}var fP=se({expm1_:Y9e});function J9e(e,t){let n=X(e,"x","tile","string_or_numeric");J(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);let r={x:n},s={reps:t};return ne.runKernel(gd,r,s)}var ja=se({tile_:J9e});function Z9e(e,t,n,r="float32"){t==null&&(t=e);let s=zt([e,t],r),a=e<=t?e:t;for(let o=0;o<a;++o)s.set(1,o,o);let i=le(s.toTensor(),[e,t]);if(n==null)return i;if(n.length===1)return ja(is(i,0),[n[0],1,1]);if(n.length===2)return ja(is(is(i,0),0),[n[0],n[1],1,1]);if(n.length===3)return ja(is(is(is(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}var pT=se({eye_:Z9e});function Q9e(e){let t={x:X(e,"x","floor","float32")};return ne.runKernel(Zp,t)}var Bb=se({floor_:Q9e});function e7e(e,t,n=0,r=0){let s=X(e,"x","gather"),a=X(t,"indices","gather","int32"),i={x:s,indices:a},o={axis:n,batchDims:r};return ne.runKernel(eb,i,o)}var Wb=se({gather_:e7e});function t7e(e,t){let n=X(e,"a","greater","string_or_numeric"),r=X(t,"b","greater","string_or_numeric");[n,r]=or(n,r),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(nb,s)}var oa=se({greater_:t7e});function n7e(e,t){let n=X(e,"a","greaterEqual","string_or_numeric"),r=X(t,"b","greaterEqual","string_or_numeric");[n,r]=or(n,r),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(nf,s)}var Au=se({greaterEqual_:n7e});function r7e(e){let t={input:X(e,"input","imag")};return ne.runKernel(QN,t)}var ww=se({imag_:r7e});function s7e(e){let t={x:X(e,"x","isFinite")};return ne.runKernel(sf,t)}var mP=se({isFinite_:s7e});function a7e(e){let t={x:X(e,"x","isInf")};return ne.runKernel(af,t)}var gP=se({isInf_:a7e});function i7e(e){let t={x:X(e,"x","isNaN")};return ne.runKernel(of,t)}var yP=se({isNaN_:i7e});function o7e(e,t=.2){let n={x:X(e,"x","leakyRelu")},r={alpha:t};return ne.runKernel(lf,n,r)}var kw=se({leakyRelu_:o7e});function l7e(e,t){let n=X(e,"a","less","string_or_numeric"),r=X(t,"b","less","string_or_numeric");[n,r]=or(n,r),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(rb,s)}var Wg=se({less_:l7e});function u7e(e,t){let n=X(e,"a","lessEqual","string_or_numeric"),r=X(t,"b","lessEqual","string_or_numeric");[n,r]=or(n,r),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(sb,s)}var vd=se({lessEqual_:u7e});function eQ(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");let r={start:e,stop:t,num:n};return ne.runKernel(ab,{},r)}function c7e(e,t=5,n=1,r=1,s=.5){let a=X(e,"x","localResponseNormalization");J(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),J(Mg(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=a,o=!1;a.rank===3&&(o=!0,i=le(a,[1,a.shape[0],a.shape[1],a.shape[2]]));let l={x:i},u={depthRadius:t,bias:n,alpha:r,beta:s},c=ne.runKernel(df,l,u);return o?le(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var bP=se({localResponseNormalization_:c7e});function d7e(e){let t={x:X(e,"x","log","float32")};return ne.runKernel(uf,t)}var Qa=se({log_:d7e});function h7e(e){let t={x:X(e,"x","log1p")};return ne.runKernel(cf,t)}var Sw=se({log1p_:h7e});function p7e(e){return J(Pc(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{let r=X(t,"x","tf.grad","string_or_numeric"),s=n!=null?X(n,"dy","tf.grad"):null;return ne.tidy(()=>{let{value:a,grads:i}=ne.gradients(()=>e(r),[r],s);return s!=null&&aa(a.shape,s.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),fT(i),i[0]})}}function f7e(e){return J(Pc(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{J(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let r=Q1(t,"args","tf.grads","string_or_numeric"),s=n!=null?X(n,"dy","tf.grads"):null;return ne.tidy(()=>{let{value:a,grads:i}=ne.gradients(()=>e(...r),r,s);return s!=null&&aa(a.shape,s.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),fT(i),i})}}function m7e(e){return J(Pc(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{J(t instanceof Bt,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),J(n==null||n instanceof Bt,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:r,value:s}=ne.gradients(()=>e(t),[t],n);return fT(r),{grad:r[0],value:s}}}function g7e(e){return J(Pc(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{J(Array.isArray(t)&&t.every(s=>s instanceof Bt),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),J(n==null||n instanceof Bt,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let r=ne.gradients(()=>e(...t),t,n);return n!=null&&aa(r.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),fT(r.grads),r}}function tQ(e,t){J(Pc(e),()=>"The f passed in variableGrads(f) must be a function"),J(t==null||Array.isArray(t)&&t.every(u=>u instanceof Hh),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let n=t!=null;if(!n){t=[];for(let u in ne.registeredVariables)t.push(ne.registeredVariables[u])}let r=n?t.filter(u=>!u.trainable):null,s=t.length;t=t.filter(u=>u.trainable),J(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let a=!0,{value:i,grads:o}=ne.gradients(e,t,null,a);J(o.some(u=>u!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),J(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let l={};return t.forEach((u,c)=>{o[c]!=null&&(l[u.name]=o[c])}),r!=null&&r.forEach(u=>l[u.name]=null),{value:i,grads:l}}function Pl(e){return ne.customGrad(e)}function fT(e){if(e.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function y7e(e){let t={x:X(e,"x","neg")};return ne.runKernel(hb,t)}var Fn=se({neg_:y7e});function b7e(e){let t={x:X(e,"x","softplus")};return ne.runKernel(zf,t)}var Xf=se({softplus_:b7e});function v7e(e){let t=X(e,"x","logSigmoid");return Pl(n=>({value:Fn(Xf(Fn(n))),gradFunc:r=>oe(r,qi(Fn(n)))}))(t)}var vP=se({logSigmoid_:v7e});function x7e(e,t){let n=X(e,"a","sub"),r=X(t,"b","sub");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(jf,s)}var nt=se({sub_:x7e});function w7e(e,t=-1){let n=X(e,"logits","logSoftmax");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);return Pl((r,s)=>{let a=vi(r,t,!0),i=nt(r,a),o=nt(je(i,"float32"),Qa(ct(Ms(i),t,!0)));return s([o]),{value:o,gradFunc:(l,u)=>{let[c]=u,d=!0,h=Ms(c);return nt(l,oe(ct(l,t,d),h))}}})(n)}var mT=se({logSoftmax_:w7e});function k7e(e,t=null,n=!1){let r=X(e,"x","logSumExp"),s=ao(t,r.shape),a=vi(r,s,!0),i=nt(r,a),o=Ms(i),l=ct(o,s),u=Qa(l),c=De(le(a,u.shape),u);if(n){let d=Qh(c.shape,s);return le(c,d)}return c}var Iw=se({logSumExp_:k7e});function S7e(e,t){let n=X(e,"a","logicalAnd","bool"),r=X(t,"b","logicalAnd","bool");Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(ib,s)}var eo=se({logicalAnd_:S7e});function I7e(e){let t={x:X(e,"x","logicalNot","bool")};return ne.runKernel(ob,t)}var Cw=se({logicalNot_:I7e});function C7e(e,t){let n=X(e,"a","logicalOr","bool"),r=X(t,"b","logicalOr","bool");Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(lb,s)}var gT=se({logicalOr_:C7e});function N7e(e,t){let n=X(e,"a","logicalXor","bool"),r=X(t,"b","logicalXor","bool");return Nn(n.shape,r.shape),eo(gT(e,t),Cw(eo(e,t)))}var xP=se({logicalXor_:N7e}),zk=2147483648;function T7e(e,t,n="left"){let r=X(e,"sortedSequence","searchSorted"),s=X(t,"values","searchSorted"),a=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],o=le(r,[-1,a]),l=le(s,[-1,i]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(yn(l.shape)>=zk)throw new Error(`values tensor size must less than ${zk}`);if(o.shape[1]>=zk)throw new Error(`trailing dim_size must less than ${zk} for int32 output type, was ${o.shape[1]}`);let u={sortedSequence:o,values:l},c={side:n};return ne.runKernel(Ib,u,c)}var yT=se({searchSorted_:T7e});function nQ(e,t){return yT(e,t,"left")}function $7e(e,t,n,r,s){let a=X(e,"x","maxPool"),i=1,o=a,l=!1;a.rank===3&&(l=!0,o=le(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),J(Bl(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`),ia("maxPool",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s},d=ne.runKernel(ff,u,c);return l?le(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Qr=se({maxPool_:$7e});function E7e(e,t=[1,1,1],n,r,s,a="NDHWC"){let i=X(e,"x","maxPool3d"),o=i,l=!1;i.rank===4&&(l=!0,o=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),J(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),J(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),ia("maxPool3d",r,s);let u={x:o},c={filterSize:t,strides:n,pad:r,dimRoundingMode:s,dataFormat:a},d=ne.runKernel(cb,u,c);return l?le(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var wP=se({maxPool3d_:E7e});function _7e(e,t,n,r,s=!1){let a={x:X(e,"x","maxPoolWithArgmax")},i={filterSize:t,strides:n,pad:r,includeBatchInIndex:s},o=ne.runKernel(tw,a,i);return{result:o[0],indexes:o[1]}}var rQ=se({maxPoolWithArgmax_:_7e});function A7e(e,t){let n=X(e,"a","maximum"),r=X(t,"b","maximum");[n,r]=or(n,r),n.dtype==="bool"&&(n=je(n,"int32"),r=je(r,"int32")),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(pf,s)}var Wl=se({maximum_:A7e});function R7e(e,t=null,n=!1){let r={x:X(e,"x","mean")},s={axis:t,keepDims:n};return ne.runKernel(mf,r,s)}var rr=se({mean_:R7e});function sr(e,t="float32"){if(ri(e),t==="complex64"){let r=sr(e,"float32"),s=sr(e,"float32");return yu(r,s)}let n=UN(yn(e),t);return ne.makeTensor(n,e,t)}function fa(e,t="float32"){if(ri(e),t==="complex64"){let r=fa(e,"float32"),s=sr(e,"float32");return yu(r,s)}let n=TM(yn(e),t);return ne.makeTensor(n,e,t)}function sQ(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(e===void 0)return[];let r=X(e,"x","meshgrid",e instanceof Bt?e.dtype:"float32");if(t===void 0)return[r];let s=X(t,"y","meshgrid",t instanceof Bt?t.dtype:"float32"),a=yn(r.shape),i=yn(s.shape);return n==="xy"?(r=le(r,[1,-1]),s=le(s,[-1,1]),[Mt(fa([i,1],r.dtype),r),Mt(s,fa([1,a],s.dtype))]):(r=le(r,[-1,1]),s=le(s,[1,-1]),[Mt(r,fa([1,i],r.dtype)),Mt(fa([a,1],s.dtype),s)])}function D7e(e,t){let n=X(e,"a","minimum"),r=X(t,"b","minimum");[n,r]=or(n,r),n.dtype==="bool"&&(n=je(n,"int32"),r=je(r,"int32")),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(yf,s)}var Vc=se({minimum_:D7e});function O7e(e,t,n){J(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);let r=X(e,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");J(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);let s=n==="reflect"?1:0;for(let o=0;o<r.rank;o++)J(t[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),J(t[o][0]>=0&&t[o][0]<=r.shape[o]-s&&t[o][1]>=0&&t[o][1]<=r.shape[o]-s,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-s} or less than 0 for input of shape ${r.shape}`);let a={paddings:t,mode:n},i={x:r};return ne.runKernel(bf,i,a)}var kP=se({mirrorPad_:O7e});function F7e(e,t){let n=X(e,"a","mod"),r=X(t,"b","mod");[n,r]=or(n,r);let s={a:n,b:r};return ne.runKernel(vf,s)}var SP=se({mod_:F7e});function M7e(e,t=null,n=!1){e=X(e,"x","moments");let r=ao(t,e.shape),s=rr(e,r,n),a=s.shape;n||(a=Qh(s.shape,r));let i=kn(nt(je(e,"float32"),le(s,a))),o=rr(i,r,n);return{mean:s,variance:o}}var Nw=se({moments_:M7e});function P7e(e,t,n,r){let s=X(t,"data","multiRNNCell"),a=Q1(n,"c","multiRNNCell"),i=Q1(r,"h","multiRNNCell"),o=s,l=[];for(let d=0;d<e.length;d++){let h=e[d](o,a[d],i[d]);l.push(h[0]),l.push(h[1]),o=h[1]}let u=[],c=[];for(let d=0;d<l.length;d+=2)u.push(l[d]),c.push(l[d+1]);return[u,c]}var aQ=se({multiRNNCell_:P7e});function L7e(e,t,n,r=!1){let s=X(e,"logits","multinomial"),a=s.size,i=s.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);n=n||Math.random();let o={logits:i===1?le(s,[1,-1]):s},l={numSamples:t,seed:n,normalized:r},u=ne.runKernel(db,o,l);return i===1?le(u,[u.size]):u}var iQ=se({multinomial_:L7e});function z7e(e,t){let n=X(e,"a","notEqual","string_or_numeric"),r=X(t,"b","notEqual","string_or_numeric");[n,r]=or(n,r),Nn(n.shape,r.shape);let s={a:n,b:r};return ne.runKernel(pb,s)}var ep=se({notEqual_:z7e});function B7e(e,t,n=1,r=0,s="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:X(e,"indices","oneHot","int32")},i={dtype:s,depth:t,onValue:n,offValue:r};return ne.runKernel(wf,a,i)}var Vg=se({oneHot_:B7e});function W7e(e){let t={x:X(e,"x","onesLike")};return ne.runKernel(yb,t)}var ei=se({onesLike_:W7e});function V7e(e,t){let n=X(e,"v1","outerProduct"),r=X(t,"v2","outerProduct");J(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);let s=le(n,[-1,1]),a=le(r,[1,-1]);return Mt(s,a)}var oQ=se({outerProduct_:V7e});function U7e(e,t,n=0){let r=X(e,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:n},a={x:r};return ne.runKernel(kf,a,s)}var Ho=se({pad_:U7e});function j7e(e,t,n=0){return J(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),Ho(e,[t],n)}var lQ=se({pad1d_:j7e});function G7e(e,t,n=0){return J(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ho(e,t,n)}var uQ=se({pad2d_:G7e});function H7e(e,t,n=0){return J(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ho(e,t,n)}var cQ=se({pad3d_:H7e});function q7e(e,t,n=0){return J(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Ho(e,t,n)}var dQ=se({pad4d_:q7e});function K7e(e,t,n){let r=X(e,"x","spaceToBatchND");J(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),J(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`),J(r.shape.reduce((i,o,l)=>l>0&&l<=t.length?i&&(o+n[l-1][0]+n[l-1][1])%t[l-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:r},a={blockShape:t,paddings:n};return ne.runKernel(Tb,s,a)}var Tw=se({spaceToBatchND_:K7e});function X7e(e,t,n,r,s,a,i){s==null&&(s=[1,1]),a==null&&(a=1),r===0&&(r="valid");let o=X(e,"x","maxPool"),l=o,u=!1;o.rank===3&&(u=!0,l=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),J(Bl(a,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${s}'`);let c=BZ(l.shape,t,a,s,r),d=[c.dilationHeight,c.dilationWidth],h;r==="same"?h=J7e([c.filterHeight,c.filterWidth],d):h=[[0,0],[0,0]];let p=d[0]===1&&d[1]===1,[f,m]=Y7e([c.inHeight,c.inWidth],d,h),g=p?r:"valid",y=p?l:Tw(l,d,f),b=(n==="avg"?()=>_u(y,t,a,g,i):()=>Qr(y,t,a,g,i))(),x=p?b:vw(b,d,m);return u?le(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function Y7e(e,t,n){let r=n.map(c=>c[0]),s=n.map(c=>c[1]),a=e.concat(r,s),i=t.map((c,d)=>(c-a[d]%c)%c),o=s.map((c,d)=>c+i[d]),l=t.map((c,d)=>[r[d],o[d]]),u=t.map((c,d)=>[0,i[d]]);return[l,u]}function J7e(e,t){let n=e.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),r=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-r[i]);return n.map((a,i)=>[r[i],s[i]])}var IP=se({pool_:X7e});function Z7e(e,t){let n=X(e,"x","prelu"),r=X(t,"alpha","prelu"),s={x:n,alpha:r};return ne.runKernel(If,s)}var $w=se({prelu_:Z7e});function Q7e(e,t=null,n=!1){let r=X(e,"x","prod");r.dtype==="bool"&&(r=je(r,"int32"));let s={x:r},a={axis:t,keepDims:n};return ne.runKernel(Cf,s,a)}var CP=se({prod_:Q7e});function eKe(e,t,n,r){let s=e.map((c,d)=>X(c,`tensors${d}`,"raggedGather","int32")),a=X(t,"paramsDenseValues","raggedGather"),i=X(n,"indices","raggedGather","int32"),o={paramsNestedSplits:s,paramsDenseValues:a,indices:i},l={outputRaggedRank:r},u=ne.runKernel(eT,o,l);return{outputNestedSplits:u.slice(0,u.length-1),outputDenseValues:u[u.length-1]}}var hQ=se({raggedGather_:eKe});function tKe(e,t,n){let r=X(e,"starts","raggedRange"),s=X(t,"limits","raggedRange",r.dtype),a=X(n,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:a},o=ne.runKernel(tT,i);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}var pQ=se({raggedRange_:tKe});function nKe(e,t,n,r,s){let a=X(e,"shape","raggedTensorToTensor","int32"),i=X(t,"values","raggedTensorToTensor"),o=X(n,"defaultValue","raggedTensorToTensor",i.dtype),l=r.map((d,h)=>X(d,`tensors${h}`,"raggedTensorToTensor","int32")),u={shape:a,values:i,defaultValue:o,rowPartitionTensors:l},c={rowPartitionTypes:s};return ne.runKernel(nT,u,c)}var fQ=se({raggedTensorToTensor_:nKe});function rKe(e,t,n){ri(e);let r=yn(e),s=null;if(n==null||n==="float32")s=new Float32Array(r);else if(n==="int32")s=new Int32Array(r);else if(n==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let a=0;a<r;a++)s[a]=t();return ne.makeTensor(s,e,n)}var mQ=se({rand_:rKe}),NP=pd(WN()),gQ={};At(gQ,{TEST_EPSILON_FLOAT16:()=>yQ,createVideoElement:()=>dKe,encodeStrings:()=>bQ,expectArrayBuffersEqual:()=>cKe,expectArraysClose:()=>aKe,expectArraysEqual:()=>oKe,expectNumbersClose:()=>lKe,expectPromiseToFail:()=>iKe,expectValuesInRange:()=>uKe,play:()=>hKe,testEpsilon:()=>TP});var sKe=.001,yQ=.1;function aKe(e,t,n){return n==null&&(n=TP()),pR(e,t,(r,s)=>$P(r,s,n))}function TP(){return ne.backend.floatPrecision()===32?sKe:yQ}function pR(e,t,n){let r=!0;if((as(e)||as(t))&&(r=!1),as(e)&&as(t)&&(r=!0),r){let i=e.constructor.name,o=t.constructor.name;if(i!==o)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${o}`)}if(Array.isArray(e)&&Array.isArray(t)){let i=Ml(e),o=Ml(t);if(!$u(i,o))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${o}]`)}let s=as(e)?e:Lc(e),a=as(t)?t:Lc(t);if(s.length!==a.length)throw new Error(`Arrays have different lengths actual: ${s.length} vs expected: ${a.length}.
Actual:   ${s}.
Expected: ${a}.`);for(let i=0;i<a.length;++i){let o=s[i],l=a[i];if(!n(o,l))throw new Error(`Arrays differ: actual[${i}] = ${o}, expected[${i}] = ${l}.
Actual:   ${s}.
Expected: ${a}.`)}typeof expect<"u"&&expect().nothing()}function iKe(e,t){e().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function oKe(e,t){let n=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return ic(e)||ic(e[0])||ic(t)||ic(t[0])?pR(e,n,(r,s)=>r==s):pR(e,t,(r,s)=>$P(r,s,0))}function lKe(e,t,n){if(n==null&&(n=TP()),!$P(e,t,n))throw new Error(`Numbers differ: actual === ${e}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function $P(e,t,n){return!isFinite(e)&&!isFinite(t)?!0:!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function uKe(e,t,n){for(let r=0;r<e.length;r++)if(e[r]<t||e[r]>n)throw new Error(`Value out of range:${e[r]} low: ${t}, high: ${n}`)}function cKe(e,t){let n=new Float32Array(e),r=new Float32Array(t);if(n.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${n.length}`);for(let s=0;s<r.length;s++)if(n[s]!==r[s])throw new Error(`Expected ArrayBuffer value at ${s} to be ${r[s]} but got ${n[s]} instead`)}function bQ(e){for(let t=0;t<e.length;t++){let n=e[t];Array.isArray(n)?bQ(n):e[t]=mw(n)}return e}function dKe(e){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise(n=>{t.addEventListener("loadeddata",r=>n(t)),t.load()})}async function hKe(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise(t=>{e.requestVideoFrameCallback(t)})}var EP=class{constructor(e,t,n,r,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=NP.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,s,a;do r=2*this.random()-1,s=2*this.random()-1,a=r*r+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},pKe=class{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;let s=r||Math.random();this.randu=NP.alea(s.toString()),this.randn=new EP(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,s,a;for(;;){do r=this.randn.nextValue(),a=1+this.c*r;while(a<=0);if(a*=a*a,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},fKe=class{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=NP.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function mKe(e,t,n=1,r="float32",s){if(ri(e),n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);let a=new pKe(t,n,r,s),i=zt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var vQ=se({randomGamma_:mKe});function gKe(e,t=0,n=1,r,s){if(ri(e),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);let a=new EP(t,n,r,!1,s),i=zt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var bT=se({randomNormal_:gKe});function yKe(e,t,n){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return bT(e,0,1,t,n)}var xQ=se({randomStandardNormal_:yKe});function bKe(e,t=0,n=1,r="float32",s){ri(e);let a=zt(e,r),i=new fKe(t,n,null,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}var xd=se({randomUniform_:bKe});function vKe(e,t,n,r){return xd(e,t,n,"int32",r)}var wQ=se({randomUniformInt_:vKe});function tp(e,t,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");let s={start:e,stop:t,step:n,dtype:r};return ne.runKernel(nw,{},s)}function xKe(e){let t={input:X(e,"input","real")};return ne.runKernel(rT,t)}var Ug=se({real_:xKe});function wKe(e){let t={x:X(e,"x","reciprocal")};return ne.runKernel(Nf,t)}var _P=se({reciprocal_:wKe});function kKe(e){let t={x:X(e,"x","relu")};return ne.runKernel(Tf,t)}var gn=se({relu_:kKe});function SKe(e){let t={x:X(e,"x","relu6")};return ne.runKernel(_f,t)}var vT=se({relu6_:SKe});function IKe(e,t){let n={x:X(e,"x","reverse")},r={dims:t};return ne.runKernel(Af,n,r)}var Ii=se({reverse_:IKe});function CKe(e){let t=X(e,"x","reverse");return J(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Ii(t,0)}var kQ=se({reverse1d_:CKe});function NKe(e,t){let n=X(e,"x","reverse");return J(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),Ii(n,t)}var SQ=se({reverse2d_:NKe});function TKe(e,t){let n=X(e,"x","reverse");return J(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),Ii(n,t)}var IQ=se({reverse3d_:TKe});function $Ke(e,t){let n=X(e,"x","reverse");return J(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),Ii(n,t)}var CQ=se({reverse4d_:$Ke});function EKe(e){let t={x:X(e,"x","round")};return ne.runKernel(Rf,t)}var xT=se({round_:EKe});function _Ke(e){let t={x:X(e,"x","rsqrt","float32")};return ne.runKernel(Df,t)}var wT=se({rsqrt_:_Ke});function AKe(e){let t={x:X(e,"x","selu")};return ne.runKernel(Of,t)}var kT=se({selu_:AKe});function RKe(e,t,n,r,s,a=[1,1],i="NHWC"){let o=X(e,"x","separableConv2d"),l=X(t,"depthwiseFilter","separableConv2d"),u=X(n,"pointwiseFilter","separableConv2d"),c=o,d=!1;if(o.rank===3&&(d=!0,c=le(o,[1,o.shape[0],o.shape[1],o.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");J(c.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`),J(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),J(u.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),J(u.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`),J(u.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`);let h=l.shape[2],p=l.shape[3];J(u.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${u.shape[2]}.`);let f=Kf(c,l,r,s,i,a),m=ta(f,u,1,"valid",i);return d?le(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Vb=se({separableConv2d_:RKe});async function DKe(e,t){let n=X(e,"x","setdiff1d"),r=X(t,"y","setdiff1d");J(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),J(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),J(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);let s=await n.data(),a=await r.data(),i=new Set(a),o=0;for(let c=0;c<s.length;c++)i.has(s[c])||o++;let l=new Er([o],n.dtype),u=new Er([o],"int32");for(let c=0,d=0;c<s.length;c++)i.has(s[c])||(l.values[d]=s[c],u.values[d]=c,d++);return[l.toTensor(),u.toTensor()]}var NQ=DKe;function OKe(e){let t={x:X(e,"x","sign")};return ne.runKernel(Pf,t)}var AP=se({sign_:OKe});function FKe(e){let t={x:X(e,"x","sin","float32")};return ne.runKernel(Ff,t)}var ST=se({sin_:FKe});function MKe(e){let t={x:X(e,"x","sinh")};return ne.runKernel(Mf,t)}var IT=se({sinh_:MKe});function PKe(e,t,n){let r=X(e,"x","slice1d");return J(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Kt(r,[t],[n])}var Ew=se({slice1d_:PKe});function LKe(e,t,n){let r=X(e,"x","slice2d");return J(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Kt(r,t,n)}var CT=se({slice2d_:LKe});function zKe(e,t,n){let r=X(e,"x","slice3d");return J(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Kt(r,t,n)}var Ub=se({slice3d_:zKe});function BKe(e,t,n){let r=X(e,"x","slice4d");return J(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Kt(r,t,n)}var jg=se({slice4d_:BKe});function WKe(e,t=-1){let n=X(e,"logits","softmax","float32");if(t===-1&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);let r={logits:n},s={dim:t};return ne.runKernel(Vf,r,s)}var wd=se({softmax_:WKe});function VKe(e){J(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);let t={input:e};return ne.runKernel(JN,t)}var _w=se({fft_:VKe});function UKe(e){J(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);let t={input:e};return ne.runKernel(ZN,t)}var Gg=se({ifft_:UKe});function jKe(e){let t=e.shape[e.shape.length-1],n=e.size/t,r;if(t<=2){let s=le(e,[n,t]);r=Gg(s)}else{let s=[n,2*(t-1)],a=le(Ug(e),[n,t]),i=le(ww(e),[n,t]),o=Ii(Kt(a,[0,1],[n,t-2]),1),l=oe(Ii(Kt(i,[0,1],[n,t-2]),1),bt(-1)),u=In([a,o],1),c=In([i,l],1),d=le(yu(u,c),[s[0],s[1]]);r=Gg(d)}if(r=Ug(r),e.rank===3&&e.shape[0]!==0){let s=r,a=e.shape[0];r=le(r,[a,r.shape[0]/a,r.shape[1]]),s.dispose()}return r}var NT=se({irfft_:jKe});function GKe(e,t,n=0){let r={x:X(e,"x","split")},s={numOrSizeSplits:t,axis:n};return ne.runKernel($b,r,s)}var ya=se({split_:GKe});function HKe(e,t){J(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1],r=e.size/n,s;if(t!=null&&t<n){let f=e.shape.map(g=>0),m=e.shape.map(g=>g);m[e.shape.length-1]=t,s=Kt(e,f,m),n=t}else if(t!=null&&t>n){let f=e.shape.map(m=>m);f[e.shape.length-1]=t-n,s=In([e,sr(f)],e.shape.length-1),n=t}else s=e;let a=Xt(s),i=le(yu(s,a),[r,n]),o=_w(i),l=Math.floor(n/2)+1,u=Ug(o),c=ww(o),d=ya(u,[l,n-l],u.shape.length-1),h=ya(c,[l,n-l],c.shape.length-1),p=s.shape.slice();return p[s.shape.length-1]=l,le(yu(d[0],h[0]),p)}var Aw=se({rfft_:HKe});function qKe(e,t){let n=X(e,"a","squaredDifference"),r=X(t,"b","squaredDifference");[n,r]=or(n,r),Nn(n.shape,r.shape);let s={a:n,b:r},a={};return ne.runKernel(Uf,s,a)}var TT=se({squaredDifference_:qKe});function KKe(e,t){let n=X(e,"x","squeeze","string_or_numeric");return le(n,QJ(n.shape,t).newShape)}var kd=se({squeeze_:KKe});function XKe(e,t=0){let n=Q1(e,"tensors","stack","string_or_numeric");J(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&J(t<=n[0].rank,()=>"Axis must be <= rank of the tensor");let r=n,s={axis:t};return ne.runKernel(bb,r,s)}var _r=se({stack_:XKe});function YKe(e,t=0){let n={x:X(e,"x","step")},r={alpha:t};return ne.runKernel(yd,n,r)}var Yf=se({step_:YKe});function JKe(e,t,n,r,s=0,a=0,i=0,o=0,l=0){let u={x:X(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:r,beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};return ne.runKernel(Ab,u,c)}var RP=se({stridedSlice_:JKe});function ZKe(e){let t={x:X(e,"x","tan","float32")};return ne.runKernel(Gf,t)}var DP=se({tan_:ZKe});function dn(e,t){Np(e);let n=Ml(e,t);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return bd(e,null,n,t)}function Tl(e,t,n){if(Np(e),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let r=Ml(e,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return bd(e,t,r,n)}function $T(e,t,n){if(Np(e),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let r=Ml(e,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return bd(e,t,r,n)}function Uc(e,t,n){if(Np(e),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let r=Ml(e,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return bd(e,t,r,n)}function TQ(e,t,n){if(Np(e),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let r=Ml(e,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return bd(e,t,r,n)}function $Q(e,t,n){if(Np(e),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let r=Ml(e,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,bd(e,t,r,n)}var ET={};At(ET,{calculateShapes:()=>EQ,validateInput:()=>_T,validateUpdateShape:()=>OP});function OP(e,t,n){let r=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${r}, and batchDim: ${s}.`;if(n.rank<s)throw new Error(a+` update.rank < ${s}. `);if(e.length<r+(n.rank-s))throw new Error(a+` Output shape length < ${r+(n.rank-s)}`);if(n.rank!==s+e.length-r)throw new Error(a+` update.rank != ${s+e.length-r}`);for(let i=0;i<s;++i)if(n.shape[i]!==t.shape[i])throw new Error(a+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`);for(let i=0;i<n.rank-s;++i)if(n.shape[i+s]!==e[i+r])throw new Error(a+` updates.shape[${i+s}] (${n.shape[i+s]}) != shape[${i+s}] (${e[i+s]})`)}function _T(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}OP(n,t,e)}function EQ(e,t,n){let r=t.shape.length,s=r>1?t.shape[r-1]:1,a=n.length,i=1;for(let d=s;d<a;++d)i*=n[d];let o=s<1?1:s,l=yn(t.shape)/o,u=[...Oy(n.slice(0,s)),1],c=yn(n);return{sliceRank:s,numUpdates:l,sliceSize:i,strides:u,outputSize:c}}function QKe(e,t,n){let r=X(e,"tensor","tensorScatterupdate"),s=X(t,"indices","tensorScatterupdate","int32"),a=X(n,"updates","tensorScatterupdate");if(_T(a,s,r.shape),r.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${a.dtype}.`);let i={tensor:r,indices:s,updates:a},o={};return ne.runKernel(Sb,i,o)}var _Q=se({tensorScatterUpdate_:QKe});function eXe(e,t=1,n=!0){let r=X(e,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let a={x:r},i={k:t,sorted:n},[o,l]=ne.runKernel(Rb,a,i);return{values:o,indices:l}}var FP=se({topk_:eXe});function tXe(e,t=0,n=1,r,s){if(ri(e),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");let a=new EP(t,n,r,!0,s),i=zt(e,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}var AT=se({truncatedNormal_:tXe});function nXe(e,t=0){let n=X(e,"x","unique","string_or_numeric");J(n.rank>0,()=>"The input tensor must be at least 1D");let r={x:n},s={axis:t},[a,i]=ne.runKernel(dw,r,s);return{values:a,indices:i}}var MP=se({unique_:nXe});function rXe(e,t,n){let r=X(e,"x","unsortedSegmentSum"),s=X(t,"segmentIds","unsortedSegmentSum","int32");J(Mg(n),()=>"numSegments must be of dtype int");let a={x:r,segmentIds:s},i={numSegments:n};return ne.runKernel(hw,a,i)}var RT=se({unsortedSegmentSum_:rXe});function sXe(e,t=0){let n=X(e,"x","unstack","string_or_numeric");J(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);let r={value:n},s={axis:t};return ne.runKernel(Ob,r,s)}var hr=se({unstack_:sXe});function AQ(e,t){return yT(e,t,"right")}function PP(e,t=!0,n,r){return ne.makeVariable(e,t,n,r)}function RQ(e,t){let n=[];for(let a=0;a<t.length;a++)t[a]&&n.push(a);let r=zt(e,"int32"),s=zt([n.length,e.length],"int32");for(let a=0;a<n.length;a++){let i=r.indexToLoc(n[a]),o=a*e.length;s.values.set(i,o)}return s.toTensor()}async function aXe(e){let t=X(e,"condition","whereAsync","bool"),n=await t.data(),r=RQ(t.shape,n);return e!==t&&t.dispose(),r}var LP=aXe;async function iXe(e,t,n){let r=X(e,"tensor","boolMask"),s=X(t,"mask","boolMask","bool"),a=n??0,i=s.rank,o=r.shape;J(i>0,()=>"mask cannot be scalar"),aa(o.slice(a,a+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let m=a;m<a+i;m++)l*=o[m];let u=o.slice(0,a).concat([l],o.slice(a+i)),c=le(r,u),d=le(s,[-1]),h=await LP(d),p=kd(h,[1]),f=Wb(c,p,a);return e!==r&&r.dispose(),t!==s&&s.dispose(),p.dispose(),c.dispose(),d.dispose(),h.dispose(),f}var DQ=iXe;function oXe(e,t,n){let r=X(e,"x","transpose");if(t==null&&(t=r.shape.map((i,o)=>o).reverse()),J(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(i=>{J(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();let s={x:r},a={perm:t};return r.dtype==="complex64"?ue(()=>{let i=Ug(r),o=ww(r);return i=ne.runKernel(au,{x:i},a),o=ne.runKernel(au,{x:o},a),n&&(o=Fn(o)),yu(i,o)}):ne.runKernel(au,s,a)}var Lt=se({transpose_:oXe});function lXe(e,t,n,r,s=!0){let a=X(e,"v","movingAverage"),i=X(t,"x","movingAverage"),o=X(n,"decay","movingAverage");vZ(a,i),J($u(a.shape,i.shape),()=>"Shape mismatch in v and x");let l=bt(1),u=nt(l,o),c=oe(nt(i,a),u);if(s){J(r!=null,()=>"When using zeroDebias: true, step is required.");let d=X(r,"step","movingAverage");c=ot(c,nt(l,bu(o,d)))}return De(a,c)}var OQ=se({movingAverage_:lXe});function uXe(e,t,n){ri(n);let r=X(e,"indices","scatterND","int32"),s=X(t,"updates","scatterND");_T(s,r,n);let a={indices:r,updates:s},i={shape:n};return ne.runKernel(kb,a,i)}var FQ=se({scatterND_:uXe});function cXe(e,t,n,r){if(e.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`);let s=e.rank>0?e.shape[0]:1,a=e.rank>1?e.shape[1]:1;if(n.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${a}.`);let i=t.size;if(!(t.rank===0||t.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${s}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function dXe(e,t,n,r=0){ri(n);let s=X(e,"sparseIndices","sparseToDense","int32"),a=X(t,"sparseValues","sparseToDense","string_or_numeric"),i=X(r,"defaultValue","sparseToDense",a.dtype);cXe(s,a,n,i);let o={sparseIndices:s,sparseValues:a,defaultValue:i},l={outputShape:n};return ne.runKernel(_b,o,l)}var MQ=se({sparseToDense_:dXe});function hXe(e,t){let n=X(t,"indices","gatherND","int32"),r={params:X(e,"x","gatherND","string_or_numeric"),indices:n};return ne.runKernel(tb,r)}var PQ=se({gatherND_:hXe});function pXe(e,t){if(t==null)return e.shape.slice();if($u(e.shape,t))return t;if(e.shape.length===t.length){let n=[];for(let r=0;r<e.shape.length;r++)t[r]==null&&e.shape[r]!=null?n.push(e.shape[r]):n.push(t[r]);return n}return t}function fXe(e,t,n,r){let s=X(e,"x","dropout");if(J(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),J(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return e instanceof Bt?s.clone():s;let a=pXe(s,n),i=1-t,o=ot(Bb(De(xd(a,0,1,"float32",r),i)),i);return oe(s,o)}var zP=se({dropout_:fXe});function BP(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function DT(e,t,n){let r=1-e%2,s=new Float32Array(e);for(let a=0;a<e;++a){let i=2*Math.PI*a/(e+r-1);s[a]=t-n*Math.cos(i)}return dn(s,"float32")}async function mXe(e,t,n=1){let r=X(e,"predictions","inTopK"),s=X(t,"targets","inTopK");J(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),J(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),aa(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let a=r.shape[r.shape.length-1];J(n>0&&n<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${n}`);let i=await r.data(),o=await s.data(),[l,u]=[i.length/a,a],c=eZ("bool",l);for(let d=0;d<l;d++){let h=d*u,p=i.subarray(h,h+u),f=[];for(let m=0;m<p.length;m++)f.push({value:p[m],index:m});f.sort((m,g)=>g.value-m.value),c[d]=0;for(let m=0;m<n;m++)if(f[m].index===o[d]){c[d]=1;break}}return e!==r&&r.dispose(),t!==s&&s.dispose(),Js(c,s.shape,"bool")}var LQ=mXe,Hg={};At(Hg,{conv2d:()=>bXe,depthwiseConv2d:()=>kXe,matMul:()=>IXe});function gXe(e,t,n,r,s,a="NHWC",i){let o=e;e.rank===3&&(o=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=le(t,[1,t.shape[0],t.shape[1],t.shape[2]])),J(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),J(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),J(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);let u=a==="NHWC"?o.shape[3]:o.shape[1],c=a==="NHWC"?l.shape[3]:l.shape[1];J(u===n[2],()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`),J(c===n[3],()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`),ia("conv2dDerFilter",s,i);let d={x:o,dy:l},h={strides:r,pad:s,dataFormat:a,dimRoundingMode:i,filterShape:n};return ne.runKernel(HN,d,h)}var WP=se({conv2DBackpropFilter_:gXe});function OT(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return oe(e,Yf(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function FT(e,t){let n=t,r=Rr(e.shape,t.shape);return r.length>0&&(n=ct(n,r)),le(n,e.shape)}function MT(e,t,n,r){if(t==="linear")return e;if(t==="relu")return gn(e);if(t==="elu")return Lb(e);if(t==="relu6")return vT(e);if(t==="prelu")return $w(e,n);if(t==="leakyrelu")return kw(e,r);if(t==="sigmoid")return qi(e);throw new Error(`Unknown fused activation ${t}.`)}var PT=(e,t)=>!(e>0)||t==="linear";function yXe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(l=l||"linear",PT(ne.state.gradientDepth,l)===!1){J(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=ta(e,t,n,r,s,a,i);return o!=null&&(k=De(k,o)),MT(k,l,u,c)}let d=X(e,"x","conv2d","float32"),h=X(t,"filter","conv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=le(d,[1,d.shape[0],d.shape[1],d.shape[2]])),J(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),J(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`),ia("fused conv2d",r,i);let m=s==="NHWC"?p.shape[3]:p.shape[1];J(h.shape[2]===m,()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${h.shape[2]}.`),J(Bl(n,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`);let g=bw(p.shape,h.shape,n,a,r,i),y;o!=null&&(y=X(o,"bias","fused conv2d"),[y]=or(y,d),s==="NHWC"?Nn(g.outShape,y.shape):(J(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),J(y.shape.length===0||y.shape[0]===g.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let b;if(u!=null){let k=u.shape;if(J(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)J(k[0]===1||k[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${g.outChannels}).`);else if(k.length===3)try{Nn(k,g.outShape)}catch{let I=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(I)}b=X(u,"prelu weights","fused conv2d")}let x=(k,S)=>{J(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);let[I,$,C,T]=S,N=OT(k,C,l);J(Wc(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);let E=rP($.shape,N,I,n,r),_=WP($,N,I.shape,n,r),R=[E,_];if(T!=null){let z=FT(T,N);R.push(z)}return R},v={x:p,filter:h,bias:y,preluActivationWeights:b},w={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?Pl((k,S,I)=>{let $=ne.runKernel(jh,v,w);return I([S,k,$]),f&&($=le($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(p,h):Pl((k,S,I,$)=>{let C=ne.runKernel(jh,v,w);return $([S,k,C,I]),f&&(C=le(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:x}})(p,h,y)}var bXe=se({fusedConv2d_:yXe});function vXe(e,t,n,r,s,a=[1,1],i){let o=e;e.rank===3&&(o=le(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;l.rank===3&&(l=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={x:o,dy:l},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,filterShape:n};return ne.runKernel(qN,u,c)}var zQ=se({depthwiseConv2dNativeBackpropFilter_:vXe});function xXe(e,t,n,r,s,a=[1,1],i){let o=t,l=!1;t.rank===3&&(l=!0,o=le(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let u={dy:o,filter:n},c={strides:r,pad:s,dimRoundingMode:i,dilations:a,inputShape:e},d=ne.runKernel(KN,u,c);return l?le(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var BQ=se({depthwiseConv2dNativeBackpropInput_:xXe});function wXe({x:e,filter:t,strides:n,pad:r,dataFormat:s="NHWC",dilations:a=[1,1],dimRoundingMode:i,bias:o,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:c}){if(PT(ne.state.gradientDepth,l)===!1){let w=Kf(e,t,n,r,s,a,i);return o!=null&&(w=De(w,o)),MT(w,l,u,c)}let d=X(e,"x","depthwiseConv2d","float32"),h=X(t,"filter","depthwiseConv2d","float32"),p=d,f=!1;d.rank===3&&(f=!0,p=le(d,[1,d.shape[0],d.shape[1],d.shape[2]])),J(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),J(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`),J(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`),a==null&&(a=[1,1]),J(Bl(n,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${a}'`),ia("fused depthwiseConv2d",r,i);let m=bw(p.shape,h.shape,n,a,r,i,!0),g;o!=null&&(g=X(o,"bias","fused conv2d"),[g]=or(g,d),Nn(m.outShape,g.shape));let y;u!=null&&(y=X(u,"prelu weights","fused depthwiseConv2d"));let b=(w,k)=>{J(Wc(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[S,I,$,C]=k,T=OT(w,$,l),N=BQ(I.shape,T,S,n,r,a,i),E=zQ(I,T,S.shape,n,r,a,i);if(C!=null){let _=FT(g,T);return[N,E,_]}return[N,E]},x={x:p,filter:h,bias:g,preluActivationWeights:y},v={strides:n,pad:r,dataFormat:s,dilations:a,dimRoundingMode:i,activation:l,leakyreluAlpha:c};return o==null?Pl((w,k,S)=>{let I=ne.runKernel(Gh,x,v);return S([k,w,I]),f&&(I=le(I,[I.shape[1],I.shape[2],I.shape[3]])),{value:I,gradFunc:b}})(p,h):Pl((w,k,S,I)=>{let $=ne.runKernel(Gh,x,v);return I([k,w,$,S]),f&&($=le($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:b}})(p,h,g)}var kXe=se({fusedDepthwiseConv2d_:wXe});function SXe({a:e,b:t,transposeA:n=!1,transposeB:r=!1,bias:s,activation:a="linear",preluActivationWeights:i,leakyreluAlpha:o=.2}){if(PT(ne.state.gradientDepth,a)===!1){let C=Mt(e,t,n,r);return s!=null&&(C=De(C,s)),MT(C,a,i,o)}let l=X(e,"a","fused matMul"),u=X(t,"b","fused matMul");[l,u]=or(l,u);let c=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],p=r?u.shape[u.rank-2]:u.shape[u.rank-1],f=l.shape.slice(0,-2),m=u.shape.slice(0,-2),g=yn(f),y=yn(m);J(c===d,()=>`Error in fused matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${l.shape} and ${u.shape} and transposeA=${n} and transposeB=${r} must match.`);let b=Nn(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([h,p]),x=n?le(l,[g,c,h]):le(l,[g,h,c]),v=r?le(u,[y,p,d]):le(u,[y,d,p]),w;s!=null&&(w=X(s,"bias","fused matMul"),[w]=or(w,l),Nn(b,w.shape));let k;i!=null&&(k=X(i,"prelu weights","fused matMul"));let S=(C,T)=>{let[N,E,_,R]=T,z=OT(le(C,_.shape),_,a),W,F;if(!n&&!r?(W=Mt(z,E,!1,!0),F=Mt(N,z,!0,!1)):!n&&r?(W=Mt(z,E,!1,!1),F=Mt(z,N,!0,!1)):n&&!r?(W=Mt(E,z,!1,!0),F=Mt(N,z,!1,!1)):(W=Mt(E,z,!0,!0),F=Mt(z,N,!0,!0)),s!=null){let L=FT(R,z);return[W,F,L]}else return[W,F]},I={a:x,b:v,bias:w,preluActivationWeights:k},$={transposeA:n,transposeB:r,activation:a,leakyreluAlpha:o};return s==null?Pl((C,T,N)=>{let E=ne.runKernel(Uh,I,$);return N([C,T,E]),{value:le(E,b),gradFunc:S}})(x,v):Pl((C,T,N,E)=>{let _=ne.runKernel(Uh,I,$);return E([C,T,_,N]),{value:le(_,b),gradFunc:S}})(x,v,w)}var IXe=se({fusedMatMul_:SXe});function CXe(e){return DT(e,.54,.46)}var NXe=se({hammingWindow_:CXe});function TXe(e){return DT(e,.5,.5)}var WQ=se({hannWindow_:TXe});function $Xe(e,t,n,r=!1,s=0){let a=0,i=[];for(;a+t<=e.size;)i.push(Kt(e,a,t)),a+=n;if(r)for(;a<e.size;){let o=a+t-e.size,l=In([Kt(e,a,t-o),Ka([o],s)]);i.push(l),a+=n}return i.length===0?Tl([],[0,t]):le(In(i),[i.length,t])}var VQ=se({frame_:$Xe});function EXe(e,t,n,r,s=WQ){r==null&&(r=BP(t));let a=VQ(e,t,n),i=oe(a,s(t));return Aw(i,r)}var _Xe=se({stft_:EXe});function AXe(e,t,n,r,s="bilinear",a=0){let i=X(e,"image","cropAndResize"),o=X(t,"boxes","cropAndResize","float32"),l=X(n,"boxInd","cropAndResize","int32"),u=o.shape[0];J(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),J(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`),J(l.rank===1&&l.shape[0]===u,()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`),J(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),J(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),J(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);let c={image:i,boxes:o,boxInd:l},d={method:s,extrapolationValue:a,cropSize:r};return ne.runKernel(Ky,c,d)}var RXe=se({cropAndResize_:AXe});function DXe(e){let t=X(e,"image","flipLeftRight","float32");J(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let n={image:t};return ne.runKernel(Qy,n,{})}var OXe=se({flipLeftRight_:DXe});function FXe(e){let t=X(e,"image","grayscaleToRGB"),n=t.rank-1,r=t.shape[n];J(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),J(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);let s=new Array(t.rank);return s.fill(1,0,n),s[n]=3,ja(t,s)}var MXe=se({grayscaleToRGB_:FXe});function PXe(e){let t=X(e,"image","RGBToGrayscale"),n=t.rank-1,r=t.shape[n];J(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),J(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);let s=t.dtype,a=je(t,"float32"),i=dn([.2989,.587,.114]),o;switch(t.rank){case 2:o=Kd("ij,j->i",a,i);break;case 3:o=Kd("ijk,k->ij",a,i);break;case 4:o=Kd("ijkl,l->ijk",a,i);break;case 5:o=Kd("ijklm,m->ijkl",a,i);break;case 6:o=Kd("ijklmn,n->ijklm",a,i);break;default:throw new Error("Not a valid tensor rank.")}return o=is(o,-1),je(o,s)}var LXe=se({rgbToGrayscale_:PXe});function zXe(e,t,n=0,r=.5){let s=X(e,"image","rotateWithOffset","float32");J(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);let a={image:s},i={radians:t,fillValue:n,center:r};return ne.runKernel(Mb,a,i)}var BXe=se({rotateWithOffset_:zXe});function jb(e,t,n,r,s,a){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),a==null&&(a=0);let i=e.shape[0];return n=Math.min(n,i),J(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),J(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`),J(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`),J(t.rank===1,()=>"scores must be a 1D tensor"),J(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`),J(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a}}function WXe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=X(e,"boxes","nonMaxSuppression","float32"),i=X(t,"scores","nonMaxSuppression","float32"),o=jb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let l={maxOutputSize:n,iouThreshold:r,scoreThreshold:s};return ne.runKernel(fb,{boxes:a,scores:i},l)}var VXe=se({nonMaxSuppression_:WXe});function UXe(e,t,n){let r=jXe(e,t,n),s=r<0?-(r+1):r;e.splice(s,0,t)}function jXe(e,t,n){return HXe(e,t,n||GXe)}function GXe(e,t){return e>t?1:e<t?-1:0}function HXe(e,t,n){let r=0,s=e.length,a=0,i=!1;for(;r<s;){a=r+(s-r>>>1);let o=n(t,e[a]);o>0?r=a+1:(s=a,i=!o)}return i?r:-r-1}function UQ(e,t,n,r,s){return VP(e,t,n,r,s,0)}function jQ(e,t,n,r,s,a){return VP(e,t,n,r,s,0,!1,a,!0)}function GQ(e,t,n,r,s,a){return VP(e,t,n,r,s,a,!0)}function VP(e,t,n,r,s,a,i=!1,o=!1,l=!1){let u=[];for(let g=0;g<t.length;g++)t[g]>s&&u.push({score:t[g],boxIndex:g,suppressBeginIndex:0});u.sort(Oj);let c=a>0?-.5/a:0,d=[],h=[];for(;d.length<n&&u.length>0;){let g=u.pop(),{score:y,boxIndex:b,suppressBeginIndex:x}=g;if(y<s)break;let v=!1;for(let w=d.length-1;w>=x;--w){let k=qXe(e,b,d[w]);if(k>=r){v=!0;break}if(g.score=g.score*KXe(r,c,k),g.score<=s)break}g.suppressBeginIndex=d.length,v||(g.score===y?(d.push(b),h.push(g.score)):g.score>s&&UXe(u,g,Oj))}let p=d.length,f=n-p;o&&f>0&&(d.push(...new Array(f).fill(0)),h.push(...new Array(f).fill(0)));let m={selectedIndices:d};return i&&(m.selectedScores=h),l&&(m.validOutputs=p),m}function qXe(e,t,n){let r=e.subarray(t*4,t*4+4),s=e.subarray(n*4,n*4+4),a=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),u=Math.min(s[0],s[2]),c=Math.min(s[1],s[3]),d=Math.max(s[0],s[2]),h=Math.max(s[1],s[3]),p=(o-a)*(l-i),f=(d-u)*(h-c);if(p<=0||f<=0)return 0;let m=Math.max(a,u),g=Math.max(i,c),y=Math.min(o,d),b=Math.min(l,h),x=Math.max(y-m,0)*Math.max(b-g,0);return x/(p+f-x)}function KXe(e,t,n){let r=Math.exp(t*n*n);return n<=e?r:0}function Oj(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function XXe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY){let a=X(e,"boxes","nonMaxSuppressionAsync"),i=X(t,"scores","nonMaxSuppressionAsync"),o=jb(a,i,n,r,s);n=o.maxOutputSize,r=o.iouThreshold,s=o.scoreThreshold;let l=await Promise.all([a.data(),i.data()]),u=l[0],c=l[1],{selectedIndices:d}=UQ(u,c,n,r,s);return a!==e&&a.dispose(),i!==t&&i.dispose(),dn(d,"int32")}var YXe=XXe;function JXe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=X(e,"boxes","nonMaxSuppression"),o=X(t,"scores","nonMaxSuppression"),l=jb(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;let u={boxes:i,scores:o},c={maxOutputSize:n,iouThreshold:r,scoreThreshold:s,softNmsSigma:a},d=ne.runKernel(gb,u,c);return{selectedIndices:d[0],selectedScores:d[1]}}var ZXe=se({nonMaxSuppressionWithScore_:JXe});async function QXe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=0){let i=X(e,"boxes","nonMaxSuppressionAsync"),o=X(t,"scores","nonMaxSuppressionAsync"),l=jb(i,o,n,r,s,a);n=l.maxOutputSize,r=l.iouThreshold,s=l.scoreThreshold,a=l.softNmsSigma;let u=await Promise.all([i.data(),o.data()]),c=u[0],d=u[1],{selectedIndices:h,selectedScores:p}=GQ(c,d,n,r,s,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:dn(h,"int32"),selectedScores:dn(p)}}var eYe=QXe;function tYe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=X(e,"boxes","nonMaxSuppression"),o=X(t,"scores","nonMaxSuppression"),l=jb(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,h={boxes:i,scores:o},p={maxOutputSize:u,iouThreshold:c,scoreThreshold:d,padToMaxOutputSize:a},f=ne.runKernel(mb,h,p);return{selectedIndices:f[0],validOutputs:f[1]}}var nYe=se({nonMaxSuppressionPadded_:tYe});async function rYe(e,t,n,r=.5,s=Number.NEGATIVE_INFINITY,a=!1){let i=X(e,"boxes","nonMaxSuppressionAsync"),o=X(t,"scores","nonMaxSuppressionAsync"),l=jb(i,o,n,r,s,null),u=l.maxOutputSize,c=l.iouThreshold,d=l.scoreThreshold,[h,p]=await Promise.all([i.data(),o.data()]),{selectedIndices:f,validOutputs:m}=jQ(h,p,u,c,d,a);return i!==e&&i.dispose(),o!==t&&o.dispose(),{selectedIndices:dn(f,"int32"),validOutputs:bt(m,"int32")}}var sYe=rYe;function aYe(e,t,n=!1,r=!1){let s=X(e,"images","resizeBilinear");J(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),J(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),J(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=le(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ne.runKernel(Ef,o,l);return i?le(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var HQ=se({resizeBilinear_:aYe});function iYe(e,t,n=!1,r=!1){let s=X(e,"images","resizeNearestNeighbor");J(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),J(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),J(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),J(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=s,i=!1;s.rank===3&&(i=!0,a=le(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let o={images:a},l={alignCorners:n,halfPixelCenters:r,size:t},u=ne.runKernel($f,o,l);return i?le(u,[u.shape[1],u.shape[2],u.shape[3]]):u}var qQ=se({resizeNearestNeighbor_:iYe});function oYe(e,t="binary",n=!1,r=.5){let s=X(e,"image","threshold"),a=.2989,i=.587,o=.114,l=s.shape[0]*s.shape[1],u=oe(dn([r]),255),c,d,h,p;if(J(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),J(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),J(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),J(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),s.shape[2]===3){[c,d,h]=ya(s,[1,1,1],-1);let m=oe(c,a),g=oe(d,i),y=oe(h,o);p=De(De(m,g),y)}else p=e;if(t==="otsu"){let m=JM(je(xT(p),"int32"),Js([]),256);u=lYe(m,l)}let f=n?vd(p,u):oa(p,u);return je(oe(f,255),"int32")}function lYe(e,t){let n=dn([-1]),r=dn([0]),s=dn([0]),a,i,o,l,u,c;for(let d=0;d<e.size-1;d++){a=Kt(e,0,d+1),i=Kt(e,d+1),u=ot(ct(a),t),c=ot(ct(i),t);let h=ct(oe(a,tp(0,a.size)));o=ot(h,ct(a));let p=Ka(i.shape,a.size),f=De(tp(0,i.size),p),m=oe(i,f);l=ot(ct(m),ct(i));let g=nt(o,l),y=nt(o,l),b=oe(u,c);s=oe(oe(b,g),y);let x=oa(s,r);r=ds(x,s,r),n=ds(x,dn([d]),n)}return n}var uYe=se({threshold_:oYe});function cYe(e,t,n="nearest",r="constant",s=0,a){let i=X(e,"image","transform","float32"),o=X(t,"transforms","transform","float32");J(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),J(o.rank===2&&(o.shape[0]===i.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),J(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);let l={image:i,transforms:o},u={interpolation:n,fillMode:r,fillValue:s,outputShape:a};return ne.runKernel(Db,l,u)}var dYe=se({transform_:cYe});function hYe(e,t,n){let r=X(e,"a","bandPart");J(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);let s=r.shape,[a,i]=r.shape.slice(-2),o,l;typeof t=="number"?(J(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),J(t<=a,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${a}).`),o=X(t<0?a:t,"numLower","bandPart")):(J(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=ds(Wg(t,0),a,Vc(t,a))),typeof n=="number"?(J(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`),J(n<=i,()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`),l=X(n<0?i:n,"numUpper","bandPart")):(J(n.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),l=ds(Wg(n,0),i,Vc(n,i)));let u=le(tp(0,a,1,"int32"),[-1,1]),c=tp(0,i,1,"int32"),d=nt(u,c),h=eo(vd(d,o),Au(d,Fn(l))),p=sr([a,i],r.dtype);return le(_r(hr(le(r,[-1,a,i])).map(f=>ds(h,f,p))),s)}var pYe=se({bandPart_:hYe});function fYe(e){let t;if(Array.isArray(e)){t=!1,J(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=e[0].shape[0];for(let a=1;a<e.length;++a)J(e[a].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[a].shape[0]} vs. ${s})`)}else t=!0,e=ya(e,e.shape[0],0).map(s=>kd(s,[0]));J(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);let n=[],r=e;for(let s=0;s<e.length;++s)n.push(ne.tidy(()=>{let a=r[s];if(s>0)for(let i=0;i<s;++i){let o=oe(ct(oe(n[i],a)),n[i]);a=nt(a,o)}return ot(a,zb(a,"euclidean"))}));return t?_r(n,0):n}var mYe=se({gramSchmidt_:fYe});function gYe(e,t=!1){if(J(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`),e.rank===2)return Fj(e,t);{let n=e.shape.slice(0,e.shape.length-2).reduce((l,u)=>l*u),r=hr(le(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),s=[],a=[];r.forEach(l=>{let[u,c]=Fj(l,t);s.push(u),a.push(c)});let i=le(_r(s,0),e.shape),o=le(_r(a,0),e.shape);return[i,o]}}function Fj(e,t=!1){return ne.tidy(()=>{J(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);let n=e.shape[0],r=e.shape[1],s=pT(n),a=Nl(e),i=Tl([[1]],[1,1]),o=Nl(i),l=n>=r?r:n;for(let u=0;u<l;++u){let c=a,d=o,h=s;[o,a,s]=ne.tidy(()=>{let p=Kt(a,[u,u],[n-u,1]),f=zb(p),m=Kt(a,[u,u],[1,1]),g=ds(oa(m,0),Tl([[-1]]),Tl([[1]])),y=nt(m,oe(g,f)),b=ot(p,y);b.shape[0]===1?o=Nl(i):o=In([i,Kt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);let x=Fn(ot(Mt(g,y),f)),v=Kt(a,[u,0],[n-u,r]),w=oe(x,o),k=Lt(o);if(u===0)a=nt(v,Mt(w,Mt(k,v)));else{let $=nt(v,Mt(w,Mt(k,v)));a=In([Kt(a,[0,0],[u,r]),$],0)}let S=Lt(w),I=Kt(s,[0,u],[n,s.shape[1]-u]);if(u===0)s=nt(I,Mt(Mt(I,o),S));else{let $=nt(I,Mt(Mt(I,o),S));s=In([Kt(s,[0,0],[n,u]),$],1)}return[o,a,s]}),_t([c,d,h])}return!t&&n>r&&(s=Kt(s,[0,0],[n,r]),a=Kt(a,[0,0],[r,r])),[s,a]})}var yYe=se({qr_:gYe}),Ks;(function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(Ks||(Ks={}));function bYe(e,t,n=Ks.SUM_BY_NONZERO_WEIGHTS){let r=X(e,"losses","computeWeightedLoss"),s=null;t!=null&&(s=X(t,"weights","computeWeightedLoss"));let a=s==null?r:oe(r,s);if(n===Ks.NONE)return a;if(n===Ks.SUM)return ct(a);if(n===Ks.MEAN){if(s==null)return rr(a);{let i=r.size/s.size,o=ot(ct(a),ct(s));return i>1?ot(o,bt(i)):o}}if(n===Ks.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ot(ct(a),bt(r.size));{let i=oe(s,fa(r.shape)),o=je(ct(ep(i,bt(0))),"float32");return ot(ct(a),o)}}throw Error(`Unknown reduction: ${n}`)}var Ru=se({computeWeightedLoss_:bYe});function vYe(e,t,n,r=Ks.SUM_BY_NONZERO_WEIGHTS){let s=X(e,"labels","absoluteDifference"),a=X(t,"predictions","absoluteDifference"),i=null;n!=null&&(i=X(n,"weights","absoluteDifference")),aa(s.shape,a.shape,"Error in absoluteDifference: ");let o=Ir(nt(s,a));return Ru(o,i,r)}var xYe=se({absoluteDifference_:vYe});function wYe(e,t,n,r,s=Ks.SUM_BY_NONZERO_WEIGHTS){let a=X(e,"labels","cosineDistance"),i=X(t,"predictions","cosineDistance"),o=null;r!=null&&(o=X(r,"weights","cosineDistance")),aa(a.shape,i.shape,"Error in cosineDistance: ");let l=bt(1),u=nt(l,ct(oe(a,i),n,!0));return Ru(u,o,s)}var kYe=se({cosineDistance_:wYe});function SYe(e,t,n,r=Ks.SUM_BY_NONZERO_WEIGHTS){let s=X(e,"labels","hingeLoss"),a=X(t,"predictions","hingeLoss"),i=null;n!=null&&(i=X(n,"weights","hingeLoss")),aa(s.shape,a.shape,"Error in hingeLoss: ");let o=bt(1);s=nt(oe(bt(2),s),o);let l=gn(nt(o,oe(s,a)));return Ru(l,i,r)}var IYe=se({hingeLoss_:SYe});function CYe(e,t,n,r=1,s=Ks.SUM_BY_NONZERO_WEIGHTS){let a=X(e,"labels","huberLoss"),i=X(t,"predictions","huberLoss"),o=null;n!=null&&(o=X(n,"weights","huberLoss")),aa(a.shape,i.shape,"Error in huberLoss: ");let l=bt(r),u=Ir(nt(i,a)),c=Vc(u,l),d=nt(u,c),h=De(oe(bt(.5),kn(c)),oe(l,d));return Ru(h,o,s)}var NYe=se({huberLoss_:CYe});function TYe(e,t,n,r=1e-7,s=Ks.SUM_BY_NONZERO_WEIGHTS){let a=X(e,"labels","logLoss"),i=X(t,"predictions","logLoss"),o=null;n!=null&&(o=X(n,"weights","logLoss")),aa(a.shape,i.shape,"Error in logLoss: ");let l=bt(1),u=bt(r),c=Fn(oe(a,Qa(De(i,u)))),d=oe(nt(l,a),Qa(De(nt(l,i),u))),h=nt(c,d);return Ru(h,o,s)}var $Ye=se({logLoss_:TYe});function EYe(e,t,n,r=Ks.SUM_BY_NONZERO_WEIGHTS){let s=X(e,"labels","meanSquaredError"),a=X(t,"predictions","meanSquaredError"),i=null;n!=null&&(i=X(n,"weights","meanSquaredError")),aa(s.shape,a.shape,"Error in meanSquaredError: ");let o=TT(s,a);return Ru(o,i,r)}var _Ye=se({meanSquaredError_:EYe});function AYe(e,t){let n=X(e,"labels","sigmoidCrossEntropyWithLogits"),r=X(t,"logits","sigmoidCrossEntropyWithLogits");aa(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");let s=gn(r),a=oe(r,n),i=Sw(Ms(Fn(Ir(r))));return De(nt(s,a),i)}function RYe(e,t,n,r=0,s=Ks.SUM_BY_NONZERO_WEIGHTS){let a=X(e,"multiClassLabels","sigmoidCrossEntropy"),i=X(t,"logits","sigmoidCrossEntropy"),o=null;if(n!=null&&(o=X(n,"weights","sigmoidCrossEntropy")),aa(a.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){let u=bt(r),c=bt(1),d=bt(.5);a=De(oe(a,nt(c,u)),oe(d,u))}let l=AYe(a,i);return Ru(l,o,s)}var DYe=se({sigmoidCrossEntropy_:RYe});function OYe(e,t,n=-1){if(n===-1&&(n=t.rank-1),n!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`);return Pl((r,s,a)=>{let i=Iw(s,[n],!0),o=nt(je(s,"float32"),i);a([r,o]);let l=Fn(oe(o,r));return{value:ct(l,[n]),gradFunc:(u,c)=>{let[d,h]=c,p=Qh(u.shape,[n]);return[oe(le(u,p),nt(je(d,"float32"),Ms(h))),oe(le(u,p),nt(Ms(h),je(d,"float32")))]}}})(e,t)}function FYe(e,t,n,r=0,s=Ks.SUM_BY_NONZERO_WEIGHTS){let a=X(e,"onehotLabels","softmaxCrossEntropy"),i=X(t,"logits","softmaxCrossEntropy"),o=null;if(n!=null&&(o=X(n,"weights","softmaxCrossEntropy")),aa(a.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){let u=bt(r),c=bt(1),d=bt(a.shape[1]);a=De(oe(a,nt(c,u)),ot(u,d))}let l=OYe(a,i);return Ru(l,o,s)}var MYe=se({softmaxCrossEntropy_:FYe});function PYe(e,t,n,r){let s=X(e,"indices","sparseFillEmptyRows","int32"),a=X(t,"values","sparseFillEmptyRows"),i=X(n,"denseShape","sparseFillEmptyRows","int32"),o=X(r,"defaultValue","sparseFillEmptyRows",a.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);let l={indices:s,values:a,denseShape:i,defaultValue:o},u=ne.runKernel(rw,l);return{outputIndices:u[0],outputValues:u[1],emptyRowIndicator:u[2],reverseIndexMap:u[3]}}var LYe=se({sparseFillEmptyRows_:PYe});function zYe(e,t,n){let r=X(e,"inputIndices","sparseReshape","int32"),s=X(t,"inputShape","sparseReshape","int32"),a=X(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);let i={inputIndices:r,inputShape:s,newShape:a},o=ne.runKernel(Eb,i);return{outputIndices:o[0],outputShape:o[1]}}var BYe=se({sparseReshape_:zYe});function WYe(e,t,n){let r=X(e,"data","sparseSegmentMean"),s=X(t,"indices","sparseSegmentMean","int32"),a=X(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return ne.runKernel(sw,i)}var VYe=se({sparseSegmentMean_:WYe});function UYe(e,t,n){let r=X(e,"data","sparseSegmentSum"),s=X(t,"indices","sparseSegmentSum","int32"),a=X(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);let i={data:r,indices:s,segmentIds:a};return ne.runKernel(aw,i)}var jYe=se({sparseSegmentSum_:UYe});function GYe(e,t,n,r,s,a,i,o){let l=X(e,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);let u=X(t,"dataSplits","stringNGrams");if(u.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let c={separator:n,nGramWidths:r,leftPad:s,rightPad:a,padWidth:i,preserveShortSequences:o},d={data:l,dataSplits:u},h=ne.runKernel(lw,d,c);return{nGrams:h[0],nGramsSplits:h[1]}}var HYe=se({stringNGrams_:GYe});function qYe(e,t,n=!0){let r=X(e,"input","stringSplit","string"),s=X(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);let a={skipEmpty:n},i={input:r,delimiter:s},o=ne.runKernel(uw,i,a);return{indices:o[0],values:o[1],shape:o[2]}}var KYe=se({stringSplit_:qYe});function XYe(e,t){let n=X(e,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let s={input:n};return ne.runKernel(cw,s,r)}var YYe=se({stringToHashBucketFast_:XYe});function JYe(e,t,n,r=!0){let s=X(e,"input","staticRegexReplace","string"),a={pattern:t,rewrite:n,replaceGlobal:r};return ne.runKernel(ow,{x:s},a)}var ZYe=se({staticRegexReplace_:JYe}),KQ={fft:_w,ifft:Gg,rfft:Aw,irfft:NT},XQ={hammingWindow:NXe,hannWindow:WQ,frame:VQ,stft:_Xe},di={flipLeftRight:OXe,grayscaleToRGB:MXe,resizeNearestNeighbor:qQ,resizeBilinear:HQ,rgbToGrayscale:LXe,rotateWithOffset:BXe,cropAndResize:RXe,nonMaxSuppression:VXe,nonMaxSuppressionAsync:YXe,nonMaxSuppressionWithScore:ZXe,nonMaxSuppressionWithScoreAsync:eYe,nonMaxSuppressionPadded:nYe,nonMaxSuppressionPaddedAsync:sYe,threshold:uYe,transform:dYe},UP={bandPart:pYe,gramSchmidt:mYe,qr:yYe},YQ={absoluteDifference:xYe,computeWeightedLoss:Ru,cosineDistance:kYe,hingeLoss:IYe,huberLoss:NYe,logLoss:$Ye,meanSquaredError:_Ye,sigmoidCrossEntropy:DYe,softmaxCrossEntropy:MYe},JQ={sparseFillEmptyRows:LYe,sparseReshape:BYe,sparseSegmentMean:VYe,sparseSegmentSum:jYe},ZQ={stringNGrams:HYe,stringSplit:KYe,stringToHashBucketFast:YYe,staticRegexReplace:ZYe},Be={};At(Be,{Serializable:()=>QQ,SerializationMap:()=>eee,getRegisteredName:()=>eJe,registerClass:()=>tee});var QYe=new Map,fR=new Map,QQ=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},eee=class Cm{constructor(){this.classNameMap={}}static getMap(){return Cm.instance==null&&(Cm.instance=new Cm),Cm.instance}static register(t){Cm.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function tee(e,t,n){J(e.className!=null,()=>"Class being registered does not have the static className property defined."),J(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),J(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);let r=n,s=t+">"+r;return eee.register(e),QYe.set(s,e),fR.set(e,s),e}function eJe(e){return fR.has(e)?fR.get(e):e.className}var Du=class extends QQ{minimize(e,t=!1,n){let{value:r,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return _t(s),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return tQ(e,t)}dispose(){this.iterations_!=null&&_t(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:bt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Du,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});var jP=class extends Du{static get className(){return"Adadelta"}constructor(e,t,n=null){super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t],s=!1;this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:ue(()=>Xt(r).variable(s))}),this.accumulatedUpdates[n]==null&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:ue(()=>Xt(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;ue(()=>{let l=De(oe(i,this.rho),oe(kn(a),1-this.rho)),u=oe(ot(Is(De(o,this.epsilon)),Is(De(i,this.epsilon))),a),c=De(oe(o,this.rho),oe(kn(u),1-this.rho));i.assign(l),o.assign(c);let d=De(oe(u,-this.learningRate),r);r.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_t(this.accumulatedGrads.map(e=>e.variable)),_t(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}},GP=class extends Du{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t];this.accumulatedGrads[n]==null&&(this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:ue(()=>Ka(r.shape,this.initialAccumulatorValue).variable(!1))});let s=Array.isArray(e)?e[n].tensor:e[t];if(s==null)return;let a=this.accumulatedGrads[n].variable;ue(()=>{let i=De(a,kn(s));a.assign(i);let o=De(oe(ot(s,Is(De(i,ne.backend.epsilon()))),-this.learningRate),r);r.assign(o)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_t(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}},HP=class extends Du{static get className(){return"Adam"}constructor(e,t,n,r=null){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ue(()=>{this.accBeta1=bt(t).variable(),this.accBeta2=bt(n).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ue(()=>{let n=nt(1,this.accBeta1),r=nt(1,this.accBeta2);t.forEach((s,a)=>{let i=ne.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:ue(()=>Xt(i).variable(o))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:ue(()=>Xt(i).variable(o))});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedSecondMoment[a].variable,d=De(oe(u,this.beta1),oe(l,1-this.beta1)),h=De(oe(c,this.beta2),oe(kn(l),1-this.beta2)),p=ot(d,n),f=ot(h,r);u.assign(d),c.assign(h);let m=De(oe(ot(p,De(Is(f),this.epsilon)),-this.learningRate),i);i.assign(m)}),this.accBeta1.assign(oe(this.accBeta1,this.beta1)),this.accBeta2.assign(oe(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&_t(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ue(()=>{this.accBeta1.assign(bu(this.beta1,this.iterations_+1)),this.accBeta2.assign(bu(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}},qP=class extends Du{static get className(){return"Adamax"}constructor(e,t,n,r=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=r,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ue(()=>{this.iteration=bt(0).variable(),this.accBeta1=bt(t).variable()}),r==null&&(this.epsilon=ne.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);ue(()=>{let n=nt(1,this.accBeta1),r=ot(-this.learningRate,De(oe(this.iteration,this.decay),1));t.forEach((s,a)=>{let i=ne.registeredVariables[s],o=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Xt(i).variable(o)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:Xt(i).variable(o)});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let u=this.accumulatedFirstMoment[a].variable,c=this.accumulatedWeightedInfNorm[a].variable,d=De(oe(u,this.beta1),oe(l,1-this.beta1)),h=oe(c,this.beta2),p=Ir(l),f=Wl(h,p);u.assign(d),c.assign(f);let m=De(oe(ot(r,n),ot(d,De(f,this.epsilon))),i);i.assign(m)}),this.iteration.assign(De(this.iteration,1)),this.accBeta1.assign(oe(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_t(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&_t(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}},LT=class extends Du{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=Array.isArray(e)?e[n].tensor:e[t];if(r==null)return;let s=ne.registeredVariables[t];ue(()=>{let a=De(oe(this.c,r),s);s.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Vr(bt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}},KP=class extends LT{static get className(){return"Momentum"}constructor(e,t,n=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=bt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t];this.accumulations[n]==null&&(this.accumulations[n]={originalName:`${t}/momentum`,variable:ue(()=>Xt(r).variable(!1))});let s=this.accumulations[n].variable,a=Array.isArray(e)?e[n].tensor:e[t];a!=null&&ue(()=>{let i,o=De(oe(this.m,s),a);this.useNesterov?i=De(oe(this.c,De(a,oe(o,this.m))),r):i=De(oe(this.c,o),r),s.assign(o),r.assign(i)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_t(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}},XP=class extends Du{static get className(){return"RMSProp"}constructor(e,t=.9,n=0,r=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,r==null&&(this.epsilon=ne.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,n)=>{let r=ne.registeredVariables[t],s=!1;this.accumulatedMeanSquares[n]==null&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:ue(()=>Xt(r).variable(s))}),this.accumulatedMoments[n]==null&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:ue(()=>Xt(r).variable(s))}),this.accumulatedMeanGrads[n]==null&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:ue(()=>Xt(r).variable(s))});let a=Array.isArray(e)?e[n].tensor:e[t];if(a==null)return;let i=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;ue(()=>{let l=De(oe(i,this.decay),oe(kn(a),1-this.decay));if(this.centered){let u=this.accumulatedMeanGrads[n].variable,c=De(oe(u,this.decay),oe(a,1-this.decay)),d=ot(oe(a,this.learningRate),Is(nt(l,De(kn(c),this.epsilon)))),h=De(oe(o,this.momentum),d);i.assign(l),u.assign(c),o.assign(h);let p=nt(r,h);r.assign(p)}else{let u=De(oe(i,this.decay),oe(kn(a),1-this.decay)),c=De(oe(o,this.momentum),ot(oe(a,this.learningRate),Is(De(u,this.epsilon))));i.assign(u),o.assign(c);let d=nt(r,c);r.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_t(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_t(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&_t(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}},tJe=[jP,GP,HP,qP,KP,XP,LT];function nJe(){for(let e of tJe)tee(e)}var ws={};At(ws,{CompositeArrayBuffer:()=>Eu,browserFiles:()=>uJe,browserHTTPRequest:()=>mJe,concatenateArrayBuffers:()=>U8e,copyModel:()=>dqe,decodeWeights:()=>TZ,decodeWeightsStream:()=>EZ,encodeWeights:()=>P8e,fromMemory:()=>yJe,fromMemorySync:()=>iee,getLoadHandlers:()=>J8e,getModelArtifactsForJSON:()=>MM,getModelArtifactsForJSONSync:()=>AZ,getModelArtifactsInfoForJSON:()=>yw,getSaveHandlers:()=>Y8e,getWeightSpecs:()=>lR,http:()=>JP,isHTTPScheme:()=>gR,listModels:()=>uqe,loadWeights:()=>dJe,moveModel:()=>hqe,registerLoadRouter:()=>X8e,registerSaveRouter:()=>K8e,removeModel:()=>cqe,weightsLoaderFactory:()=>ree,withSaveHandler:()=>bJe,withSaveHandlerSync:()=>vJe});var rJe="model",sJe=".json",aJe=".weights.bin";function Mj(e){return new Promise(t=>setTimeout(t)).then(e)}var tI=class mR{constructor(t){if(!xe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(mR.URL_SCHEME)&&(t=t.slice(mR.URL_SCHEME.length)),(t==null||t.length===0)&&(t=rJe),this.modelJsonFileName=t+sJe,this.weightDataFileName=t+aJe}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let n=Eu.join(t.weightData),r=window.URL.createObjectURL(new Blob([n],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a=_Z(t,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await Mj(()=>o.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=r,await Mj(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:yw(t)}}}};tI.URL_SCHEME="downloads://";var iJe=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=r=>{let s=JSON.parse(r.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let i=MM(s,o=>this.loadWeights(o));e(i)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let r=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,r[a]));return Promise.all(s).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((n,r)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>r(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>Dj(s.name)),r={};for(let s of e)s.paths.forEach(a=>{let i=Dj(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[a]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}},oJe=e=>xe().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(tI.URL_SCHEME)?lJe(e.slice(tI.URL_SCHEME.length)):null;Si.registerSaveRouter(oJe);function lJe(e="model"){return new tI(e)}function uJe(e){return new iJe(e)}function Pj(e,t,n,r){i(e),n=n??0,r=r??1,o(n,r);let s=0,a=l=>(l.then(u=>{let c=n+ ++s/e.length*(r-n);return t(c),u}),l);function i(l){J(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,u){J(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),J(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${u}`),J(u>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${u}`)}return Promise.all(e.map(a))}async function nee(e,t){t==null&&(t={});let n=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,r=e.map(a=>n(a,t.requestInit,{isBinary:!0})),s=(t.onProgress==null?await Promise.all(r):await Pj(r,t.onProgress,0,.5)).map(a=>a.arrayBuffer());return t.onProgress==null?await Promise.all(s):await Pj(s,t.onProgress,.5,1)}function cJe(e,t){var n;let r=t.fetchFunc==null?xe().platform.fetch:t.fetchFunc,s=0,a;return(n=t.onProgress)===null||n===void 0||n.call(t,0),new ReadableStream({pull:async i=>{for(var o;s<e.length;){a||(a=(await r(e[s],t.requestInit,{isBinary:!0})).body.getReader());let{done:l,value:u}=await a.read();if(l){s++,a=void 0,(o=t.onProgress)===null||o===void 0||o.call(t,s/e.length);continue}i.enqueue(u);return}i.close()}})}async function dJe(e,t="",n,r){return ree(s=>nee(s,{requestInit:r}))(e,t,n)}function ree(e){return async(t,n="",r)=>{let s=t.map(()=>!1),a={},i=r!=null?r.map(()=>!1):[],o=[];if(t.forEach((p,f)=>{let m=0;p.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,b=qh[y]*yn(g.shape),x=()=>{s[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:b})};r!=null?r.forEach((v,w)=>{v===g.name&&(x(),i[w]=!0)}):x(),o.push(g.name),m+=b})}),!i.every(p=>p)){let p=r.filter((f,m)=>!i[m]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}let l=s.reduce((p,f,m)=>(f&&p.push(m),p),[]),u=[];l.forEach(p=>{t[p].paths.forEach(f=>{let m=n+(n.endsWith("/")?"":"/")+f;u.push(m)})});let c=await e(u),d={},h=0;return l.forEach(p=>{let f=t[p].paths.length,m=new Eu(c.slice(h,h+f));a[p].forEach(g=>{let y=m.slice(g.groupOffset,g.groupOffset+g.sizeBytes),b=TZ(y,[g.manifestEntry]);for(let x in b)d[x]=b[x]}),h+=f}),d}}var hJe="application/octet-stream",pJe="application/json",YP=class{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(J(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=xe().platform.fetch,J(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&J(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=_Z(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:pJe}),"model.json"),e.weightData!=null){let a=Eu.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:hJe}),"model.weights.bin")}let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:yw(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();let e=await this.loadModelJSON();return MM(e,t=>this.loadWeights(t))}async loadStream(){let e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=lR(e.weightsManifest),r=()=>cJe(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=fJe(t),s=this.weightPathPrefix||n,a=[],i=[];for(let o of e)for(let l of o.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):a.push(s+l+r);return this.weightUrlConverter&&a.push(...await Promise.all(i)),a}async loadWeights(e){let t=await this.getWeightUrls(e),n=lR(e),r=await nee(t,this.loadOptions);return[n,r]}};YP.URL_SCHEME_REGEX=/^https?:\/\//;function fJe(e){let t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),r=e.substring(0,t),s=n>t?e.substring(n):"";return[r+"/",s]}function gR(e){return e.match(YP.URL_SCHEME_REGEX)!=null}var see=(e,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let n=!0;if(Array.isArray(e)?n=e.every(r=>gR(r)):n=gR(e),n)return JP(e,t)}return null};Si.registerSaveRouter(see);Si.registerLoadRouter(see);function JP(e,t){return new YP(e,t)}function mJe(e,t){return JP(e,t)}var FE=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},aee=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},gJe=class{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function yJe(e,t,n,r){let s=arguments;return new gJe(iee(...s))}function iee(e,t,n,r){return arguments.length===1?e.modelTopology!=null||e.weightSpecs!=null?new FE(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new FE({modelTopology:e})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new FE({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:r}))}function bJe(e){return new aee(e)}function vJe(e){return new aee(e)}var oee={};At(oee,{confusionMatrix:()=>wJe});function xJe(e,t,n){let r=X(e,"labels","confusionMatrix"),s=X(t,"predictions","confusionMatrix");J(n==null||n>0&&Number.isInteger(n),()=>`If provided, numClasses must be a positive integer, but got ${n}`),J(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),J(s.rank===1,()=>`Expected the rank of predictions to be 1, but got ${s.rank}`),J(r.shape[0]===s.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${s.shape[0]}. Labels and predictions should have the same number of elements.`),J(n>0&&Number.isInteger(n),()=>`numClasses is required to be a positive integer, but got ${n}`);let a=Vg(je(r,"int32"),n),i=Vg(je(s,"int32"),n),o=Lt(a),l=Mt(o,i);return je(l,"int32")}var wJe=se({confusionMatrix_:xJe}),Rw={};At(Rw,{draw:()=>EJe,fromPixels:()=>_Je,fromPixelsAsync:()=>NJe,toPixels:()=>$Je});var Dd,Lj=!1;function lee(e,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(e==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,s=!1,a=!1,i=!1,o=!1;if(e.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&e instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement)a=!0;else if(e.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&e instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${e.constructor.name}`);if(J1(YS,ne.backendName)!=null){let h={pixels:e},p={numChannels:t};return ne.runKernel(YS,h,p)}let[l,u]=s?[e.videoWidth,e.videoHeight]:[e.width,e.height],c;if(i)c=e.getContext("2d").getImageData(0,0,l,u).data;else if(r||n)c=e.data;else if(a||s||o){if(Dd==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Dd=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Dd=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Dd.canvas.width=l,Dd.canvas.height=u,Dd.drawImage(e,0,0,l,u),c=Dd.getImageData(0,0,l,u).data}let d;if(t===4)d=new Int32Array(c);else{let h=l*u;d=new Int32Array(h*t);for(let p=0;p<h;p++)for(let f=0;f<t;++f)d[p*t+f]=c[p*4+f]}return $T(d,[u,l,t],"int32")}function kJe(e){return e!=null&&e.data instanceof Uint8Array}function SJe(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function IJe(e){return e!=null&&e.width!==0&&e.height!==0}function CJe(e){return SJe()&&!(e instanceof ImageBitmap)&&IJe(e)&&!kJe(e)}async function NJe(e,t=3){let n=null;if(xe().getBool("WRAP_TO_IMAGEBITMAP")&&CJe(e)){let r;try{r=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===e.width&&r.height===e.height?n=r:n=e}else n=e;return lee(n,t)}function uee(e){if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let t=e.rank===2?1:e.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`)}function TJe(e){let t=(e==null?void 0:e.alpha)||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function $Je(e,t){let n=X(e,"img","toPixels");if(!(e instanceof Bt)){let u=n;n=je(u,"int32"),u.dispose()}uee(n);let[r,s]=n.shape.slice(0,2),a=n.rank===2?1:n.shape[2],i=await n.data(),o=n.dtype==="float32"?255:1,l=new Uint8ClampedArray(s*r*4);for(let u=0;u<r*s;++u){let c=[0,0,0,255];for(let h=0;h<a;h++){let p=i[u*a+h];if(n.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(n.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);a===1?(c[0]=p*o,c[1]=p*o,c[2]=p*o):c[h]=p*o}let d=u*4;l[d+0]=Math.round(c[0]),l[d+1]=Math.round(c[1]),l[d+2]=Math.round(c[2]),l[d+3]=Math.round(c[3])}if(t!=null){Lj||J1(XN,ne.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),Lj=!0),t.width=s,t.height=r;let u=t.getContext("2d"),c=new ImageData(l,s,r);u.putImageData(c,0,0)}return n!==e&&n.dispose(),l}function EJe(e,t,n){let r=X(e,"img","draw");if(!(e instanceof Bt)){let i=r;r=je(i,"int32"),i.dispose()}uee(r),TJe(n==null?void 0:n.imageOptions);let s={image:r},a={canvas:t,options:n};ne.runKernel(XN,s,a)}var _Je=se({fromPixels_:lee}),ZP={};At(ZP,{prepareAndValidate:()=>cee});function cee(e,t){let n=e.shape.length,r=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${n}`);if(yn(e.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);let s=t.shape,a=s[s.length-1],i=1;for(let d=0;d<s.length-1;++d)i*=s[d];let o=e.shape,l=s.slice();l.pop();let u=1;for(let d=a;d<n;++d)u*=o[d],l.push(o[d]);let c=[...Oy(e.shape).map(d=>d/u),1].slice(0,a);return[l,i,u,c]}var Hr={};At(Hr,{assertParamsValid:()=>RJe,computeFlatOffset:()=>PJe,computeOutShape:()=>OJe,getNormalizedAxes:()=>FJe,isSliceContinous:()=>MJe,maskToAxes:()=>DJe,parseSliceParams:()=>vee,sliceInfo:()=>LJe,startForAxis:()=>yee,startIndicesWithElidedDims:()=>fee,stopForAxis:()=>bee,stopIndicesWithElidedDims:()=>mee,stridesForAxis:()=>gee,stridesWithElidedDims:()=>dee});var yR=-2,AJe=-1;function RJe(e,t,n){let r=e.shape.length;J(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),J(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)J(t[s]+n[s]<=e.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${t[s]+n[s]}) would overflow input.shape[${s}] (${e.shape[s]})`)}function DJe(e){let t=[],n=0;for(;e>0;)e&1&&t.push(n),e/=2,n++;return t}function OJe(e,t,n){let r=[];for(let s=0;s<e.length;s++)r[s]=Math.ceil((t[s]-e[s])/n[s]);return r}function dee(e,t,n,r){let s=[...e];for(let a=s.length;a<r.length;a++)s.push(1);for(let a=0;a<n;a++)a===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function hee(e,t,n){return n<=e?n:n-(t-1)}function pee(e,t){let n=[];for(let r=0;r<e;r++)n.push(t+r);return n}function FJe(e,t,n,r,s,a,i,o,l){let u=e.length,c=new Array(u),d=new Array(u),h=new Array(u);if(t.length&&n>0){let p=t[0],f=n+1;c=fee(i,p,f,r,e),d=mee(o,p,f,s,e),h=dee(a,p,f,e)}else for(let p=0;p<u;p++)c[p]=yee(i,r,a,e,p,l),d[p]=bee(o,s,a,e,p,l),h[p]=gee(a,p,l);return{begin:c,end:d,strides:h}}function fee(e,t,n,r,s){let a=[...s],i=pee(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=0;else{let l=hee(t,n,o),u=r[l];e&1<<l&&(u=0),a[o]=u}return a}function mee(e,t,n,r,s){let a=[...s],i=pee(n,t);for(let o=0;o<a.length;o++)if(i.indexOf(o)>-1)a[o]=Number.MAX_SAFE_INTEGER;else{let l=hee(t,n,o),u=r[l];e&1<<l&&(u=Number.MAX_SAFE_INTEGER),a[o]=u}for(let o=0;o<a.length;o++){let l=s[o];a[o]<0&&(a[o]+=l),a[o]=X1(0,a[o],s[o])}return a}function gee(e,t,n){let r=e[t];return(n&1<<t||r==null)&&(r=1),r}function yee(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let l=r[s];return i<0&&(i+=l),i=X1(0,i,l-1),i}function bee(e,t,n,r,s,a){let i=t[s],o=n[s]||1;(e&1<<s||a&1<<s||i==null)&&(o>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let l=r[s];return i<0&&(i+=l),o>0?i=X1(0,i,l):i=X1(-1,i,l-1),i}function MJe(e,t,n){let r=n.length;for(let s=0;s<n.length;s++)if(n[s]>1){r=s;break}for(let s=r+1;s<n.length;s++)if(t[s]>0||n[s]!==e[s])return!1;return!0}function PJe(e,t){let n=e.length>0?e[e.length-1]:1;for(let r=0;r<e.length-1;r++)n+=e[r]*t[r];return n}function vee(e,t,n){let r,s=e.shape.length;typeof t=="number"?r=[t,...new Array(s-1).fill(0)]:t.length<s?r=t.concat(new Array(s-t.length).fill(0)):r=t.slice(),r.forEach(i=>{J(i!==-1,()=>"slice() does not support negative begin indexing.")});let a;return n==null?a=new Array(s).fill(-1):typeof n=="number"?a=[n,...new Array(s-1).fill(-1)]:n.length<s?a=n.concat(new Array(s-n.length).fill(-1)):a=n,a=a.map((i,o)=>i>=0?i:(J(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${o}.`),e.shape[o]-r[o])),[r,a]}function LJe(e,t,n,r,s,a,i,o,l){let u;if(r==null?(u=new Array(t.length),u.fill(1)):u=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let c=!1,d={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:s,endMask:a,ellipsisMask:i,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<d.dims;b++)c&&1<<b&o&&d.numAddAxisAfterEllipsis++,1<<b&i&&(c=!0);c||(d.ellipsisMask|=1<<d.dims,d.dims++);let h={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};zJe(d,h);let p=!0,f=!0,m=!0,g=[],y=[];for(let b=0;b<e.length;++b){if(h.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);let x=!!(h.shrinkAxisMask&1<<b),v=e[b];if(v===-1){g.push(x?1:-1);continue}let w=[h.beginMask&1<<b,h.endMask&1<<b],k=[h.strides[b]>0?0:-1,h.strides[b]>0?v:v-1];if(x&&h.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&h.strides[b]===1;let S=!!(h.beginMask&1<<b&&h.endMask&1<<b);if(h.beginValid&&h.endValid){if(x){let T=h.begin[b]<0?v+h.begin[b]:h.begin[b];if(h.begin[b]=T,h.end[b]=h.begin[b]+1,T<0||T>=v)throw Error(`slice index ${h.begin[b]} of dimension ${b} out of bounds.`)}else h.begin[b]=zj(h.begin[b],0,h.strides[b],v,w,k),h.end[b]=zj(h.end[b],1,h.strides[b],v,w,k);let C=h.strides[b]===1&&h.begin[b]===0&&h.end[b]===v;p=p&&C,f=f&&(b===0&&h.strides[b]===1||C)}else p=p&&h.strides[b]===1&&S,f=f&&(b===0&&h.strides[b]===1||S);let I,$=!1;if(h.beginValid&&h.endValid?(I=h.end[b]-h.begin[b],$=!0):x?(I=1,$=!0):S&&v>=0&&(h.strides[b]<0?I=-v:I=v,$=!0),$){let C;I===0||I<0!=h.strides[b]<0?C=0:C=Math.trunc(I/h.strides[b])+(I%h.strides[b]!==0?1:0),g.push(C)}else g.push(-1)}for(let b=0;b<h.finalShapeGatherIndices.length;++b){let x=h.finalShapeGatherIndices[b];x>=0?y.push(g[x]):x===yR&&y.push(1)}return{finalShapeSparse:y.filter((b,x)=>h.finalShapeGatherIndices[x]!==yR),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:h.begin,end:h.end,strides:h.strides}}function zJe(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null,t.endValid=e.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<e.dims;r++)if(1<<r&e.ellipsisMask){let s=Math.min(t.dims-(e.dims-r)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<s;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&e.newAxisMask)t.finalShapeGatherIndices.push(yR),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);e.begin!=null&&(t.begin[n]=e.begin[r]),e.end!=null&&(t.end[n]=e.end[r]),t.strides[n]=e.strides[r],e.beginMask&1<<r&&(t.beginMask|=1<<n),e.endMask&1<<r&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(AJe),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[n]=r,n++}}function zj(e,t,n,r,s,a){if(s[t])return n>0?a[t]:a[t+1&1];{let i=e<0?r+e:e;return i<a[0]?a[0]:i>a[1]?a[1]:i}}var BJe="4.16.0",xee=class{static sgd(e){return new LT(e)}static momentum(e,t,n=!1){return new KP(e,t,n)}static rmsprop(e,t=.9,n=0,r=null,s=!1){return new XP(e,t,n,r,s)}static adam(e=.001,t=.9,n=.999,r=null){return new HP(e,t,n,r)}static adadelta(e=.001,t=.95,n=null){return new jP(e,t,n)}static adamax(e=.002,t=.9,n=.999,r=null,s=0){return new qP(e,t,n,r,s)}static adagrad(e,t=.1){return new GP(e,t)}},Vd=xee,WJe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:e=>e();function QP(){return new Promise(e=>WJe(()=>e()))}var H={};At(H,{ERF_A1:()=>nZe,ERF_A2:()=>rZe,ERF_A3:()=>sZe,ERF_A4:()=>aZe,ERF_A5:()=>iZe,ERF_P:()=>tZe,PARALLELIZE_THRESHOLD:()=>eL,RowPartitionType:()=>cl,SELU_SCALE:()=>kee,SELU_SCALEALPHA:()=>wee,applyActivation:()=>MT,assertAndGetBroadcastShape:()=>Nn,assertAxesAreInnerMostDims:()=>L9e,assertParamsConsistent:()=>VJe,assignToTypedArray:()=>hZe,axesAreInnerMostDims:()=>dP,calculateShapes:()=>EQ,checkEinsumDimSizes:()=>bZe,checkPadOnDimRoundingMode:()=>ia,combineLocations:()=>YZ,combineRaggedTensorToTensorShapes:()=>jJe,complexWithEvenIndex:()=>uZe,complexWithOddIndex:()=>cZe,computeConv2DInfo:()=>bw,computeConv3DInfo:()=>WZ,computeDefaultPad:()=>HM,computeDilation2DInfo:()=>Mqe,computeOptimalWindowSize:()=>KJe,computeOutAndReduceShapes:()=>JZ,computeOutShape:()=>UJe,computePool2DInfo:()=>BZ,computePool3DInfo:()=>Pqe,convertConv2DDataFormat:()=>VZ,decodeEinsumEquation:()=>gZe,eitherStridesOrDilationsAreOne:()=>Bl,expandShapeToKeepDim:()=>Qh,exponent:()=>fZe,exponents:()=>pZe,fromStringArrayToUint8:()=>zZe,fromUint8ToStringArray:()=>LZe,getAxesPermutation:()=>ZZ,getBroadcastDims:()=>KZ,getComplexWithIndex:()=>dZe,getEinsumComputePath:()=>vZe,getEinsumPermutation:()=>yZe,getFusedBiasGradient:()=>FT,getFusedDyActivation:()=>OT,getImageCenter:()=>XJe,getInnerMostAxes:()=>z9e,getPermuted:()=>JJe,getRaggedRank:()=>HJe,getReductionAxes:()=>Rr,getReshaped:()=>YJe,getReshapedPermuted:()=>ZJe,getRowPartitionTypesHelper:()=>GJe,getSliceBeginCoords:()=>QJe,getSliceSize:()=>eZe,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>SZe,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>IZe,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>CZe,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>$Ze,getSparseReshapeInputOutputMismatchErrorMessage:()=>_Ze,getSparseReshapeInputOutputMultipleErrorMessage:()=>EZe,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>NZe,getSparseReshapeNegativeOutputDimErrorMessage:()=>TZe,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>OZe,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>AZe,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>RZe,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>DZe,getUndoAxesPermutation:()=>hP,isIdentityPermutation:()=>xZe,log:()=>KHe,mergeRealAndImagArrays:()=>oZe,prepareAndValidate:()=>cee,prepareSplitSize:()=>kZe,segment_util:()=>See,shouldFuse:()=>PT,slice_util:()=>Hr,splitRealAndImagArrays:()=>lZe,stridesOrDilationsArePositive:()=>Jh,tupleValuesAreOne:()=>Wc,upcastType:()=>ki,validateDefaultValueShape:()=>qJe,validateInput:()=>_T,validateUpdateShape:()=>OP,warn:()=>Zu});function VJe(e,t){let n=e[0].length;e.forEach((s,a)=>{J(s.length===n,()=>`Error in concat${n}D: rank of tensors[${a}] must be the same as the rank of the rest (${n})`)}),J(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);let r=e[0];e.forEach((s,a)=>{for(let i=0;i<n;i++)J(i===t||s[i]===r[i],()=>`Error in concat${n}D: Shape of tensors[${a}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${a}.`)})}function UJe(e,t){let n=e[0].slice();for(let r=1;r<e.length;r++)n[t]+=e[r][t];return n}var cl;(function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"})(cl||(cl={}));function jJe(e,t,n){let r=new Array;if(n==null&&t==null)return r;if(t==null)for(;r.length<e+n.length;)r.push(-1);else r=t.slice();if(n==null)return r;if(e+n.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${r.length}`);for(let s=1;s<n.length;++s){let a=n[s],i=r[r.length-n.length+s],o=r[i];if(a>=0)if(o>=0){if(o!==a)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${s+e}] = ${a} but shape[${s+e}] = ${o}`)}else r[i]=a}return r}function GJe(e){let t={FIRST_DIM_SIZE:cl.FIRST_DIM_SIZE,VALUE_ROWIDS:cl.VALUE_ROWIDS,ROW_LENGTHS:cl.ROW_LENGTHS,ROW_SPLITS:cl.ROW_SPLITS,ROW_LIMITS:cl.ROW_LIMITS,ROW_STARTS:cl.ROW_STARTS},n=[];for(let r of e)if(r in t)n.push(t[r]);else break;return n}function HJe(e){return e.length===0?0:e[0]===cl.FIRST_DIM_SIZE?e.length-1:e.length}function qJe(e,t){if(e==null||t==null)return;let n=e.length,r=t.length;if(n>=r)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(n,r-1);++s){let a=e[s],i=t[s+1];if(a>=0&&i>=0&&a!==1&&a!==i)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${s-e.length}] = ${a} but ragged tensor input.flatValues.shape[${s-e.length}] = ${i}`)}}var eL=30;function KJe(e){return e<=eL?e:XS(e,Math.floor(Math.sqrt(e)))}function XJe(e,t,n){let r=n*(typeof e=="number"?e:e[0]),s=t*(typeof e=="number"?e:e[1]);return[r,s]}function YJe(e,t,n,r=!0){let s=[];if(r)s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);let a=t.length;for(let i=0;i<a;++i)s=s.concat([e[i+1]/t[i],t[i]]);s=s.concat(e.slice(a+1))}return s}function JJe(e,t,n=!0){let r=[];if(n){r.push(t);for(let s=t+1;s<e;++s)s<=2*t?(r.push(s),r.push(s-(t+1))):r.push(s)}else{let s=[],a=[];for(let i=1;i<e;++i)i>=t*2+1||i%2===1?a.push(i):s.push(i);r.push(...s),r.push(0),r.push(...a)}return r}function ZJe(e,t,n,r=!0){let s=[];r?s.push(e[0]/n):s.push(e[0]*n);for(let a=1;a<e.length;++a)a<=t.length?r?s.push(t[a-1]*e[a]):s.push(e[a]/t[a-1]):s.push(e[a]);return s}function QJe(e,t){let n=[0];for(let r=0;r<t;++r)n.push(e[r][0]);return n}function eZe(e,t,n){let r=e.slice(0,1);for(let s=0;s<n;++s)r.push(e[s+1]-t[s][0]-t[s][1]);return r}var wee=1.7580993408473768,kee=1.0507009873554805,tZe=.3275911,nZe=.254829592,rZe=-.284496736,sZe=1.421413741,aZe=-1.453152027,iZe=1.061405429;function oZe(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);let n=new Float32Array(e.length*2);for(let r=0;r<n.length;r+=2)n[r]=e[r/2],n[r+1]=t[r/2];return n}function lZe(e){let t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let r=0;r<e.length;r+=2)t[r/2]=e[r],n[r/2]=e[r+1];return{real:t,imag:n}}function uZe(e){let t=Math.ceil(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=0;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function cZe(e){let t=Math.floor(e.length/4),n=new Float32Array(t),r=new Float32Array(t);for(let s=2;s<e.length;s+=4)n[Math.floor(s/4)]=e[s],r[Math.floor(s/4)]=e[s+1];return{real:n,imag:r}}function dZe(e,t){let n=e[t*2],r=e[t*2+1];return{real:n,imag:r}}function hZe(e,t,n,r){e[r*2]=t,e[r*2+1]=n}function pZe(e,t){let n=new Float32Array(e/2),r=new Float32Array(e/2);for(let s=0;s<Math.ceil(e/2);s++){let a=(t?2:-2)*Math.PI*(s/e);n[s]=Math.cos(a),r[s]=Math.sin(a)}return{real:n,imag:r}}function fZe(e,t,n){let r=(n?2:-2)*Math.PI*(e/t),s=Math.cos(r),a=Math.sin(r);return{real:s,imag:a}}var ME="->",mZe=/->/g,Bj=",",Wj="...";function gZe(e,t){e=e.replace(/\s/g,"");let n=(e.length-e.replace(mZe,"").length)/ME.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${ME}").`);let[r,s]=e.split(ME);J(r.indexOf(Wj)===-1,()=>`The ellipsis notation ("${Wj}") is not supported yet.`);let a=r.split(Bj),i=a.length;if(t!==i)throw new Error(`Expected ${i} input tensors, received ${t}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let o=[];for(let h=0;h<s.length;++h){let p=s[h];if(!a.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let h=0;h<r.length;++h){let p=r[h];o.indexOf(p)===-1&&p!==Bj&&o.push(p)}let l=new Array(a.length);for(let h=0;h<i;++h){if(new Set(a[h].split("")).size!==a[h].length)throw new Error(`Found duplicate axes in input component ${a[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let p=0;p<a[h].length;++p)l[h].push(o.indexOf(a[h][p]))}let u=o.length,c=s.length,d=[];for(let h=c;h<u;++h)d.push(h);return{allDims:o,summedDims:d,idDims:l}}function yZe(e,t){let n=new Array(e);n.fill(-1);for(let s=0;s<t.length;++s)n[t[s]]=s;let r=[];for(let s=0;s<e;++s)n[s]===-1&&r.push(s);return n=n.filter(s=>s!==-1),{permutationIndices:n,expandDims:r}}function bZe(e,t,n){let r=new Array(e);for(let s=0;s<n.length;++s){let a=n[s].shape;for(let i=0;i<t[s].length;++i)r[t[s][i]]===void 0?r[t[s][i]]=a[i]:J(r[t[s][i]]===a[i],()=>`Expected dimension ${r[t[s][i]]} at axis ${i} of input shaped ${JSON.stringify(a)}, but got dimension ${a[i]}`)}}function vZe(e,t){let n=e,r=[],s=0;e.length===0&&n.push(-1),s=e.length+1;for(let i=0;i<s;++i)r.push([]);let a=[];for(let i=0;i<n.length;++i){let o=n[i],l=wZe(t,o);for(let u of l)a.indexOf(u)===-1&&(r[i].push(u),a.push(u))}return{path:n,steps:r}}function xZe(e){return e.every((t,n)=>t===n)}function wZe(e,t){let n=[];for(let r=0;r<e.length;++r)(e[r].length===0||e[r].indexOf(t)!==-1||t===-1)&&n.push(r);return n}function kZe(e,t,n=0){let r=[];if(typeof t=="number")J(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(e.shape[n]/t);else{let s=t.reduce((i,o)=>(o===-1&&(i+=1),i),0);J(s<=1,()=>"There should be only one negative value in split array.");let a=t.indexOf(-1);if(a!==-1){let i=t.reduce((o,l)=>l>0?o+l:o);t[a]=e.shape[n]-i}J(e.shape[n]===t.reduce((i,o)=>i+o),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function SZe(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function IZe(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function CZe(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function NZe(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function TZe(e,t){return`size ${e} must be non-negative, not ${t}`}function $Ze(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function EZe(e,t){let n=yn(e),r=yn(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${e} outputShape= ${t}`}function _Ze(e,t){let n=yn(e),r=yn(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${e} outputShape=${t}`}function AZe(){return"segment ids must be >= 0"}function RZe(){return"segment ids are not increasing"}function DZe(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function OZe(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}var See={};At(See,{collectGatherOpShapeInfo:()=>PZe,computeOutShape:()=>MZe,segOpComputeOptimalWindowSize:()=>FZe});function FZe(e,t){let n=!1,r;for(e<=eL?(r=e,n=!0):r=XS(e,Math.floor(Math.sqrt(e)));!n;)r>t||r===e?n=!0:r=XS(e,r+1);return r}function MZe(e,t,n){let r=[],s=e.length;for(let a=0;a<s;a++)a!==t?r.push(e[a]):r.push(n);return r}function PZe(e,t,n,r){let s=t.shape.length,a=e.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>a)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${a}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(e.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${e.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);let i=e.shape[n],o=[],l=1,u=1,c=1;for(let d=0;d<r;++d)o.push(e.shape[d]),l*=e.shape[d];for(let d=r;d<n;d++)o.push(e.shape[d]),u*=e.shape[d];for(let d=r;d<s;d++)o.push(t.shape[d]);for(let d=n+1;d<a;d++)o.push(e.shape[d]),c*=e.shape[d];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:i,outputShape:o}}function LZe(e){try{return e.map(t=>ZS(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function zZe(e){return e.map(t=>mw(t))}var Vl={};At(Vl,{nonMaxSuppressionV3Impl:()=>UQ,nonMaxSuppressionV4Impl:()=>jQ,nonMaxSuppressionV5Impl:()=>GQ,whereImpl:()=>RQ});nJe();var Iee={kernelName:Fy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,Yf(je(n,"float32"),-1))}}},BZe={kernelName:Tp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=kn(je(n,"float32")),s=Is(nt(bt(1),r));return Fn(ot(e,s))}}}},WZe={kernelName:$p,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Is(nt(kn(je(n,"float32")),1));return ot(e,r)}}}},VZe={kernelName:fd,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Nn(n.shape,r.shape);return{a:()=>{let a=e,i=Rr(n.shape,s);return i.length>0&&(a=ct(a,i)),le(a,n.shape)},b:()=>{let a=e,i=Rr(r.shape,s);return i.length>0&&(a=ct(a,i)),le(a,r.shape)}}}},UZe={kernelName:Ep,saveAllInputs:!0,gradFunc:(e,t)=>{let n={};return t.forEach((r,s)=>{n[s]=()=>e.clone()}),n}},jZe={kernelName:Ly,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Xt(n)}}},GZe={kernelName:zy,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Xt(n)}}},HZe={kernelName:_p,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,Is(nt(bt(1),kn(je(n,"float32")))))}}},qZe={kernelName:Ap,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=Is(De(bt(1),kn(je(n,"float32"))));return ot(e,r)}}}},KZe={kernelName:Op,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Nn(n.shape,r.shape);return{a:()=>{let a=De(kn(n),kn(r)),i=oe(e,ot(r,a)),o=Rr(n.shape,s);return o.length>0&&(i=ct(i,o)),le(i,n.shape)},b:()=>{let a=De(kn(n),kn(r)),i=Fn(oe(e,ot(n,a))),o=Rr(r.shape,s);return o.length>0&&(i=ct(i,o)),le(i,r.shape)}}}},XZe={kernelName:Rp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,De(kn(je(n,"float32")),1))}}},YZe={kernelName:Dp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,nt(bt(1),kn(je(n,"float32"))))}}};function JZe(e,t,n,r,s,a){let i=X(e,"dy","avgPool3dGrad"),o=X(t,"input","avgPool3dGrad"),l=i,u=o,c=!1;o.rank===4&&(c=!0,l=le(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),u=le(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),J(u.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`),ia("avgPool3dGrad",s,a);let d={dy:l,input:u},h={filterSize:n,strides:r,pad:s,dimRoundingMode:a},p=ne.runKernel(qx,d,h);return c?le(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}var ZZe=se({avgPool3dGrad_:JZe}),QZe={kernelName:By,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:o}=n;return{x:()=>ZZe(e,r,s,a,i,o)}}};function eQe(e,t,n,r,s){let a=X(e,"dy","avgPoolGrad"),i=X(t,"input","avgPoolGrad");J(i.rank===a.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${a.rank})`);let o=i,l=a,u=!1;i.rank===3&&(u=!0,o=le(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=le(a,[1,a.shape[0],a.shape[1],a.shape[2]])),J(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),J(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);let c={dy:l,input:o},d={filterSize:n,strides:r,pad:s},h=ne.runKernel(Hx,c,d);return u?le(h,[h.shape[1],h.shape[2],h.shape[3]]):h}var tQe=se({avgPoolGrad_:eQe}),nQe={kernelName:Fp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{filterSize:s,strides:a,pad:i}=n;return{x:()=>tQe(e,r,s,a,i)}}},rQe={kernelName:Mp,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{let[r,s]=t,{transposeA:a,transposeB:i}=n;return!a&&!i?{a:()=>Mt(e,s,!1,!0),b:()=>Mt(r,e,!0,!1)}:!a&&i?{a:()=>Mt(e,s,!1,!1),b:()=>Mt(e,r,!0,!1)}:a&&!i?{a:()=>Mt(s,e,!1,!0),b:()=>Mt(r,e,!1,!1)}:{a:()=>Mt(s,e,!0,!0),b:()=>Mt(e,r,!0,!0)}}},sQe={kernelName:Wy,gradFunc:(e,t,n)=>{let{blockShape:r,crops:s}=n;return{x:()=>Tw(e,r,s)}}},aQe={kernelName:uZ,gradFunc:(e,t,n)=>{let r=n,s=r.inputShape,a=r.shape,i=Array.from(a);for(let l=s.length-1;l>=0;l--)if(s[l]===a[l])i[l]=1;else if(s[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${a}].`);let o=[];for(let l=0;l<i.length;l++)i[l]>1&&o.push(l);return{x:()=>ct(e,o,!0)}}},iQe={kernelName:Pp,gradFunc:e=>({x:()=>e.clone()})},oQe={kernelName:Lp,gradFunc:e=>({x:()=>Xt(e)})},lQe={kernelName:md,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{clipValueMin:s,clipValueMax:a}=n;return{x:()=>ds(eo(Au(r,s),vd(r,a)),e,Xt(e))}}},uQe={kernelName:Xx,inputsToSave:["x"],gradFunc:Iee.gradFunc},cQe={kernelName:jy,saveAllInputs:!0,gradFunc:(e,t,n)=>{let r=t.map(o=>o.shape),{axis:s}=n,a=ao(s,t[0].shape)[0],i=r.map(o=>o[a]);return ya(e,i,a).map(o=>()=>o)}},dQe={kernelName:zp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{dilations:a,strides:i,pad:o,dataFormat:l}=n;return J(Wc(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>rP(r.shape,e,s,i,o,l),filter:()=>WP(r,e,s.shape,i,o,l)}}},hQe={kernelName:Bp,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,{strides:a,pad:i,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>ta(e,s,a,i,o,1,l),filter:()=>WP(e,r,s.shape,a,i,o,l)}}};function pQe(e,t,n,r,s){let a=e;e.rank===4&&(a=le(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let i=t;i.rank===4&&(i=le(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),J(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),J(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),J(n.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`),J(a.shape[4]===n[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${n[3]}.`),J(i.shape[4]===n[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${n[4]}).`);let o={x:a,dy:i},l={strides:r,pad:s,filterShape:n};return ne.runKernel(Gy,o,l)}var fQe=se({conv3DBackpropFilter_:pQe}),mQe={kernelName:Wp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a}=n;J(Wc(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);let[i,o]=t;return{x:()=>HZ(i.shape,e,o,s,a),filter:()=>fQe(i,e,o.shape,s,a)}}},gQe={kernelName:Vp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(Fn(ST(je(n,"float32"))),e)}}},yQe={kernelName:Up,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(IT(je(n,"float32")),e)}}},bQe={kernelName:jp,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s,exclusive:a,reverse:i}=n;return{x:()=>{let o=ZZ([s],r.rank),l=hT(e,s,a,!i);return o!=null&&(l=Lt(l,o)),l}}}},vQe={kernelName:Gp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let{dilations:r,strides:s,pad:a,dimRoundingMode:i}=n,o=r??[1,1];J(Wc(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[l,u]=t;return J(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),J(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`),J(l.shape[3]===u.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),J(Bl(s,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${o}'.`),ia("depthwiseConv2d",a,i),{x:()=>BQ(l.shape,e,u,s,a,o,i),filter:()=>zQ(l,e,u.shape,s,a,o,i)}}},xQe={kernelName:Hp,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{let[r,s]=t,a={x:r,filter:s,dy:e},i={x:r,filter:s,dy:e};return{x:()=>ne.runKernel(Pg,a,n),filter:()=>ne.runKernel(Lg,i,n)}}},wQe={kernelName:Kp,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t,r={dy:e,y:n};return{x:()=>ne.runKernel(Yy,r)}}},kQe={kernelName:Xp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=oe(Ms(Fn(kn(n))),2/Math.sqrt(Math.PI));return{x:()=>oe(e,r)}}},SQe={kernelName:Yp,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,n)}}},IQe={kernelName:Zy,inputsToSave:["input"],gradFunc:(e,t)=>{let[n]=t;return{input:()=>le(e,n.shape)}}},CQe={kernelName:Jp,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,Ms(n))}}},NQe={kernelName:Zp,gradFunc:e=>({x:()=>Xt(e)})},TQe={kernelName:Qp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Nn(n.shape,r.shape);return{a:()=>{let a=ot(e,je(r,"float32")),i=Rr(n.shape,s);return i.length>0?le(ct(a,i),n.shape):a},b:()=>{let a=oe(e,je(n,"float32")),i=Rr(r.shape,s);i.length>0&&(a=le(ct(a,i),r.shape));let o=kn(r);return Fn(ot(a,je(o,"float32")))}}}},$Qe={kernelName:ef,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{let{varianceEpsilon:r}=n,[s,a,i,o]=t,l=o??bt(1),u=Rr(a.shape,s.shape),c=[];if(a.rank===1){for(let m=0;m<s.shape.length-1;++m)c.push(s.shape[m]);c.push(1)}let d=nt(s,a),h=oe(e,l),p=wT(De(i,bt(r))),f=oe(oe(oe(p,p),p),bt(-.5));return{x:()=>a.rank===1?le(oe(oe(e,ja(le(p,[1,1,1,a.shape[0]]),c)),l),s.shape):le(oe(oe(e,p),l),s.shape),mean:()=>{let m=oe(oe(p,bt(-1)),h);return a.rank===1&&(m=ct(m,u)),le(m,a.shape)},variance:()=>{let m=oe(oe(f,d),h);return a.rank===1&&(m=ct(m,u)),le(m,a.shape)},scale:()=>{let m=oe(d,p),g=oe(e,m);return a.rank===1&&(g=ct(g,u)),le(g,a.shape)},offset:()=>{let m=e;return a.rank===1&&(m=ct(m,u)),le(m,a.shape)}}}},EQe={kernelName:eb,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{let[r,s]=t,{axis:a,batchDims:i}=n,o=ao(a,r.shape)[0],l=(u,c,d)=>()=>{let h=u.shape,p=c.size,f=h.slice(0,o),m=f.length,g=h.slice(a,h.length).slice(1),y=g.length,b=Vj(0,m),x=Vj(m+1,m+1+y),v=Uj([f,[p],g]),w=le(d,v),k=le(c,[p]),S=Uj([[m],b,x]),I=Lt(w,S),$=RT(I,k,u.shape[o]),C=hP(S);return $=Lt($,C),$};if(i===1){let u=r.shape[0],c=r.split(u,0);return{x:()=>_r(c.map((d,h)=>l(d,s.slice(h,1),e.slice(h,1))())).reshape(r.shape),indices:()=>s}}else return{x:l(r,s,e),indices:()=>s}}};function Vj(e,t){let n=[];for(let r=e;r<t;++r)n.push(r);return n}function Uj(e){let t=[];for(let n=0;n<e.length;++n)for(let r=0;r<e[n].length;++r)t.push(e[n][r]);return t}var _Qe={kernelName:nf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>Xt(n),b:()=>Xt(r)}}},AQe={kernelName:rf,gradFunc:e=>({x:()=>je(e,"float32")})},RQe={kernelName:sf,gradFunc:e=>({x:()=>Xt(e)})},DQe={kernelName:af,gradFunc:e=>({x:()=>Xt(e)})},OQe={kernelName:of,gradFunc:e=>({x:()=>Xt(e)})},FQe={kernelName:lf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{alpha:s}=n,a=oa(r,0);return{x:()=>ds(a,e,oe(e,s))}}},MQe={kernelName:cf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,De(n,1))}}},PQe={kernelName:uf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,je(n,"float32"))}}},LQe={kernelName:dZ,inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n;return{logits:()=>{let a=Ms(r);return nt(e,oe(ct(e,s,!0),a))}}}};function zQe(e,t,n,r=5,s=1,a=1,i=.5){let o={x:e,y:t,dy:n},l={depthRadius:r,bias:s,alpha:a,beta:i};return ne.runKernel(ub,o,l)}var BQe=se({localResponseNormalizationBackprop_:zQe}),WQe={kernelName:df,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{depthRadius:a,bias:i,alpha:o,beta:l}=n;return{x:()=>BQe(r,s,e,a,i,o,l)}}};function Cee(e,t,n,r){return t.rank<n.rank&&(t=le(t,Qh(t.shape,r))),e.rank<n.rank&&(e=le(e,Qh(e.shape,r))),{x:()=>oe(e,je(Za(n,t),e.dtype))}}var jj={kernelName:hf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{reductionIndices:s}=r,a=t[0],i=t[1],o=ao(s,a.shape),l=Cee(e,i,a,o);return{x:()=>l.x()}}},VQe={kernelName:pf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>oe(e,je(Au(n,r),"float32")),b:()=>oe(e,je(Wg(n,r),"float32"))}}};function UQe(e,t,n,r,s,a,i){let o=X(e,"dy","maxPool3dGrad"),l=X(t,"input","maxPool3dGrad"),u=X(n,"output","maxPool3dGrad"),c=o,d=l,h=u,p=!1;l.rank===4&&(p=!0,c=le(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),d=le(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),h=le(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),J(c.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),J(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),J(h.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${h.rank}.`),ia("maxPool3dGrad",a,i);let f={dy:c,input:d,output:h},m={filterSize:r,strides:s,pad:a,dimRoundingMode:i},g=ne.runKernel(ew,f,m);return p?le(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var jQe=se({maxPool3dGrad_:UQe}),GQe={kernelName:cb,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=n;return{x:()=>jQe(e,r,s,a,i,o,l)}}};function HQe(e,t,n,r,s,a,i){let o=X(e,"dy","maxPoolGrad"),l=X(t,"input","maxPoolGrad"),u=X(n,"output","maxPoolGrad");J(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),J(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),J(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ia("maxPoolGrad",a,i);let c={dy:o,input:l,output:u},d={filterSize:r,strides:s,pad:a,dimRoundingMode:i};return ne.runKernel(Qx,c,d)}var qQe=se({maxPoolGrad_:HQe}),KQe={kernelName:ff,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r,s]=t,{filterSize:a,strides:i,pad:o}=n;return{x:()=>qQe(e,r,s,a,i,o)}}},XQe={kernelName:mf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=ao(s,r.shape),i=JZ(r.shape,a)[1],o=yn(i);return{x:()=>{let l=r.shape.slice();a.forEach(c=>{l[c]=1});let u=le(e,l);return ot(oe(u,fa(r.shape,"float32")),o)}}}},YQe={kernelName:gf,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{let r=n,{axis:s}=r,[a,i]=t,o=ao(s,a.shape),l=Cee(e,i,a,o);return{x:()=>l.x()}}},JQe={kernelName:yf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t;return{a:()=>oe(e,je(vd(n,r),"float32")),b:()=>oe(e,je(oa(n,r),"float32"))}}},ZQe={kernelName:bf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Kt(e,a,r.shape)}}},QQe={kernelName:vf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Nn(n.shape,r.shape);return{a:()=>{let a=Rr(n.shape,s);return a.length>0?le(ct(e,a),n.shape):e},b:()=>{let a=oe(e,Fn(Bb(ot(n,r)))),i=Rr(r.shape,s);return i.length>0?le(ct(a,i),r.shape):a}}}},eet={kernelName:xf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Nn(n.shape,r.shape);return{a:()=>{let a=oe(e,je(r,"float32")),i=Rr(n.shape,s);return i.length>0?le(ct(a,i),n.shape):a},b:()=>{let a=oe(e,je(n,"float32")),i=Rr(r.shape,s);return i.length>0?le(ct(a,i),r.shape):a}}}},tet={kernelName:hb,gradFunc:e=>({x:()=>Fn(e)})},net={kernelName:wf,inputsToSave:["indices"],gradFunc:(e,t)=>{let n=t[0];return{indices:()=>sr(n.shape,"float32")}}},ret={kernelName:yb,gradFunc:e=>({x:()=>Xt(e)})},set={kernelName:bb,saveAllInputs:!0,gradFunc:(e,t,n)=>{let{axis:r}=n;return hr(e,r).map(s=>()=>s)}},Gj={kernelName:kf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let r=t[0],{paddings:s}=n,a=s.map(i=>i[0]);return{x:()=>Kt(e,a,r.shape)}}},aet={kernelName:Sf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{let[n,r,s]=t,a=n,i=r,o=Nn(a.shape,i.shape);return{a:()=>{let l=je(i,"float32"),u=oe(e,oe(l,bu(a,nt(l,bt(1))))),c=Rr(a.shape,o);return c.length>0&&(u=ct(u,c)),le(u,a.shape)},b:()=>{let l=oa(a,0),u=ds(l,Qa(a),Xt(a)),c=oe(e,oe(s,u)),d=Rr(i.shape,o);return d.length>0&&(c=ct(c,d)),le(c,i.shape)}}}},iet={kernelName:If,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{let[n,r]=t,s=oa(n,0);return{x:()=>ds(s,e,oe(e,r)),alpha:()=>{let a=ds(s,Xt(e),oe(e,n)),i=Rr(r.shape,e.shape);return i.length>0&&(a=ct(a,i)),le(a,r.shape)}}}};function oet(e,t,n){let r=e.shape.slice();r[n]=1;let s=le(t,r),a=r0(e,n,!0,!1),i=r0(e,n,!0,!0),o=oe(a,i);return oe(s,o)}function uet(e,t,n){let r=e.shape.length,s=r-n.length,a=H.getAxesPermutation(n,r),i=e;a!=null&&(i=Lt(e,a));let o=i.shape.slice(),l=o.splice(r-n.length,n.length).reduce((d,h)=>d*h,1);o.push(l);let u=i.reshape(o),c=oet(u,t,s);if(c=c.reshape(i.shape),a!=null){let d=H.getUndoAxesPermutation(a);c=Lt(c,d)}return c}var cet={kernelName:Cf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{axis:s}=n,a=[];return s==null?a=r.shape.map((i,o)=>o):typeof s=="number"?a=[s]:a=s,{x:()=>uet(r,e,a)}}},det={kernelName:qp,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Nn(n.shape,r.shape);return{a:()=>{let a=ot(e,je(r,"float32")),i=Rr(n.shape,s);return i.length>0?le(ct(a,i),n.shape):a},b:()=>{let a=oe(e,je(n,"float32")),i=Rr(r.shape,s);i.length>0&&(a=le(ct(a,i),r.shape));let o=kn(r);return Fn(ot(a,je(o,"float32")))}}}},het={kernelName:Nf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,Fn(kn(n)))}}},pet={kernelName:_f,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t,r=oe(vd(n,6),Yf(n));return{x:()=>oe(e,je(r,"float32"))}}},fet={kernelName:Tf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,je(Yf(n),"float32"))}}},met={kernelName:vb,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>le(e,n.shape)}}},get={kernelName:Ef,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>ne.runKernel(wb,s,n)}}},yet={kernelName:$f,inputsToSave:["images"],gradFunc:(e,t,n)=>{let[r]=t,s={dy:e,images:r};return{images:()=>ne.runKernel(xb,s,n)}}},bet={kernelName:Af,gradFunc:(e,t,n)=>{let{dims:r}=n,s=ao(r,e.shape);return{x:()=>Ii(e,s)}}},vet={kernelName:Rf,gradFunc:e=>({x:()=>Xt(e)})},xet={kernelName:Df,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Fn(ot(e,oe(bu(n,1.5),2)))}}},wet={kernelName:Cb,inputsToSave:["condition"],gradFunc:(e,t)=>{let[n]=t;return{condition:()=>je(Xt(n),"float32"),t:()=>oe(e,je(n,e.dtype)),e:()=>oe(e,je(Cw(n),e.dtype))}}},ket={kernelName:Of,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>{let r=oa(n,bt(0)),s=bt(wee),a=bt(kee),i=oe(e,a),o=oe(oe(e,s),Ms(je(n,"float32")));return ds(r,i,o)}}}},Iet={kernelName:Lf,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,oe(n,nt(bt(1),n)))}}},Cet={kernelName:Pf,gradFunc:e=>({x:()=>Xt(e)})},Net={kernelName:Ff,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(xw(je(n,"float32")),e)}}},Tet={kernelName:Mf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(dT(je(n,"float32")),e)}}},$et={kernelName:Nb,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{begin:s,size:a}=n,i=r.shape,[o,l]=vee(r,s,a),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],i[c]-o[c]-l[c]]);return{x:()=>Ho(e,u)}}},Eet={kernelName:Vf,outputsToSave:[!0],gradFunc:(e,t,n)=>{let[r]=t,{dim:s}=n,a=!0,i=oe(e,r);return{logits:()=>nt(i,oe(ct(i,[s],a),r))}}},_et={kernelName:zf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,qi(n))}}},Hj={kernelName:Tb,gradFunc:(e,t,n)=>{let{blockShape:r,paddings:s}=n;return{x:()=>vw(e,r,s)}}},qj={kernelName:$b,gradFunc:(e,t,n)=>{let{axis:r}=n;return{x:()=>In(e,r)}}},Aet={kernelName:Bf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,oe(Is(je(n,"float32")),2))}}},Ret={kernelName:iw,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(e,oe(je(n,"float32"),2))}}},Det={kernelName:Uf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=bt(2);return{a:()=>oe(e,oe(s,nt(n,r))),b:()=>oe(e,oe(s,nt(r,n)))}}},Oet={kernelName:yd,gradFunc:e=>({x:()=>Xt(e)})},Fet={kernelName:jf,inputsToSave:["a","b"],gradFunc:(e,t)=>{let[n,r]=t,s=Nn(n.shape,r.shape);return{a:()=>{let a=e,i=Rr(n.shape,s);return i.length>0&&(a=ct(a,i)),le(a,n.shape)},b:()=>{let a=e,i=Rr(r.shape,s);return i.length>0&&(a=ct(a,i)),le(Fn(a),r.shape)}}}},Met={kernelName:Wf,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,s=r.shape.slice(),{axis:a}=n;ao(a,r.shape).forEach(l=>{s[l]=1});let i=le(e,s),o=oe(i,fa(r.shape,"float32"));return{x:()=>o}}},Pet={kernelName:Gf,inputsToSave:["x"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>ot(e,kn(xw(n)))}}},Let={kernelName:Hf,outputsToSave:[!0],gradFunc:(e,t)=>{let[n]=t;return{x:()=>oe(nt(bt(1),kn(n)),e)}}},zet={kernelName:gd,inputsToSave:["x"],gradFunc:(e,t,n)=>{let[r]=t,{reps:s}=n;return{x:()=>{let a=Xt(r);if(r.rank===1)for(let i=0;i<s[0];++i)a=De(a,Kt(e,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)a=De(a,Kt(e,[i*r.shape[0],o*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)a=De(a,Kt(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<s[0];++i)for(let o=0;o<s[1];++o)for(let l=0;l<s[2];++l)for(let u=0;u<s[3];++u)a=De(a,Kt(e,[i*r.shape[0],o*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}},Bet={kernelName:au,gradFunc:(e,t,n)=>{let r=n,{perm:s}=r,a=hP(s);return{x:()=>Lt(e,a)}}},Wet={kernelName:Ob,gradFunc:(e,t,n)=>{let r=n,{axis:s}=r;return{value:()=>_r(e,s)}}},Vet={kernelName:hw,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{let[n]=t;return{x:()=>Uet(e,n)}}};function Uet(e,t){let n=Wl(t,Xt(t)),r=Wb(e,n),s=Au(t,bt(0,"int32")),a=r.rank-s.rank;for(let o=0;o<a;++o)s=is(s,o+1);s=eo(s,fa(r.shape,"bool"));let i=Xt(r);return ds(s,r,i)}var jet={kernelName:Fb,gradFunc:e=>({x:()=>Xt(e)})},Get=[Iee,BZe,WZe,VZe,UZe,jZe,GZe,HZe,qZe,KZe,XZe,YZe,QZe,nQe,rQe,sQe,aQe,iQe,oQe,lQe,uQe,cQe,hQe,dQe,mQe,gQe,yQe,bQe,vQe,xQe,det,wQe,kQe,SQe,IQe,CQe,TQe,NQe,$Qe,EQe,_Qe,AQe,RQe,DQe,OQe,FQe,MQe,PQe,LQe,WQe,jj,jj,VQe,GQe,KQe,XQe,YQe,JQe,ZQe,QQe,eet,tet,net,ret,set,Gj,Gj,aet,iet,cet,het,pet,fet,met,get,yet,bet,vet,xet,wet,ket,Iet,Cet,Net,Tet,$et,Eet,_et,Hj,Hj,qj,qj,Aet,Det,Ret,Oet,Fet,Met,Pet,Let,zet,Bet,Wet,Vet,jet];for(let e of Get)hZ(e);Fe().prototype.abs=function(){return this.throwIfDisposed(),Ir(this)};Fe().prototype.acos=function(){return this.throwIfDisposed(),LM(this)};Fe().prototype.acosh=function(){return this.throwIfDisposed(),zM(this)};Fe().prototype.add=function(e){return this.throwIfDisposed(),De(this,e)};Fe().prototype.all=function(e,t){return this.throwIfDisposed(),lT(this,e,t)};Fe().prototype.any=function(e,t){return this.throwIfDisposed(),e0(this,e,t)};Fe().prototype.argMax=function(e){return this.throwIfDisposed(),Yh(this,e)};Fe().prototype.argMin=function(e){return this.throwIfDisposed(),BM(this,e)};Fe().prototype.asScalar=function(){return this.throwIfDisposed(),J(this.size===1,()=>"The array must have only 1 element."),le(this,[])};Fe().prototype.asType=function(e){return this.throwIfDisposed(),je(this,e)};Fe().prototype.as1D=function(){return this.throwIfDisposed(),le(this,[this.size])};Fe().prototype.as2D=function(e,t){return this.throwIfDisposed(),le(this,[e,t])};Fe().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),le(this,[e,t,n])};Fe().prototype.as4D=function(e,t,n,r){return this.throwIfDisposed(),le(this,[e,t,n,r])};Fe().prototype.as5D=function(e,t,n,r,s){return this.throwIfDisposed(),le(this,[e,t,n,r,s])};Fe().prototype.asin=function(){return this.throwIfDisposed(),WM(this)};Fe().prototype.asinh=function(){return this.throwIfDisposed(),VM(this)};Fe().prototype.atan=function(){return this.throwIfDisposed(),UM(this)};Fe().prototype.atan2=function(e){return this.throwIfDisposed(),jM(this,e)};Fe().prototype.atanh=function(){return this.throwIfDisposed(),GM(this)};Fe().prototype.avgPool=function(e,t,n,r){return this.throwIfDisposed(),_u(this,e,t,n,r)};Fe().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),vw(this,e,t)};Fe().prototype.batchNorm=function(e,t,n,r,s){return this.throwIfDisposed(),qf(this,e,t,n,r,s)};Fe().prototype.broadcastTo=function(e){return this.throwIfDisposed(),gh(this,e)};Fe().prototype.cast=function(e){return this.throwIfDisposed(),je(this,e)};Fe().prototype.ceil=function(){return this.throwIfDisposed(),ZM(this)};Fe().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Fs(this,e,t)};Fe().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Bt&&(e=[e]),In([this,...e],t)};Fe().prototype.conv1d=function(e,t,n,r,s,a){return this.throwIfDisposed(),uT(this,e,t,n,r,s,a)};Fe().prototype.conv2dTranspose=function(e,t,n,r,s){return this.throwIfDisposed(),cT(this,e,t,n,r,s)};Fe().prototype.conv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),ta(this,e,t,n,r,s,a)};Fe().prototype.cos=function(){return this.throwIfDisposed(),xw(this)};Fe().prototype.cosh=function(){return this.throwIfDisposed(),dT(this)};Fe().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),r0(this,e,t,n)};Fe().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),hT(this,e,t,n)};Fe().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),iP(this,e,t)};Fe().prototype.depthwiseConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Kf(this,e,t,n,r,s,a)};Fe().prototype.dilation2d=function(e,t,n,r,s){return this.throwIfDisposed(),oP(this,e,t,n,r,s)};Fe().prototype.divNoNan=function(e){return this.throwIfDisposed(),lP(this,e)};Fe().prototype.div=function(e){return this.throwIfDisposed(),ot(this,e)};Fe().prototype.dot=function(e){return this.throwIfDisposed(),uP(this,e)};Fe().prototype.elu=function(){return this.throwIfDisposed(),Lb(this)};Fe().prototype.equal=function(e){return this.throwIfDisposed(),Za(this,e)};Fe().prototype.erf=function(){return this.throwIfDisposed(),cP(this)};Fe().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),pP(this,e,t)};Fe().prototype.exp=function(){return this.throwIfDisposed(),Ms(this)};Fe().prototype.expandDims=function(e){return this.throwIfDisposed(),is(this,e)};Fe().prototype.expm1=function(){return this.throwIfDisposed(),fP(this)};Fe().prototype.fft=function(){return this.throwIfDisposed(),_w(this)};Fe().prototype.flatten=function(){return this.throwIfDisposed(),le(this,[this.size])};Fe().prototype.floor=function(){return this.throwIfDisposed(),Bb(this)};Fe().prototype.floorDiv=function(e){return this.throwIfDisposed(),oT(this,e)};Fe().prototype.gather=function(e,t,n){return this.throwIfDisposed(),Wb(this,e,t,n)};Fe().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Au(this,e)};Fe().prototype.greater=function(e){return this.throwIfDisposed(),oa(this,e)};Fe().prototype.ifft=function(){return this.throwIfDisposed(),Gg(this)};Fe().prototype.irfft=function(){return this.throwIfDisposed(),NT(this)};Fe().prototype.isFinite=function(){return this.throwIfDisposed(),mP(this)};Fe().prototype.isInf=function(){return this.throwIfDisposed(),gP(this)};Fe().prototype.isNaN=function(){return this.throwIfDisposed(),yP(this)};Fe().prototype.leakyRelu=function(e){return this.throwIfDisposed(),kw(this,e)};Fe().prototype.lessEqual=function(e){return this.throwIfDisposed(),vd(this,e)};Fe().prototype.less=function(e){return this.throwIfDisposed(),Wg(this,e)};Fe().prototype.localResponseNormalization=function(e,t,n,r){return this.throwIfDisposed(),bP(this,e,t,n,r)};Fe().prototype.logSigmoid=function(){return this.throwIfDisposed(),vP(this)};Fe().prototype.logSoftmax=function(e){return this.throwIfDisposed(),mT(this,e)};Fe().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Iw(this,e,t)};Fe().prototype.log=function(){return this.throwIfDisposed(),Qa(this)};Fe().prototype.log1p=function(){return this.throwIfDisposed(),Sw(this)};Fe().prototype.logicalAnd=function(e){return this.throwIfDisposed(),eo(this,e)};Fe().prototype.logicalNot=function(){return this.throwIfDisposed(),Cw(this)};Fe().prototype.logicalOr=function(e){return this.throwIfDisposed(),gT(this,e)};Fe().prototype.logicalXor=function(e){return this.throwIfDisposed(),xP(this,e)};Fe().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),Mt(this,e,t,n)};Fe().prototype.maxPool=function(e,t,n,r){return this.throwIfDisposed(),Qr(this,e,t,n,r)};Fe().prototype.max=function(e,t){return this.throwIfDisposed(),vi(this,e,t)};Fe().prototype.maximum=function(e){return this.throwIfDisposed(),Wl(this,e)};Fe().prototype.mean=function(e,t){return this.throwIfDisposed(),rr(this,e,t)};Fe().prototype.min=function(e,t){return this.throwIfDisposed(),Bg(this,e,t)};Fe().prototype.minimum=function(e){return this.throwIfDisposed(),Vc(this,e)};Fe().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),kP(this,e,t)};Fe().prototype.mod=function(e){return this.throwIfDisposed(),SP(this,e)};Fe().prototype.mul=function(e){return this.throwIfDisposed(),oe(this,e)};Fe().prototype.neg=function(){return this.throwIfDisposed(),Fn(this)};Fe().prototype.norm=function(e,t,n){return this.throwIfDisposed(),zb(this,e,t,n)};Fe().prototype.notEqual=function(e){return this.throwIfDisposed(),ep(this,e)};Fe().prototype.oneHot=function(e,t=1,n=0){return this.throwIfDisposed(),Vg(this,e,t,n)};Fe().prototype.onesLike=function(){return this.throwIfDisposed(),ei(this)};Fe().prototype.pad=function(e,t){return this.throwIfDisposed(),Ho(this,e,t)};Fe().prototype.pool=function(e,t,n,r,s,a){return this.throwIfDisposed(),IP(this,e,t,n,r,s,a)};Fe().prototype.pow=function(e){return this.throwIfDisposed(),bu(this,e)};Fe().prototype.prelu=function(e){return this.throwIfDisposed(),$w(this,e)};Fe().prototype.prod=function(e,t){return this.throwIfDisposed(),CP(this,e,t)};Fe().prototype.reciprocal=function(){return this.throwIfDisposed(),_P(this)};Fe().prototype.relu=function(){return this.throwIfDisposed(),gn(this)};Fe().prototype.relu6=function(){return this.throwIfDisposed(),vT(this)};Fe().prototype.reshapeAs=function(e){return this.throwIfDisposed(),le(this,e.shape)};Fe().prototype.reshape=function(e){return this.throwIfDisposed(),le(this,e)};Fe().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),HQ(this,e,t,n)};Fe().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),qQ(this,e,t,n)};Fe().prototype.reverse=function(e){return this.throwIfDisposed(),Ii(this,e)};Fe().prototype.rfft=function(){return this.throwIfDisposed(),Aw(this)};Fe().prototype.round=function(){return this.throwIfDisposed(),xT(this)};Fe().prototype.rsqrt=function(){return this.throwIfDisposed(),wT(this)};Fe().prototype.selu=function(){return this.throwIfDisposed(),kT(this)};Fe().prototype.separableConv2d=function(e,t,n,r,s,a){return this.throwIfDisposed(),Vb(this,e,t,n,r,s,a)};Fe().prototype.sigmoid=function(){return this.throwIfDisposed(),qi(this)};Fe().prototype.sign=function(){return this.throwIfDisposed(),AP(this)};Fe().prototype.sin=function(){return this.throwIfDisposed(),ST(this)};Fe().prototype.sinh=function(){return this.throwIfDisposed(),IT(this)};Fe().prototype.slice=function(e,t){return this.throwIfDisposed(),Kt(this,e,t)};Fe().prototype.softmax=function(e){return this.throwIfDisposed(),wd(this,e)};Fe().prototype.softplus=function(){return this.throwIfDisposed(),Xf(this)};Fe().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),Tw(this,e,t)};Fe().prototype.split=function(e,t){return this.throwIfDisposed(),ya(this,e,t)};Fe().prototype.sqrt=function(){return this.throwIfDisposed(),Is(this)};Fe().prototype.square=function(){return this.throwIfDisposed(),kn(this)};Fe().prototype.squaredDifference=function(e){return this.throwIfDisposed(),TT(this,e)};Fe().prototype.squeeze=function(e){return this.throwIfDisposed(),kd(this,e)};Fe().prototype.stack=function(e,t){this.throwIfDisposed();let n=e instanceof Bt?[this,e]:[this,...e];return _r(n,t)};Fe().prototype.step=function(e){return this.throwIfDisposed(),Yf(this,e)};Fe().prototype.stridedSlice=function(e,t,n,r,s,a,i,o){return this.throwIfDisposed(),RP(this,e,t,n,r,s,a,i,o)};Fe().prototype.sub=function(e){return this.throwIfDisposed(),nt(this,e)};Fe().prototype.sum=function(e,t){return this.throwIfDisposed(),ct(this,e,t)};Fe().prototype.tan=function(){return this.throwIfDisposed(),DP(this)};Fe().prototype.tanh=function(){return this.throwIfDisposed(),Zh(this)};Fe().prototype.tile=function(e){return this.throwIfDisposed(),ja(this,e)};Fe().prototype.toBool=function(){return this.throwIfDisposed(),je(this,"bool")};Fe().prototype.toFloat=function(){return this.throwIfDisposed(),je(this,"float32")};Fe().prototype.toInt=function(){return this.throwIfDisposed(),je(this,"int32")};Fe().prototype.topk=function(e,t){return this.throwIfDisposed(),FP(this,e,t)};Fe().prototype.transpose=function(e){return this.throwIfDisposed(),Lt(this,e)};Fe().prototype.unique=function(e){return this.throwIfDisposed(),MP(this,e)};Fe().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),RT(this,e,t)};Fe().prototype.unstack=function(e){return this.throwIfDisposed(),hr(this,e)};Fe().prototype.where=function(e,t){return this.throwIfDisposed(),ds(e,this,t)};Fe().prototype.zerosLike=function(){return this.throwIfDisposed(),Xt(this)};var Ku=class Nee extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Nee.prototype)}},gl=class Tee extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Tee.prototype)}},he=class $ee extends Error{constructor(t){super(t),Object.setPrototypeOf(this,$ee.prototype)}},Wt=class Eee extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Eee.prototype)}},Het=class _ee extends Error{constructor(t){super(t),Object.setPrototypeOf(this,_ee.prototype)}},Aee=class{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function np(e,t){if(Array.isArray(e)){let n=[];for(let r=0;r<t;r++)n=n.concat(e);return n}else{let n=new Array(t);return n.fill(e),n}}function dl(e,t){if(!e)throw new Het(t)}function Kj(e,t){let n=0;for(let r of e)r===t&&n++;return n}function pa(e){return e.length===1?e[0]:e}function mn(e){return Array.isArray(e)?e:[e]}function Yl(e){let t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Xd(e){return e.length<=1||e.indexOf("_")===-1?e:e.replace(/[_]+(\w|$)/g,(t,n)=>n.toUpperCase())}var Ri={};function tL(e){if(e==null)return null;let t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function bR(e){if(!(e==null||typeof e!="object"))if(Array.isArray(e))e.forEach(t=>bR(t));else{let t=Object.keys(e);for(let n of t){let r=e[n];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?e[n]=r.value:bR(r))}}}function Dw(e,t={},n={},r="object",s=!1){if(typeof e=="string"){let a=e,i;if(a in n)i=n[a];else if(a in Ri)i=Ri[a];else if(i=t[a],i==null)throw new he(`Unknown ${r}: ${e}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let a=e;if(a.className==null||a.config==null)throw new he(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);let i=a.className,o,l;if(i in n?[o,l]=n[i]:i in Ri?[o,l]=Ri.className:i in t&&([o,l]=t[i]),o==null)throw new he(`Unknown ${r}: ${i}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){let u={};for(let p of Object.keys(Ri))u[p]=Ri[p];for(let p of Object.keys(n))u[p]=n[p];let c=a.config;c.customObjects=u;let d=Object.assign({},Ri);for(let p of Object.keys(n))Ri[p]=n[p];bR(a.config);let h=l(o,a.config,n,s);return Ri=Object.assign({},d),h}else{let u=Object.assign({},Ri);for(let d of Object.keys(n))Ri[d]=n[d];let c=new o(a.config);return Ri=Object.assign({},u),c}}}function qet(e,t){return e<t?-1:e>t?1:0}function Bk(e,t){return-1*qet(e,t)}function Cc(e){if(e==null)return e;let t=[];for(let n of e)t.indexOf(n)===-1&&t.push(n);return t}function Ket(e){if(e==null)throw new he(`Invalid value in obj: ${JSON.stringify(e)}`);for(let t in e)if(e.hasOwnProperty(t))return!1;return!0}function Jf(e,t,n){if(n!=null&&e.indexOf(n)<0)throw new he(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function nL(e,t,n=0,r=1/0){return dl(n>=0),dl(r>=n),Array.isArray(e)&&e.length>=n&&e.length<=r&&e.every(s=>typeof s===t)}function cs(e,t){Array.isArray(e)?(M.assert(e.length>0,()=>`${t} is unexpectedly an empty array.`),e.forEach((n,r)=>cs(n,`element ${r+1} of ${t}`))):M.assert(Number.isInteger(e)&&e>0,()=>`Expected ${t} to be a positive integer, but got ${Ree(e)}.`)}function Ree(e){return e===null?"null":Array.isArray(e)?"["+e.map(t=>Ree(t)).join(",")+"]":typeof e=="string"?`"${e}"`:`${e}`}function Xet(e,t,n){let r=n!=null?n():M.now(),s;return(...a)=>{let i=n!=null?n():M.now();return i-r<t||(r=i,s=e(...a)),s}}function Dee(e){return e==="relu"?"relu":e==="linear"?"linear":e==="elu"?"elu":null}var Yet=0;function Oee(){return Yet++}var Wk={};function zT(e=""){return e in Wk||(Wk[e]=0),Wk[e]+=1,e+Wk[e].toString()}var Jet=["channelsFirst","channelsLast"],Zet=["nearest","bilinear"],Qet=["valid","same","causal"],ett=["max","avg"],ttt=["sum","mul","concat","ave"],mm=new Map;function kr(e){Jf(Jet,"DataFormat",e)}function ntt(e){Jf(Zet,"InterpolationFormat",e)}function Ei(e){Jf(Qet,"PaddingMode",e)}function Fee(e){Jf(ett,"PoolMode",e)}var u1=[],Xj="/";function yh(e,t){u1.push(e);try{let n=t();return u1.pop(),n}catch(n){throw u1.pop(),n}}function rtt(){return u1.length===0?"":u1.join(Xj)+Xj}function Mee(e){if(!Lee(e))throw new Error("Not a valid tensor name: '"+e+"'");return rtt()+e}function Pee(e){if(!Lee(e))throw new Error("Not a valid tensor name: '"+e+"'");mm.has(e)||mm.set(e,0);let t=mm.get(e);if(mm.set(e,mm.get(e)+1),t>0){let n=`${e}_${t}`;return mm.set(n,1),n}else return e}var stt=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Lee(e){return!!e.match(stt)}function att(e){return e===parseInt(e.toString(),10)}function Nc(e,t,n){t==null&&(t=0),n==null&&(n=e.length);let r=1;for(let s=t;s<n;++s)r*=e[s];return r}function qg(e){if(e.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r<t&&(t=r)}return t}function jc(e){if(e.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){let r=e[n];r>t&&(t=r)}return t}function Bo(e,t){if(t<e)throw new he(`end (${t}) < begin (${e}) is forbidden.`);let n=[];for(let r=e;r<t;++r)n.push(r);return n}var PE;function Ur(){return PE==null&&(PE=OM().epsilon()),PE}function Wo(){return"channelsLast"}function vu(e,t){return je(e,t)}function Ow(e,t=-1){let n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),le(e,n)}function itt(e,t){return ue(()=>{if(e.shape.length!==2)throw new he(`repeat() expects a rank-2 tensor, but received a rank-${e.shape.length} tensor.`);let n=Ow(e,1);return vR(n,[1,t,1])})}function ott(e){let t=[Nc(e.shape)];return le(e,t)}function ltt(e){if(e.rank<=1)throw new he(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);let t=[e.shape[0],Nc(e.shape,1)];return le(e,t)}function bh(e,t,n){return ue(()=>{switch(e.rank){case 1:return Ew(e,t,n);case 2:return CT(e,[t,0],[n,e.shape[1]]);case 3:return Ub(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return jg(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return Kt(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return Kt(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new he(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}})}function LE(e,t,n){return ue(()=>{switch(e.rank){case 1:return Ew(e,t,n);case 2:return CT(e,[0,t],[e.shape[0],n]);case 3:return Ub(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return jg(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function Vk(e,t,n,r){return ue(()=>{switch(e.rank){case 1:return Ew(e,t,n);case 2:switch(r){case 1:return bh(e,t,n);case 2:return LE(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return bh(e,t,n);case 2:return Ub(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return LE(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return bh(e,t,n);case 2:return jg(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return jg(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return LE(e,t,n);default:throw new he(`The axis is not within the rank of the tensor ${r}`)}default:throw new he(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}})}function rL(e,t=-1){let n;return t<0&&(n=e[0].rank,n!==0?t=n:t=0),t===e[0].rank&&(t=-1),In(e,t)}function Yj(e,t){switch(e.rank){case 1:return QM([e,t]);case 2:return eP([e,t],0);case 3:return tP([e,t],0);case 4:return nP([e,t],0);default:throw new he(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function vR(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new he(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return ja(e,t)}function BT(e,t=0,n=1,r,s){return bT(e,t,n,r,s)}function $l(e,t,n,r){if(e.rank<2||t.rank<2)throw new Wt(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=e.shape.slice(-1)[0],a=t.shape.slice(-2)[0];if(s!==a)throw new Wt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(e.rank===2&&t.rank===2)return Hg.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?xR(e.rank,r,Wo()):null,activation:n});{let s=e.shape.slice(),a=s.pop();e=le(e,[-1,a]);let i=t.shape.slice(),o=i.pop(),l=i.pop(),u=[...i,o],c=Array.from({length:t.rank},(h,p)=>p===0?t.rank-2:p<=t.rank-2?p-1:p);t=le(Lt(t,c),[l,-1]);let d=[...s,...u];return le(Hg.matMul({a:e,b:t,transposeA:!1,transposeB:!1,bias:r?xR(e.rank,r,Wo()):null,activation:n}),d)}}function zee(e,t,n){return ue(()=>(Array.isArray(t)?t=dn(t,"int32"):t=je(t,"int32"),Wb(e,t,n)))}function Fw(e){return oe(e,e)}function xR(e,t,n){let r=t.shape;if(t.rank!==1&&t.rank!==e)throw new he(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(e===5){if(n==="channelsFirst")return r.length===1?le(t,[1,r[0],1,1,1]):le(t,[1,r[3],r[0],r[1],r[2]]);if(n==="channelsLast")return r.length===1?le(t,[1,1,1,1,r[0]]):le(t,[1].concat(r))}else if(e===4){if(n==="channelsFirst")return r.length===1?le(t,[1,r[0],1,1]):le(t,[1,r[2],r[0],r[1]]);if(n==="channelsLast")return r.length===1?le(t,[1,1,1,r[0]]):le(t,[1].concat(r))}else if(e===3){if(n==="channelsFirst")return r.length===1?le(t,[1,r[0],1]):le(t,[1,r[1],r[0]]);if(n==="channelsLast")return r.length===1?le(t,[1,1,r[0]]):le(t,[1].concat(r))}else if(e<3)return t;throw new he(`Unsupported input rank by biasAdd: ${t.rank}`)}function qo(e,t,n){return ue(()=>(n==null&&(n=Wo()),kr(n),De(e,xR(e.rank,t,n))))}function utt(e,t=1){if(t!==1)throw new Wt(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return Lb(e)}function ctt(e){return ue(()=>ot(e,De(Ir(e),1)))}function Bee(e,t,n,r){return ue(()=>zP(e,t,n,r))}function dtt(e){return ue(()=>{let t=De(.5,oe(.2,e));return Fs(t,0,1)})}function Mw(e,t,n=!1){return n?e():t()}var htt=["fanIn","fanOut","fanAvg"],ptt=["normal","uniform","truncatedNormal"];function ftt(e){Jf(htt,"FanMode",e)}function mtt(e){Jf(ptt,"Distribution",e)}var io=class extends Be.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},sL=class extends io{apply(e,t){return sr(e,t)}};sL.className="Zeros";Be.registerClass(sL);var WT=class extends io{apply(e,t){return fa(e,t)}};WT.className="Ones";Be.registerClass(WT);var aL=class extends io{constructor(e){if(super(),typeof e!="object")throw new he(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new he(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return ue(()=>oe(bt(this.value),fa(e,t)))}getConfig(){return{value:this.value}}};aL.className="Constant";Be.registerClass(aL);var iL=class extends io{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return xd(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};iL.className="RandomUniform";Be.registerClass(iL);var oL=class extends io{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Wt(`randomNormal does not support dType ${t}.`);return BT(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};oL.className="RandomNormal";Be.registerClass(oL);var lL=class extends io{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Wt(`truncatedNormal does not support dType ${t}.`);return AT(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};lL.className="TruncatedNormal";Be.registerClass(lL);var uL=class extends io{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return ue(()=>{if(e.length!==2||e[0]!==e[1])throw new he("Identity matrix initializer can only be used for 2D square matrices.");return oe(this.gain,pT(e[0]))})}getConfig(){return{gain:this.gain}}};uL.className="Identity";Be.registerClass(uL);function gtt(e,t="channelsLast"){let n,r;if(kr(t),e.length===2)n=e[0],r=e[1];else if([3,4,5].indexOf(e.length)!==-1){if(t==="channelsFirst"){let s=Nc(e,2);n=e[1]*s,r=e[0]*s}else if(t==="channelsLast"){let s=Nc(e,0,e.length-2);n=e[e.length-2]*s,r=e[e.length-1]*s}}else{let s=Nc(e);n=Math.sqrt(s),r=Math.sqrt(s)}return[n,r]}var ka=class extends io{constructor(e){if(super(),e.scale<0)throw new he(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,ftt(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,mtt(this.distribution),this.seed=e.seed}apply(e,t){let n=gtt(e),r=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,r):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(r+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Wt(`${this.getClassName()} does not support dType ${t}.`);return AT(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return xd(e,-i,i,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};ka.className="VarianceScaling";Be.registerClass(ka);var VT=class extends ka{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ka.className}};VT.className="GlorotUniform";Be.registerClass(VT);var UT=class extends ka{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ka.className}};UT.className="GlorotNormal";Be.registerClass(UT);var jT=class extends ka{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ka.className}};jT.className="HeNormal";Be.registerClass(jT);var GT=class extends ka{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ka.className}};GT.className="HeUniform";Be.registerClass(GT);var HT=class extends ka{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return ka.className}};HT.className="LeCunNormal";Be.registerClass(HT);var qT=class extends ka{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return ka.className}};qT.className="LeCunUniform";Be.registerClass(qT);var cL=class extends io{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return ue(()=>{if(e.length<2)throw new Wt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;let n=M.sizeFromShape(e.slice(0,-1)),r=e[e.length-1],s=n*r;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);let a=[Math.max(r,n),Math.min(r,n)],i=BT(a,0,1,t,this.seed),o=UP.qr(i,!1),l=o[0],u=o[1].flatten().stridedSlice([0],[Math.min(r,n)*Math.min(r,n)],[Math.min(r,n)+1]);return l=oe(l,u.sign()),n<r&&(l=l.transpose()),oe(bt(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}};cL.className="Orthogonal";Be.registerClass(cL);var Jj={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Zj(e,t={}){return Dw(e,Be.SerializationMap.getMap().classNameMap,t,"initializer")}function ir(e){return tL(e)}function Yn(e){if(typeof e=="string"){let t=e in Jj?Jj[e]:e;if(t==="GlorotNormal")return new UT;if(t==="GlorotUniform")return new VT;if(t==="HeNormal")return new jT;if(t==="HeUniform")return new GT;if(t==="LeCunNormal")return new HT;if(t==="LeCunUniform")return new qT;{let n={};return n.className=t,n.config={},Zj(n)}}else return e instanceof io?e:Zj(e)}function wR(e){return Array.isArray(e)&&Array.isArray(e[0])}function nI(e){return e.length===0?[]:Array.isArray(e[0])?e:[e]}function Et(e){let t;if(Array.isArray(e)){if(e.length!==1)throw new he(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function rn(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(e.length===1)return e=e,e[0];throw new he(`Expected exactly 1 Shape; got ${e.length}`)}else return e}function rI(e){let t=0;for(let n of e)n.shape.length===0?t+=1:t+=n.shape.reduce((r,s)=>r*s);return t}var Qj="Variable",Wee=class{constructor(e,t="float32",n=Qj,r=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Oee(),n=n??Qj,this.originalName=Mee(n),this.name=Pee(this.originalName),this.trainable_=r,this.constraint=s,this.val=PP(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),ytt(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function ytt(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}function kR(e){return e.map(t=>t.read())}function dL(e){e.forEach(t=>{t[0].write(t[1])})}var Tr=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},Vo=class{constructor(e,t,n,r,s,a,i){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=r,this.callArgs=s,this.outputTensorIndex=i,this.id=Oee(),a!=null&&(this.originalName=Mee(a),this.name=Pee(this.originalName)),this.rank=t.length}},btt=0,KT=class{constructor(e,t){this.callArgs=t,this.id=btt++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},vtt=0,Ut=class extends Be.Serializable{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=vtt++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Yl(n)+"_"+zT(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let r=e.dtype;r==null&&(r=e.inputDType),r==null&&(r="float32"),this.dtype=r}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new gl(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new he(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return pa(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return pa(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ku(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ku(`Layer ${this.name} is not connected, no input to return.`);return pa(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ku(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ku(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return pa(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){let t=mn(e);if(this.inputSpec==null||this.inputSpec.length===0)return;let n=mn(this.inputSpec);if(t.length!==n.length)throw new he(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let r=0;r<t.length;r++){let s=t[r],a=n[r];if(a==null)continue;let i=s.rank;if(a.ndim!=null&&i!==a.ndim)throw new he(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(a.maxNDim!=null&&i>a.maxNDim)throw new he(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(a.minNDim!=null&&i<a.minNDim)throw new he(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(a.dtype!=null&&s.dtype!==a.dtype)throw new he(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${s.dtype}.`);if(a.axes){let o=s.shape;for(let l in a.axes){let u=Number(l),c=a.axes[l],d=u>=0?o[u]:o[o.length+u];if(c!=null&&[c,null].indexOf(d)===-1)throw new he(`Input ${r} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${c} but got shape ${o}.`)}}if(a.shape!=null)for(let o=0;o<a.shape.length;++o){let l=a.shape[o],u=s.shape[o];if(l!=null&&u!=null&&l!==u)throw new he(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=mn(e),r=ktt(e),s=Stt(e);if(r===s)throw new he("Arguments to apply() must be all SymbolicTensors or all Tensors");return yh(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of mn(e))a.push(i.shape);this.build(pa(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);let i=mn(a),o=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),o.push(l);if(a=pa(o),this.activityRegularizer!=null)throw new Wt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=xtt(e),i=this.computeOutputShape(a),o,l=wtt(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?o=i.map((u,c)=>new Vo(l,u,this,mn(e),t,this.name,c)):o=new Vo(l,i,this,mn(e),t,this.name),this.addInboundNode(e,o,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new Wt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,r)=>{n!=null&&e[r]!=null&&e[r]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ku(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Ku(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new gl(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return rI(this.weights)}build(e){this.built=!0}getWeights(e=!1){return kR(e?this.trainableWeights:this.weights)}setWeights(e){ue(()=>{let t=this.weights;if(t.length!==e.length)throw new he(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],r=kR(t);for(let s=0;s<r.length;++s){let a=r[s],i=t[s],o=e[s];if(!M.arraysEqual(a.shape,o.shape))throw new he(`Layer weight shape ${a.shape} not compatible with provided weight shape ${o.shape}`);n.push([i,o])}dL(n)})}addWeight(e,t,n,r,s,a,i,o){if(this._addedWeightNames.indexOf(e)!==-1)throw new he(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(r=o!=null?o():Yn("zeros"));let l=r.apply(t,n),u=new Wee(l,n,e,a,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(u.read())),a==null&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=mn(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;let r=this.computeMask(e,n),s=mn(t),a=mn(r);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=a[i]}addInboundNode(e,t,n,r,s,a,i=null){let o=mn(e);t=mn(t),n=mn(n),r=mn(r),s=nI(s),a=nI(a);let l=[],u=[],c=[];for(let d of o)l.push(d.sourceLayer),u.push(d.nodeIndex),c.push(d.tensorIndex);new KT({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:r,inputShapes:s,outputShapes:a},i);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function xtt(e){e=mn(e);let t=[];for(let n of e)t.push(n.shape);return pa(t)}function wtt(e){return"float32"}function Vee(e,t,n){if((t==null||n!=null&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),t.inboundNodes.length===0)return[e];{let r=t.inboundNodes[n];if(r.inboundLayers.length===0)return r.inputTensors;{let s=[];for(let a=0;a<r.inboundLayers.length;a++){let i=r.inputTensors[a],o=r.inboundLayers[a],l=r.nodeIndices[a],u=Vee(i,o,l);for(let c of u)s.indexOf(c)===-1&&s.push(c)}return s}}}function ktt(e){let t=!0;for(let n of mn(e))if(!(n instanceof Vo)){t=!1;break}return t}function Stt(e){let t=!0;for(let n of mn(e))if(n instanceof Vo){t=!1;break}return t}var Gb=class extends Ut{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:zT("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new he("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new he("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new he("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let r=new Vo(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new KT({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new he(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Gb.className="InputLayer";Be.registerClass(Gb);function Uee(e){if(e.batchShape==null&&e.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(e.batchShape!=null&&e.shape!=null)throw new he("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;e.shape!=null&&t==null&&(t=[null].concat(e.shape));let n=e.dtype;return n==null&&(n="float32"),new Gb({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}function Itt(e,t){if(e.dtype==null||e.dtype===t.dtype)return t;try{return je(t,e.dtype)}catch{throw new he(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}var Bm=class jee{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof jee)for(let n in t.id2Value)this.id2Value[n]=t.id2Value[n],n in t.id2Mask&&(this.id2Mask[n]=t.id2Mask[n]);else{if(t==null)return;for(let n of t)this.add(n.key,n.value)}}add(t,n,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=Itt(t,n),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new he(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof Vo){if(this.id2Value[t.id]==null)throw new he(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let n=this.name2Id[t];if(n==null)throw new he(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[n]}}getMask(t){if(t instanceof Vo){if(this.id2Value[t.id]==null)throw new he(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let n=this.name2Id[t];if(n==null)throw new he(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[n]}}disposeMasks(){this.id2Mask!=null&&_t(this.id2Mask)}},sI=new Aee,aI=new Aee;function Ctt(e){sI!=null&&sI.setMaxEntries(e),aI!=null&&aI.setMaxEntries(e)}function Wv(e,t,n,r){let s=n==null?!1:n.training,a=Array.isArray(e),i=a?e:[e],o=i.map(f=>f.name),l=[],u=t.names();for(let f of o)u.indexOf(f)!==-1?l.push(t.getValue(f)):l.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);let c=o.join(",")+"|"+t.names().sort().join(","),d=sI.get(c),h;if(d==null){let f=Ntt(i,t);d=f.sorted,h=f.recipientCounts,sI.put(c,d),aI.put(c,h)}h={},s||Object.assign(h,aI.get(c));let p=new Bm(t);for(let f=0;f<d.length;++f){if(r!=null){let $=QS().numTensors;$>r.maxNumTensors&&(r.maxNumTensors=$),$<r.minNumTensors&&(r.minNumTensors=$)}let m=d[f],g=m.sourceLayer;if(g instanceof Gb)continue;let y=[],b=[],x=[],v=!1;for(let $ of m.inputs){let C=p.getValue($),T=p.getMask($);y.push(C),b.push(T),T!=null&&(v=!0),s||(h[$.name]--,h[$.name]===0&&!t.hasKey($)&&o.indexOf($.name)===-1&&!C.isDisposed&&$.sourceLayer.stateful!==!0&&x.push(C))}v&&(n=n||{},n.mask=b[0]);let w=mn(g.apply(y,n)),k=null;g.supportsMasking&&(k=g.computeMask(y,b));let S=$tt(m),I=Array.isArray(S)?S:[S];for(let $=0;$<I.length;++$){p.hasKey(I[$])||p.add(I[$],w[$],Array.isArray(k)?k[0]:k);let C=o.indexOf(I[$].name);C!==-1&&(l[C]=w[$])}s||_t(x)}return p.disposeMasks(),a?l:l[0]}function Ntt(e,t){M.assert(e!=null&&e.length>0,()=>"Expected at least one fetch, got none");let n=[],r={};if(e.length===1){let s=e5(e[0],t);n=s.sorted,r=s.recipientMap}else{let s=new Set;for(let a of e){let{sorted:i,recipientMap:o}=e5(a,t);for(let l of i)s.has(l.name)||(n.push(l),s.add(l.name));for(let l in o)r[l]==null&&(r[l]=new Set),o[l].forEach(u=>r[l].add(u))}}return{sorted:n,recipientCounts:Ttt(r)}}function Ttt(e){let t={};for(let n in e)t[n]=e[n].size;return t}function e5(e,t){let n=new Set,r=[],s={};for(let o of t.names())n.add(o);let a=[],i=[];for(a.push(e);a.length>0;){let o=a[a.length-1];if(n.has(o.name)){a.pop();continue}let l=i[i.length-1]===a.length-1;if(o.inputs.length===0||l)a.pop(),r.push(o),n.add(o.name),l&&i.pop();else{i.push(a.length-1);for(let u of o.inputs)s[u.name]==null&&(s[u.name]=new Set),s[u.name].add(o.name),!n.has(u.name)&&a.push(u)}}return{sorted:r,recipientMap:s}}function $tt(e){let t;if(e.sourceLayer.inboundNodes.length===1)t=e.sourceLayer.output;else{let n=null;for(let r=0;r<e.sourceLayer.inboundNodes.length;++r)for(let s of e.sourceLayer.inboundNodes[r].outputTensors)if(s.id===e.id){n=r;break}t=e.sourceLayer.getOutputAt(n)}return t}var Ett=xe();Ett.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Ctt);var Gee={};At(Gee,{maxNorm:()=>_tt,minMaxNorm:()=>Dtt,nonNeg:()=>Rtt,unitNorm:()=>Att});function hL(e,t){return ue(()=>Is(ct(oe(e,e),t,!0)))}var Pw=class extends Be.Serializable{getConfig(){return{}}},pL=class extends Pw{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ue(()=>{let t=hL(e,this.axis),n=Fs(t,0,this.maxValue);return oe(e,ot(n,De(Ur(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};pL.className="MaxNorm";Be.registerClass(pL);var fL=class extends Pw{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ue(()=>ot(e,De(Ur(),hL(e,this.axis))))}getConfig(){return{axis:this.axis}}};fL.className="UnitNorm";Be.registerClass(fL);var mL=class extends Pw{apply(e){return gn(e)}};mL.className="NonNeg";Be.registerClass(mL);var gL=class extends Pw{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return ue(()=>{let t=hL(e,this.axis),n=De(oe(this.rate,Fs(t,this.minValue,this.maxValue)),oe(1-this.rate,t));return oe(e,ot(n,De(Ur(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};gL.className="MinMaxNorm";Be.registerClass(gL);var t5={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function qr(e){return tL(e)}function n5(e,t={}){return Dw(e,Be.SerializationMap.getMap().classNameMap,t,"constraint")}function Kr(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in t5?t5[e]:e,config:{}};return n5(t)}else return e instanceof Pw?e:n5(e)}function _tt(e){return new pL(e)}function Att(e){return new fL(e)}function Rtt(){return new mL}function Dtt(e){return new gL(e)}var Hee={};At(Hee,{constant:()=>Mtt,glorotNormal:()=>Utt,glorotUniform:()=>Vtt,heNormal:()=>jtt,heUniform:()=>Gtt,identity:()=>Btt,leCunNormal:()=>Htt,leCunUniform:()=>qtt,ones:()=>Ftt,orthogonal:()=>Ktt,randomNormal:()=>Ltt,randomUniform:()=>Ptt,truncatedNormal:()=>ztt,varianceScaling:()=>Wtt,zeros:()=>Ott});function Ott(){return new sL}function Ftt(){return new WT}function Mtt(e){return new aL(e)}function Ptt(e){return new iL(e)}function Ltt(e){return new oL(e)}function ztt(e){return new lL(e)}function Btt(e){return new uL(e)}function Wtt(e){return new ka(e)}function Vtt(e){return new VT(e)}function Utt(e){return new UT(e)}function jtt(e){return new jT(e)}function Gtt(e){return new GT(e)}function Htt(e){return new HT(e)}function qtt(e){return new qT(e)}function Ktt(e){return new cL(e)}var qee={};At(qee,{Layer:()=>Ut,RNN:()=>Ou,RNNCell:()=>zw,activation:()=>Irt,add:()=>Drt,alphaDropout:()=>gst,average:()=>Ort,averagePooling1d:()=>$4,averagePooling2d:()=>E4,averagePooling3d:()=>_4,avgPool1d:()=>Urt,avgPool2d:()=>Grt,avgPool3d:()=>qrt,avgPooling1d:()=>jrt,avgPooling2d:()=>Hrt,avgPooling3d:()=>Krt,batchNormalization:()=>Brt,bidirectional:()=>lst,categoryEncoding:()=>wst,centerCrop:()=>vst,concatenate:()=>Frt,conv1d:()=>mrt,conv2d:()=>grt,conv2dTranspose:()=>yrt,conv3d:()=>brt,conv3dTranspose:()=>vrt,convLstm2d:()=>sst,convLstm2dCell:()=>ast,cropping2D:()=>wrt,dense:()=>Crt,depthwiseConv2d:()=>Srt,dot:()=>zrt,dropout:()=>Nrt,elu:()=>urt,embedding:()=>Rrt,flatten:()=>$rt,gaussianDropout:()=>mst,gaussianNoise:()=>fst,globalAveragePooling1d:()=>Xrt,globalAveragePooling2d:()=>Yrt,globalMaxPool1d:()=>cst,globalMaxPool2d:()=>dst,globalMaxPooling1d:()=>qte,globalMaxPooling2d:()=>Kte,gru:()=>Zrt,gruCell:()=>Qrt,input:()=>dte,inputLayer:()=>lrt,layerNormalization:()=>Wrt,leakyReLU:()=>drt,lstm:()=>est,lstmCell:()=>tst,masking:()=>yst,maxPool1d:()=>hst,maxPool2d:()=>pst,maxPooling1d:()=>Xte,maxPooling2d:()=>Yte,maxPooling3d:()=>Jrt,maximum:()=>Mrt,minimum:()=>Prt,multiply:()=>Lrt,permute:()=>Art,prelu:()=>hrt,randomWidth:()=>kst,reLU:()=>crt,repeatVector:()=>Ert,rescaling:()=>bst,reshape:()=>_rt,resizing:()=>xst,rnn:()=>ist,separableConv2d:()=>xrt,simpleRNN:()=>nst,simpleRNNCell:()=>rst,softmax:()=>prt,spatialDropout1d:()=>Trt,stackedRNNCells:()=>ost,thresholdedReLU:()=>frt,timeDistributed:()=>ust,upSampling2d:()=>krt,zeroPadding2d:()=>Vrt});async function Uu(e){if(e==null)return;let t=[],n=[],r=[];for(let s in e){let a=e[s];if(typeof a!="number"){let i=a;t.push(i.data()),n.push(s),r.push(i)}}if(t.length>0){let s=await Promise.all(t);for(let a=0;a<s.length;++a)e[n[a]]=s[a][0];_t(r)}}function Kee(e){if(e!=null)for(let t in e){let n=e[t];typeof n!="number"&&n.dispose()}}var r5;(function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"})(r5||(r5={}));var Xtt=125,Kg=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},Xee=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},Ytt=class extends Kg{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let r in t){let s=t[r];if(typeof s=="number")this.totals.hasOwnProperty(r)||(this.totals[r]=0),this.totals[r]=this.totals[r]+s*n;else{let a;r in this.totals?a=this.totals[r]:this.totals[r]=0;let i=ue(()=>De(this.totals[r],oe(s,n)));this.totals[r]=i,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:ue(()=>{let r=oe(ot(1,this.seen),this.totals[n]);t[n]=r,this.totals[n].dispose(),Vr(t[n])}))}},Yee=class extends Kg{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let o=a[i];e.push(o.data()),t.push(s),n.push(i)}}let r=await Promise.all(e);for(let s=0;s<r.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=r[s][0]}},Jee=class extends Kg{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||QP,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Xtt),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");M.isNumber(this.yieldEvery)&&(this.maybeWait=Xet(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let r=[];this.yield!=null&&(await Uu(n),r.push(this.yield(e,t,n))),r.push(this.nextFrameFunc()),await Promise.all(r)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Uu(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Uu(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Uu(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Uu(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):M.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Uu(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Uu(e),await this.trainEnd(e))}};function Zee(e,t){return e==null&&(e={}),e instanceof Kg?[e]:Array.isArray(e)&&e[0]instanceof Kg?e:mn(e).map(n=>new Jee(n,t))}var yL=class el{constructor(){}static registerCallbackConstructor(t,n){M.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),el.checkForDuplicate(n),el.constructors[t]==null&&(el.constructors[t]=[]),el.constructors[t].push(n)}static checkForDuplicate(t){for(let n in el.constructors)el.constructors[+n].forEach(r=>{if(r===t)throw new he("Duplicate callback constructor.")})}static clear(){el.constructors={}}static createCallbacks(t){let n=[];for(let r in el.constructors){let s=+r;t>=s&&n.push(...el.constructors[s])}return n.map(r=>new r)}};yL.constructors={};function Qee(e,t,n,r,s,a,i,o,l){let u=new Yee,c=[new Ytt,...yL.createCallbacks(t)];e!=null&&c.push(...e),c.push(u);let d=new Xee(c);return d.setParams({epochs:n,initialEpoch:r,samples:s,steps:a,batchSize:i,verbose:t,doValidation:o,metrics:l}),{callbackList:d,history:u}}function Oo(e,t={},n=!1){return Dw(e,Be.SerializationMap.getMap().classNameMap,t,"layer",n)}function iI(e,t){return ue(()=>{e.dtype!=="float32"&&(e=je(e,"float32"));let n=ct(Fw(e),t,!0),r=Ka(n.shape,Ur()),s=Is(Wl(n,r));return ot(e,s)})}function Zf(e,t){return ue(()=>rr(Fw(nt(t,e)),-1))}function XT(e,t){return ue(()=>rr(Ir(nt(t,e)),-1))}function Hb(e,t){return ue(()=>{let n=nt(e,t),r=Fs(Ir(e),Ur(),Number.MAX_VALUE),s=Ir(ot(n,r));return oe(100,rr(s,-1))})}function Jtt(e,t){return ue(()=>{let n=Fs(t,Ur(),Number.MAX_VALUE),r=Qa(De(1,n)),s=Fs(e,Ur(),Number.MAX_VALUE),a=Qa(De(1,s));return rr(Fw(nt(r,a)),-1)})}function Ztt(e,t){return ue(()=>{let n=Wl(0,nt(1,oe(e,t)));return rr(Fw(n),-1)})}function Qtt(e,t){return ue(()=>{let n=Wl(0,nt(1,oe(e,t)));return rr(n,-1)})}function ent(e,t){return ue(()=>{let n=ct(oe(e,t),-1),r=vi(oe(nt(1,e),t),-1);return Wl(0,De(1,nt(r,n)))})}function tnt(e,t){return ue(()=>{let n=Math.log(2),r=nt(t,e),s=nt(De(r,Xf(oe(-2,r))),n);return rr(s,-1)})}function s0(e,t,n=!1){return ue(()=>{if(n)t=wd(t);else{let r=ct(t,t.shape.length-1,!0);t=ot(t,r)}return t=Fs(t,Ur(),1-Ur()),Fn(ct(oe(je(e,"float32"),Qa(t)),t.shape.length-1))})}function oI(e,t,n=!1){return ue(()=>{let r=je(Bb(ott(e)),"int32");t=Fs(t,Ur(),1-Ur());let s=t.shape,a=le(Vg(r,s[s.length-1]),s);return s0(a,t,n)})}function nnt(e,t){if(!M.arraysEqual(e.shape,t.shape))throw new he(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return ue(()=>{let n=gn(t),r=Fn(Ir(t));return De(nt(n,oe(t,e)),Sw(Ms(r)))})}function YT(e,t){return ue(()=>{let n;return n=Fs(t,Ur(),1-Ur()),n=Qa(ot(n,nt(1,n))),rr(nnt(e,n),-1)})}function rnt(e,t){return ue(()=>{let n=Fs(e,Ur(),1),r=Fs(t,Ur(),1);return ct(oe(e,Qa(ot(n,r))),-1)})}function snt(e,t){return ue(()=>{let n=Qa(De(Ur(),t));return rr(nt(t,oe(e,n)),-1)})}function bL(e,t){return ue(()=>{let n=iI(e,-1),r=iI(t,-1),s=oe(n,r);return Fn(ct(s,-1))})}var lI={meanSquaredError:Zf,meanAbsoluteError:XT,meanAbsolutePercentageError:Hb,meanSquaredLogarithmicError:Jtt,squaredHinge:Ztt,hinge:Qtt,categoricalHinge:ent,logcosh:tnt,categoricalCrossentropy:s0,sparseCategoricalCrossentropy:oI,binaryCrossentropy:YT,kullbackLeiblerDivergence:rnt,poisson:snt,cosineProximity:bL};function zE(e){if(typeof e=="string"){if(e in lI)return lI[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new he(t)}else return e}function vL(e,t){return ue(()=>{let n=oe(.5,ei(t)),r=vu(oa(t,n),e.dtype);return rr(Za(e,r),-1)})}function xL(e,t){return ue(()=>vu(Za(Yh(e,-1),Yh(t,-1)),"float32"))}function ete(e,t){return ue(()=>je(ct(eo(Za(e,1),Za(t,1))),"float32"))}function ant(e,t){return ue(()=>je(ct(eo(Za(e,1),Za(t,0))),"float32"))}function int(e,t){return ue(()=>je(ct(eo(Za(e,0),Za(t,1))),"float32"))}function tte(e,t){return ue(()=>{let n=ete(e,t),r=int(e,t),s=De(n,r);return je(ds(oa(s,0),ot(n,s),0),"float32")})}function ont(e,t){return ue(()=>{let n=ete(e,t),r=ant(e,t),s=De(n,r);return je(ds(oa(s,0),ot(n,s),0),"float32")})}function nte(e,t){return YT(e,t)}function rte(e,t){return e.rank===t.rank&&(e=kd(e,[e.rank-1])),t=Yh(t,-1),t.dtype!==e.dtype&&(t=je(t,e.dtype)),je(Za(e,t),"float32")}var lnt=Zf,unt=Zf,cnt=XT,dnt=XT,hnt=Hb,pnt=Hb,wL=s0,fnt=bL,ste=oI,uI={binaryAccuracy:vL,categoricalAccuracy:xL,precision:tte,categoricalCrossentropy:wL,sparseCategoricalCrossentropy:ste,mse:lnt,MSE:unt,mae:cnt,MAE:dnt,mape:hnt,MAPE:pnt,cosine:fnt};function mnt(e){if(typeof e=="string"&&e in uI)return uI[e];if(typeof e!="string"&&e!=null)return e;throw new he(`Unknown metric ${e}`)}function Uk(e){if(dl(e!==null,`Unknown LossOrMetricFn ${e}`),typeof e=="string")return e;{let t;for(let n of Object.keys(lI))if(lI[n]===e){t=n;break}if(t!==void 0)return t;for(let n of Object.keys(uI))if(uI[n]===e){t=n;break}return t!==void 0?t:e.name}}function gnt(e){let t={Adagrad:()=>Vd.adagrad(.01),Adadelta:()=>Vd.adadelta(1,.95,Ur()),Adam:()=>Vd.adam(.001,.9,.999,Ur()),Adamax:()=>Vd.adamax(.002,.9,.999,Ur(),0),RMSProp:()=>Vd.rmsprop(.001,.9,0,Ur()),SGD:()=>Vd.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new he(`Unknown Optimizer ${e}`)}function s5(e,t,n=!1){if(e==null||typeof e!="object"||Object.getPrototypeOf(e)!==Object.prototype||!SR(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){let r=JSON.stringify(e);r.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function SR(e){if(e===null)return!0;if(typeof e=="object")if(Object.getPrototypeOf(e)===Object.prototype){let t=Object.keys(e);for(let n of t)if(typeof n!="string"||!SR(e[n]))return!1;return!0}else if(Array.isArray(e)){for(let t of e)if(!SR(t))return!1;return!0}else return!1;else{let t=typeof e;return t==="string"||t==="number"||t==="boolean"}}function ynt(e,t,n,r=console.log){let s=vnt(e),a=["Layer (type)","Input Shape","Output shape","Param #"];s?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map(c=>Math.floor(t*c)));let i;if(!s){a.push("Receives inputs"),i=[];for(let c in e.nodesByDepth)i.push(...e.nodesByDepth[c])}r("_".repeat(t)),cI(a,n,r),r("=".repeat(t));let o=e.layers;for(let c=0;c<o.length;++c)s?xnt(o[c],n,r):wnt(o[c],n,i,r),r((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();let l=bnt(e),u=rI(e.nonTrainableWeights);r(`Total params: ${l+u}`),r(`Trainable params: ${l}`),r(`Non-trainable params: ${u}`),r("_".repeat(t))}function bnt(e){let t;return e.collectedTrainableWeights!=null?t=rI(e.collectedTrainableWeights):t=rI(e.trainableWeights),t}function vnt(e){let t=!0,n=[],r=[];for(let s in e.nodesByDepth)n.push(e.nodesByDepth[s]);for(let s of n){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}r.push(...s)}if(t)for(let s of e.layers){let a=!1;for(let i of s.inboundNodes)if(r.indexOf(i)!==-1)if(a){t=!1;break}else a=!0;if(!t)break}return t}function cI(e,t,n=console.log){let r="";for(let s=0;s<e.length;++s)s>0&&(r=r.slice(0,r.length-1)+" "),r+=e[s],r=r.slice(0,t[s]),r+=" ".repeat(t[s]-r.length);n(r)}function xnt(e,t,n){let r,s;try{s=e.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{s="multiple"}try{r=JSON.stringify(e.outputShape)}catch{r="multiple"}let a=e.name,i=e.getClassName(),o=[`${a} (${i})`,s,r,e.countParams().toString()];cI(o,t,n)}function wnt(e,t,n,r){let s,a;try{a=e.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{a="multiple"}try{s=JSON.stringify(e.outputShape)}catch{s="multiple"}let i=[];for(let d of e.inboundNodes)if(!(n!=null&&n.length>0&&n.indexOf(d)===-1))for(let h=0;h<d.inboundLayers.length;++h){let p=d.inboundLayers[h].name,f=d.nodeIndices[h],m=d.tensorIndices[h];i.push(`${p}[${f}][${m}]`)}let o=e.name,l=e.getClassName(),u=i.length===0?"":i[0],c=[`${o} (${l})`,a,s,e.countParams().toString(),u];cI(c,t,r);for(let d=1;d<i.length;++d)cI(["","","","",i[d]],t,r)}function ate(e,t,n){return(e==="inboundNodes"||e==="outputLayers"||e==="inputLayers")&&t===0&&typeof n=="string"}function a0(e,t){if(e===null)return null;if(typeof e=="string")return Xd(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];ate(t,s,a)?n.push(a):n.push(a0(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r];if(r==="name"&&typeof s=="string")n[r]=s;else{let a=Xd(r);n[a]=a0(s,a)}}return n}}function IR(e,t){if(e==null)return null;if(typeof e=="string")return Yl(e);if(typeof e=="number"||typeof e=="boolean")return e;if(e instanceof Array){let n=[],r=e.length;for(let s=0;s<r;++s){let a=e[s];ate(t,s,a)?n.push(a):n.push(IR(a,t))}return n}else{let n={};for(let r of Object.keys(e)){let s=e[r],a=Yl(r);(r==="name"||r==="className")&&typeof s=="string"?n[a]=s:n[a]=IR(s,r)}return n}}var kL="4.16.0",knt=e=>{let t=Object.keys(e);if(t.length===0)return!1;let n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))},Snt=class tl extends Ut{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){let b=this.getClassName().toLowerCase();this.name=zT(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Cc(this.inputs).length!==this.inputs.length)throw new he(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Cc(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let b of this.outputs){let x=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(let b of this.inputs){let x=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;dl(v===0,"input layer has >1 nodes"),dl(w===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){let x=this.inputLayers[b];if(!(x instanceof Gb))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);let n={},r={},s={},a={},i={},o=[],l=(b,x,v,w,k,S)=>{(w==null||k==null||S==null)&&(w=b.sourceLayer,k=b.nodeIndex,S=b.tensorIndex);let I=w.inboundNodes[k];if(v.indexOf(I)!==-1)throw new gl(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(x.indexOf(I)!==-1)return;this.containerNodes.add(tl.nodeKey(w,k)),w.id in i||(i[w.id]=Object.keys(i).length),v.indexOf(I)===-1&&v.push(I);let $=I.inboundLayers.length;for(let C=0;C<$;C++){let T=I.inputTensors[C],N=I.inboundLayers[C],E=I.nodeIndices[C],_=I.tensorIndices[C];l(T,x,v,N,E,_)}for(x.push(I);v.indexOf(I)>=0;)v.splice(v.indexOf(I),1);o.push(I)},u=[],c=[];for(let b of this.outputs)l(b,u,c);let d=o.slice().reverse();for(let b of d){r[b.id]=b,b.id in n||(n[b.id]=0);let x=n[b.id],v=s[b.outboundLayer.id]==null?0:s[b.outboundLayer.id];x=Math.max(x,v),s[b.outboundLayer.id]=x,a[b.outboundLayer.id]=b.outboundLayer,n[b.id]=x;for(let w=0;w<b.inboundLayers.length;w++){let k=b.inboundLayers[w],S=b.nodeIndices[w],I=k.inboundNodes[S],$=n[I.id]==null?0:n[I.id];n[I.id]=Math.max(x+1,$),r[I.id]=I}}let h={};for(let b in n){let x=n[b];x in h||(h[x]=[]),h[x].push(r[b])}let p={};for(let b in s){let x=s[b];x in p||(p[x]=[]),p[x].push(a[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(Bk);this.layers=[];for(let b of f){let x=p[b];x.sort((v,w)=>{let k=i[v.id],S=i[w.id];return k<S?-1:k>S?1:0});for(let v of x)v instanceof tl&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,f=Object.keys(h).map(b=>parseInt(b,10)).sort(Bk);let m=this.inputs.slice(),g=[];for(let b of f)for(let x of h[b]){let v=x.outboundLayer;if(v!=null){for(let w of x.inputTensors)if(m.indexOf(w)===-1)throw new gl(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${g}`);for(let w of x.outputTensors)m.push(w);g.push(v.name)}}this.nodesByDepth=h;let y=this.layers.map(b=>b.name);for(let b of y){let x=y.filter(v=>v===b).length;if(x!==1)throw new gl(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new KT({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)t.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)t.numDisposedVariables+=n.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(n=>{n._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new he("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let n of this.layers)t=t.concat(n.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let n of this.layers)t.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let r of this.layers)n.push(...r.trainableWeights);return n.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,n=!0){let r={},s=0,a=knt(t);a&&this.parseWeights(t);for(let o of this.layers)for(let[l,u]of o.weights.entries()){let c=a?`${u.name.split("/").slice(0,-1).join("/")+"/"}${l}`:u.originalName;if(r[c]!=null)throw new he(`Duplicate weight name: ${c}`);r[c]=u,s++}let i=[];for(let o in t){let l=o;if(r[o]==null){let u=o.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(r[l]!=null)i.push([r[l],t[o]]);else if(n)throw new he(`Provided weight data has no target variable: ${o}`);delete r[l]}if(n){let o=[];for(let l in r)o.push(l);if(o.length>0)throw new he(`${o.length} of ${s} weights are not set: ${o}`)}dL(i)}parseWeights(t){for(let n in Object.keys(t)){let r=n.split("/"),s=["vars","layer_checkpoint_dependencies"],a=r.map(i=>i.startsWith("_")?i.slice(1):i).filter(i=>!s.includes(i)).join("/");a!==n&&(t[a]=t[n],delete t[n])}}updatedConfig(){let t=this.getConfig(),n={};return n.className=this.getClassName(),n.config=t,n.kerasVersion=`tfjs-layers ${kL}`,n.backend="TensorFlow.js",n}toJSON(t,n=!0){let r=IR(this.updatedConfig());return n?JSON.stringify(r):r}call(t,n){return ue(()=>{t=mn(t);let r=new Bm;for(let s=0;s<this.inputs.length;++s)r.add(this.inputs[s],t[s]);return Wv(this.outputs,r,n)})}computeMask(t,n){return ue(()=>{t=mn(t);let r;return n==null?r=np(null,t.length):r=mn(n),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){let n=nI(t);if(n.length!==this.inputLayers.length)throw new he(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let r={};for(let o=0;o<n.length;o++){let l=this.inputLayers[o],u=n[o],c=l.name+"_0_0";r[c]=u}let s=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Bk);if(s.length>1)for(let o of s){let l=this.nodesByDepth[o];for(let u of l){let c=u.outboundLayer;if(this.inputLayers.map(m=>m.id).indexOf(c.id)!==-1)continue;let d=[];for(let m=0;m<u.inboundLayers.length;m++){let g=u.inboundLayers[m],y=u.nodeIndices[m],b=u.tensorIndices[m],x=`${g.name}_${y}_${b}`,v=r[x];d.push(v)}let h=c.computeOutputShape(pa(d)),p=nI(h),f=c.inboundNodes.indexOf(u);for(let m=0;m<p.length;m++){let g=`${c.name}_${f}_${m}`;r[g]=p[m]}}}let a=[],i=[];for(let o=0;o<this.outputLayers.length;o++){let l=this.outputLayers[o],u=this.outputLayersNodeIndices[o],c=this.outputLayersTensorIndices[o],d=`${l.name}_${u}_${c}`;i.push(d)}for(let o=0;o<i.length;o++){let l=i[o];dl(l in r),a.push(r[l])}return pa(a)}runInternalGraph(t,n){n==null&&(n=np(null,t.length));let r={};for(let l=0;l<this.inputs.length;++l){let u=this.inputs[l],c=t[l],d=n[l];r[u.id]=[c,d]}let s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Bk);for(let l of s){let u=this.nodesByDepth[l];for(let c of u){let d=c.outboundLayer,h=c.inputTensors,p=c.outputTensors,f=new Array;for(let m of h)m.id in r&&f.push(r[m.id]);if(f.length===h.length){let m={},g,y,b,x;if(c.callArgs!=null&&(m=c.callArgs),f.length===1){let[v,w]=f[0];m.mask==null&&(m.mask=w),b=mn(d.call(v,m)),x=mn(d.computeMask(v,w)),g=[v],y=[w]}else g=f.map(v=>v[0]),y=f.map(v=>v[1]),m.mask==null&&(m.mask=y),b=mn(d.call(g,m)),x=mn(d.computeMask(g,y));if(d.activityRegularizer)throw new Wt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v){let w=p[v],k=b[v],S=x[v];r[w.id]=[k,S]}}}}let a=[],i=[],o=[];for(let l of this.outputs){dl(l.id in r,`Could not compute output ${l.name} : ${l.id}`);let[u,c]=r[l.id];o.push(u.shape),a.push(u),i.push(c)}return[a,i,o]}buildNodeConversionMap(t){let n={},r;for(let s of this.layers){r=s instanceof tl?1:0;for(let a=0;a<s.inboundNodes.length;a++){let i=tl.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=r,r+=1)}}return n}getLayer(t,n){if(n!=null)return this.findLayer(n);if(t==null)throw new he("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(let r of this.layers)if(r.name===t)return r;throw new he(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new he(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return ue(()=>{let t=[];for(let n of this.layers)for(let r=0;r<n.inboundNodes.length;++r){let s=tl.nodeKey(n,r);this.containerNodes.has(s)&&t.push(...n.calculateLosses())}return t})}getConfig(){let t={name:this.name},n=this.buildNodeConversionMap(this.layers),r=[];for(let i of this.layers){let o=i.getClassName(),l=i.getConfig(),u=[];for(let d=0;d<i.inboundNodes.length;d++){let h=i.inboundNodes[d],p=tl.nodeKey(i,d),f={};if(this.containerNodes.has(p)){if(h.callArgs)try{JSON.stringify(h.callArgs),f=h.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${h.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(h.inboundLayers.length>0){let m=[];for(let g=0;g<h.inboundLayers.length;g++){let y=h.inboundLayers[g],b=h.nodeIndices[g],x=h.tensorIndices[g],v=tl.nodeKey(y,b),w=n[v];w==null&&(w=0),m.push([y.name,w,x,f])}u.push(m)}}}let c={};c.name=i.name,c.className=o,c.config=l,c.inboundNodes=u,r.push(c)}t.layers=r;let s=[];for(let i=0;i<this.inputLayers.length;i++){let o=this.inputLayers[i],l=this.inputLayersNodeIndices[i],u=tl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let d=this.inputLayersTensorIndices[i];s.push([o.name,c,d])}t.inputLayers=s;let a=[];for(let i=0;i<this.outputLayers.length;i++){let o=this.outputLayers[i],l=this.outputLayersNodeIndices[i],u=tl.nodeKey(o,l);if(!this.containerNodes.has(u))continue;let c=n[u];c==null&&(c=0);let d=this.outputLayersTensorIndices[i];a.push([o.name,c,d])}return t.outputLayers=a,t}static fromConfig(t,n,r={},s=!1){let a={},i={};function o(g,y){g.name in i?i[g.name].push(y):i[g.name]=[y]}function l(g,y){let b=[],x;for(let v of y){let w=v[0],k=v[1],S=v[2];if(x=v[3]==null?{}:v[3],!(w in a)){o(g,y);return}let I=a[w];if(I.inboundNodes.length<=k){o(g,y);return}let $=I.inboundNodes[k];b.push($.outputTensors[S])}b.length>0&&g.apply(pa(b),x)}function u(g){let y=g.name,b=Oo(g,n.customObjects!=null?n.customObjects:{});b.setFastWeightInitDuringBuild(s),a[y]=b,g.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new he(`Corrupted configuration, expected array for nodeData: ${x}`);o(b,x)})}let c=n.name,d=n.layers;for(let g of d)u(g);for(;!Ket(i);)for(let g of d){let y=a[g.name];if(y.name in i){let b=i[y.name];delete i[y.name];for(let x of b)l(y,x)}}let h=[],p=[],f=n.inputLayers;for(let g of f){let y=g[0],b=g[1],x=g[2];dl(y in a);let v=a[y].inboundNodes[b].outputTensors;h.push(v[x])}let m=n.outputLayers;for(let g of m){let y=g[0],b=g[1],x=g[2];dl(y in a);let v=a[y].inboundNodes[b].outputTensors;p.push(v[x])}return new t({inputs:h,outputs:p,name:c})}get stateful(){if(this._stateful)throw new he("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ue(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function Int(e,t,n){let r=t.length;if(e==null||Array.isArray(e)&&e.length===0)return t.map(s=>null);if(r===1)return Array.isArray(e)&&e.length===1?e:typeof e=="object"&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==r)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return e}else if(typeof e=="object"&&Object.keys(e).length>0&&typeof e[Object.keys(e)[0]]=="object"){let s=[];return t.forEach(a=>{a in e?s.push(e[a]):s.push(null)}),s}else throw new Error(`The model has multiple (${r}) outputs, so ${n} must be either an array with ${r} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function ite(e,t){return Int(e,t,"classWeight")}async function ote(e,t,n,r){if(t!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(n!=null){let s=ue(()=>{if(e.shape.length===1)return Nl(e);if(e.shape.length===2){if(e.shape[1]>1)return Yh(e,1);if(e.shape[1]===1)return le(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await s.data());_t(s);let i=[];return a.forEach(o=>{if(n[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);i.push(n[o])}),dn(i,"float32")}else return null}function Cnt(e,t){return oe(e,t)}var Nnt=32;function lte(e,t){let n,r,s=t;n=s.xs,r=s.ys,M.assert(n!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let a=a5("input",e.inputNames,n),i=a5("output",e.outputNames,r),o=a[0].shape[0];M.assert(a.length===e.inputs.length,()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`),M.assert(i.length===e.outputs.length,()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`);for(let l=0;l<a.length;l++)M.assert(a[l].shape[0]===o,()=>`Batch size mismatch: input ${e.inputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);for(let l=0;l<i.length;l++)M.assert(i[l].shape[0]===o,()=>`Batch size mismatch: output ${e.outputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`);return{xs:a,ys:i}}function a5(e,t,n){if(n instanceof Bt)return[n];if(Array.isArray(n))return M.assert(n.length===t.length,()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`),n;{let r=[];for(let s of t){if(n[s]==null)throw new he(`The feature data generated by the dataset lacks the required ${e} key '${s}'.`);r.push(n[s])}return r}}function Tnt(e){if(e.length===3)throw new Wt("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}async function $nt(e,t,n){let r=n.batchesPerEpoch!=null;if(M.assert(e.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),M.assert(n!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),M.assert(n.epochs!=null&&n.epochs>0&&Number.isInteger(n.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`),M.assert(!r||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`),M.assert(n.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{let s=n.validationData!=null,a,i;if(s)if(i5(n.validationData))M.assert(n.validationBatches==null||n.validationBatches>0&&Number.isInteger(n.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`);else{let g=Tnt(n.validationData);a=g.xs,i=g.ys}let o=e.makeTrainFunction(),l=e.getDedupedMetricsNames(),u;s?u=l.slice().concat(l.map(g=>"val_"+g)):u=l.slice();let c=Zee(n.callbacks,n.yieldEvery),d=n.verbose==null?1:n.verbose,{callbackList:h,history:p}=Qee(c,d,n.epochs,null,null,Ent(t,n),null,s,u);h.setModel(e),e.history=p,await h.onTrainBegin(),e.stopTraining_=!1;let f=n.initialEpoch==null?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){let g={};await h.onEpochBegin(f);let y=0,b=0;for(r||(m=await t.iterator());!r||y<n.batchesPerEpoch;){let x=await m.next();if(r&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${n.batchesPerEpoch*n.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:v,ys:w}=lte(e,x.value),k={};k.batch=b,k.size=v[0].shape[0],await h.onBatchBegin(b,k);let S=[];if(n.classWeight!=null){let C=ite(n.classWeight,e.outputNames);for(let T=0;T<C.length;++T)S.push(await ote(w[T],null,C[T]))}let I=v.concat(w).concat(S),$=o(I);_t(I);for(let C=0;C<l.length;++C){let T=l[C],N=$[C];k[T]=N,Vr(N)}await h.onBatchEnd(b,k),Kee(k),b++,y++}if(r?y>=n.batchesPerEpoch:x.done){if(s){let v;i5(n.validationData)?v=mn(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):v=mn(e.evaluate(a,i,{batchSize:n.validationBatchSize==null?Nnt:n.validationBatchSize,verbose:0}));for(let w=0;w<e.metricsNames.length;++w)g[`val_${e.metricsNames[w]}`]=v[w]}break}if(e.stopTraining_)break}if(await h.onEpochEnd(f,g),f++,e.stopTraining_)break}return await h.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Ent(e,t){let n=null;return t.batchesPerEpoch!=null?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size),n}function i5(e){return typeof e.iterator=="function"}function _nt(e){return typeof e.next=="function"}async function Ant(e,t,n){n=n||{};let r=n.batches!=null,s=e.testFunction,a=[];if(n.verbose>0)throw new Wt("Verbose mode is not implemented yet.");M.assert(!r||n.batches>0&&Number.isInteger(n.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`);let i=_nt(t)?t:await t.iterator(),o=0,l=0;for(;!r||l<n.batches;){let u=await i.next();if(a=ue(()=>{if(u.value){let{xs:c,ys:d}=lte(e,u.value),h=c.concat(d),p=ue(()=>s(h));if(_t(h),l===0)for(let m=0;m<p.length;++m)a.push(bt(0));let f=h[0].shape[0];for(let m=0;m<p.length;++m){let g=p[m],y=a[m];a[m]=ue(()=>De(a[m],oe(f,g))),l>0&&_t(y)}_t(p),o+=f,++l}return a}),u.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<a.length;++u){let c=a[u];a[u]=ot(a[u],o),_t(c)}return pa(a)}function BE(e){M.assert(e>0&&Number.isInteger(e),()=>`batchSize is required to be a positive integer, but got ${e}`)}function Sv(e,t,n){return e==null?[null]:Array.isArray(e)?e.map(r=>bh(r,t,n-t)):bh(e,t,n-t)}function CR(e,t){return ue(()=>e==null?null:Array.isArray(e)?e.map(n=>CR(n,t)):zee(e,t.dtype==="int32"?t:je(t,"int32")))}function WE(e,t){let n=[],r=0,s=null;for(;r<e;)s=r+t,s>=e&&(s=e),n.push([r,s]),r=s;return n}function ute(e){let t=[];e instanceof Bt&&(e=[e]);for(let n=0;n<e.length;++n){let r=e[n];if(r.rank===1)t.push(Ow(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function fo(e,t){if(e==null)return;let n=[];if(t instanceof Bt)n.push(t.id);else if(Array.isArray(t))t.forEach(s=>n.push(s.id));else if(t!=null)for(let s in t){let a=t[s];n.push(a.id)}let r=[];if(e instanceof Bt)n.indexOf(e.id)===-1&&r.push(e);else if(Array.isArray(e))e.forEach(s=>{n.indexOf(s.id)===-1&&r.push(s)});else if(e!=null)for(let s in e){let a=e[s];n.indexOf(a.id)===-1&&r.push(a)}r.forEach(s=>{s.isDisposed||s.dispose()})}function Rnt(e){return e instanceof Bt}function NR(e){return Array.isArray(e)}function o5(e){return!Rnt(e)&&!NR(e)}function l5(e,t,n,r=!0,s=""){if(t==null||t.length===0){if(e!=null){let i=!1;if(NR(e)&&e.length>0)i=!0;else if(o5(e)){for(let o in e)if(e.hasOwnProperty(o)){i=!0;break}}else i=!0;if(i)throw new he(`Error when checking model ${s} expected no data, but got ${e}`)}return[]}if(e==null)return t.map(i=>null);let a;if(o5(e)){e=e,a=[];for(let i of t){if(e[i]==null)throw new he(`No data provided for "${i}". Need data for each key in: ${t}`);a.push(e[i])}}else if(NR(e)){if(e=e,e.length!==t.length)throw new he(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);a=e}else{if(e=e,t.length>1)throw new he(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);a=[e]}if(a=ute(a),n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new he(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c>=0&&u!==c)throw new he(`${s} expected a batch of elements where each example has shape [${n[i].slice(1,n[i].length)}] (i.e.,tensor shape [*,${n[i].slice(1,n[i].length)}]) but the ${s} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return a}function Dnt(e,t,n){let r=Cc(e.map(a=>a.shape[0]));r.sort();let s=Cc(t.map(a=>a.shape[0]));if(s.sort(),r.length>1)throw new he(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(s.length>1)throw new he(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(a=>a.shape))}`);if(r.length>0&&s.length>0&&!M.arraysEqual(r,s))throw new he(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${s[0]} target sample(s).`)}function Ont(e,t,n){let r=[Zf,YT,s0];for(let s=0;s<e.length;++s){let a=e[s],i=t[s],o=n[s];if(i!=null){if(i===s0&&a.shape[a.shape.length-1]===1)throw new he(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(i)!==-1){let l=a.shape.slice(1),u=o.slice(1);for(let c=0;c<l.length;++c){let d=l[c],h=u[c];if(h!=null&&d!==h)throw new he(`A target Tensor with shape ${a.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function u5(e,t,n,r=!0,s=""){let a;if(Array.isArray(e)){if(e.length!==t.length)throw new he(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);a=e}else{if(t.length>1)throw new he(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);a=[e]}if(n!=null)for(let i=0;i<t.length;++i){if(n[i]==null)continue;let o=a[i];if(o.shape.length!==n[i].length)throw new he(`Error when checking ${s}: expected ${t[i]} to have ${n[i].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<n[i].length;++l){if(l===0&&!r)continue;let u=o.shape[l],c=n[i][l];if(c!=null&&c!==u)throw new he(`Error when checking ${s}: expected ${t[i]} to have shape ${JSON.stringify(n[i])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function Fnt(e,t){if(e==null||Array.isArray(e)&&e.length===0)return t.map(r=>[]);let n;if(typeof e=="string"||typeof e=="function")n=[e];else if(Array.isArray(e)||typeof e=="object")n=e;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);if(Array.isArray(n))return t.map(r=>n);{let r=[];for(let s of t){let a=n.hasOwnProperty(s)?n[s]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}var Mnt="layers-model",iu=class extends Snt{constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new he("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");ynt(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=gnt(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Du))throw new he("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new he(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(zE(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new he(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>zE(a))}else{let a=zE(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],o=this.outputNames[a];this.feedOutputNames.push(o),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],yh("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let r=Fnt(e.metrics,this.outputNames),s=(a,i,o)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([o,a])};yh("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=r[a];(o=>{let l="",u,c,d;for(let h of o){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let f=this.internalOutputShapes[a];f[f.length-1]===1||this.lossFunctions[a]===YT?["accuracy","acc"].indexOf(h)!==-1?c=vL:["crossentropy","ce"].indexOf(h)!==-1&&(c=nte):this.lossFunctions[a]===oI?["accuracy","acc"].indexOf(h)!==-1?c=rte:["crossentropy","ce"].indexOf(h)!==-1&&(c=ste):["accuracy","acc"].indexOf(h)!==-1?c=xL:["crossentropy","ce"].indexOf(h)!==-1&&(c=wL);let m;["accuracy","acc"].indexOf(h)!==-1?m="acc":["crossentropy","ce"].indexOf(h)!==-1&&(m="ce"),d=c,u=l+m}else d=mnt(h),u=l+Uk(h);let p;yh(u,()=>{p=d}),s(a,u,p)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let r=n.batchSize==null?32:n.batchSize;BE(r);let s=this.standardizeUserDataXY(e,t,!0,r);try{let a=s[0].concat(s[1]);this.makeTestFunction();let i=this.testFunction,o=this.testLoop(i,a,r,n.verbose,n.steps);return pa(o)}finally{fo(s[0],e),fo(s[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),Ant(this,e,t)}checkNumSamples(e,t,n,r="steps"){let s;if(n!=null){if(s=null,t!=null)throw new he(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new he(`Either the input data should have a defined shape, or ${r} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new he("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),r=n?t:[t],s=this.retrieveSymbolicTensors(r),a=new Bm;if(e instanceof Bt&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new he(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let o=0;o<this.inputs.length;++o)a.add(this.inputs[o],e[o])}else for(let o of this.inputs){let l=e[o.name];if(l==null)throw new he(`No value is provided for the model's input ${o.name}`);a.add(o,l)}let i=Wv(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=np(null,e.length),n=e.length;for(let r of this.layers){let s=Array.isArray(r.output)?r.output:[r.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let o=a.indexOf(e[i]);if(o!==-1&&(t[i]=s[o],n--),n===0)break}if(n===0)break}if(n>0){let r=[];throw t.forEach((s,a)=>{s==null&&r.push(e[a])}),new he(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(r)}`)}return t}predictLoop(e,t=32,n=!1){return ue(()=>{let r=this.checkNumSamples(e);if(n)throw new Wt("Verbose predictLoop() is not implemented yet.");let s=WE(r,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)ue(()=>{let o=s[i][0],l=s[i][1],u=Sv(e,o,l),c=[];if(Array.isArray(u))for(let h=0;h<u.length;++h)c.push({key:this.inputs[h],value:u[h]});else c.push({key:this.inputs[0],value:u});let d=new Bm(c);return Wv(this.outputs,d)}).forEach((o,l)=>a[l].push(o));return pa(a.map(i=>In(i,0)))})}predict(e,t={}){let n=ute(e);u5(n,this.inputNames,this.feedInputShapes,!1);try{let r=t.batchSize==null?32:t.batchSize;return BE(r),this.predictLoop(n,r)}finally{fo(n,e)}}predictOnBatch(e){u5(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,r){if(this.optimizer_==null)throw new gl("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===oI?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=l5(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=l5(t,this.feedOutputNames,s,!1,"target"),Dnt(e,t),Ont(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&r!=null&&r>0&&e[0].shape[0]%r!==0)throw new he(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${r}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,r,s=!0,a){let[i,o]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(r!=null){let u=ite(r,this.outputNames);l=[];for(let c=0;c<u.length;++c)l.push(await ote(o[c],null,u[c]))}return[i,o,l]}testLoop(e,t,n,r=0,s){return ue(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(r>0)throw new Wt("Verbose mode is not implemented yet.");if(s!=null)throw new Wt("steps mode in testLoop() is not implemented yet");{let o=WE(a,n),l=dn(Bo(0,a));for(let u=0;u<o.length;++u){let c=o[u][0],d=o[u][1],h=bh(l,c,d-c),p=CR(t,h),f=e(p);if(u===0)for(let m=0;m<f.length;++m)i.push(bt(0));for(let m=0;m<f.length;++m){let g=f[m];i[m]=De(i[m],oe(d-c,g))}}for(let u=0;u<i.length;++u)i[u]=ot(i[u],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let r=e[n],s=r;if(Kj(e,r)>1){let a=Kj(e.slice(0,n),r);s+=`_${a}`}t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let l=[];for(let h=0;h<this.inputs.length;++h)l.push({key:this.inputs[h],value:n[h]});let u=new Bm(l),c=Wv(this.outputs,u,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let p=this.lossFunctions[h],f=p(r[h],c[h]);s[h]!=null&&(f=Cnt(f,s[h]));let m=rr(f);t.push(m),h===0?d=f:d=De(d,f)}for(let h=0;h<this.metricsTensors.length;++h){let p;if(this.outputs.length>1&&h<this.outputs.length)p=t[h];else{let f=this.metricsTensors[h][0],m=this.metricsTensors[h][1];p=rr(f(r[m],c[m]))}Vr(p),a.push(p)}return d=rr(d),this.calculateLosses().forEach(h=>{d=De(d,h)}),d},o=this.collectedTrainableWeights.map(l=>l.read());return[this.optimizer_.minimize(i,!0,o)].concat(a)}}makeTestFunction(){this.testFunction=e=>ue(()=>{let t=[],n,r=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:r[l]});let i=new Bm(a),o=Wv(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let u=this.lossFunctions[l],c=rr(u(s[l],o[l]));l===0?n=c:n=De(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let u=this.metricsTensors[l][0],c=this.metricsTensors[l][1],d=rr(u(s[c],o[c]));t.push(d)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let r,s,a,i,o,l,u,c,d;try{let h=n.batchSize==null?32:n.batchSize;BE(h);let p=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,!1,h);r=p[0],s=p[1],d=p[2];let f=!1,m;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)o=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Wt("validationData including sample weights is not supported yet."):new he(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let k=await this.standardizeUserData(o,l,null,null,!0,h);u=k[0],c=k[1],m=u.concat(c)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let k=Math.floor(r[0].shape[0]*(1-n.validationSplit)),S=r[0].shape[0];u=Sv(r,k,S),a=r,r=Sv(r,0,k),c=Sv(s,k,S),i=s,s=Sv(s,0,k),m=u.concat(c)}else n.validationSteps!=null&&(f=!0);let g=r.concat(s).concat(d);this.checkTrainableWeightsConsistency();let y=this.makeTrainFunction(),b=this.getDedupedMetricsNames(),x,v;f?(this.makeTestFunction(),x=this.testFunction,v=b.slice().concat(b.map(k=>"val_"+k))):(x=null,m=[],v=b.slice());let w=Zee(n.callbacks,n.yieldEvery);return await this.fitLoop(y,g,b,h,n.epochs,n.verbose,w,x,m,n.shuffle,v,n.initialEpoch,null,null)}finally{this.isTraining=!1,fo(r,e),fo(s,t),fo(a,e),fo(i,t),fo(u,o),fo(c,l),d!=null&&_t(d)}}async fitLoop(e,t,n,r,s,a,i,o,l,u,c,d,h,p){r==null&&(r=32),s==null&&(s=1),u==null&&(u=!0),d==null&&(d=0);let f=!1;if(o!=null&&l!=null&&(f=!0),p!=null&&(f=!0,h==null))throw new he("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let m=this.checkNumSamples(t,r,h,"steps_per_epoch"),g;m!=null&&(g=Bo(0,m)),a==null&&(a=1);let{callbackList:y,history:b}=Qee(i,a,s,d,m,h,r,f,c);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let x=d;x<s;++x){await y.onEpochBegin(x);let v={};if(h!=null)throw new Wt("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new Wt("batch shuffling is not implemneted yet");u&&M.shuffle(g);let w=dn(g),k=WE(m,r);for(let S=0;S<k.length;++S){let I={};if(await y.onBatchBegin(S,I),ue(()=>{let $=k[S][0],C=k[S][1],T=bh(w,$,C-$);I.batch=S,I.size=C-$;let N=CR(t,T),E=e(N);for(let _=0;_<n.length;++_){let R=n[_],z=E[_];I[R]=z,Vr(z)}if(S===k.length-1&&f){let _=this.testLoop(o,l,r);for(let R=0;R<n.length;++R){let z=n[R],W=_[R];Vr(W),v["val_"+z]=W}}}),await y.onBatchEnd(S,I),Kee(I),this.stopTraining_)break}w.dispose()}if(await y.onEpochEnd(x,v),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return $nt(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),r=n[0],s=n[1],a=this.makeTrainFunction()(r.concat(s)),i=[];for(let o of a){let l=await o.data();i.push(l[0])}return _t(a),fo(n[0],e),fo(n[1],t),pa(i)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,r=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<r.length;++a)n&&!r[a].trainable||t.push({name:r[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=QS().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-QS().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Yl(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Yl(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let r of t)if(typeof n[r]=="string")e[r]=Yl(n[r]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Yl(Uk(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Yl(Uk(e)));{let e={};for(let t in this.metrics)e[t]=Yl(Uk(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=a0(e.optimizer_config),n=Oo(t),r;if(typeof e.loss=="string")r=Xd(e.loss);else if(Array.isArray(e.loss))r=e.loss.map(a=>Xd(a));else if(e.loss!=null){r={};for(let a in e.loss)r[a]=Xd(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>Xd(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=Xd(e.metrics[a])}this.compile({loss:r,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let s=ws.getSaveHandlers(e);if(s.length===0)throw new he(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new he(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new he("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await ws.encodeWeights(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:Mnt,generatedBy:`TensorFlow.js tfjs-layers v${kL}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){r.trainingConfig=this.getTrainingConfig();let s="optimizer",{data:a,specs:i}=await ws.encodeWeights(await this.optimizer.getWeights(),s);n.specs.push(...i),n.data=ws.concatenateArrayBuffers([n.data,a])}return this.userDefinedMetadata!=null&&(s5(this.userDefinedMetadata,this.name,!0),r.userDefinedMetadata=this.userDefinedMetadata),r.weightData=n.data,r.weightSpecs=n.specs,e.save(r)}setUserDefinedMetadata(e){s5(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};iu.className="Model";Be.registerClass(iu);var cte=class extends iu{};cte.className="Functional";Be.registerClass(cte);async function Pnt(e,t){"modelTopology"in e||(e={modelTopology:e}),e=e;let n=e.modelTopology;n.model_config!=null&&(n=n.model_config);let r=a0(n),s=Oo(r,t);if(e.weightsManifest!=null){let a=await ws.loadWeights(e.weightsManifest,e.pathPrefix,s.weights.map(o=>o.originalName)),i={};for(let o of s.weights)i[o.originalName]=a[o.originalName];s.loadWeights(i),_t(a)}return s}async function Lnt(e,t){if(t==null&&(t={}),typeof e=="string"){let n=ws.getLoadHandlers(e,t);if(n.length===0)n.push(ws.browserHTTPRequest(e,t));else if(n.length>1)throw new he(`Found more than one (${n.length}) load handlers for URL '${e}'`);e=n[0]}return znt(e,void 0,t)}async function znt(e,t,n){if(n==null&&(n={}),e.load==null)throw new he("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let r=await e.load(),s=r.modelTopology;s.model_config!=null&&(s=s.model_config);let a=n.strict==null?!0:n.strict,i=r.weightData!=null&&r.weightSpecs!=null&&a,o=Oo(a0(s),t,i),l=r.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),r.userDefinedMetadata!=null&&o.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new he("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:u,optimizerWeights:c}=Bnt(r.weightData,r.weightSpecs);o.loadWeights(u,a),o.optimizer!=null&&c.length>0&&await o.optimizer.setWeights(c),_t(u),_t(c.map(d=>d.tensor))}return o}function Bnt(e,t){let n=ws.decodeWeights(e,t),r={},s=[];return t.forEach(a=>{a.group==="optimizer"?s.push({name:a.name,tensor:n[a.name]}):r[a.name]=n[a.name]}),{modelWeights:r,optimizerWeights:s}}var JT=class TR extends iu{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:zT("sequential_"),t.layers!=null)for(let n of t.layers)this.add(n)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new he(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let n=t instanceof TR||t instanceof iu,r;if(n){if(r=t,r.outputs.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new he("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new he("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=Uee({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(n)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new he(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new he("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=Vee(this.outputs[0])}this.inboundNodes=[],new KT({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:np(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,n){return this.model==null&&this.build(),this.model.call(t,n)}build(t){if(rn(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new iu({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,n,r=console.log){this.built||this.build(),super.summary(t,n,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,n,r={}){if(!this.built)throw new gl("The model needs to be compiled before being used.");return this.model.evaluate(t,n,r)}async evaluateDataset(t,n){if(!this.built)throw new gl("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,n)}predict(t,n={}){return this.model==null&&this.build(),this.model.predict(t,n)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,n,r={}){if(!this.built)throw new gl("The model needs to be compiled before being used.");return this.model.fit(t,n,r)}async fitDataset(t,n){if(!this.built)throw new gl("The model needs to be compiled before being used.");return this.model.fitDataset(t,n)}async trainOnBatch(t,n){return this.model.trainOnBatch(t,n)}static fromConfig(t,n,r={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new he("Legacy serialization format not supported yet.");a=n}else M.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;let o=new t(i);if(!(o instanceof TR))throw new Wt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(let l of a){let u=Oo(l,void 0,s);s&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(t){if(this.model==null)throw new he("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new he("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let n of this.layers){let r={};r.className=n.getClassName(),r.config=n.getConfig(),t.push(r)}return{name:this.name,layers:t}}};JT.className="Sequential";Be.registerClass(JT);function Wnt(e){return new iu(e)}function Vnt(e){return new JT(e)}function dte(e){return Uee(e)}function Unt(e,t){yL.registerCallbackConstructor(e,t)}var Ea=class extends Be.Serializable{getConfig(){return{}}},hte=class extends Ea{apply(e,t=1){return utt(e,t)}};hte.className="elu";Be.registerClass(hte);var pte=class extends Ea{apply(e){return kT(e)}};pte.className="selu";Be.registerClass(pte);var fte=class extends Ea{apply(e){return gn(e)}};fte.className="relu";Be.registerClass(fte);var mte=class extends Ea{apply(e){return ue(()=>Vc(6,gn(e)))}};mte.className="relu6";Be.registerClass(mte);var gte=class extends Ea{apply(e){return e}};gte.className="linear";Be.registerClass(gte);var yte=class extends Ea{apply(e){return qi(e)}};yte.className="sigmoid";Be.registerClass(yte);var bte=class extends Ea{apply(e){return dtt(e)}};bte.className="hardSigmoid";Be.registerClass(bte);var vte=class extends Ea{apply(e){return Xf(e)}};vte.className="softplus";Be.registerClass(vte);var xte=class extends Ea{apply(e){return ctt(e)}};xte.className="softsign";Be.registerClass(xte);var wte=class extends Ea{apply(e){return Zh(e)}};wte.className="tanh";Be.registerClass(wte);var SL=class extends Ea{apply(e,t=-1){return wd(e,t)}};SL.className="softmax";Be.registerClass(SL);var kte=class extends Ea{apply(e,t=-1){return mT(e,t)}};kte.className="logSoftmax";Be.registerClass(kte);var Ste=class extends Ea{apply(e,t=1){return ue(()=>oe(qi(oe(e,t)),e))}};Ste.className="swish";Be.registerClass(Ste);var Ite=class extends Ea{apply(e){return ue(()=>oe(e,Zh(Xf(e))))}};Ite.className="mish";Be.registerClass(Ite);function Gc(e){return e.getClassName()}function VE(e,t={}){return Dw(e,Be.SerializationMap.getMap().classNameMap,t,"activation")}function Hc(e){if(e==null){let t={};return t.className="linear",t.config={},VE(t)}if(typeof e=="string"){let t={};return t.className=e,t.config={},VE(t)}else return e instanceof Ea?e:VE(e)}function IL(e){if(e!=null&&typeof e!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}var Cte=class extends Be.Serializable{},Lw=class extends Cte{constructor(e){super(),IL(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return ue(()=>{let t=sr([1]);return this.hasL1&&(t=De(t,ct(oe(this.l1,Ir(e))))),this.hasL2&&(t=De(t,ct(oe(this.l2,Fw(e))))),le(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Lw.className="L1L2";Be.registerClass(Lw);function jnt(e){return IL(e),new Lw({l1:e!=null?e.l1:null,l2:0})}function Gnt(e){return IL(e),new Lw({l2:e!=null?e.l2:null,l1:0})}var c5={l1l2:"L1L2"};function _n(e){return tL(e)}function d5(e,t={}){return Dw(e,Be.SerializationMap.getMap().classNameMap,t,"regularizer")}function Zn(e){if(e==null)return null;if(typeof e=="string"){let t={className:e in c5?c5[e]:e,config:{}};return d5(t)}else return e instanceof Cte?e:d5(e)}var CL=class extends Ut{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Et(e);let n=gn(e);return this.maxValue!=null&&(n=Fs(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};CL.className="ReLU";Be.registerClass(CL);var NL=class extends Ut{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Et(e);return kw(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};NL.className="LeakyReLU";Be.registerClass(NL);var TL=class extends Ut{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=Yn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Zn(e.alphaRegularizer),this.alphaConstraint=Kr(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new he(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=rn(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let r of this.sharedAxes)t[r-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let r=1;r<e.length;++r)n[r]=e[r];this.inputSpec=[new Tr({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Et(e),$w(e,this.alpha.read())}getConfig(){let e={alphaInitializer:ir(this.alphaInitializer),alphaRegularizer:_n(this.alphaRegularizer),alphaConstraint:qr(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};TL.className="PReLU";Be.registerClass(TL);var $L=class extends Ut{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Wt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Et(e);return Lb(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};$L.className="ELU";Be.registerClass($L);var EL=class extends Ut{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Et(e);return oe(n,je(oa(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};EL.className="ThresholdedReLU";Be.registerClass(EL);var _L=class extends Ut{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new SL().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return ue(()=>{let n=Et(e),r=t.mask;if(r!=null){let s=oe(nt(fa(n.shape),je(r,n.dtype)),bt(-1e9));n=De(n,s)}return this.axis instanceof Array?this.axis.length>1?Ms(nt(n,Iw(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)})}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};_L.className="Softmax";Be.registerClass(_L);function ag(e,t,n){if(typeof e=="number")return np(e,t);if(e.length!==t)throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){let s=e[r];if(!att(s))throw new he(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${s}`)}return e}function Fo(e,t,n,r,s=1){if(e==null)return e;let a=t+(t-1)*(s-1),i;return n==="same"?i=e:i=e-a+1,Math.floor((i+r-1)/r)}function hl(e,t,n,r){if(e==null)return null;if(r==="valid")e=e*t+jc([n-t,0]);else if(r==="same")e=e*t;else throw new he(`Unsupport padding mode: ${r}.`);return e}function AL(e,t){return ue(()=>(kr(t),t==="channelsFirst"?Lt(e,[0,2,3,1]):e))}function Nte(e,t){return ue(()=>(kr(t),t==="channelsFirst"?Lt(e,[0,2,3,4,1]):e))}function Hnt(e,t,n,r=1,s="valid",a,i=1){return ue(()=>{if(a==null&&(a=Wo()),kr(a),e.shape.length!==3)throw new he(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(t.shape.length!==3)throw new he(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(n!=null&&n.shape.length!==1)throw new he(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(a==="channelsFirst"&&(e=Lt(e,[0,2,1])),s==="causal")throw new Wt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=uT(e,t,r,s==="same"?"same":"valid","NWC",i);return n!=null&&(o=qo(o,n)),o})}function h5(e,t,n,r=[1,1],s="valid",a,i,o=null){return ue(()=>{if(a==null&&(a=Wo()),kr(a),e.rank!==3&&e.rank!==4)throw new he(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(t.rank!==3&&t.rank!==4)throw new he(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=AL(e,a);if(s==="causal")throw new Wt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Hg.conv2d({x:l,filter:t,strides:r,pad:s==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:n,activation:o}),a==="channelsFirst"&&(l=Lt(l,[0,3,1,2])),l})}function qnt(e,t,n,r=[1,1,1],s="valid",a,i){return ue(()=>{if(a==null&&(a=Wo()),kr(a),e.rank!==4&&e.rank!==5)throw new he(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(t.rank!==4&&t.rank!==5)throw new he(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=Nte(e,a);if(s==="causal")throw new Wt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=sP(o,t,r,s==="same"?"same":"valid","NDHWC",i),n!=null&&(o=qo(o,n)),a==="channelsFirst"&&(o=Lt(o,[0,4,1,2,3])),o})}var Tte=class $te extends Ut{constructor(t,n){if(super(n),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",$te.verifyArgs(n),this.rank=t,cs(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Wt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ag(n.kernelSize,t,"kernelSize"),this.strides=ag(n.strides==null?1:n.strides,t,"strides"),this.padding=n.padding==null?"valid":n.padding,Ei(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,kr(this.dataFormat),this.activation=Hc(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=Yn(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Kr(n.biasConstraint),this.biasRegularizer=Zn(n.biasRegularizer),this.activityRegularizer=Zn(n.activityRegularizer),this.dilationRate=ag(n.dilationRate==null?1:n.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new he(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new he(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new he(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(dl("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!nL(t.kernelSize,"number",1,3))throw new he(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Gc(this.activation),useBias:this.useBias,biasInitializer:ir(this.biasInitializer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),biasConstraint:qr(this.biasConstraint)},n=super.getConfig();return Object.assign(t,n),t}},ZT=class Ete extends Tte{constructor(t,n){super(t,n),this.kernel=null,Ete.verifyArgs(n),this.filters=n.filters,cs(this.filters,"filters"),this.kernelInitializer=Yn(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Kr(n.kernelConstraint),this.kernelRegularizer=Zn(n.kernelRegularizer)}build(t){t=rn(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new he(`The channel dimension of the input should be defined. Found ${t[n]}`);let r=t[n],s=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:r}}],this.built=!0}call(t,n){return ue(()=>{t=Et(t);let r,s=this.bias==null?null:this.bias.read(),a=Dee(this.activation.getClassName());if(a!=null&&this.rank===2)r=h5(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=Hnt(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=h5(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=qnt(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Wt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=rn(t);let n=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let a=0;a<r.length;++a){let i=Fo(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){let t={filters:this.filters,kernelInitializer:ir(this.kernelInitializer),kernelRegularizer:_n(this.kernelRegularizer),kernelConstraint:qr(this.kernelConstraint)},n=super.getConfig();return Object.assign(t,n),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new he(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},QT=class _te extends ZT{constructor(t){super(2,t),_te.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!nL(t.kernelSize,"number",1,2))throw new he(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};QT.className="Conv2D";Be.registerClass(QT);var e$=class Ate extends ZT{constructor(t){super(3,t),Ate.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new he(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};e$.className="Conv3D";Be.registerClass(e$);var RL=class extends QT{constructor(e){if(super(e),this.inputSpec=[new Tr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=rn(e),e.length!==4)throw new he("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Tr({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return ue(()=>{let n=Et(e);if(n.shape.length!==4)throw new he(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let o=r[a],l=r[i],u=this.kernelSize[0],c=this.kernelSize[1],d=this.strides[0],h=this.strides[1],p=hl(o,d,u,this.padding),f=hl(l,h,c,this.padding),m=[s,p,f,this.filters];this.dataFormat!=="channelsLast"&&(n=Lt(n,[0,2,3,1]));let g=cT(n,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=Lt(g,[0,3,1,2])),this.bias!=null&&(g=qo(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=rn(e);let t=e.slice(),n,r,s;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3):(n=3,r=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[r]=hl(t[r],o,a,this.padding),t[s]=hl(t[s],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};RL.className="Conv2DTranspose";Be.registerClass(RL);var DL=class extends e${constructor(e){if(super(e),this.inputSpec=[new Tr({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new he(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=rn(e),e.length!==5)throw new he("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new he("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],r=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",r,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Tr({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return ue(()=>{let n=Et(e);if(n.shape.length!==5)throw new he(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let r=n.shape,s=r[0],a,i,o;this.dataFormat==="channelsFirst"?(o=2,a=3,i=4):(o=1,a=2,i=3);let l=r[o],u=r[a],c=r[i],d=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],f=this.strides[0],m=this.strides[1],g=this.strides[2],y=hl(l,f,d,this.padding),b=hl(u,m,h,this.padding),x=hl(c,g,p,this.padding),v=[s,y,b,x,this.filters];this.dataFormat!=="channelsLast"&&(n=Lt(n,[0,2,3,4,1]));let w=aP(n,this.kernel.read(),v,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Lt(w,[0,4,1,2,3])),this.bias!==null&&(w=qo(w,this.bias.read(),this.dataFormat)),this.activation!==null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=rn(e);let t=e.slice(),n,r,s,a;this.dataFormat==="channelsFirst"?(n=1,r=2,s=3,a=4):(n=4,r=1,s=2,a=3);let i=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],d=this.strides[2];return t[n]=this.filters,t[r]=hl(t[r],u,i,this.padding),t[s]=hl(t[s],c,o,this.padding),t[a]=hl(t[a],d,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};DL.className="Conv3DTranspose";Be.registerClass(DL);var Rte=class extends ZT{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new he("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new he("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new he(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Yn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Zn(t.depthwiseRegularizer),this.depthwiseConstraint=Kr(t.depthwiseConstraint),this.pointwiseInitializer=Yn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Zn(t.pointwiseRegularizer),this.pointwiseConstraint=Kr(t.pointwiseConstraint)}build(e){if(e=rn(e),e.length<this.rank+2)throw new he(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new he(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],r=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",r,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Tr({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return ue(()=>{e=Et(e);let n;if(this.rank===1)throw new Wt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Lt(e,[0,2,3,1])),n=Vb(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=qo(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Lt(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ir(this.depthwiseInitializer),e.pointwiseInitializer=ir(this.pointwiseInitializer),e.depthwiseRegularizer=_n(this.depthwiseRegularizer),e.pointwiseRegularizer=_n(this.pointwiseRegularizer),e.depthwiseConstraint=qr(this.depthwiseConstraint),e.pointwiseConstraint=qr(this.pointwiseConstraint),e}};Rte.className="SeparableConv";var OL=class extends Rte{constructor(e){super(2,e)}};OL.className="SeparableConv2D";Be.registerClass(OL);var FL=class Dte extends ZT{constructor(t){super(1,t),Dte.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!nL(t.kernelSize,"number",1,1))throw new he(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};FL.className="Conv1D";Be.registerClass(FL);var ML=class extends Ut{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return ue(()=>{if(e=Et(e),this.dataFormat==="channelsLast"){let n=Vk(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Vk(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Vk(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Vk(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};ML.className="Cropping2D";Be.registerClass(ML);var PL=class extends Ut{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,ntt(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return ue(()=>{let n=Et(e),r=n.shape;if(this.dataFormat==="channelsFirst"){n=Lt(n,[0,2,3,1]);let s=this.size[0]*r[2],a=this.size[1]*r[3],i=this.interpolation==="nearest"?di.resizeNearestNeighbor(n,[s,a]):di.resizeBilinear(n,[s,a]);return Lt(i,[0,3,1,2])}else{let s=this.size[0]*r[1],a=this.size[1]*r[2];return this.interpolation==="nearest"?di.resizeNearestNeighbor(n,[s,a]):di.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};PL.className="UpSampling2D";Be.registerClass(PL);function Knt(e,t,n=[1,1],r="valid",s,a){return ue(()=>{s==null&&(s=Wo()),kr(s);let i=AL(e,s);if(e.rank!==4)throw new he(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(t.rank!==4)throw new he(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return i=Kf(i,t,n,r==="same"?"same":"valid","NHWC",a),s==="channelsFirst"&&(i=Lt(i,[0,3,1,2])),i})}var LL=class extends Tte{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Yn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Kr(e.depthwiseConstraint),this.depthwiseRegularizer=Zn(e.depthwiseRegularizer)}build(e){if(e=rn(e),e.length<4)throw new he(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new he(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],r=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",r,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ue(()=>{e=Et(e);let n=Knt(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=qo(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=rn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Fo(t,this.kernelSize[0],this.padding,this.strides[0]),a=Fo(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],r,s,a]:[e[0],s,a,r]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ir(this.depthwiseInitializer),e.depthwiseRegularizer=_n(this.depthwiseRegularizer),e.depthwiseConstraint=qr(this.depthwiseRegularizer),e}};LL.className="DepthwiseConv2D";Be.registerClass(LL);function Ote(e,t,n,r){if(Array.isArray(e)){if(t!=null||n!=null)throw new he("When inputs is an array, neither initialState or constants should be provided");r!=null&&(n=e.slice(e.length-r,e.length),e=e.slice(0,e.length-r)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function s(a){return a==null||Array.isArray(a)?a:[a]}return t=s(t),n=s(n),{inputs:e,initialState:t,constants:n}}function Fte(e,t,n,r=!1,s,a,i=!1,o=!1){return ue(()=>{let l=t.shape.length;if(l<3)throw new he(`Input should be at least 3D, but is ${l}D.`);let u=[1,0].concat(Bo(2,l));if(t=Lt(t,u),a!=null)throw new Wt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=je(je(s,"bool"),"float32"),s.rank===l-1&&(s=is(s,-1)),s=Lt(s,u)),r&&(t=Ii(t,0),s!=null&&(s=Ii(s,0)));let c=[],d,h=n,p=t.shape[0],f=hr(t),m;s!=null&&(m=hr(s));for(let y=0;y<p;++y){let b=f[y],x=ue(()=>e(b,h));if(s==null)d=x[0],h=x[1];else{let v=ue(()=>{let w=m[y],k=nt(ei(w),w),S=De(oe(x[0],w),oe(h[0],k)),I=h.map(($,C)=>De(oe(x[1][C],w),oe($,k)));return{output:S,newStates:I}});d=v.output,h=v.newStates}o&&c.push(d)}let g;return o&&(g=_r(c,1)),[d,g,h]})}var Ou=class Mte extends Ut{constructor(t){super(t);let n;if(t.cell==null)throw new he("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?n=new r$({cells:t.cell}):n=t.cell,n.stateSize==null)throw new he("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new Tr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Bo(0,t).map(n=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){wR(t)&&(t=t[0]),t=t;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let r=n[0],s;if(this.returnSequences?s=[t[0],t[1],r]:s=[t[0],r],this.returnState){let a=[];for(let i of n)a.push([t[0],i]);return[s].concat(a)}else return s}computeMask(t,n){return ue(()=>{Array.isArray(n)&&(n=n[0]);let r=this.returnSequences?n:null;if(this.returnState){let s=this.states.map(a=>null);return[r].concat(s)}else return r})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let r=0;r<t;++r)n.push(null);return n}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new Wt("Constants support is not implemented in RNN yet.");wR(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new Tr({shape:[n,null,...r]});let s=[t[0]].concat(t.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!M.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new he(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Tr({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(t,n=!1){ue(()=>{if(!this.stateful)throw new Ku("Cannot call resetStates() on an RNN Layer that is not stateful.");let r=this.inputSpec[0].shape[0];if(r==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>sr([r,s])):this.states_=[sr([r,this.cell.stateSize])];else if(t==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>sr([r,s])):this.states_[0]=sr([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);n===!0?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let s=0;s<this.states_.length;++s){let a=t[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,o=[r,i];if(!M.arraysEqual(a.shape,o))throw new he(`State ${s} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>Vr(s.clone()))})}apply(t,n){let r=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let a=Ote(t,r,s,this.numConstants);t=a.inputs,r=a.initialState,s=a.constants;let i=[],o=[];if(r!=null){n.initialState=r,i=i.concat(r),this.stateSpec=[];for(let l of r)this.stateSpec.push(new Tr({shape:l.shape}));o=o.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof Vo){let l=[t].concat(i),u=this.inputSpec.concat(o),c=this.inputSpec;this.inputSpec=u;let d=super.apply(l,n);return this.inputSpec=c,d}else return super.apply(t,n)}call(t,n){return ue(()=>{let r=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;t=Et(t),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(t));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new he(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let o={training:s},l=Fte((p,f)=>{let m=this.cell.call([p].concat(f),o);return[m[0],m.slice(1)]},t,a,this.goBackwards,r,null,this.unroll,this.returnSequences),u=l[0],c=l[1],d=l[2];this.stateful&&this.resetStates(d,s);let h=this.returnSequences?c:u;return this.returnState?[h].concat(d):h})}getInitialState(t){return ue(()=>{let n=sr(t.shape);return n=ct(n,[1,2]),n=Ow(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?vR(n,[1,r]):n):this.cell.stateSize>1?[vR(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let r=this.cell.getConfig();return this.getClassName()===Mte.className&&(n.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),n)}static fromConfig(t,n,r={}){let s=n.cell,a=Oo(s,r);return new t(Object.assign(n,{cell:a}))}};Ou.className="RNN";Be.registerClass(Ou);var zw=class extends Ut{},t$=class extends zw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,cs(this.units,"units"),this.activation=Hc(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Zn(e.kernelRegularizer),this.recurrentRegularizer=Zn(e.recurrentRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=qg([1,jc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=qg([1,jc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=rn(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ue(()=>{if(e=e,e.length!==2)throw new he(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let r=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qc({ones:()=>ei(e),rate:this.dropout,training:r,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qc({ones:()=>ei(n),rate:this.recurrentDropout,training:r,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=$l(oe(e,a),this.kernel.read()):s=$l(e,this.kernel.read()),this.bias!=null&&(s=qo(s,this.bias.read())),i!=null&&(n=oe(n,i));let o=De(s,$l(n,this.recurrentKernel.read()));return this.activation!=null&&(o=this.activation.apply(o)),[o,o]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Gc(this.activation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),recurrentInitializer:ir(this.recurrentInitializer),biasInitializer:ir(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};t$.className="SimpleRNNCell";Be.registerClass(t$);var zL=class extends Ou{constructor(e){e.cell=new t$(e),super(e)}call(e,t){return ue(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return new e(t)}};zL.className="SimpleRNN";Be.registerClass(zL);var n$=class extends zw{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new he("GRUCell does not support reset_after parameter set to true.");this.units=e.units,cs(this.units,"units"),this.activation=Hc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Hc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Zn(e.kernelRegularizer),this.recurrentRegularizer=Zn(e.recurrentRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=qg([1,jc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=qg([1,jc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=rn(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return ue(()=>{if(e=e,e.length!==2)throw new he(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,r=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qc({ones:()=>ei(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qc({ones:()=>ei(r),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,o,l;0<this.dropout&&this.dropout<1&&(e=oe(e,s[0]));let u=$l(e,this.kernel.read());this.useBias&&(u=qo(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oe(r,a[0]));let c=this.recurrentKernel.read(),[d,h]=ya(c,[2*this.units,this.units],c.rank-1),p=$l(r,d),[f,m,g]=ya(u,3,u.rank-1),[y,b]=ya(p,2,p.rank-1);i=this.recurrentActivation.apply(De(f,y)),o=this.recurrentActivation.apply(De(m,b));let x=$l(oe(o,r),h);l=this.activation.apply(De(g,x));let v=De(oe(i,r),oe(De(1,Fn(i)),l));return[v,v]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Gc(this.activation),recurrentActivation:Gc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),recurrentInitializer:ir(this.recurrentInitializer),biasInitializer:ir(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};n$.className="GRUCell";Be.registerClass(n$);var BL=class extends Ou{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new n$(e),super(e)}call(e,t){return ue(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};BL.className="GRU";Be.registerClass(BL);var Bw=class extends zw{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,cs(this.units,"units"),this.activation=Hc(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Hc(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Yn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Zn(e.kernelRegularizer),this.recurrentRegularizer=Zn(e.recurrentRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.kernelConstraint=Kr(e.kernelConstraint),this.recurrentConstraint=Kr(e.recurrentConstraint),this.biasConstraint=Kr(e.biasConstraint),this.dropout=qg([1,jc([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=qg([1,jc([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=rn(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let r;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;r=new(t=class extends io{apply(i,o){let l=s.apply([a]),u=new WT().apply([a]),c=s.apply([a*2]);return Yj(Yj(l,u),c)}},t.className="CustomInit",t)}else r=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,r,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return ue(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new he(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let r=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qc({ones:()=>ei(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qc({ones:()=>ei(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,o,l,u,c;0<this.dropout&&this.dropout<1&&(e=oe(e,a[0]));let d=$l(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(r=oe(r,i[0])),d=De(d,$l(r,this.recurrentKernel.read())),this.useBias&&(d=qo(d,this.bias.read()));let[h,p,f,m]=ya(d,4,d.rank-1);o=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=De(oe(l,s),oe(o,this.activation.apply(f))),c=this.recurrentActivation.apply(m);let g=oe(c,this.activation.apply(u));return[g,g,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Gc(this.activation),recurrentActivation:Gc(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),recurrentInitializer:ir(this.recurrentInitializer),biasInitializer:ir(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:_n(this.kernelRegularizer),recurrentRegularizer:_n(this.recurrentRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),recurrentConstraint:qr(this.recurrentConstraint),biasConstraint:qr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}};Bw.className="LSTMCell";Be.registerClass(Bw);var WL=class extends Ou{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Bw(e),super(e)}call(e,t){return ue(()=>{this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};WL.className="LSTM";Be.registerClass(WL);var r$=class extends zw{constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return ue(()=>{e=e;let n=e.slice(1),r=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?r.push(n.splice(0,i.stateSize.length)):r.push(n.splice(0,1));r.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let o=this.cells[i];n=r[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=o.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){wR(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,r)=>{yh(`RNNCell_${r}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=r=>({className:r.getClassName(),config:r.getConfig()}),n={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),n)}static fromConfig(e,t,n={}){let r=[];for(let s of t.cells)r.push(Oo(s,n));return new e({cells:r})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return kR(e)}setWeights(e){let t=[];for(let n of this.cells){let r=n.weights.length,s=e.splice(r);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}dL(t)}};r$.className="StackedRNNCells";Be.registerClass(r$);function qc(e){let{ones:t,rate:n,training:r=!1,count:s=1,dropoutFunc:a}=e,i=()=>a!=null?a(t(),n):Bee(t(),n),o=()=>Mw(i,t,r);return!s||s<=1?Vr(o().clone()):Array(s).fill(void 0).map(o).map(l=>Vr(l.clone()))}var Xnt=function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,r=Object.getOwnPropertySymbols(e);s<r.length;s++)t.indexOf(r[s])<0&&Object.prototype.propertyIsEnumerable.call(e,r[s])&&(n[r[s]]=e[r[s]]);return n},Pte=class extends Ou{constructor(e){if(e.unroll)throw new Wt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Wt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Tr({ndim:5})]}call(e,t){return ue(()=>{if(this.cell.dropoutMask!=null&&(_t(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_t(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new he("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,r=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:r,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return ue(()=>{let{stateSize:t}=this.cell,n=e.shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)],a=sr(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){ue(()=>{if(!this.stateful)throw new Ku("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,r=this.computeSingleOutputShape(n),s=[r[0],...r.slice(2)];if(n[0]==null)throw new he("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(s)):this.states_=[sr(s)];else if(e==null)_t(this.states_),this.keptStates!=null&&(_t(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>sr(s)):this.states_[0]=sr(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new he(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_t(this.states_);for(let a=0;a<this.states_.length;++a){let i=e[a],o=s;if(!M.arraysEqual(i.shape,o))throw new he(`State ${a} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${i.shape}`);this.states_[a]=i}}this.states_=this.states_.map(a=>Vr(a.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:r,padding:s,strides:a,dilationRate:i}=this.cell,o=t==="channelsFirst",l=e[o?3:2],u=e[o?4:3],c=Fo(l,r[0],s,a[0],i[0]),d=Fo(u,r[1],s,a[1],i[1]);return[...e.slice(0,2),...o?[n,c,d]:[c,d,n]]}};Pte.className="ConvRNN2D";var s$=class extends Bw{constructor(e){let{filters:t,kernelSize:n,strides:r,padding:s,dataFormat:a,dilationRate:i}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,cs(this.filters,"filters"),this.kernelSize=ag(n,2,"kernelSize"),this.kernelSize.forEach(o=>cs(o,"kernelSize")),this.strides=ag(r||1,2,"strides"),this.strides.forEach(o=>cs(o,"strides")),this.padding=s||"valid",Ei(this.padding),this.dataFormat=a||"channelsLast",kr(this.dataFormat),this.dilationRate=ag(i||1,2,"dilationRate"),this.dilationRate.forEach(o=>cs(o,"dilationRate"))}build(e){var t;e=rn(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new he(`The channel dimension of the input should be defined. Found ${e[n]}`);let r=e[n],s=4,a=this.kernelSize.concat([r,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let o;if(this.unitForgetBias){let l=this.biasInitializer,u=this.filters;o=new(t=class extends io{apply(c,d){let h=l.apply([u]),p=fa([u]),f=l.apply([u*2]);return rL([h,p,f])}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,o,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return ue(()=>{if(e.length!==3)throw new he(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,r=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qc({ones:()=>ei(r),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let o=this.dropoutMask,l=(L,O,D)=>!O||!O[D]?L:oe(O[D],L),u=l(r,o,0),c=l(r,o,1),d=l(r,o,2),h=l(r,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qc({ones:()=>ei(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let p=this.recurrentDropoutMask,f=l(s,p,0),m=l(s,p,1),g=l(s,p,2),y=l(s,p,3),b=3,[x,v,w,k]=ya(this.kernel.read(),i,b),[S,I,$,C]=this.useBias?ya(this.bias.read(),i):[null,null,null,null];u=this.inputConv(u,x,S,this.padding),c=this.inputConv(c,v,I,this.padding),d=this.inputConv(d,w,$,this.padding),h=this.inputConv(h,k,C,this.padding);let[T,N,E,_]=ya(this.recurrentKernel.read(),i,b);f=this.recurrentConv(f,T),m=this.recurrentConv(m,N),g=this.recurrentConv(g,E),y=this.recurrentConv(y,_);let R=this.recurrentActivation.apply(De(u,f)),z=this.recurrentActivation.apply(De(c,m)),W=De(oe(z,a),oe(R,this.activation.apply(De(d,g)))),F=oe(this.recurrentActivation.apply(De(h,y)),this.activation.apply(W));return[F,F,W]})}getConfig(){let e=super.getConfig(),t=Xnt(e,["units"]),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),n)}inputConv(e,t,n,r){let s=ta(e,t,this.strides,r||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?qo(s,n,this.dataFormat):s}recurrentConv(e,t){return ta(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};s$.className="ConvLSTM2DCell";Be.registerClass(s$);var VL=class extends Pte{constructor(e){let t=new s$(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};VL.className="ConvLSTM2D";Be.registerClass(VL);var a$=class extends Ut{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let r=0;r<this.noiseShape.length;++r)n.push(this.noiseShape[r]==null?t[r]:this.noiseShape[r]);return n}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e);if(0<this.rate&&this.rate<1){let r=t.training==null?!1:t.training,s=this.getNoiseShape(n);return Mw(()=>Bee(n,this.rate,s,this.seed),()=>n,r)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};a$.className="Dropout";Be.registerClass(a$);var UL=class extends a${constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};UL.className="SpatialDropout1D";Be.registerClass(UL);var jL=class extends Ut{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,cs(this.units,"units"),this.activation=Hc(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=Yn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Yn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Kr(e.kernelConstraint),this.biasConstraint=Kr(e.biasConstraint),this.kernelRegularizer=Zn(e.kernelRegularizer),this.biasRegularizer=Zn(e.biasRegularizer),this.activityRegularizer=Zn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=rn(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=rn(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e),r=Dee(this.activation.getClassName()),s;return r!=null?s=$l(n,this.kernel.read(),r,this.bias?this.bias.read():null):(s=$l(n,this.kernel.read()),this.bias!=null&&(s=qo(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:Gc(this.activation),useBias:this.useBias,kernelInitializer:ir(this.kernelInitializer),biasInitializer:ir(this.biasInitializer),kernelRegularizer:_n(this.kernelRegularizer),biasRegularizer:_n(this.biasRegularizer),activityRegularizer:_n(this.activityRegularizer),kernelConstraint:qr(this.kernelConstraint),biasConstraint:qr(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};jL.className="Dense";Be.registerClass(jL);var GL=class extends Ut{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=rn(e);for(let t of e.slice(1))if(t==null)throw new he(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Nc(e,1)]}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let r=[0];for(let s=2;s<n.rank;++s)r.push(s);r.push(1),n=Lt(n,r)}return ltt(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};GL.className="Flatten";Be.registerClass(GL);var HL=class extends Ut{constructor(e){super(e),this.supportsMasking=!0,this.activation=Hc(e.activation)}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e);return this.activation.apply(n)})}getConfig(){let e={activation:Gc(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};HL.className="Activation";Be.registerClass(HL);var qL=class extends Ut{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return ue(()=>(e=Et(e),itt(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};qL.className="RepeatVector";Be.registerClass(qL);var KL=class extends Ut{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",r=t.slice(),s=1,a=null;for(let o=0;o<r.length;++o){let l=r[o];if(this.isUnknown(l))if(a===null)a=o;else throw new he("Can only specifiy one unknown dimension.");else s*=l}let i=Nc(e);if(a!==null){if(s===0||i%s!==0)throw new he(n);r[a]=i/s}else if(i!==s)throw new he(n);return r}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e),r=n.shape,s=r.slice(0,1).concat(this.fixUnknownDimension(r.slice(1),this.targetShape));return le(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};KL.className="Reshape";Be.registerClass(KL);var XL=class extends Ut{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Bo(1,e.dims.length+1);if(!M.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Tr({ndim:this.dims.length+1})]}computeOutputShape(e){e=rn(e);let t=e.slice();return this.dims.forEach((n,r)=>{t[r+1]=e[n]}),t}call(e,t){return Lt(Et(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};XL.className="Permute";Be.registerClass(XL);var YL=class extends Ut{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Et(e);return e0(ep(n,this.maskValue),-1)}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e),r=e0(ep(n,this.maskValue),-1,!0);return oe(n,je(r,n.dtype))})}};YL.className="Masking";Be.registerClass(YL);var JL=class extends Ut{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(mn(e.inputLength))}this.inputDim=e.inputDim,cs(this.inputDim,"inputDim"),this.outputDim=e.outputDim,cs(this.outputDim,"outputDim"),this.embeddingsInitializer=Yn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Zn(e.embeddingsRegularizer),this.activityRegularizer=Zn(e.activityRegularizer),this.embeddingsConstraint=Kr(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return ue(()=>this.maskZero?(e=Et(e),ep(e,Xt(e))):null)}computeOutputShape(e){if(e=rn(e),this.inputLength==null)return[...e,this.outputDim];let t=mn(this.inputLength);if(t.length!==e.length-1)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let r=0;r<t.length;++r){let s=t[r],a=e[r+1];if(s!=null&&a!=null&&s!==a)throw new he(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e);n.dtype!=="int32"&&(n=vu(n,"int32"));let r=zee(this.embeddings.read(),le(n,[n.size]));return le(r,rn(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ir(this.embeddingsInitializer),embeddingsRegularizer:_n(this.embeddingsRegularizer),activityRegularizer:_n(this.activityRegularizer),embeddingsConstraint:qr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};JL.className="Embedding";Be.registerClass(JL);var Qf=class extends Ut{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Wt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let r=0;r<t.length;++r){let s=e[e.length-t.length+r],a=t[r];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new he("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[rn(e)]),e=e,e.length<2)throw new he(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Cc(t),t.length>1)throw new he(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let r=e.map(s=>s.length);e.indexOf(null)===-1&&Cc(r).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return ue(()=>{if(e=e,this.reshapeRequired){let n=[],r=e.map(s=>s.rank);if(r.indexOf(null)===-1){let s=jc(r);for(let a of e){let i=a.rank;for(let o=0;o<s-i;++o)a=Ow(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let o of e){let l=o.rank;if(l==null){let u=o.shape,c=u[0],d=u.slice(1).concat([c]),h=le(o,[c].concat(Nc(u.slice(1))));h=Lt(h,[1,0]),h=le(h,d),n.push(h),s=!0}else if(l>1){let u=Bo(1,l).concat([0]);n.push(Lt(o,u)),s=!0}else n.push(o)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let o=a.shape,l=o.length,u=o[l-1],c=[u].concat(o.slice(0,o.length-1));a=le(Lt(le(a,[-1,u]),[1,0]),c)}else if(i>1){let o=[i-1].concat(Bo(0,i-1));a=Lt(a,o)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let r=1;r<e.length;++r){let s=e[r]==null?null:e[r].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let r of e)r!=null&&r[0]!==null&&n.push(r[0]);return n=Cc(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return ue(()=>{if(t==null)return null;if(!Array.isArray(t))throw new he("`mask` should be an Array");if(!Array.isArray(e))throw new he("`inputs` should be an Array");if(t.length!==e.length)throw new he(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(r=>r==null))return null;t=t.map(r=>r==null?r:is(r,0));let n=t[0];for(let r=1;r<t.length-1;++r)n=eo(n,t[r]);return n})}},ZL=class extends Qf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=De(t,e[n]);return t})}};ZL.className="Add";Be.registerClass(ZL);var QL=class extends Qf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=oe(t,e[n]);return t})}};QL.className="Multiply";Be.registerClass(QL);var e4=class extends Qf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=De(t,e[n]);return oe(1/e.length,t)})}};e4.className="Average";Be.registerClass(e4);var t4=class extends Qf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Wl(t,e[n]);return t})}};t4.className="Maximum";Be.registerClass(t4);var n4=class extends Qf{constructor(e){super(e)}mergeFunction(e){return ue(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Vc(t,e[n]);return t})}};n4.className="Minimum";Be.registerClass(n4);var r4=class extends Qf{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new he("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let r of e)if(r!=null){t=!1;break}if(t)return;let n=[];for(let r=0;r<e.length;++r){let s=e[r].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if(M.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new he("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return ue(()=>rL(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new he("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),r=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[r]==null||s[r]==null){n[r]=null;break}n[r]+=s[r]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new he("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new he("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new he(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return ue(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let r=[];for(let a=0;a<e.length;++a)t[a]==null?r.push(je(ei(e[a]),"bool")):t[a].rank<e[a].rank?r.push(is(t[a],-1)):r.push(t[a]);let s=In(r,this.axis);return lT(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};r4.className="Concatenate";Be.registerClass(r4);function Iv(e,t){for(;e<0;)e+=t;return e}function Ynt(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Wt("batchDot is not implemented for tensors of 4D or higher rank yet");if(M.assert(e.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`),M.assert(e.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof n=="number"&&(n=[n,n]),e.dtype==="complex64"||t.dtype==="complex64")throw new Wt("batchDot is not implemented for complex64-type Tensors yet.");let r=e.shape.length,s=t.shape.length;n==null&&(n=[r-1,s-2]);let a=n;return ue(()=>{let i;if(r>s){i=r-s;let l=[];for(let u=0;u<i;++u)l.push(1);t=le(t,t.shape.concat(l))}else if(s>r){i=s-r;let l=[];for(let u=0;u<i;++u)l.push(1);e=le(e,e.shape.concat(l))}else i=0;let o;if(e.shape.length===2&&t.shape.length===2)a[0]===a[1]?o=ct(oe(e,t),a[0]):o=ct(oe(Lt(e,[1,0]),t),a[1]);else{let l=a[0]!==e.shape.length-1,u=a[1]===t.shape.length-1;o=Mt(e,t,l,u)}if(i>0){let l;r>s?l=r+s-3:l=r-1;let u=[];for(let c=l;c<l+i;++c)u.push(c);o=kd(o,u)}return o.shape.length===1&&(o=is(o,1)),o})}var s4=class extends Qf{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){M.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Wt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);if(t[r[0]]!==n[r[1]])throw new he(`Dimension incompatibility: ${t[r[0]]} !== ${n[r[1]]}`)}mergeFunction(e){if(e.length!==2)throw new he(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],r;return Array.isArray(this.axes)?r=this.axes.map((s,a)=>Iv(s,e[a].shape.length)):r=[Iv(this.axes,t.shape.length),Iv(this.axes,n.shape.length)],this.normalize&&(t=iI(t,r[0]),n=iI(n,r[1])),Ynt(t,n,r)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Iv(this.axes,e.length),Iv(this.axes,t.length)],n}computeOutputShape(e){M.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Wt("Dot layer does not support tensors of 4D or higher rank yet.");let r=this.interpretAxes(t,n);t.splice(r[0],1),n.splice(r[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};s4.className="Dot";Be.registerClass(s4);var a4=class extends Ut{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e);return Mw(()=>De(BT(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};a4.className="GaussianNoise";Be.registerClass(a4);var i4=class extends Ut{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ue(()=>{this.invokeCallHook(e,t);let n=Et(e);return this.rate>0&&this.rate<1?Mw(()=>{let r=Math.sqrt(this.rate/(1-this.rate));return oe(n,BT(n.shape,1,r))},()=>n,t.training||!1):n})}};i4.className="GaussianDropout";Be.registerClass(i4);var o4=class extends Ut{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Et(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return ue(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return Mw(()=>{let r=Et(e),s=-1.6732632423543772*1.0507009873554805,a=Au(xd(n),this.rate);a=vu(a,"float32");let i=((1-this.rate)*(1+this.rate*s**2))**-.5,o=-i*s*this.rate,l=De(oe(r,a),oe(De(a,-1),s));return De(oe(l,i),o)},()=>Et(e),t.training||!1)}return e})}};o4.className="AlphaDropout";Be.registerClass(o4);function i0(e,t,n,r,s,a=.001){let i;if(e.rank===2)i=KM(e,t,n,r,s,a);else if(e.rank===3)i=XM(e,t,n,r,s,a);else if(e.rank===4)i=YM(e,t,n,r,s,a);else throw new Wt(`batchNormalization is not implemented for array of rank ${e.rank} yet`);return i}function Jnt(e,t,n,r,s=.001){return ue(()=>{let a=Nw(e,r),i=a.mean,o=a.variance;return[i0(e,i,o,n,t,s),i,o]})}function Znt(e,t,n,r,s=.001){return ue(()=>{let a=Nw(e,r),i=a.mean,o=a.variance,l=[];for(let p of Bo(0,e.rank))r.indexOf(p)!==-1?l.push(1):l.push(e.shape[p]);let u=le(i,l),c=le(o,l),d=t==null?null:le(t,l),h=n==null?null:le(n,l);return[i0(e,u,c,h,d,s),i,o]})}function Qnt(e,t,n,r,s=.001){return M.arraysEqual(r.slice().sort(),Bo(0,e.rank-1))?Jnt(e,t,n,r,s):Znt(e,t,n,r,s)}var l4=class extends Ut{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Yn(e.betaInitializer||"zeros"),this.gammaInitializer=Yn(e.gammaInitializer||"ones"),this.movingMeanInitializer=Yn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Yn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Kr(e.betaConstraint),this.gammaConstraint=Kr(e.gammaConstraint),this.betaRegularizer=Zn(e.betaRegularizer),this.gammaRegularizer=Zn(e.gammaRegularizer)}build(e){e=rn(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new he(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Tr({ndim:e.length,axes:{[t]:n}})];let r=[n];this.scale&&(this.gamma=this.addWeight("gamma",r,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",r,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",r,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",r,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return ue(()=>{let n=t.training==null?!1:t.training,r=Et(e),s=r.shape,a=s.length,i=Bo(0,a),o=this.axis>=0?this.axis:this.axis+a;i.splice(o,1);let l=np(1,a);l[o]=s[o];let u=i.slice();u.sort();let c=!M.arraysEqual(u,Bo(0,a).slice(0,a-1)),d=()=>{if(c){let g=le(this.movingMean.read(),l),y=le(this.movingVariance.read(),l),b=this.center?le(this.beta.read(),l):null,x=this.scale?le(this.gamma.read(),l):null;return i0(r,g,y,b,x,this.epsilon)}else return i0(r,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[h,p,f]=Qnt(r,this.gamma.read(),this.beta.read(),i,this.epsilon),m=(g,y,b)=>{ue(()=>{let x=1-b,v=g.read(),w=oe(nt(v,y),x);g.write(nt(v,w))})};return m(this.movingMean,p,this.momentum),m(this.movingVariance,f,this.momentum),h})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ir(this.betaInitializer),gammaInitializer:ir(this.gammaInitializer),movingMeanInitializer:ir(this.movingMeanInitializer),movingVarianceInitializer:ir(this.movingVarianceInitializer),betaRegularizer:_n(this.betaRegularizer),gammaRegularizer:_n(this.gammaRegularizer),betaConstraint:qr(this.betaConstraint),gammaConstraint:qr(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};l4.className="BatchNormalization";Be.registerClass(l4);var u4=class extends Ut{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=Yn(e.betaInitializer||"zeros"),this.gammaInitializer=Yn(e.gammaInitializer||"ones"),this.betaRegularizer=Zn(e.betaRegularizer),this.gammaRegularizer=Zn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=rn(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Cc(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),r=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,r):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,r):this.beta=null,this.built=!0}call(e,t){let n=Et(e),r=n.shape,s=r.length;return ue(()=>{let{mean:a,variance:i}=Nw(n,this.axis,!0),o=np(1,s);for(let p of this.axis)o[p]=r[p];let l=p=>p!=null&&p.shape.length!==s?le(p,o):p,u=this.scale?l(this.gamma.read()):null,c=this.center?l(this.beta.read()):null,d=[],h=[];for(let p=0;p<s;++p)this.axis.indexOf(p)!==-1?(d.push(r[p]),h.push(1)):(d.push(1),h.push(r[p]));return a=ja(a,d),i=ja(i,d),u!=null&&(u=ja(u,h)),c!=null&&(c=ja(c,h)),i0(n,a,i,c,u,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ir(this.betaInitializer),gammaInitializer:ir(this.gammaInitializer),betaRegularizer:_n(this.betaRegularizer),gammaRegularizer:_n(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};u4.className="LayerNormalization";Be.registerClass(u4);function ert(e,t,n){return ue(()=>{if(e.rank!==4)throw new he(`temporalPadding expects input tensor to be 4-D, but received a ${e.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new he("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(n==null&&(n=Wo()),n!=="channelsLast"&&n!=="channelsFirst")throw new he(`Unknown data format: ${n}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return n==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],Ho(e,r)})}var c4=class extends Ut{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Wo():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new he(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new he(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new he(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Tr({ndim:4})]}computeOutputShape(e){e=rn(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return ue(()=>ert(Et(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};c4.className="ZeroPadding2D";Be.registerClass(c4);function i$(e,t,n,r,s,a){return ue(()=>{kr(s),Fee(a),Ei(r),n==null&&(n=[1,1]),r==null&&(r="valid"),s==null&&(s=Wo()),a==null&&(a="max"),e=AL(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=Qr(e,t,n,o):i=_u(e,t,n,o),s==="channelsFirst"&&(i=Lt(i,[0,3,1,2])),i})}function Lte(e,t,n,r,s,a){return ue(()=>{kr(s),Fee(a),Ei(r),n==null&&(n=[1,1,1]),r==null&&(r="valid"),s==null&&(s=Wo()),a==null&&(a="max"),e=Nte(e,s);let i,o=r==="same"?"same":"valid";return a==="max"?i=wP(e,t,n,o):i=qM(e,t,n,o),s==="channelsFirst"&&(i=Lt(i,[0,4,1,2,3])),i})}var zte=class extends Ut{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new he(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(cs(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new he(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);cs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,Ei(this.padding),this.inputSpec=[new Tr({ndim:3})]}computeOutputShape(e){e=rn(e);let t=Fo(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return ue(()=>{this.invokeCallHook(e,t),e=Ow(Et(e),2);let n=this.poolingFunction(Et(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return kd(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},d4=class extends zte{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Ei(r),i$(e,t,n,r,s,"max")}};d4.className="MaxPooling1D";Be.registerClass(d4);var h4=class extends zte{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Ei(r),i$(e,t,n,r,s,"avg")}};h4.className="AveragePooling1D";Be.registerClass(h4);var Bte=class extends Ut{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new he(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];cs(this.poolSize,"poolSize"),cs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),Ei(this.padding),this.inputSpec=[new Tr({ndim:4})]}computeOutputShape(e){e=rn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Fo(t,this.poolSize[0],this.padding,this.strides[0]),n=Fo(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return ue(()=>(this.invokeCallHook(e,t),this.poolingFunction(Et(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},p4=class extends Bte{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Ei(r),i$(e,t,n,r,s,"max")}};p4.className="MaxPooling2D";Be.registerClass(p4);var f4=class extends Bte{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Ei(r),i$(e,t,n,r,s,"avg")}};f4.className="AveragePooling2D";Be.registerClass(f4);var Wte=class extends Ut{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new he(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];cs(this.poolSize,"poolSize"),cs(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),Ei(this.padding),this.inputSpec=[new Tr({ndim:5})]}computeOutputShape(e){e=rn(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],r=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Fo(t,this.poolSize[0],this.padding,this.strides[0]),n=Fo(n,this.poolSize[1],this.padding,this.strides[1]),r=Fo(r,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,r]:[e[0],t,n,r,e[4]]}call(e,t){return ue(()=>(this.invokeCallHook(e,t),this.poolingFunction(Et(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},m4=class extends Wte{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Ei(r),Lte(e,t,n,r,s,"max")}};m4.className="MaxPooling3D";Be.registerClass(m4);var g4=class extends Wte{constructor(e){super(e)}poolingFunction(e,t,n,r,s){return kr(s),Ei(r),Lte(e,t,n,r,s,"avg")}};g4.className="AveragePooling3D";Be.registerClass(g4);var Vte=class extends Ut{constructor(e){super(e),this.inputSpec=[new Tr({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Wt}},y4=class extends Vte{constructor(e){super(e||{})}call(e,t){return ue(()=>{let n=Et(e);return rr(n,1)})}};y4.className="GlobalAveragePooling1D";Be.registerClass(y4);var b4=class extends Vte{constructor(e){super(e||{})}call(e,t){return ue(()=>{let n=Et(e);return vi(n,1)})}};b4.className="GlobalMaxPooling1D";Be.registerClass(b4);var Ute=class extends Ut{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,kr(this.dataFormat),this.inputSpec=[new Tr({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Wt}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},v4=class extends Ute{call(e,t){return ue(()=>{let n=Et(e);return this.dataFormat==="channelsLast"?rr(n,[1,2]):rr(n,[2,3])})}};v4.className="GlobalAveragePooling2D";Be.registerClass(v4);var x4=class extends Ute{call(e,t){return ue(()=>{let n=Et(e);return this.dataFormat==="channelsLast"?vi(n,[1,2]):vi(n,[2,3])})}};x4.className="GlobalMaxPooling2D";Be.registerClass(x4);var jte=class extends Ut{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let r=t.layer,s=Oo(r,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},w4=class extends jte{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=rn(e),e.length<3)throw new he(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=rn(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),r=e[1];return[n[0],r].concat(n.slice(1))}call(e,t){return ue(()=>(e=Et(e),Fte((n,r)=>[Et(this.layer.call(n,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};w4.className="TimeDistributed";Be.registerClass(w4);function trt(e){Jf(ttt,"BidirectionalMergeMode",e)}var nrt="concat",k4=class extends jte{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Oo(n),t.goBackwards=t.goBackwards!==!0;let r={};if(r.className=e.layer.getClassName(),r.config=t,this.backwardLayer=Oo(r),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?nrt:e.mergeMode,trt(this.mergeMode),e.weights)throw new Wt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,r,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,r=[n]):this.mergeMode==null?r=[n,n.slice()]:r=[n],this.returnState?this.mergeMode==null?r.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):pa(r)}apply(e,t){let n=t==null?null:t.initialState,r=t==null?null:t.constants;t==null&&(t={});let s=Ote(e,n,r,this.numConstants);if(e=s.inputs,n=s.initialState,r=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&r==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new he("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let u=n.map(c=>new Tr({shape:c.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),i.push(...u)}if(r!=null)throw new Wt("Support for constants in Bidirectional layers is not implemented yet.");let o=a[0]instanceof Vo;for(let l of a)if(l instanceof Vo!==o)throw new he("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){let l=[e].concat(a),u=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=u;let d=super.apply(l,t);return this.inputSpec=c,d}else return super.apply(e,t)}call(e,t){return ue(()=>{let n=t.initialState,r,s;if(n==null)r=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let o=n.slice(0,n.length/2),l=n.slice(n.length/2);r=this.forwardLayer.call(e,Object.assign(t,{initialState:o})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(r)&&(a=r.slice(1).concat(s.slice(1))),r=r[0],s=s[0]),this.returnSequences&&(s=Ii(s,1));let i;return this.mergeMode==="concat"?i=rL([r,s]):this.mergeMode==="sum"?i=De(r,s):this.mergeMode==="ave"?i=oe(.5,De(r,s)):this.mergeMode==="mul"?i=oe(r,s):this.mergeMode==null&&(i=[r,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){yh(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),yh(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let r=this.forwardLayer.states.map(s=>null);return Array.isArray(n)?n.concat(r).concat(r):[n].concat(r).concat(r)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Oo(t.layer);if(delete t.layer,t.numConstants!=null)throw new Wt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let r=t;return r.layer=n,new e(r)}};k4.className="Bidirectional";Be.registerClass(k4);var S4=class extends Ut{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ue(()=>(e=Et(e),e.dtype!=="float32"&&(e=vu(e,"float32")),De(oe(e,this.scale),this.offset)))}};S4.className="Rescaling";Be.registerClass(S4);var{resizeBilinear:rrt,cropAndResize:srt}=di,I4=class extends Ut{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,r,s,a,i,o){return ue(()=>{let l,u=!1,c=t/a,d=n/i,h=(r+t)/a,p=(s+n)/i,f=[c,d,h,p],m=[];e.rank===3?(u=!0,l=_r([e])):l=e;for(let x=0;x<l.shape[0];x++)m.push(f);let g=Js(m,[m.length,4]),y=tp(0,m.length,1,"int32"),b=srt(l,g,y,[r,s],"nearest");return vu(u?Et(hr(b)):b,o)})}upsize(e,t,n,r){return ue(()=>{let s=rrt(e,[t,n]);return vu(s,r)})}call(e,t){return ue(()=>{let n=Et(e),r=n.dtype,s=n.shape,a=s[s.length-3],i=s[s.length-2],o=0;a!==this.height&&(o=Math.floor((a-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),o>=0&&l>=0?this.centerCrop(n,o,l,this.height,this.width,a,i,r):this.upsize(e,this.height,this.width,r)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=rn(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};I4.className="CenterCrop";Be.registerClass(I4);function art(e,t,n,r){let s=Et(e);if(s.dtype!=="int32"&&(s=vu(s,"int32")),t==="int")return s;let a=s.shape;if(s.rank===0&&(s=is(s,-1)),t==="oneHot"&&s.shape[s.shape.length-1]!==1&&(s=is(s,-1)),s.rank>2)throw new he(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${a} which would result in output rank ${s.rank}.`);let i=["multiHot","oneHot"].includes(t),o=s,l;if(typeof r<"u"&&t==="count"?l=eI(o,r,n,i):l=eI(o,[],n,i),t!=="tfIdf")return l;if(r)return oe(l,r);throw new he("When outputMode is 'tfIdf', weights must be provided.")}var C4=class extends Ut{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=rn(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return ue(()=>{e=Et(e),e.dtype!=="int32"&&(e=vu(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new he(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=Et(t.countWeights)}let r=vi(e),s=Bg(e),a=oa(this.numTokens,r).bufferSync().get(0),i=Au(s,0).bufferSync().get(0);if(!(a&&i))throw new he(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return art(e,this.outputMode,this.numTokens,n)})}};C4.className="CategoryEncoding";Be.registerClass(C4);var irt=["bilinear","nearest"],p5=new Set(irt),N4=class extends Ut{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(p5.has(e.interpolation))this.interpolation=e.interpolation;else throw new he(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=rn(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return ue(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return di.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return di.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...p5]} are supported`)})}};N4.className="Resizing";Be.registerClass(N4);var Gte=class{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}};Gte.className="RandomSeed";var Hte=class extends Ut{constructor(e){super(e),this.randomGenerator=new Gte(e.seed)}getConfig(){let e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}};Hte.className="BaseRandomLayer";var ort=["bilinear","nearest"],f5=new Set(ort),T4=class extends Hte{constructor(e){super(e);let{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new he(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new he(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new he(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(n)if(f5.has(n))this.interpolation=n;else throw new he(`Invalid interpolation parameter: ${n} is not implemented`)}getConfig(){let e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=rn(e);let t=e[2];return[this.imgHeight,-1,t]}call(e,t){return ue(()=>{let n=Et(e);this.imgHeight=n.shape[n.shape.length-3];let r=n.shape[n.shape.length-2];this.widthFactor=xd([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*r;s=Math.round(s);let a=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return di.resizeBilinear(e,a);case"nearest":return di.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...f5]} are supported`)}})}};T4.className="RandomWidth";Be.registerClass(T4);function lrt(e){return new Gb(e)}function urt(e){return new $L(e)}function crt(e){return new CL(e)}function drt(e){return new NL(e)}function hrt(e){return new TL(e)}function prt(e){return new _L(e)}function frt(e){return new EL(e)}function mrt(e){return new FL(e)}function grt(e){return new QT(e)}function yrt(e){return new RL(e)}function brt(e){return new e$(e)}function vrt(e){return new DL(e)}function xrt(e){return new OL(e)}function wrt(e){return new ML(e)}function krt(e){return new PL(e)}function Srt(e){return new LL(e)}function Irt(e){return new HL(e)}function Crt(e){return new jL(e)}function Nrt(e){return new a$(e)}function Trt(e){return new UL(e)}function $rt(e){return new GL(e)}function Ert(e){return new qL(e)}function _rt(e){return new KL(e)}function Art(e){return new XL(e)}function Rrt(e){return new JL(e)}function Drt(e){return new ZL(e)}function Ort(e){return new e4(e)}function Frt(e){return new r4(e)}function Mrt(e){return new t4(e)}function Prt(e){return new n4(e)}function Lrt(e){return new QL(e)}function zrt(e){return new s4(e)}function Brt(e){return new l4(e)}function Wrt(e){return new u4(e)}function Vrt(e){return new c4(e)}function $4(e){return new h4(e)}function Urt(e){return $4(e)}function jrt(e){return $4(e)}function E4(e){return new f4(e)}function Grt(e){return E4(e)}function Hrt(e){return E4(e)}function _4(e){return new g4(e)}function qrt(e){return _4(e)}function Krt(e){return _4(e)}function Xrt(e){return new y4(e)}function Yrt(e){return new v4(e)}function qte(e){return new b4(e)}function Kte(e){return new x4(e)}function Xte(e){return new d4(e)}function Yte(e){return new p4(e)}function Jrt(e){return new m4(e)}function Zrt(e){return new BL(e)}function Qrt(e){return new n$(e)}function est(e){return new WL(e)}function tst(e){return new Bw(e)}function nst(e){return new zL(e)}function rst(e){return new t$(e)}function sst(e){return new VL(e)}function ast(e){return new s$(e)}function ist(e){return new Ou(e)}function ost(e){return new r$(e)}function lst(e){return new k4(e)}function ust(e){return new w4(e)}var cst=qte,dst=Kte,hst=Xte,pst=Yte;function fst(e){return new a4(e)}function mst(e){return new i4(e)}function gst(e){return new o4(e)}function yst(e){return new YL(e)}function bst(e){return new S4(e)}function vst(e){return new I4(e)}function xst(e){return new N4(e)}function wst(e){return new C4(e)}function kst(e){return new T4(e)}var Jte={};At(Jte,{MAPE:()=>Dst,MSE:()=>Mst,binaryAccuracy:()=>Sst,binaryCrossentropy:()=>Ist,categoricalAccuracy:()=>Nst,categoricalCrossentropy:()=>Tst,cosineProximity:()=>_st,mape:()=>Ost,meanAbsoluteError:()=>Ast,meanAbsolutePercentageError:()=>Rst,meanSquaredError:()=>Fst,mse:()=>Pst,precision:()=>$st,recall:()=>Est,sparseCategoricalAccuracy:()=>Cst});function Sst(e,t){return vL(e,t)}function Ist(e,t){return nte(e,t)}function Cst(e,t){return rte(e,t)}function Nst(e,t){return xL(e,t)}function Tst(e,t){return wL(e,t)}function $st(e,t){return tte(e,t)}function Est(e,t){return ont(e,t)}function _st(e,t){return bL(e,t)}function Ast(e,t){return XT(e,t)}function Rst(e,t){return Hb(e,t)}function Dst(e,t){return Hb(e,t)}function Ost(e,t){return Hb(e,t)}function Fst(e,t){return Zf(e,t)}function Mst(e,t){return Zf(e,t)}function Pst(e,t){return Zf(e,t)}var Zte={};At(Zte,{modelFromJSON:()=>Pnt});var Qte={};At(Qte,{l1:()=>zst,l1l2:()=>Lst,l2:()=>Bst});function Lst(e){return new Lw(e)}function zst(e){return jnt(e)}function Bst(e){return Gnt(e)}var ene=class extends Kg{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof iu))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function jk(e,t){return e<t}function m5(e,t){return e>t}var tne=class extends ene{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Wt("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=jk:this.mode==="max"?this.monitorFunc=m5:this.monitor.indexOf("acc")!==-1?this.monitorFunc=m5:this.monitorFunc=jk,this.monitorFunc===jk&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===jk?1/0:-1/0}async onEpochEnd(e,t){await Uu(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function Wst(e){return new tne(e)}var Vst={earlyStopping:Wst},Ust=xe();Ust.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Oa;(function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"})(Oa||(Oa={}));var g5;(function(e){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(g5||(g5={}));var A4={};function jst(e,t){let n={tfOpName:e,category:"custom",inputs:[],attrs:[],customExecutor:t};A4[e]=n}function nne(e){return A4[e]}function Gst(e){delete A4[e]}function P(e,t,n,r,s){let a=t.inputParams[e];if(a&&a.inputIndexStart!==void 0){let o=a.inputIndexStart,l=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?o+1:a.inputIndexEnd,u=o<0?t.inputNames.length+o:o;if(a.type==="tensor")return vs(t.inputNames[u],n,r,s);if(a.type==="tensors"){let h=t.inputs.slice(o,l);return t.inputNames.slice(o,l).filter((p,f)=>{var m;return((m=h[f])===null||m===void 0?void 0:m.op)!=="NoOp"}).map(p=>vs(p,n,r,s))}let c=vs(t.inputNames[u],n,r,s),d=c.dataSync();return a.type==="number"?d[0]:M.toNestedArray(c.shape,d)}let i=t.attrParams[e];return i&&i.value}function vs(e,t,n,r){let[s,a]=Ma(e,n);if(r!=null){let o=r.getHashTableHandleByName(s);if(o!=null)return o}let i=n.currentContextIds.find(o=>!!t[dI(s,o)]);return i!==void 0?t[dI(s,i)][a]:void 0}function y5(e,t,n){return t[dI(e,n.currentContextId)]}function Jl(e,t){let[n,r,s]=Ma(e,t);return[dI(n,t&&t.currentContextId),r,s]}function dI(e,t){return t?`${e}-${t}`:e}function Ma(e,t){if(e==="")return["",0,void 0];let n=t!=null&&t.parseNodeNameCache!=null;if(n){let a=t.parseNodeNameCache.get(e);if(a!=null)return a}let r=e.split(":"),s;if(r.length===1)s=[e,0,void 0];else{let a=r[0],i=r.length===3?r[1]:void 0,o=Number(r[r.length-1]);s=[a,o,i]}return n&&t.parseNodeNameCache.set(e,s),s}function S2(e,t,n){let r=P("pad",e,t,n);if(r==="explicit"){r=P("explicitPaddings",e,t,n);let s=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)s[a][0]=r[a*2],s[a][1]=r[a*2+1];return s}return r}function Zl(e){return e.kept?e:Nl(e)}var rne={};At(rne,{json:()=>Hst});var Hst=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],sne={};At(sne,{json:()=>qst});var qst=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ane={};At(ane,{json:()=>Kst});var Kst=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],ine={};At(ine,{json:()=>Xst});var Xst=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],one={};At(one,{json:()=>Yst});var Yst=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],lne={};At(lne,{json:()=>Jst});var Jst=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],une={};At(une,{json:()=>Zst});var Zst=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],cne={};At(cne,{json:()=>Qst});var Qst=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],dne={};At(dne,{json:()=>eat});var eat=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],hne={};At(hne,{json:()=>tat});var tat=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],pne={};At(pne,{json:()=>nat});var nat=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],fne={};At(fne,{json:()=>rat});var rat=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],mne={};At(mne,{json:()=>sat});var sat=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],gne={};At(gne,{json:()=>aat});var aat=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],yne={};At(yne,{json:()=>iat});var iat=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],bne={};At(bne,{json:()=>oat});var oat=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],vne={};At(vne,{json:()=>lat});var lat=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],xne={};At(xne,{json:()=>uat});var uat=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],wne={};At(wne,{json:()=>cat});var cat=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],b5=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[rne,sne,ane,ine,one,lne,une,cne,dne,hne,pne,fne,mne,gne,yne,bne,vne,xne,wne],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){let n=e.node,r=[],s=[],a=[],i=n.reduce((f,m)=>(f[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?r.push(f[m.name]):m.op==="Const"?s.push(f[m.name]):(m.input==null||m.input.length===0)&&a.push(f[m.name]),f),{}),o=[],l=[],u={},c={};t!=null&&(u=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let d=Object.keys(i);d.forEach(f=>{let m=i[f];m.inputNames.forEach((g,y)=>{let[b,,x]=Jl(g),v=i[b];if(v.outputs!=null){let w=v.outputs.indexOf(x);if(w!==-1){let k=`${b}:${w}`;m.inputNames[y]=k}}m.inputs.push(v),v.children.push(m)})}),Object.keys(c).length===0?d.forEach(f=>{let m=i[f];m.children.length===0&&l.push(m)}):Object.keys(c).forEach(f=>{let[m]=Jl(f),g=i[m];g!=null&&(g.signatureKey=c[f],l.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(f=>{let[m]=Jl(f),g=i[m];g&&(g.signatureKey=u[f],o.push(g))}):o=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((f,m)=>(f[m.signature.name]=this.mapFunction(m),f),{}));let p={nodes:i,inputs:o,outputs:l,weights:s,placeholders:r,signature:t,functions:h};return a.length>0&&(p.initNodes=a),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=nne(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,s)=>(r[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,s)=>{let a=s.type,i;switch(s.type){case"string":i=$R(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=$R(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=FR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=FR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=_R(e.attr,s.tfName,s.defaultValue||0),i===void 0&&s.tfDeprecatedName&&(i=_R(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=OR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=OR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=ER(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=ER(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=PR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=PR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=DR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=DR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=MR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=MR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=AR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=AR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=RR(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=RR(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=v5(e.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=v5(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return r[s.name]={value:i,type:a},r},{})),n}mapFunction(e){let t=e.nodeDef,n=[],r=[],s={};t!=null&&(s=t.reduce((u,c)=>(u[c.name]=this.mapNode(c),c.op==="Const"&&r.push(u[c.name]),u),{}));let a=[],i=[];e.signature.inputArg.forEach(u=>{let[c]=Jl(u.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:R4(u.type),type:"dtype"}},children:[]};d.signatureKey=u.name,a.push(d),s[c]=d}),Object.keys(s).forEach(u=>{let c=s[u];c.inputNames.forEach((d,h)=>{let[p,,f]=Jl(d),m=s[p];if(m.outputs!=null){let g=m.outputs.indexOf(f);if(g!==-1){let y=`${p}:${g}`;c.inputNames[h]=y}}c.inputs.push(m),m.children.push(c)})});let o=e.ret;e.signature.outputArg.forEach(u=>{let[c,d]=Jl(o[u.name]),h=s[c];h!=null&&(h.defaultOutput=d,i.push(h))});let l=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:r,placeholders:n,signature:l}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function dat(e){let t=xe().global;if(typeof t.atob<"u")return t.atob(e);if(typeof Buffer<"u")return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function kne(e,t){let n=Array.isArray(e)?String.fromCharCode.apply(null,e):dat(e);return t?n:n.toLowerCase()}function $R(e,t,n,r=!1){let s=e[t];return s!=null?kne(s.s,r):n}function ER(e,t,n){let r=e[t];return r?r.b:n}function _R(e,t,n){let r=e[t]||{},s=r.i!=null?r.i:r.f!=null?r.f:n;return typeof s=="number"?s:parseInt(s,10)}function R4(e){switch(typeof e=="string"&&(e=Oa[e]),e){case Oa.DT_FLOAT:case Oa.DT_HALF:return"float32";case Oa.DT_INT32:case Oa.DT_INT64:case Oa.DT_INT8:case Oa.DT_UINT8:return"int32";case Oa.DT_BOOL:return"bool";case Oa.DT_DOUBLE:return"float32";case Oa.DT_STRING:return"string";case Oa.DT_COMPLEX64:case Oa.DT_COMPLEX128:return"complex64";default:return null}}function v5(e,t,n){let r=e[t];return r&&r.func?r.func.name:n}function AR(e,t,n){let r=e[t];return r&&r.type?R4(r.type):n}function RR(e,t,n){let r=e[t];return r&&r.list&&r.list.type?r.list.type.map(s=>R4(s)):n}function Sne(e){if(!e.unknownRank)return e.dim!=null?e.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function DR(e,t,n){let r=e[t];return r&&r.shape?Sne(r.shape):n}function OR(e,t,n){let r=e[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):n}function FR(e,t,n,r=!1){let s=e[t];return s&&s.list&&s.list.s?s.list.s.map(a=>kne(a,r)):n}function MR(e,t,n){let r=e[t];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Sne(s)):n}function PR(e,t,n){let r=e[t];return r&&r.list&&r.list.b?r.list.b:n}var hat=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,s)=>(r[s]=this.getAttr(s),r),{}))}getInput(e){return vs(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return vs(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return _R(this.node.rawAttrs,e,t);if(n.s!=null)return $R(this.node.rawAttrs,e,t);if(n.b!=null)return ER(this.node.rawAttrs,e,t);if(n.shape!=null)return DR(this.node.rawAttrs,e,t);if(n.type!=null)return AR(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return OR(this.node.rawAttrs,e,t);if(n.list.s!=null)return FR(this.node.rawAttrs,e,t);if(n.list.shape!=null)return MR(this.node.rawAttrs,e,t);if(n.list.b!=null)return PR(this.node.rawAttrs,e,t);if(n.list.type!=null)return RR(this.node.rawAttrs,e,t)}return t}},fs={};At(fs,{OP_SCOPE_SUFFIX:()=>DM,abs:()=>Ir,acos:()=>LM,acosh:()=>zM,add:()=>De,addN:()=>zZ,all:()=>lT,any:()=>e0,argMax:()=>Yh,argMin:()=>BM,asin:()=>WM,asinh:()=>VM,atan:()=>UM,atan2:()=>jM,atanh:()=>GM,avgPool:()=>_u,avgPool3d:()=>qM,basicLSTMCell:()=>UZ,batchNorm:()=>qf,batchNorm2d:()=>KM,batchNorm3d:()=>XM,batchNorm4d:()=>YM,batchToSpaceND:()=>vw,bincount:()=>JM,bitwiseAnd:()=>jZ,booleanMaskAsync:()=>DQ,broadcastArgs:()=>GZ,broadcastTo:()=>gh,buffer:()=>zt,cast:()=>je,ceil:()=>ZM,clipByValue:()=>Fs,clone:()=>Nl,complex:()=>yu,concat:()=>In,concat1d:()=>QM,concat2d:()=>eP,concat3d:()=>tP,concat4d:()=>nP,conv1d:()=>uT,conv2d:()=>ta,conv2dTranspose:()=>cT,conv3d:()=>sP,conv3dTranspose:()=>aP,cos:()=>xw,cosh:()=>dT,cosineWindow:()=>DT,cumprod:()=>r0,cumsum:()=>hT,denseBincount:()=>eI,depthToSpace:()=>iP,depthwiseConv2d:()=>Kf,diag:()=>qZ,dilation2d:()=>oP,div:()=>ot,divNoNan:()=>lP,dot:()=>uP,dropout:()=>zP,einsum:()=>Kd,elu:()=>Lb,enclosingPowerOfTwo:()=>BP,ensureShape:()=>XZ,equal:()=>Za,erf:()=>cP,euclideanNorm:()=>pP,exp:()=>Ms,expandDims:()=>is,expm1:()=>fP,eye:()=>pT,fft:()=>_w,fill:()=>Ka,floor:()=>Bb,floorDiv:()=>oT,fused:()=>Hg,gather:()=>Wb,gatherND:()=>PQ,greater:()=>oa,greaterEqual:()=>Au,ifft:()=>Gg,imag:()=>ww,image:()=>di,inTopKAsync:()=>LQ,irfft:()=>NT,isFinite:()=>mP,isInf:()=>gP,isNaN:()=>yP,leakyRelu:()=>kw,less:()=>Wg,lessEqual:()=>vd,linalg:()=>UP,linspace:()=>eQ,localResponseNormalization:()=>bP,log:()=>Qa,log1p:()=>Sw,logSigmoid:()=>vP,logSoftmax:()=>mT,logSumExp:()=>Iw,logicalAnd:()=>eo,logicalNot:()=>Cw,logicalOr:()=>gT,logicalXor:()=>xP,losses:()=>YQ,lowerBound:()=>nQ,matMul:()=>Mt,max:()=>vi,maxPool:()=>Qr,maxPool3d:()=>wP,maxPoolWithArgmax:()=>rQ,maximum:()=>Wl,mean:()=>rr,meshgrid:()=>sQ,min:()=>Bg,minimum:()=>Vc,mirrorPad:()=>kP,mod:()=>SP,moments:()=>Nw,movingAverage:()=>OQ,mul:()=>oe,multiRNNCell:()=>aQ,multinomial:()=>iQ,neg:()=>Fn,norm:()=>zb,notEqual:()=>ep,oneHot:()=>Vg,ones:()=>fa,onesLike:()=>ei,op:()=>se,outerProduct:()=>oQ,pad:()=>Ho,pad1d:()=>lQ,pad2d:()=>uQ,pad3d:()=>cQ,pad4d:()=>dQ,pool:()=>IP,pow:()=>bu,prelu:()=>$w,print:()=>PM,prod:()=>CP,raggedGather:()=>hQ,raggedRange:()=>pQ,raggedTensorToTensor:()=>fQ,rand:()=>mQ,randomGamma:()=>vQ,randomNormal:()=>bT,randomStandardNormal:()=>xQ,randomUniform:()=>xd,randomUniformInt:()=>wQ,range:()=>tp,real:()=>Ug,reciprocal:()=>_P,relu:()=>gn,relu6:()=>vT,reshape:()=>le,reverse:()=>Ii,reverse1d:()=>kQ,reverse2d:()=>SQ,reverse3d:()=>IQ,reverse4d:()=>CQ,rfft:()=>Aw,round:()=>xT,rsqrt:()=>wT,scalar:()=>bt,scatterND:()=>FQ,searchSorted:()=>yT,selu:()=>kT,separableConv2d:()=>Vb,setdiff1dAsync:()=>NQ,sigmoid:()=>qi,sign:()=>AP,signal:()=>XQ,sin:()=>ST,sinh:()=>IT,slice:()=>Kt,slice1d:()=>Ew,slice2d:()=>CT,slice3d:()=>Ub,slice4d:()=>jg,softmax:()=>wd,softplus:()=>Xf,spaceToBatchND:()=>Tw,sparse:()=>JQ,sparseToDense:()=>MQ,spectral:()=>KQ,split:()=>ya,sqrt:()=>Is,square:()=>kn,squaredDifference:()=>TT,squeeze:()=>kd,stack:()=>_r,step:()=>Yf,stridedSlice:()=>RP,string:()=>ZQ,sub:()=>nt,sum:()=>ct,tan:()=>DP,tanh:()=>Zh,tensor:()=>Js,tensor1d:()=>dn,tensor2d:()=>Tl,tensor3d:()=>$T,tensor4d:()=>Uc,tensor5d:()=>TQ,tensor6d:()=>$Q,tensorScatterUpdate:()=>_Q,tile:()=>ja,topk:()=>FP,transpose:()=>Lt,truncatedNormal:()=>AT,unique:()=>MP,unsortedSegmentSum:()=>RT,unstack:()=>hr,upperBound:()=>AQ,variable:()=>PP,where:()=>ds,whereAsync:()=>LP,zeros:()=>sr,zerosLike:()=>Xt});var pat=(e,t,n,r=fs)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(P("a",e,t,n),P("b",e,t,n))];case"AddN":return[r.addN(P("tensors",e,t,n))];case"FloorMod":case"Mod":return[r.mod(P("a",e,t,n),P("b",e,t,n))];case"Mul":return[r.mul(P("a",e,t,n),P("b",e,t,n))];case"RealDiv":case"Div":return[r.div(P("a",e,t,n),P("b",e,t,n))];case"DivNoNan":return[r.divNoNan(P("a",e,t,n),P("b",e,t,n))];case"FloorDiv":return[r.floorDiv(P("a",e,t,n),P("b",e,t,n))];case"Sub":return[r.sub(P("a",e,t,n),P("b",e,t,n))];case"Minimum":return[r.minimum(P("a",e,t,n),P("b",e,t,n))];case"Maximum":return[r.maximum(P("a",e,t,n),P("b",e,t,n))];case"Pow":return[r.pow(P("a",e,t,n),P("b",e,t,n))];case"SquaredDifference":return[r.squaredDifference(P("a",e,t,n),P("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},fat=(e,t,n,r=fs)=>{switch(e.op){case"Abs":case"ComplexAbs":return[r.abs(P("x",e,t,n))];case"Acos":return[r.acos(P("x",e,t,n))];case"Acosh":return[r.acosh(P("x",e,t,n))];case"Asin":return[r.asin(P("x",e,t,n))];case"Asinh":return[r.asinh(P("x",e,t,n))];case"Atan":return[r.atan(P("x",e,t,n))];case"Atan2":return[r.atan2(P("x",e,t,n),P("y",e,t,n))];case"Atanh":return[r.atanh(P("x",e,t,n))];case"Ceil":return[r.ceil(P("x",e,t,n))];case"Complex":return[r.complex(P("real",e,t,n),P("imag",e,t,n))];case"Cos":return[r.cos(P("x",e,t,n))];case"Cosh":return[r.cosh(P("x",e,t,n))];case"Elu":return[r.elu(P("x",e,t,n))];case"Erf":return[r.erf(P("x",e,t,n))];case"Exp":return[r.exp(P("x",e,t,n))];case"Expm1":return[r.expm1(P("x",e,t,n))];case"Floor":return[r.floor(P("x",e,t,n))];case"Log":return[r.log(P("x",e,t,n))];case"Log1p":return[r.log1p(P("x",e,t,n))];case"Imag":return[r.imag(P("x",e,t,n))];case"Neg":return[r.neg(P("x",e,t,n))];case"Reciprocal":return[r.reciprocal(P("x",e,t,n))];case"Real":return[r.real(P("x",e,t,n))];case"Relu":return[r.relu(P("x",e,t,n))];case"Round":return[r.round(P("x",e,t,n))];case"Selu":return[r.selu(P("x",e,t,n))];case"Sigmoid":return[r.sigmoid(P("x",e,t,n))];case"Sin":return[r.sin(P("x",e,t,n))];case"Sign":return[r.sign(P("x",e,t,n))];case"Sinh":return[r.sinh(P("x",e,t,n))];case"Softplus":return[r.softplus(P("x",e,t,n))];case"Sqrt":return[r.sqrt(P("x",e,t,n))];case"Square":return[r.square(P("x",e,t,n))];case"Tanh":return[r.tanh(P("x",e,t,n))];case"Tan":return[r.tan(P("x",e,t,n))];case"ClipByValue":return[r.clipByValue(P("x",e,t,n),P("clipValueMin",e,t,n),P("clipValueMax",e,t,n))];case"Relu6":return[r.relu6(P("x",e,t,n))];case"Rsqrt":return[r.rsqrt(vs(e.inputNames[0],t,n))];case"LeakyRelu":return[r.leakyRelu(P("x",e,t,n),P("alpha",e,t,n))];case"Prelu":return[r.prelu(P("x",e,t,n),P("alpha",e,t,n))];case"IsNan":return[r.isNaN(vs(e.inputNames[0],t,n))];case"IsInf":return[r.isInf(vs(e.inputNames[0],t,n))];case"IsFinite":return[r.isFinite(vs(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Mi(e,t,n=""){if(!(typeof e=="number"||typeof t=="number")){M.assert(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let r=0;r<e.length;r++){let s=e[r],a=t[r];M.assert(s<0||a<0||s===a,()=>n+` Shapes ${e} and ${t} must match`)}}}function x5(e){return!(typeof e=="number"||e.some(t=>t<0))}function Cv(e,t,n){let r=LR(e,n),s=!x5(r);if(s&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&t.forEach(a=>{r=LR(a.shape,r)}),!x5(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function LR(e,t){if(typeof e=="number")return t;if(typeof t=="number")return e;if(e.length!==t.length)throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`);let n=[];for(let r=0;r<e.length;++r){let s=e[r],a=t[r];if(s>=0&&a>=0&&s!==a)throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`);n[r]=s>=0?s:a}return n}var mat=class{constructor(e,t,n,r,s,a,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=s,this.dynamicSize=a,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=bt(0),Vr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Mi(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Vr(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Js([],[0].concat(this.elementShape));let n=this.readMany(e);return Mi(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),_r(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Js([],[0].concat(this.elementShape));let t=[];for(let r=0;r<this.size();r++)t.push(r);let n=this.readMany(t);return Mi(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),In(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,hr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,r=e.map(o=>(n+=o,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];ue(()=>{t=le(t,[1,n,s]);for(let o=0;o<e.length;++o){let l=[0,o===0?0:r[o-1],0],u=[1,e[o],s];a[o]=le(Kt(t,l,u),this.elementShape)}return a});let i=[];for(let o=0;o<e.length;o++)i[o]=o;this.writeMany(i,a)}},o$=class zR{get id(){return this.idTensor.id}constructor(t,n,r,s=-1){this.tensors=t,this.elementShape=n,this.elementDtype=r,t!=null&&t.forEach(a=>{if(r!==a.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${a.dtype}`);Mi(n,a.shape,"TensorList shape mismatch: "),Vr(a)}),this.idTensor=bt(0),this.maxNumElements=s,Vr(this.idTensor)}copy(){return new zR([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{(t==null||!t.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Mi(t,this.elementShape,"TensorList shape mismatch: ");let s=Cv(this.elementShape,this.tensors,t);return ue(()=>{let a=this.tensors.map(i=>le(i,s));return _r(a,0)})}popBack(t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let r=Cv(this.elementShape,this.tensors,t),s=this.tensors.pop();return s.kept=!1,Mi(s.shape,t,"TensorList shape mismatch: "),le(s,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Mi(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Vr(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let n=new zR([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)n.tensors[r]=this.tensors[r];return n}getItem(t,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Mi(this.tensors[t].shape,n,"TensorList shape mismatch: ");let s=Cv(this.elementShape,this.tensors,n);return le(this.tensors[t],s)}setItem(t,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Mi(this.elementShape,n.shape,"TensorList shape mismatch: "),Vr(n),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=n}gather(t,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);Mi(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());let s=Cv(this.elementShape,this.tensors,r);return t.length===0?Js([],[0].concat(s)):ue(()=>{let a=t.map(i=>le(this.tensors[i],s));return _r(a,0)})}concat(t,n){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Mi(this.elementShape,n,"TensorList shape mismatch: ");let r=Cv(this.elementShape,this.tensors,n);return this.size()===0?Js([],[0].concat(r)):ue(()=>{let s=this.tensors.map(a=>le(a,r));return In(s,0)})}};function gat(e,t,n){let r=e.dtype;if(e.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`);if(e.dtype!==n)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`);let s=e.shape.slice(1);Mi(s,t,"TensorList shape mismatch: ");let a=hr(e);return new o$(a,t,r)}function yat(e,t,n,r){return new o$([],e,t,r)}function bat(e,t,n,r){if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let s=Math.max(...t);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);let a=new o$([],n,e.dtype,r),i=hr(e,0);return t.forEach((o,l)=>{a.setItem(o,i[l])}),a}function vat(e,t,n){let r=0,s=t.map(c=>(r+=c,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);let a=e.shape.slice(1),i=LR(a,n),o=r===0?0:e.size/r,l=ue(()=>{let c=[];e=le(e,[1,r,o]);for(let d=0;d<t.length;++d){let h=[0,d===0?0:s[d-1],0],p=[1,t[d],o];c[d]=le(Kt(e,h,p),i)}return e.dispose(),c}),u=new o$([],n,e.dtype,t.length);for(let c=0;c<l.length;c++)u.setItem(c,l[c]);return u}var xat=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{let r=P("thenBranch",e,t,n),s=P("elseBranch",e,t,n),a=P("cond",e,t,n),i=P("args",e,t,n);return(await a.data())[0]?n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap):n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{let r=P("body",e,t,n),s=P("cond",e,t,n),a=P("args",e,t,n),i=await n.functionMap[s].executeFunctionAsync(a,n.tensorArrayMap,n.tensorListMap),o=a.map(c=>c.id),l=await i[0].data();i.forEach(c=>{!c.kept&&o.indexOf(c.id)===-1&&c.dispose()});let u=a;for(;l[0];){let c=u;u=await n.functionMap[r].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);let d=u.map(p=>p.id);c.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()});let h=await n.functionMap[s].executeFunctionAsync(u,n.tensorArrayMap,n.tensorListMap);l=await h[0].data(),h.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&d.indexOf(p.id)===-1&&p.dispose()})}return u}case"LoopCond":{let r=P("pred",e,t,n);return[Zl(r)]}case"Switch":{let r=P("pred",e,t,n),s=P("data",e,t,n);return s.kept||(s=Zl(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{let r=e.inputNames.find(s=>vs(s,t,n)!==void 0);if(r){let s=vs(r,t,n);return[Zl(s)]}return}case"Enter":{let r=P("frameName",e,t,n),s=P("tensor",e,t,n);return n.enterFrame(r),[Zl(s)]}case"Exit":{let r=P("tensor",e,t,n);return n.exitFrame(),[Zl(r)]}case"NextIteration":{let r=P("tensor",e,t,n);return n.nextIteration(),[Zl(r)]}case"TensorArrayV3":{let r=P("size",e,t,n),s=P("dtype",e,t,n),a=P("elementShape",e,t,n),i=P("dynamicSize",e,t,n),o=P("clearAfterRead",e,t,n),l=P("identicalElementShapes",e,t,n),u=P("name",e,t,n),c=new mat(u,s,r,a,l,i,o);return n.addTensorArray(c),[c.idTensor,bt(1)]}case"TensorArrayWriteV3":{let r=P("tensorArrayId",e,t,n),s=P("index",e,t,n),a=P("tensor",e,t,n),i=n.getTensorArray(r.id);return i.write(s,a),[i.idTensor]}case"TensorArrayReadV3":{let r=P("tensorArrayId",e,t,n),s=P("index",e,t,n);return[n.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{let r=P("tensorArrayId",e,t,n),s=P("indices",e,t,n),a=P("dtype",e,t,n);return[n.getTensorArray(r.id).gather(s,a)]}case"TensorArrayScatterV3":{let r=P("tensorArrayId",e,t,n),s=P("indices",e,t,n),a=P("tensor",e,t,n),i=n.getTensorArray(r.id);return i.scatter(s,a),[i.idTensor]}case"TensorArrayConcatV3":{let r=P("tensorArrayId",e,t,n),s=n.getTensorArray(r.id),a=P("dtype",e,t,n);return[s.concat(a)]}case"TensorArraySplitV3":{let r=P("tensorArrayId",e,t,n),s=P("tensor",e,t,n),a=P("lengths",e,t,n),i=n.getTensorArray(r.id);return i.split(a,s),[i.idTensor]}case"TensorArraySizeV3":{let r=P("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return[bt(s.size(),"int32")]}case"TensorArrayCloseV3":{let r=P("tensorArrayId",e,t,n),s=n.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{let r=P("tensorListId",e,t,n),s=P("index",e,t,n),a=P("tensor",e,t,n),i=n.getTensorList(r.id);return i.setItem(s,a),[i.idTensor]}case"TensorListGetItem":{let r=P("tensorListId",e,t,n),s=P("index",e,t,n),a=P("elementShape",e,t,n),i=P("elementDType",e,t,n);return[n.getTensorList(r.id).getItem(s,a,i)]}case"TensorListScatterV2":case"TensorListScatter":{let r=P("indices",e,t,n),s=P("tensor",e,t,n),a=P("elementShape",e,t,n),i=P("numElements",e,t,n),o=bat(s,r,a,i);return n.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let r=P("elementShape",e,t,n),s=P("elementDType",e,t,n),a;e.op==="TensorListReserve"?a="numElements":a="maxNumElements";let i=P(a,e,t,n),o=e.op==="TensorListReserve"?-1:i,l=yat(r,s,i,o);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{let r=P("tensorListId",e,t,n),s=P("indices",e,t,n),a=P("elementShape",e,t,n),i=P("elementDType",e,t,n);return[n.getTensorList(r.id).gather(s,i,a)]}case"TensorListStack":{let r=P("tensorListId",e,t,n),s=P("elementShape",e,t,n),a=P("elementDType",e,t,n),i=P("numElements",e,t,n);return[n.getTensorList(r.id).stack(s,a,i)]}case"TensorListFromTensor":{let r=P("tensor",e,t,n),s=P("elementShape",e,t,n),a=P("elementDType",e,t,n),i=gat(r,s,a);return n.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let r=P("tensorListId",e,t,n),s=n.getTensorList(r.id),a=P("dtype",e,t,n),i=P("elementShape",e,t,n);return[s.concat(a,i)]}case"TensorListPushBack":{let r=P("tensorListId",e,t,n),s=P("tensor",e,t,n),a=n.getTensorList(r.id);return a.pushBack(s),[a.idTensor]}case"TensorListPopBack":{let r=P("tensorListId",e,t,n),s=P("elementShape",e,t,n),a=P("elementDType",e,t,n);return[n.getTensorList(r.id).popBack(s,a)]}case"TensorListSplit":{let r=P("tensor",e,t,n),s=P("elementShape",e,t,n),a=P("lengths",e,t,n),i=vat(r,a,s);return n.addTensorList(i),[i.idTensor]}case"TensorListLength":{let r=P("tensorListId",e,t,n),s=n.getTensorList(r.id);return[bt(s.size(),"int32")]}case"TensorListResize":{let r=P("tensorListId",e,t,n),s=P("size",e,t,n),a=n.getTensorList(r.id).resize(s);return n.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function w5(e,t,n){let[r,s]=P("fusedOps",e,t,n),a=r==="biasadd",i=!a,o=s==="prelu",l=r==="fusedbatchnorm",u=P("numArgs",e,t,n);if(a){if(o&&u!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a&&u!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let c=P("strides",e,t,n),d=S2(e,t,n),h=P("dataFormat",e,t,n).toUpperCase(),p=P("dilations",e,t,n),[f,m]=P("args",e,t,n);i&&(m=f,f=void 0);let g=P("leakyreluAlpha",e,t,n);return{stride:c,pad:d,dataFormat:h,dilations:p,biasArg:f,preluArg:m,activationFunc:s,leakyreluAlpha:g}}var wat=(e,t,n,r=fs)=>{switch(e.op){case"Conv1D":{let s=P("stride",e,t,n),a=P("pad",e,t,n),i=P("dataFormat",e,t,n).toUpperCase(),o=P("dilation",e,t,n);return[r.conv1d(P("x",e,t,n),P("filter",e,t,n),s,a,i,o)]}case"Conv2D":{let s=P("strides",e,t,n),a=S2(e,t,n),i=P("dataFormat",e,t,n).toUpperCase(),o=P("dilations",e,t,n);return[r.conv2d(P("x",e,t,n),P("filter",e,t,n),[s[1],s[2]],a,i,[o[1],o[2]])]}case"_FusedConv2D":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=w5(e,t,n);return[r.fused.conv2d({x:P("x",e,t,n),filter:P("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{let{stride:s,pad:a,dataFormat:i,dilations:o,biasArg:l,preluArg:u,activationFunc:c,leakyreluAlpha:d}=w5(e,t,n);return[r.fused.depthwiseConv2d({x:P("x",e,t,n),filter:P("filter",e,t,n),strides:[s[1],s[2]],pad:a,dataFormat:i,dilations:[o[1],o[2]],bias:l,activation:c,preluActivationWeights:u,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let s=P("outputShape",e,t,n),a=P("strides",e,t,n),i=S2(e,t,n);return[r.conv2dTranspose(P("x",e,t,n),P("filter",e,t,n),s,[a[1],a[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let s=P("strides",e,t,n),a=S2(e,t,n),i=P("dilations",e,t,n),o=P("dataFormat",e,t,n).toUpperCase();return[r.depthwiseConv2d(P("input",e,t,n),P("filter",e,t,n),[s[1],s[2]],a,o,[i[1],i[2]])]}case"Conv3D":{let s=P("strides",e,t,n),a=P("pad",e,t,n),i=P("dataFormat",e,t,n).toUpperCase(),o=P("dilations",e,t,n);return[r.conv3d(P("x",e,t,n),P("filter",e,t,n),[s[1],s[2],s[3]],a,i,[o[1],o[2],o[3]])]}case"AvgPool":{let s=P("strides",e,t,n),a=P("pad",e,t,n),i=P("kernelSize",e,t,n);return[r.avgPool(P("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPool":{let s=P("strides",e,t,n),a=P("pad",e,t,n),i=P("kernelSize",e,t,n);return[r.maxPool(P("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a)]}case"MaxPoolWithArgmax":{let s=P("strides",e,t,n),a=P("pad",e,t,n),i=P("kernelSize",e,t,n),o=P("includeBatchInIndex",e,t,n),{result:l,indexes:u}=r.maxPoolWithArgmax(P("x",e,t,n),[i[1],i[2]],[s[1],s[2]],a,o);return[l,u]}case"AvgPool3D":{let s=P("strides",e,t,n),a=P("pad",e,t,n),i=P("kernelSize",e,t,n);return[r.avgPool3d(P("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"MaxPool3D":{let s=P("strides",e,t,n),a=P("pad",e,t,n),i=P("kernelSize",e,t,n);return[r.maxPool3d(P("x",e,t,n),[i[1],i[2],i[3]],[s[1],s[2],s[3]],a)]}case"Dilation2D":{let s=P("strides",e,t,n),a=P("pad",e,t,n),i=P("dilations",e,t,n),o=s[1],l=s[2],u=i[1],c=i[2];return[r.dilation2d(P("x",e,t,n),P("filter",e,t,n),[o,l],a,[u,c],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},kat=(e,t,n,r=fs)=>{switch(e.op){case"Fill":{let s=P("shape",e,t,n),a=P("dtype",e,t,n),i=P("value",e,t,n);return[r.fill(s,i,a)]}case"LinSpace":{let s=P("start",e,t,n),a=P("stop",e,t,n),i=P("num",e,t,n);return[r.linspace(s,a,i)]}case"Multinomial":{let s=P("logits",e,t,n),a=P("numSamples",e,t,n),i=P("seed",e,t,n);return[r.multinomial(s,a,i)]}case"OneHot":{let s=P("indices",e,t,n),a=P("depth",e,t,n),i=P("onValue",e,t,n),o=P("offValue",e,t,n),l=P("dtype",e,t,n);return[r.oneHot(s,a,i,o,l)]}case"Ones":return[r.ones(P("shape",e,t,n),P("dtype",e,t,n))];case"OnesLike":return[r.onesLike(P("x",e,t,n))];case"RandomStandardNormal":return[r.randomStandardNormal(P("shape",e,t,n),P("dtype",e,t,n),P("seed",e,t,n))];case"RandomUniform":return[r.randomUniform(P("shape",e,t,n),P("minval",e,t,n),P("maxval",e,t,n),P("dtype",e,t,n))];case"RandomUniformInt":return[r.randomUniformInt(P("shape",e,t,n),P("minval",e,t,n),P("maxval",e,t,n),P("seed",e,t,n))];case"Range":{let s=P("start",e,t,n),a=P("stop",e,t,n),i=P("step",e,t,n);return[r.range(s,a,i,P("dtype",e,t,n))]}case"TruncatedNormal":{let s=P("shape",e,t,n),a=P("mean",e,t,n),i=P("stdDev",e,t,n),o=P("seed",e,t,n);return[r.truncatedNormal(s,a,i,P("dtype",e,t,n),o)]}case"Zeros":return[r.zeros(P("shape",e,t,n),P("dtype",e,t,n))];case"ZerosLike":return[r.zerosLike(P("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function UE(e,t,n){let r=P("boxes",e,t,n),s=P("scores",e,t,n),a=P("maxOutputSize",e,t,n),i=P("iouThreshold",e,t,n),o=P("scoreThreshold",e,t,n),l=P("softNmsSigma",e,t,n);return{boxes:r,scores:s,maxOutputSize:a,iouThreshold:i,scoreThreshold:o,softNmsSigma:l}}var Sat=async(e,t,n,r,s=fs)=>{switch(e.op){case"NonMaxSuppressionV5":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u,softNmsSigma:c}=UE(e,t,n),d=await s.image.nonMaxSuppressionWithScoreAsync(a,i,o,l,u,c);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=UE(e,t,n),c=P("padToMaxOutputSize",e,t,n),d=await s.image.nonMaxSuppressionPaddedAsync(a,i,o,l,u,c);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:a,scores:i,maxOutputSize:o,iouThreshold:l,scoreThreshold:u}=UE(e,t,n);return[await s.image.nonMaxSuppressionAsync(a,i,o,l,u)]}case"Where":{let a=s.cast(P("condition",e,t,n),"bool"),i=[await s.whereAsync(a)];return a.dispose(),i}case"ListDiff":return s.setdiff1dAsync(P("x",e,t,n),P("y",e,t,n));default:throw TypeError(`Node type ${e.op} is not implemented`)}},Iat=(e,t,n,r=fs)=>{switch(e.op){case"LowerBound":{let s=P("sortedSequence",e,t,n),a=P("values",e,t,n);return[r.lowerBound(s,a)]}case"TopKV2":{let s=P("x",e,t,n),a=P("k",e,t,n),i=P("sorted",e,t,n),o=r.topk(s,a,i);return[o.values,o.indices]}case"UpperBound":{let s=P("sortedSequence",e,t,n),a=P("values",e,t,n);return[r.upperBound(s,a)]}case"Unique":{let s=P("x",e,t,n),a=r.unique(s);return[a.values,a.indices]}case"UniqueV2":{let s=P("x",e,t,n),a=P("axis",e,t,n),i=r.unique(s,a);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Cat=(e,t,n,r=fs)=>{switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":let s=P("default",e,t,n);return[vs(e.name,t,n)||s];case"Placeholder":return[vs(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let c=P("x",e,t,n);return[Zl(c)]}case"IdentityN":return P("x",e,t,n).map(c=>Zl(c));case"Snapshot":let a=P("x",e,t,n);return[Zl(a)];case"Shape":return[r.tensor1d(P("x",e,t,n).shape,"int32")];case"ShapeN":return P("x",e,t,n).map(c=>r.tensor1d(c.shape));case"Size":return[r.scalar(P("x",e,t,n).size,"int32")];case"Rank":return[r.scalar(P("x",e,t,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":let i=P("x",e,t,n),o=P("data",e,t,n),l=P("message",e,t,n),u=P("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,u));return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Nat=class{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=bt(0),this.tensorMap=new Map,Vr(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return bt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ue(()=>{let r=hr(t),s=n.length,a=r.length;M.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let o=n[i],l=r[i];Vr(l),this.tensorMap.set(o,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return ue(()=>{let r=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);r.push(i)}return _r(r)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}},Tat=async(e,t,n,r)=>{switch(e.op){case"HashTable":case"HashTableV2":{let s=r.getHashTableHandleByName(e.name);if(s!=null)return[s];{let a=P("keyDType",e,t,n),i=P("valueDType",e,t,n),o=new Nat(a,i);return r.addHashTable(e.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let s=P("tableHandle",e,t,n,r),a=P("keys",e,t,n),i=P("values",e,t,n);return[await r.getHashTableById(s.id).import(a,i)]}case"LookupTableFind":case"LookupTableFindV2":{let s=P("tableHandle",e,t,n,r),a=P("keys",e,t,n),i=P("defaultValue",e,t,n);return[await r.getHashTableById(s.id).find(a,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let s=P("tableHandle",e,t,n,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},$at=(e,t,n,r=fs)=>{switch(e.op){case"ResizeBilinear":{let s=P("images",e,t,n),a=P("size",e,t,n),i=P("alignCorners",e,t,n),o=P("halfPixelCenters",e,t,n);return[r.image.resizeBilinear(s,[a[0],a[1]],i,o)]}case"ResizeNearestNeighbor":{let s=P("images",e,t,n),a=P("size",e,t,n),i=P("alignCorners",e,t,n),o=P("halfPixelCenters",e,t,n);return[r.image.resizeNearestNeighbor(s,[a[0],a[1]],i,o)]}case"CropAndResize":{let s=P("image",e,t,n),a=P("boxes",e,t,n),i=P("boxInd",e,t,n),o=P("cropSize",e,t,n),l=P("method",e,t,n),u=P("extrapolationValue",e,t,n);return[r.image.cropAndResize(s,a,i,o,l,u)]}case"ImageProjectiveTransformV3":{let s=P("images",e,t,n),a=P("transforms",e,t,n),i=P("outputShape",e,t,n),o=P("fillValue",e,t,n),l=P("interpolation",e,t,n),u=P("fillMode",e,t,n);return[r.image.transform(s,a,l.toLowerCase(),u.toLowerCase(),o,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Eat=(e,t,n,r=fs)=>{switch(e.op){case"Equal":return[r.equal(P("a",e,t,n),P("b",e,t,n))];case"NotEqual":return[r.notEqual(P("a",e,t,n),P("b",e,t,n))];case"Greater":return[r.greater(P("a",e,t,n),P("b",e,t,n))];case"GreaterEqual":return[r.greaterEqual(P("a",e,t,n),P("b",e,t,n))];case"Less":return[r.less(P("a",e,t,n),P("b",e,t,n))];case"LessEqual":return[r.lessEqual(P("a",e,t,n),P("b",e,t,n))];case"LogicalAnd":return[r.logicalAnd(P("a",e,t,n),P("b",e,t,n))];case"LogicalNot":return[r.logicalNot(P("a",e,t,n))];case"LogicalOr":return[r.logicalOr(P("a",e,t,n),P("b",e,t,n))];case"Select":case"SelectV2":return[r.where(P("condition",e,t,n),P("a",e,t,n),P("b",e,t,n))];case"BitwiseAnd":return[r.bitwiseAnd(P("a",e,t,n),P("b",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},_at=(e,t,n,r=fs)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(P("a",e,t,n),P("b",e,t,n),P("transposeA",e,t,n),P("transposeB",e,t,n))];case"Einsum":return[r.einsum(P("equation",e,t,n),...P("tensors",e,t,n))];case"Transpose":return[r.transpose(P("x",e,t,n),P("perm",e,t,n))];case"_FusedMatMul":let[s,a]=P("fusedOps",e,t,n),i=s==="biasadd",o=a==="prelu",l=P("numArgs",e,t,n),u=P("leakyreluAlpha",e,t,n);if(i){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[c,d]=P("args",e,t,n);return[r.fused.matMul({a:P("a",e,t,n),b:P("b",e,t,n),transposeA:P("transposeA",e,t,n),transposeB:P("transposeB",e,t,n),bias:c,activation:a,preluActivationWeights:d,leakyreluAlpha:u})];case"MatrixBandPart":return[r.linalg.bandPart(P("a",e,t,n),P("numLower",e,t,n),P("numUpper",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Aat=(e,t,n,r=fs)=>{switch(e.op){case"EuclideanNorm":return[r.euclideanNorm(P("x",e,t,n),P("axis",e,t,n),P("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(P("x",e,t,n),P("mean",e,t,n),P("variance",e,t,n),P("offset",e,t,n),P("scale",e,t,n),P("epsilon",e,t,n))];case"FusedBatchNormV3":return[r.batchNorm(P("x",e,t,n),P("mean",e,t,n),P("variance",e,t,n),P("offset",e,t,n),P("scale",e,t,n),P("epsilon",e,t,n))];case"LRN":return[r.localResponseNormalization(P("x",e,t,n),P("radius",e,t,n),P("bias",e,t,n),P("alpha",e,t,n),P("beta",e,t,n))];case"Softmax":return[r.softmax(P("x",e,t,n))];case"LogSoftmax":return[r.logSoftmax(P("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Rat=(e,t,n,r=fs)=>{switch(e.op){case"RaggedGather":{let{outputNestedSplits:s,outputDenseValues:a}=r.raggedGather(P("paramsNestedSplits",e,t,n),P("paramsDenseValues",e,t,n),P("indices",e,t,n),P("outputRaggedRank",e,t,n));return s.concat(a)}case"RaggedRange":{let{rtNestedSplits:s,rtDenseValues:a}=r.raggedRange(P("starts",e,t,n),P("limits",e,t,n),P("splits",e,t,n));return[s,a]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(P("shape",e,t,n),P("values",e,t,n),P("defaultValue",e,t,n),P("rowPartitionTensors",e,t,n),P("rowPartitionTypes",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Dat=(e,t,n,r=fs)=>{switch(e.op){case"Max":{let o=P("axis",e,t,n),l=P("keepDims",e,t,n);return[r.max(P("x",e,t,n),o,l)]}case"Mean":{let o=P("axis",e,t,n),l=P("keepDims",e,t,n);return[r.mean(P("x",e,t,n),o,l)]}case"Min":{let o=P("axis",e,t,n),l=P("keepDims",e,t,n);return[r.min(P("x",e,t,n),o,l)]}case"Sum":{let o=P("axis",e,t,n),l=P("keepDims",e,t,n);return[r.sum(P("x",e,t,n),o,l)]}case"All":{let o=P("axis",e,t,n),l=P("keepDims",e,t,n);return[r.all(P("x",e,t,n),o,l)]}case"Any":{let o=P("axis",e,t,n),l=P("keepDims",e,t,n);return[r.any(P("x",e,t,n),o,l)]}case"ArgMax":{let o=P("axis",e,t,n);return[r.argMax(P("x",e,t,n),o)]}case"ArgMin":{let o=P("axis",e,t,n);return[r.argMin(P("x",e,t,n),o)]}case"Prod":{let o=P("axis",e,t,n),l=P("keepDims",e,t,n);return[r.prod(P("x",e,t,n),o,l)]}case"Cumprod":{let o=P("axis",e,t,n),l=P("exclusive",e,t,n),u=P("reverse",e,t,n);return[r.cumprod(P("x",e,t,n),o,l,u)]}case"Cumsum":{let o=P("axis",e,t,n),l=P("exclusive",e,t,n),u=P("reverse",e,t,n);return[r.cumsum(P("x",e,t,n),o,l,u)]}case"Bincount":let s=P("x",e,t,n),a=P("weights",e,t,n),i=P("size",e,t,n);return[r.bincount(s,a,i)];case"DenseBincount":{let o=P("x",e,t,n),l=P("weights",e,t,n),u=P("size",e,t,n),c=P("binaryOutput",e,t,n);return[r.denseBincount(o,l,u,c)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Oat=(e,t,n,r=fs)=>{switch(e.op){case"ConcatV2":case"Concat":{let s=P("n",e,t,n),a=P("axis",e,t,n),i=P("tensors",e,t,n);return i=i.slice(0,s),[r.concat(i,a)]}case"Gather":{let s=P("x",e,t,n),a=P("indices",e,t,n);return[r.gather(s,r.cast(a,"int32"),0)]}case"GatherV2":{let s=P("axis",e,t,n),a=P("batchDims",e,t,n),i=P("x",e,t,n),o=P("indices",e,t,n);return[r.gather(i,r.cast(o,"int32"),s,a)]}case"Reverse":{let s=P("dims",e,t,n),a=[];for(let o=0;o<s.length;o++)s[o]&&a.push(o);let i=P("x",e,t,n);return[r.reverse(i,a)]}case"ReverseV2":{let s=P("axis",e,t,n),a=P("x",e,t,n);return[r.reverse(a,s)]}case"Slice":{let s=P("begin",e,t,n),a=P("size",e,t,n);return[r.slice(P("x",e,t,n),s,a)]}case"StridedSlice":{let s=P("begin",e,t,n),a=P("end",e,t,n),i=P("strides",e,t,n),o=P("beginMask",e,t,n),l=P("endMask",e,t,n),u=P("ellipsisMask",e,t,n),c=P("newAxisMask",e,t,n),d=P("shrinkAxisMask",e,t,n),h=P("x",e,t,n);return[r.stridedSlice(h,s,a,i,o,l,u,c,d)]}case"Pack":return ue(()=>{let s=P("axis",e,t,n),a=P("tensors",e,t,n),i=a[0].shape,o=r.squeeze(a[0]).shape,l=a.map(u=>{let c=M.arraysEqual(u.shape,i);if(!c&&!M.arraysEqual(r.squeeze(u).shape,o))throw new Error("the input tensors shape does not match");return c?u:r.reshape(u,i)});return[r.stack(l,s)]});case"Unpack":{let s=P("axis",e,t,n),a=P("tensor",e,t,n);return r.unstack(a,s)}case"Tile":{let s=P("reps",e,t,n);return[r.tile(P("x",e,t,n),s)]}case"Split":case"SplitV":{let s=P("axis",e,t,n),a=P("numOrSizeSplits",e,t,n),i=P("x",e,t,n);return r.split(i,a,s)}case"ScatterNd":{let s=P("indices",e,t,n),a=P("values",e,t,n),i=P("shape",e,t,n);return[r.scatterND(s,a,i)]}case"GatherNd":{let s=P("x",e,t,n),a=P("indices",e,t,n);return[r.gatherND(s,a)]}case"SparseToDense":{let s=P("sparseIndices",e,t,n),a=P("outputShape",e,t,n),i=P("sparseValues",e,t,n),o=P("defaultValue",e,t,n);return[r.sparseToDense(s,i,a,i.dtype===o.dtype?o:r.cast(o,i.dtype))]}case"TensorScatterUpdate":{let s=P("indices",e,t,n),a=P("values",e,t,n),i=P("tensor",e,t,n);return[r.tensorScatterUpdate(i,s,a)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}},Fat=(e,t,n,r=fs)=>{switch(e.op){case"SparseFillEmptyRows":{let{outputIndices:s,outputValues:a,emptyRowIndicator:i,reverseIndexMap:o}=r.sparse.sparseFillEmptyRows(P("indices",e,t,n),P("values",e,t,n),P("denseShape",e,t,n),P("defaultValue",e,t,n));return[s,a,i,o]}case"SparseReshape":{let{outputIndices:s,outputShape:a}=r.sparse.sparseReshape(P("inputIndices",e,t,n),P("inputShape",e,t,n),P("newShape",e,t,n));return[s,a]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(P("data",e,t,n),P("indices",e,t,n),P("segmentIds",e,t,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(P("data",e,t,n),P("indices",e,t,n),P("segmentIds",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Mat=(e,t,n,r=fs)=>{switch(e.op){case"FFT":return[r.fft(P("x",e,t,n))];case"IFFT":return[r.ifft(P("x",e,t,n))];case"RFFT":return[r.rfft(P("x",e,t,n))];case"IRFFT":return[r.irfft(P("x",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Pat=(e,t,n,r=fs)=>{switch(e.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(P("input",e,t,n),P("pattern",e,t,n),P("rewrite",e,t,n),P("replaceGlobal",e,t,n))];case"StringNGrams":{let{nGrams:s,nGramsSplits:a}=r.string.stringNGrams(P("data",e,t,n),P("dataSplits",e,t,n),P("separator",e,t,n),P("nGramWidths",e,t,n),P("leftPad",e,t,n),P("rightPad",e,t,n),P("padWidth",e,t,n),P("preserveShortSequences",e,t,n));return[s,a]}case"StringSplit":{let{indices:s,values:a,shape:i}=r.string.stringSplit(P("input",e,t,n),P("delimiter",e,t,n),P("skipEmpty",e,t,n));return[s,a,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(P("input",e,t,n),P("numBuckets",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}},Lat=(e,t,n,r=fs)=>{switch(e.op){case"Cast":return[r.cast(P("x",e,t,n),P("dtype",e,t,n))];case"ExpandDims":{let s=P("axis",e,t,n);return[r.expandDims(P("x",e,t,n),s)]}case"Squeeze":{let s=P("axis",e,t,n);return[r.squeeze(P("x",e,t,n),s)]}case"Reshape":return[r.reshape(P("x",e,t,n),P("shape",e,t,n))];case"EnsureShape":return[r.ensureShape(P("x",e,t,n),P("shape",e,t,n))];case"MirrorPad":return[r.mirrorPad(P("x",e,t,n),P("padding",e,t,n),P("mode",e,t,n))];case"PadV2":case"Pad":return[r.pad(P("x",e,t,n),P("padding",e,t,n),P("constantValue",e,t,n))];case"SpaceToBatchND":{let s=P("blockShape",e,t,n),a=P("paddings",e,t,n);return[r.spaceToBatchND(P("x",e,t,n),s,a)]}case"BatchToSpaceND":{let s=P("blockShape",e,t,n),a=P("crops",e,t,n);return[r.batchToSpaceND(P("x",e,t,n),s,a)]}case"DepthToSpace":{let s=P("blockSize",e,t,n),a=P("dataFormat",e,t,n).toUpperCase();return[r.depthToSpace(P("x",e,t,n),s,a)]}case"BroadcastTo":return[r.broadcastTo(P("x",e,t,n),P("shape",e,t,n))];case"BroadcastArgs":return[r.broadcastArgs(P("s0",e,t,n),P("s1",e,t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function k5(e,t,n,r,s=ue){let a=((i,o,l)=>{switch(i.category){case"arithmetic":return s(()=>pat(i,o,l));case"basic_math":return s(()=>fat(i,o,l));case"control":return xat(i,o,l);case"convolution":return s(()=>wat(i,o,l));case"creation":return s(()=>kat(i,o,l));case"dynamic":return Sat(i,o,l);case"evaluation":return s(()=>Iat(i,o,l));case"image":return s(()=>$at(i,o,l));case"graph":return s(()=>Cat(i,o,l));case"logical":return s(()=>Eat(i,o,l));case"matrices":return s(()=>_at(i,o,l));case"normalization":return s(()=>Aat(i,o,l));case"ragged":return s(()=>Rat(i,o,l));case"reduction":return s(()=>Dat(i,o,l));case"slice_join":return s(()=>Oat(i,o,l));case"sparse":return s(()=>Fat(i,o,l));case"spectral":return s(()=>Mat(i,o,l));case"string":return s(()=>Pat(i,o,l));case"transformation":return s(()=>Lat(i,o,l));case"hash_table":return Tat(i,o,l,r);case"custom":let u=nne(i.op);if(u&&u.customExecutor)return u.customExecutor(new hat(i,o,l));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);return M.isPromise(a)?a.then(i=>[].concat(i)):[].concat(a)}var S5=class{constructor(e={},t={},n={},r={},s){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function I5(e,t,n,r){let s=new Set,a=[],i=null,o=null,l=new Set,u=new Set(Object.keys(e).map(h=>Ma(h)[0]));r=r||[];let c=new Set(r.map(h=>Ma(h.name)[0])),d=[...t];for(;d.length>0;){let h=d.pop();if((Yd(h)||Hat(h)||qat(h))&&i==null&&(i=h,o=i.children.map(p=>p.name).filter(p=>s.has(p))),s.add(h.name),n[h.name]==null&&!u.has(h.name)&&!c.has(h.name)){if(h.inputs.length===0){a.push(h.name);continue}h.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),d.push(p))})}}return{inputs:e,outputs:t,usedNodes:s,missingInputs:a,dynamicNode:i,syncInputs:o}}function zat(e,t){let{usedNodes:n,inputs:r}=t,s=Object.keys(r).map(g=>Ma(g)[0]).map(g=>e.nodes[g]),a=e.initNodes||[],i=g=>n.has(typeof g=="string"?g:g.name);function o(g){return[...new Map(g.map(y=>[y.name,y])).values()]}let l=o([...s,...e.weights,...a]).filter(i),u=o([...l,...Object.values(e.nodes)]).filter(i),c=new Map(u.map(g=>[g.name,g])),d={};for(let g of u){d[g.name]=d[g.name]||0;for(let y of g.children)i(y)||(d[y.name]=Number.POSITIVE_INFINITY),d[y.name]=(d[y.name]||0)+1}let h=Object.entries(d).filter(([,g])=>g===0).map(([g])=>g),p=[...h];for(;h.length>0;){let g=h.pop(),y=c.get(g);for(let b of y.children.filter(i))--d[b.name]===0&&(p.push(b.name),h.push(b.name))}let f=p.map(g=>c.get(g)),m=Bat(f,l);return Wat(m,l),m}function Bat(e,t){let n=new Map(e.map(a=>[a.name,a])),r=t.map(a=>a.name),s=new Set(r);for(;r.length>0;){let a=r.pop(),i=n.get(a);for(let o of i.children)!n.has(o.name)||s.has(o.name)||(s.add(o.name),r.push(o.name))}return e.filter(a=>s.has(a.name))}var Gk=class extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}};function Wat(e,t){let n=new Map(e.map((o,l)=>[o.name,l])),r=new Set(t.map(o=>o.name)),s=o=>r.has(typeof o=="string"?o:o.name),a=new Set(e.map(o=>o.name)),i=o=>a.has(typeof o=="string"?o:o.name);for(let o of e){for(let l of o.children.filter(i)){if(!n.has(l.name))throw new Gk(`Child ${l.name} of node ${o.name} is unreachable.`);if(n.get(o.name)>n.get(l.name))throw new Gk(`Node ${o.name} is scheduled to run after its child ${l.name}.`)}if(!s(o))for(let l of o.inputs){if(!n.has(l.name))throw new Gk(`Input ${l.name} of node ${o.name} is unreachable.`);if(n.get(l.name)>n.get(o.name))throw new Gk(`Node ${o.name} is scheduled to run before its input ${l.name}.`)}}}function Vat(e){let t=new Map(e.map((o,l)=>[o.name,l])),n=Number.MAX_SAFE_INTEGER,r=e.map((o,l)=>Yd(o)?n:l),s=o=>{let l=r[t.get(o.name)];return l??-1},a=e.map((o,l)=>o.children.map(s).reduce((u,c)=>Math.max(u,c),r[l])),i=new Map;for(let o=0;o<e.length;++o){let l=a[o];if(l===n)continue;let u=e[o],c=e[l];i.has(c.name)||i.set(c.name,[]),i.get(c.name).push(u)}return i}var Uat=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),jat=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Gat=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Yd(e){return Uat.has(e.op)}function Hat(e){return jat.has(e.op)}function qat(e){return Gat.has(e.op)}var C5=class Ine{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let n=Object.keys(t).map(r=>t[r].map(s=>s.id));this._weightIds=[].concat(...n),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>(t[n]=this._functions[n].signature,t),{})}constructor(t,n){this.graph=t,this.parent=n,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new Ine(t.functions[r],this)})}getCompilationKey(t,n){let r=t.map(a=>a.name).sort(),s=n.map(a=>a.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(t,n){let r=I5(t,n,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:a,syncInputs:i}=r;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){let u=n.map(d=>d.name),c=Object.keys(t);throw new Error(`Cannot compute the outputs [${u}] from the provided inputs [${c}]. Missing the following inputs: [${s}]`)}let o=zat(this.graph,r),l=Vat(o);return{orderedNodes:o,nodeLiveUntilMap:l}}cloneAndKeepTensor(t){if(t==null)return null;let n=t.clone();return Vr(n),n}cloneTensorList(t){return t?t.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,this.cloneTensorList(r)]))}execute(t,n){this.disposeIntermediateTensors(),t=this.mapInputs(t);let r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n);let s=r.map(h=>this.graph.nodes[Ma(h)[0]]),a=n.map(h=>Ma(h)[0]),i=new Set(a),o=a.map(h=>this.graph.nodes[h]);o.length===0&&(o=this._outputs);let l=this.getCompilationKey(s,o),u=this.compiledMap.get(l);u==null&&(u=this.compile(t,o),this.compiledMap.set(l,u));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let c={},d={};return ue(()=>{let h=new S5(this.weightMap,c,d,this.functionExecutorMap,this.parseNodeNameCache),p=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(y=>{let[b,x]=Ma(y,h),v=[];v[x]=t[y],p[b]=v,this.keepIntermediateTensors&&(this.clonedTensorsMap[b]=this.cloneTensorList(v))});let f=this.getFrozenTensorIds(p),{orderedNodes:m,nodeLiveUntilMap:g}=u;for(let y of m){if(p[y.name])continue;let b=k5(y,p,h,this._resourceManager);if(M.isPromise(b))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);p[y.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[y.name]=this.cloneTensorList(b)),this.checkTensorForDisposalWithNodeLiveUntilInfo(y,p,h,f,i,g.get(y.name))}return this.parent==null&&h.dispose(f),n.map(y=>vs(y,p,h))})}getFrozenTensorIds(t){let n=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(s=>s.id)));return new Set(n)}checkTensorForDisposal(t,n,r,s,a,i,o){if(!(Yd(n)||i.has(t))){for(let l of r[t])l!=null&&(o[l.id]=(o[l.id]||0)+n.children.length);for(let l of n.inputs){if(Yd(l))continue;let u=y5(l.name,r,s);if(u!=null)for(let c of u){if(!c||c.kept||a.has(c.id))continue;let d=o[c.id];d===1?(c.dispose(),delete o[c.id]):d!=null&&o[c.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,n,r,s,a,i){function o(l){return Yd(l)||a.has(l.name)}if(!(Yd(t)||i==null))for(let l of i){if(o(l))continue;let u=y5(l.name,n,r);for(let c of u)!c||c.kept||s.has(c.id)||c.dispose()}}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(let n of t)n&&!n.isDisposed&&n.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,n,r=!1,s={},a={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepIntermediateTensors=xe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}let i=new S5(this.weightMap,s,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let o=await this.executeWithControlFlow(t,i,n,r),l=n.map(h=>vs(h,o,i)),u=l.map(h=>h.id),c=Object.keys(t).map(h=>t[h].id),d=new Set([...u,...c,...this.weightIds]);return Object.values(o).forEach(h=>{h.forEach(p=>{p&&!p.isDisposed&&!d.has(p.id)&&p.dispose()})}),this.parent==null&&i.dispose(d),l}async executeFunctionAsync(t,n,r){let s=t.reduce((a,i,o)=>(a[this.inputs[o].name]=i,a),{});return this._executeAsync(s,this.outputNodes,!0,n,r)}async executeWithControlFlow(t,n,r,s){let a=Object.keys(t),i=a.map(v=>this.graph.nodes[Ma(v)[0]]),o=r.map(v=>Ma(v)[0]),l=new Set(o),u=o.map(v=>this.graph.nodes[v]);u.length===0&&(u=this._outputs);let{usedNodes:c,missingInputs:d,dynamicNode:h,syncInputs:p}=I5(t,u,this.weightMap,this._initNodes),f=[...i,...this.graph.weights,...this._initNodes||[]].map(v=>({node:v,contexts:n.currentContext})),m=Object.assign({},this.weightMap);Object.keys(t).forEach(v=>{let[w,k]=Ma(v),S=[];S[k]=t[v],m[w]=S});let g={},y=this.getFrozenTensorIds(m),b={};for(;f.length>0;){let v=this.processStack(i,f,n,m,b,y,l,g,c);await Promise.all(v)}h==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=u.filter(v=>!Yd(v)&&!vs(v.name,m,n)).map(v=>v.name);if(x.length>0){let v="";throw h!=null&&(v=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${a}]. Consider providing the following inputs: [${d}]. ${v}`)}return m}processStack(t,n,r,s,a,i,o,l,u){let c=[];for(;n.length>0;){let d=n.pop();r.currentContext=d.contexts;let h="";if(d.node.op==="Enter"&&P("isConstant",d.node,s,r)&&([h]=Jl(d.node.name,r)),s[d.node.name]==null){let p=k5(d.node,s,r,this._resourceManager);h||([h]=Jl(d.node.name,r));let f=r.currentContext;M.isPromise(p)?c.push(p.then(m=>(s[h]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(m)),r.currentContext=f,this.checkTensorForDisposal(h,d.node,s,r,i,o,l),this.processChildNodes(d.node,n,r,s,a,u),m))):(s[h]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[h]=this.cloneTensorList(p)),this.checkTensorForDisposal(h,d.node,s,r,i,o,l),this.processChildNodes(d.node,n,r,s,a,u))}else this.processChildNodes(d.node,n,r,s,a,u)}return c}processChildNodes(t,n,r,s,a,i){t.children.forEach(o=>{let[l]=Jl(o.name,r);a[l]||!i.has(o.name)||(o.op==="Merge"?o.inputNames.some(u=>!!vs(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})):o.inputNames.every(u=>!!vs(u,s,r))&&(a[l]=!0,n.push({contexts:r.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{let r=t[n],[s]=Ma(n),a=this.graph.nodes[s];if(a.attrParams.shape&&a.attrParams.shape.value){let i=a.attrParams.shape.value,o=i.length===r.shape.length&&r.shape.every((l,u)=>i[u]===-1||i[u]===l);M.assert(o,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&M.assert(r.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var n,r;let s={};for(let a in t){let i=(r=(n=this._signature)===null||n===void 0?void 0:n.inputs)===null||r===void 0?void 0:r[a];i!=null?s[i.name]=t[a]:s[a]=t[a]}return s}checkInputs(t){let n=Object.keys(t).filter(r=>{let[s]=Ma(r);return this.graph.nodes[s]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(t){return t.map(n=>{var r,s;let a=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[n];return a!=null?a.name:n},{})}checkOutputs(t){t.forEach(n=>{let[r]=Ma(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}},Kat=class{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}},Xat="?tfjs-format=file",Yat="model.json",D4=class{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=ws){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new Kat}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return M.isPromise(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){let t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");let t=await EZ(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;let n=this.artifacts.modelTopology,r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(r=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new C5(b5.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=b5.Instance.transformGraph(e.modelInitializer);this.initializer=new C5(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof Bt?[e]:e,n={};return t.forEach((r,s)=>n[this.structuredOutputKeys[s]]=r),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Bt)&&!Array.isArray(e)){let s=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(s!=null)for(let a in s){let i=s[a];i.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];let n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((s,a)=>{var i,o,l;let u=(l=(o=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||o===void 0?void 0:o[a])===null||l===void 0?void 0:l.resourceId;return u!=null?s[a]=this.resourceIdToCapturedInput[u]:s[a]=e[r++],s},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){let s=n[r],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_t(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Jat(e,t={},n=ws){if(e==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof e=="string"&&(e=Qat(e));let r=new D4(e,t,n);return await r.load(),r}function Zat(e){if(e==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(e instanceof Array){let[r,s]=e;if(!r)throw new Error("modelJSON must be the first element of the array");if(!s||!(s instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");let a=ws.getWeightSpecs(r.weightsManifest),i=ws.getModelArtifactsForJSONSync(r,a,s);t=ws.fromMemorySync(i)}else if("load"in e)t=e;else if("modelTopology"in e&&"weightSpecs"in e&&"weightData"in e)t=ws.fromMemorySync(e);else throw new Error("Unknown model format");let n=new D4(t);return n.load(),n}function Qat(e){return e.endsWith("/")||(e=e+"/"),`${e}${Yat}${Xat}`}var eit="4.16.0",Cne={};At(Cne,{CSVDataset:()=>Mne,Dataset:()=>qb,FileDataSource:()=>Une,TextLineDataset:()=>Fne,URLDataSource:()=>jne,array:()=>Sit,csv:()=>Mit,func:()=>Pit,generator:()=>Lit,microphone:()=>Bit,version_data:()=>Wit,webcam:()=>zit,zip:()=>Iit});var tit=pd(WN()),nit=pd(WN());function rit(e,t){return hI(e,t)}function hI(e,t,n=new Map,r=new Set){if(e==null)return null;if(typeof Blob=="function"&&e instanceof Blob)return e.slice();if(r.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Xg(e)){let a=Array.isArray(e)?[]:{};r.add(e);for(let i in e){let o=e[i],l=hI(o,t,n,r);a[i]=l}return r.delete(e),e.__proto__&&(a.__proto__=e.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${e}`);else return n.set(e,s.value),s.value}function sit(e,t=Tne){return Nne(e,t)}function Nne(e,t,n=new Set){let r=e[0];if(n.has(r))throw new Error("Circular references are not supported.");let s=t(e);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Xg(r)){let a=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let o=e.map(u=>u[i]),l=Nne(o,t,n);a[i]=l}return n.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return s.value}function Tne(e){return e===null?null:Xg(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function $ne(e,t){let n=new Map;hI(e,t,n);for(let r of Array.from(n.keys())){let s=n.get(r);if(M.isPromise(s)){let a=await s;n.set(r,a)}}return hI(e,t,n)}function Xg(e){let t=!1;if(xe().get("IS_BROWSER"))t=e instanceof TextDecoder;else{let{StringDecoder:n}=XJ();t=e instanceof n}return e!=null&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||typeof e=="object"&&!(e instanceof Bt)&&!(e instanceof Promise)&&!t)}function ait(e){return e==null||iit(e)||Array.isArray(e)||typeof e=="object"&&e instanceof Bt||M.isTypedArray(e)}function iit(e){return e===null||typeof e!="object"&&typeof e!="function"}function oit(e){return rit(e,lit)}function lit(e){return e instanceof Bt?{value:e.clone(),recurse:!1}:Xg(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}var Ene=class{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}},_ne=class Ane extends Ene{constructor(){super(Ane.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,n=new Array(t),r=this.length();for(let s=0;s<r;s++)n[s]=this.get(this.wrap(this.begin+s));this.data=n,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}};_ne.INITIAL_CAPACITY=32;function Rne(e){return new dit(e)}function O4(e){return new hit(e)}function uit(e,t){return new Dne(e,t)}function cit(e,t=lc.FAIL){return new wit(e,t)}var hs=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new vit(this,e)}filter(e){return new yit(this,e)}map(e){return new bit(this,e)}mapAsync(e){return new N5(this,e)}serialMapAsync(e){return new N5(this,e).serial()}flatmap(e){return new xit(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new git(this,e,t)}columnMajorBatch(e,t=!0,n=Tne){return this.rowMajorBatch(e,t).map(r=>sit(r,n))}concatenate(e,t){return new Dne(Rne([this,e]),t)}take(e){return e<0||e==null?this:new mit(this,e)}skip(e){return e<0||e==null?this:new fit(this,e)}prefetch(e){return new One(this,e)}shuffle(e,t){return new kit(this,e,t)}serial(){return new pit(this)}},dit=class extends hs{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:oit(e),done:!1}}},hit=class extends hs{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},pit=class extends hs{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},fit=class extends hs{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;_t(e.value)}return this.upstream.next()}},mit=class extends hs{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},git=class extends hs{constructor(e,t,n=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},yit=class extends hs{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;_t(e.value)}}},bit=class extends hs{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Do.getTensorsInContainer(e.value),n=this.transform(e.value),r=Do.getTensorsInContainer(n);for(let s of t)Do.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},vit=class extends hs{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},N5=class extends hs{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Do.getTensorsInContainer(e.value),n=await this.transform(e.value),r=Do.getTensorsInContainer(n);for(let s of t)Do.isTensorInList(s,r)||s.dispose();return{value:n,done:!1}}},F4=class extends hs{constructor(){super(),this.outputQueue=new _ne,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},xit=class extends F4{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Do.getTensorsInContainer(e.value),n=this.transform(e.value),r=Do.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Do.isTensorInList(s,r)||s.dispose();return!0}},Dne=class extends hs{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},lc;(function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"})(lc||(lc={}));var wit=class extends hs{constructor(e,t=lc.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function r(a){return a instanceof hs?{value:a.next().then(i=>(t++,i.done&&n++,i.value)),recurse:!1}:{value:null,recurse:!0}}let s=await $ne(this.iterators,r);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case lc.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case lc.SHORTEST:return{value:null,done:!0};case lc.LONGEST:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},One=class extends hs{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Ene(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},kit=class extends One{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=nit.alea(n||M.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}},qb=class{constructor(){this.size=null}batch(e,t=!0){let n=this;M.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let r;return this.size===1/0||this.size==null?r=this.size:t?r=Math.ceil(this.size/e):r=Math.floor(this.size/e),Fa(async()=>(await n.iterator()).columnMajorBatch(e,t,Cit),r)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Fa(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Fa(async()=>(await t.iterator()).filter(r=>ue(()=>e(r))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Fa(async()=>(await t.iterator()).map(n=>ue(()=>e(n))),this.size)}mapAsync(e){let t=this;return Fa(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Fa(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Fa(async()=>{let r=O4(async()=>({value:await t.iterator(),done:!1}));return uit(r.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Fa(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let r=this,s=tit.alea(t||M.now().toString());return Fa(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await r.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Fa(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};qb.MAX_BUFFER_SIZE=1e4;function Fa(e,t=null){return new class extends qb{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Sit(e){return Fa(async()=>Rne(e),e.length)}function Iit(e){if(!Xg(e))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(e))for(let n=0;n<e.length;n++)t=t==null?e[n].size:Math.min(t,e[n].size);else if(e instanceof Object)for(let n in e)t=t==null?e[n].size:Math.min(t,e[n].size);return Fa(async()=>{let n=await $ne(e,r=>{if(r instanceof qb)return{value:r.iterator(),recurse:!1};if(Xg(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return cit(n,lc.SHORTEST)},t)}function Cit(e){if(e===null)return null;let t=e[0];return ait(t)?{value:Nit(e),recurse:!1}:{value:null,recurse:!0}}function Nit(e){if(e.length===0)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Bt?_r(e):Js(e)}var Fne=class extends qb{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}},Hk='"',Nv=Symbol("out"),T5=Symbol("field"),qk=Symbol("quote"),jE=Symbol("quoteafterquote"),$5=Symbol("quoteinquote"),Mne=class extends qb{async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&M.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((r,s)=>(r[s]=r[s]+1||1,r),{}),n=Object.keys(t).filter(r=>t[r]>1);if(M.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let r of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(r)===-1)throw new Error('The key "'+r+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");let t=e.value;return this.parseRow(t,!1)}else return null}constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new Fne(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(M.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},r={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){let o=t[s],l=null;if(o==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);l=void 0}else{let u=Number(o);if(isNaN(u))i&&i.dtype==="bool"?l=this.getBoolean(o):l=o;else if(!i||!i.dtype)l=u;else switch(i.dtype){case"float32":l=u;break;case"int32":l=Math.floor(u);break;case"bool":l=this.getBoolean(o);break;default:l=u}}i&&i.isLabel?r[a]=l:n[a]=l}}return Object.keys(r).length===0?n:{xs:n,ys:r}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],r=0,s=e.length,a=Nv;for(let i=0;i<s;i++)switch(a){case Nv:switch(e.charAt(i)){case Hk:r=i+1,a=qk;break;case this.delimiter:if(r=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=Nv;break;default:a=T5,r=i;break}break;case T5:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i)),a=Nv,r=i+1;break}break;case qk:switch(e.charAt(i)){case Hk:a=jE;break}break;case jE:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(r,i-1)),a=Nv,r=i+1;break;case Hk:a=qk;break;default:a=$5;break}break;case $5:switch(e.charAt(i)){case Hk:a=qk;break}break}if(a===jE?n.push(e.substring(r,s-1)):n.push(e.substring(r)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}},Tit=class Pne extends hs{constructor(t){super(),this.microphoneConfig=t,this.isClosed=!1,this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(t={}){if(!xe().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new Pne(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(r){throw new Error(`Error thrown while initializing video stream: ${r.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,r=await this.getAudioData();if(this.includeSpectrogram){let s=this.flattenQueue(r.freqDataQueue);t=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let s=this.flattenQueue(r.timeDataQueue);n=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],r=0;return new Promise(s=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&s({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++r===this.numFrames&&(clearInterval(a),s({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,r=new Float32Array(t.length*n);return t.forEach((s,a)=>r.set(s,a*n)),r}getTensorFromAudioDataArray(t,n){let r=new Float32Array(M.sizeFromShape(n));return r.set(t,r.length-t.length),Js(r,n)}},$it=class Lne extends hs{constructor(t,n){if(super(),this.webcamVideoElement=t,this.webcamConfig=n,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=dn([0],"int32"),this.webcamConfig.centerCrop){let r=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-r)/2,i=(1-s)/2,o=a+r,l=s+i;this.cropBox=Tl([i,a,l,o],[1,4])}else this.cropBox=Tl([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(t,n={}){if(!xe().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let r=new Lne(t,n);return await r.start(),r}async start(){this.webcamConfig.facingMode&&M.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Rw.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return ue(()=>{let n=is(je(t,"float32"),0),r;r=di.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let s=r.shape;return le(r,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}},zne=class{},Bne=class extends hs{split(e){return new Eit(this,e)}},Eit=class extends Bne{constructor(e,t){super(),this.upstream=e,this.impl=new _it(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},_it=class extends F4{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}},Ait=class extends hs{decodeUTF8(){return new Rit(this)}},Rit=class extends Bne{constructor(e){super(),this.upstream=e,this.impl=new Dit(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Dit=class extends F4{constructor(e){if(super(),this.upstream=e,xe().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=XJ();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return xe().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}},Wne=class extends Ait{constructor(e,t={}){super(),this.file=e,this.options=t,M.assert(e instanceof Uint8Array||(xe().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{let n=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,n)));else{let r=new FileReader;r.onload=a=>{let i=r.result;if(i instanceof ArrayBuffer&&(i=new Uint8Array(i)),!(i instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(i)},r.onabort=a=>t(new Error("Aborted")),r.onerror=a=>t(new Error(a.type));let s=this.file.slice(this.offset,n);r.readAsArrayBuffer(s)}this.offset=n}),done:!1}}};async function Oit(e,t={},n){let r,s;typeof e=="string"?r=e:(r=e.url,s=Fit(e));let a=await(n||M.fetch)(r,s);if(a.ok){let i=new Uint8Array(await a.arrayBuffer());return new Wne(i,t)}else throw new Error(a.statusText)}var Fit=e=>({method:e.method,headers:e.headers,body:e.body,mode:e.mode,credentials:e.credentials,cache:e.cache,redirect:e.redirect,referrer:e.referrer,integrity:e.integrity});function Vne(e){return typeof e=="string"&&e.slice(0,7)==="file://"}var Une=class extends zne{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(Vne(this.input)&&xe().get("IS_NODE")){let e=CM();this.input=e.readFileSync(this.input.slice(7))}return new Wne(this.input,this.options)}},jne=class extends zne{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return Vne(this.url)?new Une(this.url,this.fileOptions).iterator():Oit(this.url,this.fileOptions)}};function Mit(e,t={}){return new Mne(new jne(e),t)}function Pit(e){let t=O4(e);return Fa(async()=>t)}function Lit(e){return Fa(async()=>{let t=await e();return O4(()=>t.next())})}async function zit(e,t){return $it.create(e,t)}async function Bit(e){return Tit.create(e)}var Wit="4.16.0";function pt(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&M.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var Vit=Vl.whereImpl,M4=class Gne extends jx{nextDataId(){return Gne.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new VN(this,Fi())}write(t,n,r){this.firstUse&&(this.firstUse=!1,xe().get("IS_NODE")&&H.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:t,dtype:r,refCount:1}),s}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&M.isString(r[0])){let a=r.map(i=>M.encodeString(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return{dataId:s,shape:t,dtype:n}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){let n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){let n=this.data.get(t);n.refCount--}}move(t,n,r,s,a){this.data.set(t,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:n,complexTensorInfos:r}=this.data.get(t);if(n==="complex64"){let s=this.readSync(r.real.dataId),a=this.readSync(r.imag.dataId);return H.mergeRealAndImagArrays(s,a)}return M.convertBackendValuesAndArrayBuffer(this.data.get(t).values,n)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(s=>M.decodeString(s));return zt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(t.shape,t.dtype,n)}makeOutput(t,n,r){return Fi().makeTensorFromTensorInfo(this.makeTensorInfo(n,r,t),this)}disposeData(t,n=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!n&&this.data.get(t).refCount>0)return!1;let{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){let n=M.now();return t(),{kernelMs:M.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){pt([t],"where");let n=this.readSync(t.dataId);return Vit(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};M4.nextDataId=0;var P4={};At(P4,{addImpl:()=>Kne,bincountImpl:()=>z4,bincountReduceImpl:()=>Xne,bitwiseAndImpl:()=>Yne,castImpl:()=>qne,ceilImpl:()=>Jne,concatImpl:()=>B4,equalImpl:()=>Zne,expImpl:()=>ere,expm1Impl:()=>nre,floorDivImpl:()=>sre,floorImpl:()=>rre,gatherNdImpl:()=>are,gatherV2Impl:()=>ire,greaterEqualImpl:()=>lre,greaterImpl:()=>ore,lessEqualImpl:()=>cre,lessImpl:()=>ure,linSpaceImpl:()=>dre,logImpl:()=>hre,maxImpl:()=>pre,maximumImpl:()=>fre,minimumImpl:()=>mre,multiplyImpl:()=>W4,negImpl:()=>gre,notEqualImpl:()=>yre,prodImpl:()=>bre,raggedGatherImpl:()=>vre,raggedRangeImpl:()=>xre,raggedTensorToTensorImpl:()=>wre,rangeImpl:()=>U4,rsqrtImpl:()=>kre,scatterImpl:()=>ih,sigmoidImpl:()=>Wot,simpleAbsImpl:()=>Hne,sliceImpl:()=>fI,sparseFillEmptyRowsImpl:()=>Ire,sparseReshapeImpl:()=>Cre,sparseSegmentReductionImpl:()=>j4,sqrtImpl:()=>jot,squaredDifferenceImpl:()=>Nre,staticRegexReplaceImpl:()=>Tre,stridedSliceImpl:()=>$re,stringNGramsImpl:()=>G4,stringSplitImpl:()=>H4,stringToHashBucketFastImpl:()=>q4,subImpl:()=>Ere,tileImpl:()=>_re,topKImpl:()=>Rre,transposeImpl:()=>V4,uniqueImpl:()=>X4});function Hne(e){let t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}var Uit=e=>{let{x:t}=e.inputs,n=e.backend;pt(t,"abs");let r=new Float32Array(M.sizeFromShape(t.shape)),s=n.data.get(t.dataId).values;return r=Hne(s),n.makeOutput(r,t.shape,t.dtype)},jit={kernelName:Fy,backendName:"cpu",kernelFunc:Uit};function Sr(e){return(t,n,r,s,a)=>{let i=H.assertAndGetBroadcastShape(t,n),o=i.length,l=M.computeStrides(i),u=M.sizeFromShape(i),c=M.getTypedArrayFromDType(a,u),d=t.length,h=n.length,p=M.computeStrides(t),f=M.computeStrides(n),m=H.getBroadcastDims(t,i),g=H.getBroadcastDims(n,i);if(m.length+g.length===0)for(let y=0;y<c.length;++y)c[y]=e(r[y%r.length],s[y%s.length]);else for(let y=0;y<c.length;++y){let b=M.indexToLoc(y,o,l),x=b.slice(-d);m.forEach(S=>x[S]=0);let v=M.locToIndex(x,d,p),w=b.slice(-h);g.forEach(S=>w[S]=0);let k=M.locToIndex(w,h,f);c[y]=e(r[v],s[k])}return[c,i]}}function za(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=n.makeTensorInfo(r.shape,"complex64"),l=n.data.get(o.dataId);return l.complexTensorInfos={real:n.makeTensorInfo(r.shape,"float32",a),imag:n.makeTensorInfo(s.shape,"float32",i)},o}var Git={kernelName:GN,backendName:"cpu",kernelFunc:za};function pI(e,t,n="float32"){if(n==="complex64"){let s=pI(e,t,"float32"),a=pI(e,t,"float32");return za({inputs:{real:s,imag:a},backend:e})}let r=M.makeZerosTypedArray(M.sizeFromShape(t),n);return e.makeTensorInfo(t,n,r)}function Ll(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Hit={kernelName:rf,backendName:"cpu",kernelFunc:Ll};function rp(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.real,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var qit={kernelName:rT,backendName:"cpu",kernelFunc:rp};function qne(e,t,n,r){if(r==="int32"){let s=Int32Array.from(e);return[t,"int32",s]}if(r==="bool"){let s=M.toTypedArray([0],n),[a,i]=Sr((o,l)=>o!==l?1:0)(t,[],e,s,"bool");return[i,"bool",a]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}function Kc(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return Ll({inputs:{x:s},backend:n});let c=pI(n,s.shape,s.dtype),d=Kc({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),h=za({inputs:{real:d,imag:c},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),h}if(s.dtype==="complex64"){let c=rp({inputs:{input:s},backend:n}),d=Kc({inputs:{x:c},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(c),d}if(!M.hasEncodingLoss(s.dtype,a)){let c=Ll({inputs:{x:s},backend:n});return{dataId:c.dataId,shape:c.shape,dtype:a}}let i=n.data.get(s.dataId).values,[o,l,u]=qne(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}var Kit={kernelName:Pp,backendName:"cpu",kernelFunc:Kc};function Jr(e,t,n,r){return n==null?({inputs:s,backend:a})=>{let{a:i,b:o}=s,l=a;pt([i,o],e);let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=i.dtype==="string"?H.fromUint8ToStringArray(u):u,h=i.dtype==="string"?H.fromUint8ToStringArray(c):c,p=r||i.dtype,[f,m]=t(i.shape,o.shape,d,h,p);return l.makeTensorInfo(m,p,f)}:({inputs:s,backend:a})=>{let{a:i,b:o}=s,l=a;if(i.dtype==="complex64"||o.dtype==="complex64"){let u=Kc({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}}),c=l.data.get(u.dataId),d=c.complexTensorInfos.real,h=c.complexTensorInfos.imag,p=l.data.get(d.dataId).values,f=l.data.get(h.dataId).values,m=Kc({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),g=l.data.get(m.dataId),y=g.complexTensorInfos.real,b=g.complexTensorInfos.imag,x=l.data.get(y.dataId).values,v=l.data.get(b.dataId).values,[w,k,S]=n(i.shape,o.shape,p,f,x,v),I=l.makeTensorInfo(S,"float32",w),$=l.makeTensorInfo(S,"float32",k),C=za({inputs:{real:I,imag:$},backend:l});return l.disposeIntermediateTensorInfo(u),l.disposeIntermediateTensorInfo(m),l.disposeIntermediateTensorInfo(I),l.disposeIntermediateTensorInfo($),C}else{let u=l.data.get(i.dataId).values,c=l.data.get(o.dataId).values,d=r||i.dtype,[h,p]=t(i.shape,o.shape,u,c,d);return l.makeTensorInfo(p,d,h)}}}function L4(e){return(t,n,r,s,a,i)=>{let o=H.assertAndGetBroadcastShape(t,n),l=M.sizeFromShape(o),u=o.length,c=M.computeStrides(o),d=M.getTypedArrayFromDType("float32",l),h=M.getTypedArrayFromDType("float32",l),p=H.getBroadcastDims(t,o),f=H.getBroadcastDims(n,o),m=H.mergeRealAndImagArrays(r,s),g=H.mergeRealAndImagArrays(a,i),y=t.length,b=M.computeStrides(t),x=n.length,v=M.computeStrides(n);if(p.length+f.length===0)for(let w=0;w<d.length;w++){let k=w%m.length,S=w%g.length,I=e(m[k*2],m[k*2+1],g[S*2],g[S*2+1]);d[w]=I.real,h[w]=I.imag}else for(let w=0;w<d.length;w++){let k=M.indexToLoc(w,u,c),S=k.slice(-y);p.forEach(N=>S[N]=0);let I=M.locToIndex(S,y,b),$=k.slice(-x);f.forEach(N=>$[N]=0);let C=M.locToIndex($,x,v),T=e(m[I*2],m[I*2+1],g[C*2],g[C*2+1]);d[w]=T.real,h[w]=T.imag}return[d,h,o]}}var Kne=Sr((e,t)=>e+t),Xit=L4((e,t,n,r)=>({real:e+n,imag:t+r})),Yg=Jr(fd,Kne,Xit),Yit={kernelName:fd,backendName:"cpu",kernelFunc:Yg};function z4(e,t,n,r,s){let a=M.sizeFromShape(r),i=M.makeZerosTypedArray(s,n);for(let o=0;o<e.length;o++){let l=e[o];if(l<0)throw new Error("Input x must be non-negative!");l>=s||(a>0?i[l]+=t[o]:i[l]+=1)}return i}function Xne(e,t,n,r=!1){let s=e.shape[0],a=e.shape[1],i=zt([s,n],t.dtype);for(let o=0;o<s;o++)for(let l=0;l<a;l++){let u=e.get(o,l);if(u<0)throw new Error("Input x must be non-negative!");u>=n||(r?i.set(1,o,u):t.size>0?i.set(i.get(o,u)+t.get(o,l),o,u):i.set(i.get(o,u)+1,o,u))}return i}var Yne=Sr((e,t)=>e&t),Jit=Jr(Uy,Yne),Zit={kernelName:Uy,backendName:"cpu",kernelFunc:Jit};function Ul(e){return(t,n,r)=>{let s=M.getArrayFromDType(n,t.length);for(let a=0;a<t.length;++a)s[a]=e(t[a],r);return s}}function vn(e,t,n){let r=Ul(t);return Sd(e,r,n)}function Sd(e,t,n){return({inputs:r,attrs:s,backend:a})=>{let{x:i}=r;pt(i,e);let o=a,l=o.data.get(i.dataId).values,u;if(i.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=H.fromUint8ToStringArray(l)}else u=l;let c=n||i.dtype,d=t(u,c,s);return o.makeTensorInfo(i.shape,c,d)}}var Jne=Ul(e=>Math.ceil(e)),Qit=Sd(Lp,Jne),eot={kernelName:Lp,backendName:"cpu",kernelFunc:Qit};function B4(e,t,n,r){let s=M.getArrayFromDType(n,M.sizeFromShape(t));if(r&&n!=="string"){let a=0;e.forEach(i=>{let o=M.sizeFromShape(i.shape);s.set(i.vals,a),a+=o})}else{let a=0;e.forEach(i=>{let o=n==="string"?H.fromUint8ToStringArray(i.vals):i.vals,l=0;for(let u=0;u<i.shape[0];++u){let c=u*t[1]+a;for(let d=0;d<i.shape[1];++d)s[c+d]=o[l++]}a+=i.shape[1]})}return s}var Zne=Sr((e,t)=>e===t?1:0),Qne=Jr(Jy,Zne,null,"bool"),tot={kernelName:Jy,backendName:"cpu",kernelFunc:Qne},ere=Ul(e=>Math.exp(e)),tre=Sd(Yp,ere,"float32"),not={kernelName:Yp,backendName:"cpu",kernelFunc:tre},nre=Ul(e=>Math.expm1(e)),rot=Sd(Jp,nre),sot={kernelName:Jp,backendName:"cpu",kernelFunc:rot},rre=Ul(e=>Math.floor(e)),aot=Sd(Zp,rre),iot={kernelName:Zp,backendName:"cpu",kernelFunc:aot},sre=Sr((e,t)=>Math.floor(e/t)),oot=Jr(Qp,sre,null,"int32"),lot={kernelName:Qp,backendName:"cpu",kernelFunc:oot};function are(e,t,n,r,s,a,i,o,l){let u=zt([r,a],n);for(let c=0;c<r;c++){let d=[],h=0;for(let p=0;p<s;p++){let f=e[c*s+p];h+=f*i[p],d.push(f)}if(h<0||h>=l/a)throw new Error(`Invalid indices: ${d} does not index into ${o}`);for(let p=0;p<a;p++)u.values[c*a+p]=t.get(...t.indexToLoc(h*a+p))}return u}function ire(e,t,n){let r=zt(n,e.dtype);for(let s=0;s<r.size;++s){let a=r.indexToLoc(s).slice(),i=a[0],o=a[2],l=t.locToIndex([i,o]);a[2]=t.values[l];let u=e.locToIndex(a);0<=u&&u<e.values.length&&(r.values[s]=e.values[u])}return r}var ore=Sr((e,t)=>e>t?1:0),uot=Jr(nb,ore,null,"bool"),cot={kernelName:nb,backendName:"cpu",kernelFunc:uot},lre=Sr((e,t)=>e>=t?1:0),dot=Jr(nf,lre,null,"bool"),hot={kernelName:nf,backendName:"cpu",kernelFunc:dot},ure=Sr((e,t)=>e<t?1:0),pot=Jr(rb,ure,null,"bool"),fot={kernelName:rb,backendName:"cpu",kernelFunc:pot},cre=Sr((e,t)=>e<=t?1:0),mot=Jr(sb,cre,null,"bool"),got={kernelName:sb,backendName:"cpu",kernelFunc:mot};function dre(e,t,n){let r=(t-e)/(n-1),s=M.makeZerosTypedArray(n,"float32");s[0]=e;for(let a=1;a<s.length;a++)s[a]=s[a-1]+r;return s}var hre=Ul(e=>Math.log(e)),yot=Sd(uf,hre),bot={kernelName:uf,backendName:"cpu",kernelFunc:yot};function pre(e,t,n,r){let s=M.getTypedArrayFromDType(r,M.sizeFromShape(n));for(let a=0;a<s.length;++a){let i=a*t,o=e[i];for(let l=0;l<t;++l){let u=e[i+l];(Number.isNaN(u)||u>o)&&(o=u)}s[a]=o}return s}var fre=Sr((e,t)=>Math.max(e,t)),vot=Jr(pf,fre),xot={kernelName:pf,backendName:"cpu",kernelFunc:vot},mre=Sr((e,t)=>Math.min(e,t)),wot=Jr(yf,mre),kot={kernelName:yf,backendName:"cpu",kernelFunc:wot},W4=Sr((e,t)=>e*t),Sot=L4((e,t,n,r)=>({real:e*n-t*r,imag:e*r+t*n})),l$=Jr(xf,W4,Sot),Iot={kernelName:xf,backendName:"cpu",kernelFunc:l$};function gre(e,t,n){let r=M.createScalarValue(-1,n);return W4([],t,r,e,n)}function Cot(e){let{inputs:t,backend:n}=e,{x:r}=t;pt(r,"neg");let s=n.data.get(r.dataId).values,[a,i]=gre(s,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,a)}var Not={kernelName:hb,backendName:"cpu",kernelFunc:Cot},yre=Sr((e,t)=>e!==t?1:0),Tot=Jr(pb,yre,null,"bool"),$ot={kernelName:pb,backendName:"cpu",kernelFunc:Tot};function V4(e,t,n,r,s){let a=t.length,i=M.sizeFromShape(t),o=M.computeStrides(t),l=M.computeStrides(s),u=M.getTypedArrayFromDType(n,M.sizeFromShape(s));for(let c=0;c<i;++c){let d=M.indexToLoc(c,a,o),h=new Array(d.length);for(let f=0;f<h.length;f++)h[f]=d[r[f]];let p=M.locToIndex(h,a,l);u[p]=e[c]}return u}function Sa(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{perm:a}=n;pt(s,"transpose");let i=s.shape.length,o=new Array(i);for(let c=0;c<o.length;c++)o[c]=s.shape[a[c]];let l=r.data.get(s.dataId).values,u=V4(l,s.shape,s.dtype,a,o);return{dataId:r.write(u,o,s.dtype),shape:o,dtype:s.dtype}}var Eot={kernelName:au,backendName:"cpu",kernelFunc:Sa};function bre(e,t,n,r){let[s,a]=H.computeOutAndReduceShapes(e,r),i=ki(t,"int32"),o=M.makeZerosTypedArray(M.sizeFromShape(s),i),l=M.sizeFromShape(a);for(let u=0;u<o.length;++u){let c=u*l,d=1;for(let h=0;h<l;++h)d*=n[c+h];o[u]=d}return{outVals:o,outShape:s,outDtype:i}}function _ot(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;pt(s,"prod");let o=s.shape.length,l=M.parseAxisParam(a,s.shape),u=H.getAxesPermutation(l,o),c=l,d=s,h=[];u!=null&&(d=Sa({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(d),c=H.getInnerMostAxes(c.length,o));let p=n.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=bre(d.shape,d.dtype,p,c),y=m;return i&&(y=H.expandShapeToKeepDim(m,l)),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.makeTensorInfo(y,g,f)}var Aot={kernelName:Cf,backendName:"cpu",kernelFunc:_ot};function Rot(e,t,n){e.forEach((r,s)=>{if(r<0||r>=n){let a=M.indexToLoc(s,t.length,M.computeStrides(t)).join(",");throw new Error(`indices[${a}] = ${r} is not in [0, ${n})`)}})}function Dot(e,t){for(let n=0;n<e.length;++n){let r=e[n],s=n===e.length-1?t:e[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let a=1;a<r.length;++a)if(r[a-1]>r[a])throw new Error("Ragged splits must be sorted in ascending order")}}function Oot(e,t,n,r){let s=[],a=0,i=t.length-1+n.length,o=new Array(i).fill(null).map(()=>[0]);Dot(n,r);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];let c=t[u+1];for(let d=1;d<l+1;++d)o[u].push(d*c)}for(let u=0;u<e.length;++u){let c=e[u],d=e[u]+1;for(let h=0;h<n.length;++h){let p=n[h],f=h+t.length-1;if(f>=0){let m=o[f],g=m[m.length-1]-p[c];for(let y=c;y<d;++y)o[f].push(p[y+1]+g)}c=p[c],d=p[d]}d!==c&&(s.push([c,d]),a+=d-c)}return{outSplits:o,valueSlices:s,numValues:a}}function Fot(e){let t=[];for(let n=0;n<e.length;++n){let r=e[n].length,s=M.getArrayFromDType("int32",r);t.push(s),e[n].forEach((a,i)=>s[i]=a)}return t}function E5(e,t){let n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}function Mot(e,t,n,r,s,a){let i=E5(t,2)[1],o=E5(a,2)[1],l=0;for(let u of n)for(let c=u[0];c<u[1];++c){for(let d=0;d<r;++d)s[l*o+d]=e[c*i+d];++l}}function Pot(e,t,n,r,s){let a=t.slice();a[0]=s;let i=M.getArrayFromDType(n,M.sizeFromShape(a)),o=e.length,l=o===0?0:o/t[0];return Mot(e,t,r,l,i,a),[i,a]}function vre(e,t,n,r,s,a,i,o){if(e.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");let l=t[0][0]-1;if(Rot(a,i,l),r.length===0)throw new Error("params.rank must be nonzero");let u=r[0],{outSplits:c,valueSlices:d,numValues:h}=Oot(a,i,e,u),p=Fot(c),f=Pot(n,r,s,d,h);return[p,f[0],f[1]]}var _5=2147483647;function xre(e,t,n,r,s,a,i){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");let o=t.length===0,l=s.length===0,u=i.length===0,c=[];o||c.push(t[0]),l||c.push(s[0]),u||c.push(i[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");let d=c.length===0?1:c[0],h=M.getArrayFromDType("int32",d+1);h[0]=0;for(let g=0;g<d;++g){let y=o?e[0]:e[g],b=l?r[0]:r[g],x=u?a[0]:a[g];if(x===0)throw new Error("Requires delta != 0");let v;if(x>0&&b<y||x<0&&b>y)v=0;else if(v=Math.ceil(Math.abs((b-y)/x)),v>_5)throw new Error(`Requires ((limit - start) / delta) <= ${_5}`);h[g+1]=h[g]+v}let p=h[d],f=M.getArrayFromDType(n,p),m=0;for(let g=0;g<d;++g){let y=h[g+1]-h[g],b=o?e[0]:e[g],x=u?a[0]:a[g];for(let v=0;v<y;++v)f[m++]=b,b+=x}return[h,f]}var Di=H.RowPartitionType,Lot=class BR{constructor(t,n,r,s,a,i,o,l,u,c){this.shape=t,this.shapeShape=n,this.values=r,this.valuesShape=s,this.valuesDType=a,this.defaultValue=i,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=H.getRowPartitionTypesHelper(c),this.raggedRank=H.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Di.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Di.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Di.VALUE_ROWIDS:return BR.getMaxWidthValueRowID(n);case Di.ROW_SPLITS:return BR.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${Di[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let n=t.length;if(n===0||n===1)return 0;let r=0;for(let s=0;s<n-1;++s){let a=t[s+1]-t[s];a>r&&(r=a)}return r}static getMaxWidthValueRowID(t){let n=t.length;if(n===0)return 0;let r=0,s=t[0],a=0;for(let i=1;i<n;++i){let o=t[i];o!==s&&(s=o,a=Math.max(i-r,a),r=i)}return Math.max(n-r,a)}tensorShapeFromTensor(t,n,r=!0){if(n.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return R5(t,r)}calculateOutputSize(t){let n=this.valuesShape,r=this.defaultValueShape;H.validateDefaultValueShape(r,n);let s=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=H.combineRaggedTensorToTensorShapes(this.raggedRank,s,n);a[0]<0&&(a[0]=t);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(t,n,r){let s=Math.min(t,r),a=[],i=0;for(let o=0;o<s;++o,i+=n)a.push(i);for(let o=s;o<t;++o)a.push(-1);return M.assert(a.length===t,()=>"Final length of result must be equal to firstDimension."),a}calculateOutputIndexRowSplit(t,n,r,s){let a=t.length,i=[];for(let o=0;o<a-1;++o){let l=t[o+1]-t[o],u=Math.min(s,l),c=n[o];c===-1&&(u=0);for(let d=0;d<u;++d)i.push(c),c+=r;for(let d=0;d<l-u;++d)i.push(-1)}if(a>0&&i.length!==t[a-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(t,n,r,s){let a=t.length,i=[];if(a===0)return[];let o=0,l=t[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let u=n[l];i.push(u);for(let c=1;c<a;++c){let d=t[c];if(d===l)u>=0&&(++o,o<s?u+=r:u=-1);else{if(o=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);u=n[d]}i.push(u)}if(i.length!==t.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(t,n,r,s){let a=this.getRowPartitionTensor(t),i=this.getRowPartitionTypeByDimension(t);switch(i){case Di.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(a,n,r,s);case Di.ROW_SPLITS:if(a.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${a.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(a,n,r,s);default:throw new Error(`Unsupported partition type: ${Di[i]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let n=this.rowPartitionTypes[0];switch(n){case Di.FIRST_DIM_SIZE:return t[0];case Di.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Di.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Di[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let i=r.length-2;i>=0;--i)r[i]=r[i+1]*n[i+1];let s=R5(n,!1),a=M.getArrayFromDType(this.valuesDType,M.sizeFromShape(s));if(r[0]*n[0]>0){let i=this.calculateFirstParentOutputIndex(t,r[0],n[0]);for(let o=1;o<=this.raggedRank;++o)i=this.calculateOutputIndex(o-1,i,r[o],n[o]);this.setOutput(this.raggedRank,i,a,s)}return[s,a]}setOutput(t,n,r,s){if(r.length===0)return;let a=this.values,i=r,o=s.slice();o=o.slice(t+1);let l=M.sizeFromShape(o),u=n.length,c=this.defaultValue;if(c.length!==l&&c.length!==1){let f=this.defaultValueShape;ue(()=>{let m=le(c,f);c=gh(m,o).dataSync()})}let d=0,h=0,p=0;for(let f=0;f<=u;++f){let m=f<u?n[f]:-1;if(m===p){++p;continue}if(h<p){let g=a.subarray(d*l),y=i.subarray(h*l),b=(p-h)*l;A5(y,g,b)}if(f>=u){let g=r.length;m=Math.floor(g/l)}if(m>p)if(this.defaultValue.length===1)i.subarray(p*l,m*l).fill(this.defaultValue[0]),p=m;else for(;m>p;){let g=i.slice(p*l);A5(g,c,l),++p}m<0?(d=f+1,h=p):(d=f,h=p,p=h+1)}}};function A5(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function R5(e,t){let n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function wre(e,t,n,r,s,a,i,o,l,u){return new Lot(e,t,n,r,s,a,i,o,l,u).compute()}function U4(e,t,n,r){let s=e===t,a=e<t&&n<0,i=t<e&&n>1;if(s||a||i)return M.makeZerosTypedArray(0,r);let o=Math.abs(Math.ceil((t-e)/n)),l=M.makeZerosTypedArray(o,r);t<e&&n===1&&(n=-1),l[0]=e;for(let u=1;u<l.length;u++)l[u]=l[u-1]+n;return l}var kre=Ul(e=>1/Math.sqrt(e)),zot=Sd(Df,kre),Bot={kernelName:Df,backendName:"cpu",kernelFunc:zot};function ih(e,t,n,r,s,a,i,o,l,u){let c=[r/s,s],d=e.values,h=t.values;if(r===0)return zt(n,t.dtype);let p=l instanceof Er?l:zt(c,t.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<a;f++){let m=[],g=0;for(let y=0;y<i;y++){let b=d[f*i+y];m.push(b),g+=b*o[y]}if(g<0||g>=r/s)throw new Error(`Invalid indices: ${m} does not index into ${n}`);for(let y=0;y<s;y++)u?p.values[g*s+y]+=h[f*s+y]:p.values[g*s+y]=t.rank===0?h[0]:h[f*s+y]}return p}var Wot=Ul(e=>1/(1+Math.exp(-e))),Sre=vn(Lf,e=>1/(1+Math.exp(-e))),Vot={kernelName:Lf,backendName:"cpu",kernelFunc:Sre};function fI(e,t,n,r,s){let a=Hr.isSliceContinous(r,t,n),i=M.sizeFromShape(n),o=M.computeStrides(r);if(a){let d=Hr.computeFlatOffset(t,o);return s==="string"?e.slice(d,d+i):e.subarray(d,d+i)}let l=s==="string"?H.fromUint8ToStringArray(e):e,u=zt(r,s,l),c=zt(n,s);for(let d=0;d<c.size;++d){let h=c.indexToLoc(d),p=h.map((f,m)=>f+t[m]);c.set(u.get(...p),...h)}return s==="string"?H.fromStringArrayToUint8(c.values):c.values}function sp(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r;pt(s,"slice");let[o,l]=Hr.parseSliceParams(s,a,i);Hr.assertParamsValid(s,o,l);let u=n.data.get(s.dataId).values,c=fI(u,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,c)}var Uot={kernelName:Nb,backendName:"cpu",kernelFunc:sp};function Ire(e,t,n,r,s,a,i){let o=t[0],l=a[0],u=new Array(l),c=new Array(o),d=t[1];if(l===0){if(o!==0)throw new Error(H.getSparseFillEmptyRowsIndicesDenseShapeMismatch(o));let g=M.getArrayFromDType(n,0),y=M.getArrayFromDType(s,0);return[g,[0,d],y,u,c]}let h=!0,p=0,f=new Array(l).fill(0);for(let g=0;g<o;++g){let y=e[g*d];if(y<0)throw new Error(H.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,y));if(y>=l)throw new Error(H.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,y,l));++f[y],h=h&&y>=p,p=y}let m=!0;for(let g=0;g<l;++g){let y=f[g]===0;u[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&h){let g=e,y=r;for(let b=0;b<o;++b)c[b]=b;return[g,[o,d],y,u,c]}else{let g=f[l-1],y=M.getArrayFromDType(n,g*d),b=M.getArrayFromDType(s,g),x=new Array(l).fill(0);for(let v=0;v<o;++v){let w=e[v*d],k=x[w],S=(w===0?0:f[w-1])+k;x[w]++;for(let I=0;I<d;++I)y[S*d+I]=e[v*d+I];b[S]=r[v],c[v]=S}for(let v=0;v<l;++v)if(x[v]===0){let w=v===0?0:f[v-1];y[w*d+0]=v;for(let k=1;k<d;++k)y[w*d+k]=0;b[w]=i}return[y,[g,d],b,u,c]}}function Cre(e,t,n,r,s){let a=M.sizeFromShape(r),i=t[0],o=s.length,l=[],u=1,c=-1;for(let m=0;m<o;++m){let g=s[m];if(g===-1){if(c!==-1)throw new Error(H.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,m));c=m,l.push(1)}else{if(g<0)throw new Error(H.getSparseReshapeNegativeOutputDimErrorMessage(m,g));u*=g,l.push(g)}}if(c!==-1){if(u<=0)throw new Error(H.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let m=Math.trunc(a/u);if(u*m!==a)throw new Error(H.getSparseReshapeInputOutputMultipleErrorMessage(r,l));l[c]=m}if(M.sizeFromShape(l)!==a)throw new Error(H.getSparseReshapeInputOutputMismatchErrorMessage(r,l));let d=r.length,h=[];if(d>0){h[d-1]=1;for(let m=d-2;m>=0;--m)h[m]=h[m+1]*r[m+1]}let p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*l[m+1]}let f=M.getArrayFromDType(n,i*o);for(let m=0;m<i;++m){let g=0;for(let y=0;y<d;++y)g+=e[m*d+y]*h[y];for(let y=0;y<o;++y)f[m*o+y]=Math.trunc(g/p[y]),g%=p[y]}return[f,[i,o],l]}function j4(e,t,n,r,s,a=!1,i=0){let o=r.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?s[o-1]+1:0;if(c<0)throw new Error(H.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let d=t.slice();d[0]=c;let h=d.reduce((b,x)=>b*x,1),p=M.getArrayFromDType(n,h);if(o===0)return c>0&&p.fill(i),[p,d];if(c<=0)throw new Error(H.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let f=0,m=1,g=0,y=s[f];for(;;){let b=0;if(m<o){if(b=s[m],y===b){++m;continue}if(y>=b)throw new Error(H.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(H.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>g&&p.fill(i,g*u,y*u);for(let x=f;x<m;++x){let v=r[x];if(v<0||v>=l[0])throw new Error(H.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x,r[x],l[0]));for(let w=0;w<u;w++)p[y*u+w]+=e[v*u+w]}if(a)for(let x=0;x<u;x++)p[y*u+x]/=m-f;if(f=m,++m,g=y+1,y=b,m>o)break}return g<c&&p.fill(i,g*u,c*u),[p,d]}var jot=Ul(e=>Math.sqrt(e)),Got=vn(Bf,e=>Math.sqrt(e)),Hot={kernelName:Bf,backendName:"cpu",kernelFunc:Got},Nre=Sr((e,t)=>{let n=e-t;return n*n}),qot=Jr(Uf,Nre),Kot={kernelName:Uf,backendName:"cpu",kernelFunc:qot},Tre=Ul((e,t)=>{let{pattern:n,replaceGlobal:r,rewrite:s}=t;return e.replace(new RegExp(n,r?"g":""),s)}),Xot=Sd(ow,Tre),Yot={kernelName:ow,backendName:"cpu",kernelFunc:Xot};function $re(e,t,n,r){let s=zt(e,t.dtype);for(let a=0;a<s.size;a++){let i=s.indexToLoc(a),o=new Array(i.length);for(let l=0;l<o.length;l++)o[l]=i[l]*n[l]+r[l];s.set(t.get(...o),...i)}return s}var Jot=class{constructor(e,t,n,r,s,a){this.separator=M.encodeString(e),this.nGramWidths=t,this.leftPad=M.encodeString(n),this.rightPad=M.encodeString(r),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,s,a){for(let i=0;i<s;++i){let o=this.getPadWidth(a),l=Math.max(0,o-i),u=Math.max(0,o-(s-(i+1))),c=a-(l+u),d=t+(l>0?0:i-o),h=0;h+=l*this.leftPad.length;for(let y=0;y<c;++y)h+=e[d+y].length;h+=u*this.rightPad.length;let p=l+u+c-1;h+=p*this.separator.length,n[r+i]=new Uint8Array(h);let f=n[r+i],m=0,g=y=>y.forEach(b=>f[m++]=b);for(let y=0;y<l;++y)g(this.leftPad),g(this.separator);for(let y=0;y<c-1;++y)g(e[d+y]),g(this.separator);if(c>0){g(e[d+c-1]);for(let y=0;y<u;++y)g(this.separator),g(this.rightPad)}else{for(let y=0;y<u-1;++y)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){let n=e.length,r=t.length;if(r>0){let o=t[0];if(o!==0)throw new Error(`First split value must be 0, got ${o}`);for(let l=1;l<r;++l){let u=t[l]>=o;if(u=u&&t[l]<=n,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${o}, ${n}]`);o=t[l]}if(o!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${o}`)}let s=r-1,a=M.getArrayFromDType("int32",r);if(n===0||r===0){let o=new Array(n);for(let l=0;l<=s;++l)a[l]=0;return[o,a]}a[0]=0;for(let o=1;o<=s;++o){let l=t[o]-t[o-1],u=0;this.nGramWidths.forEach(c=>{u+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&u===0&&(u=1),a[o]=a[o-1]+u}let i=new Array(a[s]);for(let o=0;o<s;++o){let l=t[o],u=a[o];if(this.nGramWidths.forEach(c=>{let d=t[o+1]-t[o],h=this.getNumNGrams(d,c);this.createNGrams(e,l,i,u,h,c),u+=h}),this.preserveShort&&u===a[o]){let c=t[o+1]-t[o];if(c===0)continue;let d=c+2*this.padWidth;this.createNGrams(e,l,i,u,1,d)}}return[i,a]}};function G4(e,t,n,r,s,a,i,o){return new Jot(n,r,s,a,i,o).compute(e,t)}function Zot(e,t,n,r){if(!e.length)return;if(t.length===0){for(let a=0;a<e.length;++a)r.push(e.subarray(a,a+1));return}if(t.length===1){let a=t[0],i=e.indexOf(a);for(;i!==-1;){let o=e.subarray(0,i);(!n||o.length!==0)&&r.push(o),e=e.subarray(i+1),i=e.indexOf(a)}(!n||e.length!==0)&&r.push(e);return}let s=0;for(let a=0;a<e.length+1;a++)if(a===e.length||t.indexOf(e[a])!==-1){let i=e.subarray(s,a);(!n||i.length!==0)&&r.push(i),s=a+1}}function H4(e,t,n){let r=e.length,s=[],a=0,i=0,o=new Array(r);for(let h=0;h<r;++h){let p=s.length;Zot(e[h],t,n,s);let f=s.length-p;o[h]=f,a+=f,i=Math.max(i,f)}let l=M.getArrayFromDType("int32",a*2),u=new Array(a),c=[r,i],d=0;for(let h=0;h<r;++h)for(let p=0;p<o[h];++p)l[d*2]=h,l[d*2+1]=p,u[d]=s[d],++d;return[l,u,c]}function q4(e,t){let n=M.getArrayFromDType("int32",e.length);for(let r=0;r<e.length;++r)n[r]=M.fingerPrint64(e[r]).modulo(t).getLowBitsUnsigned();return n}var Ere=Sr((e,t)=>e-t),Qot=L4((e,t,n,r)=>({real:e-n,imag:t-r})),K4=Jr(jf,Ere,Qot),elt={kernelName:jf,backendName:"cpu",kernelFunc:K4};function _re(e,t){let n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=e.shape[s]*t[s];let r=zt(n,e.dtype);for(let s=0;s<r.values.length;++s){let a=r.indexToLoc(s),i=new Array(e.rank);for(let l=0;l<i.length;l++)i[l]=a[l]%e.shape[l];let o=e.locToIndex(i);r.values[s]=e.values[o]}return r}var Vv=(e,t)=>{let n=t.value-e.value;return n===0?e.index-t.index:n};function Are(e,t,n=0,r=e.length-1){for(;r>n;){if(r-n>600){let o=r-n+1,l=t-n+1,u=Math.log(o),c=.5*Math.exp(2*u/3),d=.5*Math.sqrt(u*c*(o-c)/o)*Math.sign(l-o/2),h=Math.max(n,Math.floor(t-l*c/o+d)),p=Math.min(r,Math.floor(t+(o-l)*c/o+d));Are(e,t,h,p)}let s=e[t],a=n,i=r;for(M.swap(e,n,t),Vv(e[r],s)>0&&M.swap(e,n,r);a<i;){for(M.swap(e,a,i),a++,i--;Vv(e[a],s)<0;)a=a+1;for(;Vv(e[i],s)>0;)i=i-1}Vv(e[n],s)===0?M.swap(e,n,i):(i=i+1,M.swap(e,i,r)),i<=t&&(n=i+1),t<=i&&(r=i-1)}}function Rre(e,t,n,r,s){let a=t[t.length-1],[i,o]=[e.length/a,a],l=M.getTypedArrayFromDType(n,i*r),u=M.getTypedArrayFromDType("int32",i*r);for(let d=0;d<i;d++){let h=d*o,p=e.subarray(h,h+o),f=new Array(p.length);p.forEach((b,x)=>f[x]={value:b,index:x}),r<f.length&&(Are(f,r),f=f.slice(0,r)),s&&f.sort(Vv);let m=d*r,g=l.subarray(m,m+r),y=u.subarray(m,m+r);for(let b=0;b<r;b++)g[b]=f[b].value,y[b]=f[b].index}let c=t.slice();return c[c.length-1]=r,[zt(c,n,l),zt(c,"int32",u)]}function X4(e,t,n,r){let s=M.parseAxisParam(t,n)[0],a=[1,n[0],1];for(let f=0;f<s;f++)a[0]*=n[f];a[1]=n[s];for(let f=s+1;f<n.length;f++)a[2]*=n[f];let i=new Map,o=new Int32Array(n[s]),l=new Er(a,r,e),u=[],c=a[0]===1&&a[2]===1;for(let f=0;f<n[s];f++){let m;if(c)m=e[f].toString();else{let y=[];for(let b=0;b<a[0];b++)for(let x=0;x<a[2];x++)y.push(l.get(b,f,x));m=y.join(",")}let g=i.get(m);if(g!=null)o[f]=g;else{let y=i.size;i.set(m,y),o[f]=y,u.push(f)}}let d=a.slice();d[1]=i.size;let h=new Er(d,r);u.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let y=0;y<a[2];y++)h.set(l.get(g,f,y),g,m,y)});let p=n.slice();return p[s]=d[1],{outputValues:h.values,outputShape:p,indices:o}}var tlt="4.16.0";iT("cpu",()=>new M4,1);var Dre=vn(Kp,e=>e>=0?e:Math.exp(e)-1),nlt={kernelName:Kp,backendName:"cpu",kernelFunc:Dre};function Ore(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r;pt([s],"leakyRelu");let i=M.sizeFromShape(s.shape),o=n.data.get(s.dataId).values,l=M.getTypedArrayFromDType("float32",i);for(let u=0;u<o.length;u++)l[u]=o[u]<0?a*o[u]:o[u];return n.makeTensorInfo(s.shape,"float32",l)}var rlt={kernelName:lf,backendName:"cpu",kernelFunc:Ore},slt=Sr((e,t)=>e<0?t*e:e);function Fre(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t;pt([r,s],"prelu");let a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,[o,l]=slt(r.shape,s.shape,a,i,"float32");return n.makeTensorInfo(l,"float32",o)}var alt={kernelName:If,backendName:"cpu",kernelFunc:Fre},Mre=vn(Tf,e=>Math.max(0,e)),ilt={kernelName:Tf,backendName:"cpu",kernelFunc:Mre},Pre=vn(_f,e=>Math.min(Math.max(0,e),6)),olt={kernelName:_f,backendName:"cpu",kernelFunc:Pre};function mI(e,t,n,r,s){if(n==="linear")return Ll({inputs:{x:t},backend:e});if(n==="relu")return Mre({inputs:{x:t},backend:e});if(n==="elu")return Dre({inputs:{x:t},backend:e});if(n==="relu6")return Pre({inputs:{x:t},backend:e});if(n==="prelu")return Fre({inputs:{x:t,alpha:r},backend:e});if(n==="leakyrelu")return Ore({inputs:{x:t},backend:e,attrs:{alpha:s}});if(n==="sigmoid")return Sre({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function Pn(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=M.sizeFromShape(s.shape),o=M.inferFromImplicitShape(a,i),l=M.sizeFromShape(o);M.assert(i===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${s.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),n.incRef(s.dataId);let u=n.data.get(s.dataId);if(u.complexTensorInfos!=null){let c=u.complexTensorInfos.real,d=u.complexTensorInfos.imag;c.shape=o,d.shape=o}return{dataId:s.dataId,shape:o,dtype:s.dtype}}var llt={kernelName:vb,backendName:"cpu",kernelFunc:Pn};function Lre(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;pt([s,a],"matMul");let l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=M.sizeFromShape(f),y=M.sizeFromShape(m),b=Pb.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);M.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,c,h]:[g,h,c],v=o?[y,p,d]:[y,d,p],w=Pn({inputs:{x:s},backend:n,attrs:{shape:x}}),k=Pn({inputs:{x:a},backend:n,attrs:{shape:v}}),S=i?w.shape[1]:w.shape[2],I=i?w.shape[2]:w.shape[1],$=o?k.shape[1]:k.shape[2],C=Math.max(g,y),T=n.data.get(w.dataId).values,N=n.data.get(k.dataId).values,E=M.computeStrides(w.shape),_=M.computeStrides(k.shape),[R,z,W]=i?[E[0],1,E[1]]:[E[0],E[1],1],[F,L,O]=o?[1,_[1],_[0]]:[_[1],1,_[0]],D=I*$,B=zt([C,I,$],w.dtype),V=B.values,K=n.blockSize;for(let G=0;G<C;G++){let U=G%g,q=G%y;for(let Q=0;Q<I;Q+=K){let ee=Math.min(Q+K,I);for(let ae=0;ae<$;ae+=K){let ye=Math.min(ae+K,$);for(let j=0;j<S;j+=K){let ce=Math.min(j+K,S);for(let be=Q;be<ee;be++)for(let ke=ae;ke<ye;ke++){let Ae=0;for(let Pe=j;Pe<ce;Pe++){let ie=T[U*R+be*z+Pe*W],Te=N[Pe*F+ke*L+q*O];Ae+=ie*Te}V[G*D+(be*$+ke)]+=Ae}}}}}return n.disposeIntermediateTensorInfo(w),n.disposeIntermediateTensorInfo(k),n.makeTensorInfo(b,B.dtype,B.values)}var ult={kernelName:Mp,backendName:"cpu",kernelFunc:Lre};function clt(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h,p,f,m=[];h=Lre({inputs:{a:s,b:a},attrs:{transposeA:l,transposeB:u},backend:n}),i&&(p=Yg({inputs:{a:h,b:i},backend:n}),m.push(h),h=p),c&&(f=mI(n,h,c,o,d),m.push(h),h=f);for(let g of m)n.disposeIntermediateTensorInfo(g);return h}var dlt={kernelName:Uh,backendName:"cpu",kernelFunc:clt},hlt=vn(Tp,e=>Math.acos(e)),plt={kernelName:Tp,backendName:"cpu",kernelFunc:hlt},flt=vn($p,e=>Math.acosh(e)),mlt={kernelName:$p,backendName:"cpu",kernelFunc:flt};function glt(e){let{inputs:t,backend:n}=e,r=t;pt(t,"addN");let s=r.map(o=>n.data.get(o.dataId).values),a=zt(r[0].shape,r[0].dtype),i=a.values;for(let o=0;o<r.length;o++){let l=s[o];for(let u=0;u<i.length;u++)i[u]+=l[u]}return n.makeTensorInfo(a.shape,a.dtype,a.values)}var ylt={kernelName:Ep,backendName:"cpu",kernelFunc:glt};function blt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;pt(s,"all");let o=M.parseAxisParam(a,s.shape),l=o,u=H.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=Sa({inputs:{x:s},backend:n,attrs:{perm:u}}),l=H.getInnerMostAxes(l.length,s.shape.length)),H.assertAxesAreInnerMostDims("all",l,c.shape.length);let[d,h]=H.computeOutAndReduceShapes(c.shape,l),p=M.sizeFromShape(h),f=M.makeZerosTypedArray(M.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,x=m[b];for(let v=0;v<p;++v){let w=m[b+v];x=x&&w}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let y=H.expandShapeToKeepDim(d,o),b=Pn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var vlt={kernelName:My,backendName:"cpu",kernelFunc:blt};function xlt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;pt(s,"any");let o=M.parseAxisParam(a,s.shape),l=o,u=H.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=Sa({inputs:{x:s},backend:n,attrs:{perm:u}}),l=H.getInnerMostAxes(l.length,s.shape.length)),H.assertAxesAreInnerMostDims("any",l,c.shape.length);let[d,h]=H.computeOutAndReduceShapes(c.shape,l),p=M.sizeFromShape(h),f=M.makeZerosTypedArray(M.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,x=m[b];for(let v=0;v<p;++v){let w=m[b+v];x=x||w}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let y=H.expandShapeToKeepDim(d,o),b=Pn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var wlt={kernelName:Py,backendName:"cpu",kernelFunc:xlt};function klt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;pt(s,"argMax");let i=M.parseAxisParam(a,s.shape),o=H.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=Sa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=H.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],H.assertAxesAreInnerMostDims("argMax",i,l.shape.length);let[c,d]=H.computeOutAndReduceShapes(l.shape,i),h=M.sizeFromShape(c),p=M.makeZerosTypedArray(h,"int32"),f=M.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,b=m[y],x=0;for(let v=0;v<f;++v){let w=m[y+v];w>b&&(b=w,x=v)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}var Slt={kernelName:Ly,backendName:"cpu",kernelFunc:klt};function Ilt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r;pt(s,"argMin");let i=M.parseAxisParam(a,s.shape),o=H.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=Sa({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=H.getInnerMostAxes(i.length,l.shape.length)),i=[i[0]],H.assertAxesAreInnerMostDims("argMin",i,l.shape.length);let[c,d]=H.computeOutAndReduceShapes(l.shape,i),h=M.sizeFromShape(c),p=M.makeZerosTypedArray(h,"int32"),f=M.sizeFromShape(d),m=n.data.get(l.dataId).values;for(let g=0;g<p.length;++g){let y=g*f,b=m[y],x=0;for(let v=0;v<f;++v){let w=m[y+v];w<b&&(b=w,x=v)}p[g]=x}return u.forEach(g=>n.disposeIntermediateTensorInfo(g)),n.makeTensorInfo(c,"int32",p)}var Clt={kernelName:zy,backendName:"cpu",kernelFunc:Ilt},Nlt=vn(_p,e=>Math.asin(e)),Tlt={kernelName:_p,backendName:"cpu",kernelFunc:Nlt},$lt=vn(Ap,e=>Math.asinh(e)),Elt={kernelName:Ap,backendName:"cpu",kernelFunc:$lt},_lt=vn(Rp,e=>Math.atan(e)),Alt={kernelName:Rp,backendName:"cpu",kernelFunc:_lt},Rlt=Sr((e,t)=>Math.atan2(e,t)),Dlt=Jr(Op,Rlt),Olt={kernelName:Op,backendName:"cpu",kernelFunc:Dlt},Flt=vn(Dp,e=>Math.atanh(e)),Mlt={kernelName:Dp,backendName:"cpu",kernelFunc:Flt};function Y4(e,t,n,r,s,a){let i=s.strideHeight,o=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,c=s.effectiveFilterHeight,d=s.effectiveFilterWidth,h=s.padInfo.top,p=s.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=zt(s.outShape,n),g=m.values,y=s.outShape[1]*s.outShape[2]*s.outShape[3],b=s.outShape[2]*s.outShape[3],x=s.outShape[3];for(let v=0;v<s.batchSize;++v){let w=v*y,k=v*r[0];for(let S=0;S<s.inChannels;++S)for(let I=0;I<s.outHeight;++I){let $=I*i-h,C=Math.max(0,$),T=Math.min(s.inHeight,c+$),N=w+I*b;for(let E=0;E<s.outWidth;++E){let _=E*o-p,R=Math.max(0,_),z=Math.min(s.inWidth,d+_),W=f,F=0,L=0;for(let D=C;D<T;D+=l){let B=k+D*r[1];for(let V=R;V<z;V+=u){let K=B+V*r[2],G=e[K+S];a==="max"&&G>W?W=G:a==="avg"&&(F+=G,L++)}if(isNaN(W))break}let O=N+E*x+S;g[O]=a==="avg"?F/L:W}}}return m}function zre(e,t,n,r,s=!1,a=!1){let i=zt(r.outShape,"int32"),o=r.strideHeight,l=r.strideWidth,u=r.dilationHeight,c=r.dilationWidth,d=r.effectiveFilterHeight,h=r.effectiveFilterWidth,p=r.padInfo.top,f=r.padInfo.left,m=zt(t,n,e);for(let g=0;g<r.batchSize;++g)for(let y=0;y<r.inChannels;++y)for(let b=0;b<r.outHeight;++b){let x=b*o-p,v=x;for(;v<0;)v+=u;let w=Math.min(r.inHeight,d+x);for(let k=0;k<r.outWidth;++k){let S=k*l-f,I=S;for(;I<0;)I+=c;let $=Math.min(r.inWidth,h+S),C=Number.NEGATIVE_INFINITY,T=-1;for(let N=v;N<w;N+=u){let E=N-x;for(let _=I;_<$;_+=c){let R=_-S,z=m.get(g,N,_,y);z>C&&(C=z,s?T=a?((g*r.inHeight+N)*r.inWidth+_)*r.inChannels+y:(N*r.inWidth+_)*r.inChannels+y:T=E*h+R)}}i.set(T,g,b,k,y)}}return i}function Bre(e,t,n,r,s,a){let i=s.strideDepth,o=s.strideHeight,l=s.strideWidth,u=s.dilationDepth,c=s.dilationHeight,d=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=s.padInfo.front,g=s.padInfo.top,y=s.padInfo.left,b=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=zt(s.outShape,n),v=x.values,w=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],S=s.outShape[3]*s.outShape[4],I=s.outShape[4];for(let $=0;$<s.batchSize;++$){let C=$*w,T=$*r[0];for(let N=0;N<s.inChannels;++N)for(let E=0;E<s.outDepth;++E){let _=E*i-m,R=_;for(;R<0;)R+=u;let z=Math.min(s.inDepth,h+_),W=C+E*k;for(let F=0;F<s.outHeight;++F){let L=F*o-g,O=L;for(;O<0;)O+=c;let D=Math.min(s.inHeight,p+L),B=W+F*S;for(let V=0;V<s.outWidth;++V){let K=V*l-y,G=K;for(;G<0;)G+=d;let U=Math.min(s.inWidth,f+K),q=B+V*I,Q=b,ee=0,ae=0;for(let j=R;j<z;j+=u){let ce=T+j*r[1];for(let be=O;be<D;be+=c){let ke=ce+be*r[2];for(let Ae=G;Ae<U;Ae+=d){let Pe=ke+Ae*r[3],ie=e[Pe+N];if(a==="max"&&ie>Q?Q=ie:a==="avg"&&(ee+=ie,ae++),isNaN(Q))break}if(isNaN(Q))break}if(isNaN(Q))break}let ye=q+N;v[ye]=a==="avg"?ee/Math.max(ae,1):Q}}}}return x}function Plt(e,t){let n=zt(t.outShape,"int32"),r=t.strideDepth,s=t.strideHeight,a=t.strideWidth,i=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,h=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){let b=y*r-h,x=b;for(;x<0;)x+=i;let v=Math.min(t.inDepth,u+b);for(let w=0;w<t.outHeight;++w){let k=w*s-p,S=k;for(;S<0;)S+=o;let I=Math.min(t.inHeight,c+k);for(let $=0;$<t.outWidth;++$){let C=$*a-f,T=C;for(;T<0;)T+=l;let N=Math.min(t.inWidth,d+C),E=Number.NEGATIVE_INFINITY,_=-1;for(let R=x;R<v;R+=i){let z=R-b;for(let W=S;W<I;W+=o){let F=W-k;for(let L=T;L<N;L+=l){let O=L-C,D=e.get(m,R,W,L,g);D>=E&&(E=D,_=z*c*d+F*c+O)}}}n.set(_,m,y,w,$,g)}}}return n}function Llt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;pt(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;M.assert(H.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=H.computePool2DInfo(s.shape,a,i,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&M.arraysEqual(c.inShape,c.outShape))d=Ll({inputs:{x:s},backend:n});else{let h=n.data.get(s.dataId).values,p=M.computeStrides(s.shape),f=Y4(h,s.shape,s.dtype,p,c,"avg");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}var zlt={kernelName:Fp,backendName:"cpu",kernelFunc:Llt};function Blt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;pt(s,"avgPool3d");let c=H.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=Bre(d,s.shape,s.dtype,M.computeStrides(s.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}var Wlt={kernelName:By,backendName:"cpu",kernelFunc:Blt};function Vlt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;pt([s,a],"avgPool3DGrad");let c=H.computePool3DInfo(a.shape,i,o,1,l,u),d=c.strideDepth,h=c.strideHeight,p=c.strideWidth,f=c.filterDepth,m=c.filterHeight,g=c.filterWidth,y=c.dilationDepth,b=c.dilationHeight,x=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=v-1-c.padInfo.front,I=k-1-c.padInfo.left,$=w-1-c.padInfo.top,C=zt(a.shape,"float32"),T=1/(f*m*g),N=n.bufferSync(s);for(let E=0;E<c.batchSize;++E)for(let _=0;_<c.inChannels;++_)for(let R=0;R<c.inDepth;++R)for(let z=0;z<c.inHeight;++z)for(let W=0;W<c.inWidth;++W){let F=R-S,L=z-$,O=W-I,D=0;for(let B=0;B<v;B+=y){let V=(F+B)/d;if(!(V<0||V>=c.outDepth||Math.floor(V)!==V))for(let K=0;K<w;K+=b){let G=(L+K)/h;if(!(G<0||G>=c.outHeight||Math.floor(G)!==G))for(let U=0;U<k;U+=x){let q=(O+U)/p;if(q<0||q>=c.outWidth||Math.floor(q)!==q)continue;let Q=N.get(E,V,G,q,_);D+=Q}}}C.set(D*T,E,R,z,W,_)}return n.makeTensorInfo(C.shape,C.dtype,C.values)}var Ult={kernelName:qx,backendName:"cpu",kernelFunc:Vlt};function jlt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;pt([s,a],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=H.computePool2DInfo(i.shape,o,l,1,u),d=c.strideHeight,h=c.strideWidth,p=c.filterHeight,f=c.filterWidth,m=c.dilationHeight,g=c.dilationWidth,y=c.effectiveFilterHeight,b=c.effectiveFilterWidth,x=b-1-c.padInfo.left,v=y-1-c.padInfo.top,w=zt(i.shape,"float32"),k=1/(p*f),S=n.data.get(s.dataId).values,I=zt(s.shape,"float32",S);for(let $=0;$<c.batchSize;++$)for(let C=0;C<c.inChannels;++C)for(let T=0;T<c.inHeight;++T)for(let N=0;N<c.inWidth;++N){let E=T-v,_=N-x,R=0;for(let z=0;z<y;z+=m){let W=(E+z)/d;if(!(W<0||W>=c.outHeight||Math.floor(W)!==W))for(let F=0;F<b;F+=g){let L=(_+F)/h;if(L<0||L>=c.outWidth||Math.floor(L)!==L)continue;let O=I.get($,W,L,C);R+=O}}w.set(R*k,$,T,N,C)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}var Glt={kernelName:Hx,backendName:"cpu",kernelFunc:jlt};function Hlt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,scale:a,offset:i,mean:o,variance:l}=t;M.assert(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),M.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),M.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),pt([s,o,l,a,i],"batchNorm");let{varianceEpsilon:u}=r;u==null&&(u=.001);let c=n.data.get(s.dataId).values,d=n.data.get(o.dataId).values,h=n.data.get(l.dataId).values,p=a?n.data.get(a.dataId).values:new Float32Array([1]),f=i?n.data.get(i.dataId).values:new Float32Array([0]),m=new Float32Array(c.length),g=f.length,y=p.length,b=h.length,x=d.length,v=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)m[I]=f[v++]+(c[I]-d[w++])*p[k++]/Math.sqrt(h[S++]+u),v>=g&&(v=0),w>=x&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(s.shape,s.dtype,m)}var qlt={kernelName:ef,backendName:"cpu",kernelFunc:Hlt};function Klt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;pt([s],"batchToSpaceND");let o=a.reduce((y,b)=>y*b),l=H.getReshaped(s.shape,a,o),u=H.getPermuted(l.length,a.length),c=H.getReshapedPermuted(s.shape,a,o),d=H.getSliceBeginCoords(i,a.length),h=H.getSliceSize(c,i,a.length),p=Pn({inputs:{x:s},backend:n,attrs:{shape:l}}),f=Sa({inputs:{x:p},backend:n,attrs:{perm:u}}),m=Pn({inputs:{x:f},backend:n,attrs:{shape:c}}),g=sp({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var Xlt={kernelName:Wy,backendName:"cpu",kernelFunc:Klt};function Ylt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=z4(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}var Jlt={kernelName:Vy,backendName:"cpu",kernelFunc:Ylt};function Zlt(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.data.get(r.dataId).values,i=n.data.get(s.dataId).values,o=H.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Qlt={kernelName:Kx,backendName:"cpu",kernelFunc:Zlt},eut=vn(md,(e,t)=>{let n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e}),tut={kernelName:md,backendName:"cpu",kernelFunc:eut},nut=e=>{let{x:t}=e.inputs,n=e.backend,r=new Float32Array(M.sizeFromShape(t.shape)),s=n.data.get(t.dataId),a=s.complexTensorInfos.real,i=s.complexTensorInfos.imag,o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values;for(let u=0;u<o.length;u++){let c=o[u],d=l[u];r[u]=Math.hypot(c,d)}return n.makeOutput(r,t.shape,"float32")},rut={kernelName:Xx,backendName:"cpu",kernelFunc:nut};function Jg(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.data.get(r.dataId).complexTensorInfos.imag,a=n.data.get(s.dataId).values;return n.makeTensorInfo(s.shape,s.dtype,a)}var sut={kernelName:QN,backendName:"cpu",kernelFunc:Jg};function Zg(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=M.parseAxisParam(s,t[0].shape)[0],i=t.map(m=>m.shape);H.assertParamsConsistent(i,a);let o=H.computeOutShape(t.map(m=>m.shape),a);if(M.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(m=>M.sizeFromShape(m.shape)>0);if(l.length===1)return Ll({inputs:{x:l[0]},backend:n});if(l[0].dtype==="complex64"){let m=l.map(v=>rp({inputs:{input:v},backend:n})),g=l.map(v=>Jg({inputs:{input:v},backend:n})),y=Zg({inputs:m,backend:n,attrs:{axis:a}}),b=Zg({inputs:g,backend:n,attrs:{axis:a}}),x=za({inputs:{real:y,imag:b},backend:n});return m.forEach(v=>n.disposeIntermediateTensorInfo(v)),g.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),x}let u=l.map(m=>{let g=[-1,M.sizeFromShape(m.shape.slice(a))];return Pn({inputs:{x:m},backend:n,attrs:{shape:g}})}),c=u.map(m=>({vals:n.data.get(m.dataId).values,shape:m.shape}));o=H.computeOutShape(u.map(m=>m.shape),1);let d=u[0].shape[0]===1,h=B4(c,o,t[0].dtype,d),p=H.computeOutShape(l.map(m=>m.shape),a),f=n.makeTensorInfo(p,t[0].dtype,h);return u.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var aut={kernelName:jy,backendName:"cpu",kernelFunc:Zg};function Wre(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r;pt([s,a],"conv2d");let d=H.convertConv2DDataFormat(l),h=H.computeConv2DInfo(s.shape,a.shape,i,u,o,c,!1,d),p=h.filterHeight,f=h.filterWidth,m=h.dilationHeight,g=h.dilationWidth,y=h.padInfo.left,b=h.padInfo.top,x=h.dataFormat==="channelsLast",v=new Er(h.outShape,s.dtype),w=M.computeStrides(s.shape),k=M.computeStrides(a.shape),S=w[0],I=x?w[1]:w[2],$=x?w[2]:1,C=x?1:w[1],T=v.strides[0],N=x?v.strides[1]:v.strides[2],E=x?v.strides[2]:1,_=x?1:v.strides[1],R=n.data.get(s.dataId).values,z=n.data.get(a.dataId).values,W=v.values;for(let F=0;F<h.batchSize;++F){let L=F*S,O=F*T;for(let D=0;D<h.outHeight;++D){let B=O+D*N,V=D*h.strideHeight-b;for(let K=0;K<p;++K){let G=V+K*m;if(G<0||G>=h.inHeight)continue;let U=K*k[0],q=L+G*I;for(let Q=0;Q<h.outWidth;++Q){let ee=B+Q*E,ae=Q*h.strideWidth-y;for(let ye=0;ye<f;++ye){let j=ae+ye*g;if(j<0||j>=h.inWidth)continue;let ce=U+ye*k[1],be=q+j*$,ke=ce;for(let Ae=0;Ae<h.inChannels;++Ae){let Pe=R[be+Ae*C];for(let ie=0;ie<h.outChannels;++ie)W[ee+ie*_]+=Pe*z[ke+ie];ke+=h.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,W)}var iut={kernelName:zp,backendName:"cpu",kernelFunc:Wre};function out(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r;pt([s,a],"conv2dBackpropFilter");let d=H.convertConv2DDataFormat(l),h=H.computeConv2DInfo(s.shape,c,i,1,o,u,!1,d),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=h,y=h.dataFormat==="channelsLast",b=new Er(h.filterShape,"float32"),x=h.padInfo.left,v=h.padInfo.top,w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=new Er(s.shape,s.dtype,w),I=new Er(a.shape,a.dtype,k);for(let $=0;$<m;++$){let C=Math.max(0,Math.ceil((v-$)/p)),T=Math.min(h.outHeight,(h.inHeight+v-$)/p);for(let N=0;N<g;++N){let E=Math.max(0,Math.ceil((x-N)/f)),_=Math.min(h.outWidth,(h.inWidth+x-N)/f);for(let R=0;R<h.inChannels;++R)for(let z=0;z<h.outChannels;++z){let W=0;for(let F=0;F<h.batchSize;++F)for(let L=C;L<T;++L){let O=$+L*p-v;for(let D=E;D<_;++D){let B=N+D*f-x;y?W+=S.get(F,O,B,R)*I.get(F,L,D,z):W+=S.get(F,R,O,B)*I.get(F,z,L,D)}}b.set(W,$,N,R,z)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var lut={kernelName:HN,backendName:"cpu",kernelFunc:out};function uut(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r;pt([s,a],"conv2dBackpropInput");let d=M.computeStrides(a.shape),h=M.computeStrides(s.shape),p=H.convertConv2DDataFormat(u),f=H.computeConv2DInfo(i,a.shape,o,1,l,c,!1,p),m=new Er(f.inShape,"float32"),g=m.values,y=n.data.get(s.dataId).values,b=n.data.get(a.dataId).values,[x,v,w]=d,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:$,inHeight:C,inWidth:T,outChannels:N,outHeight:E,outWidth:_,strideHeight:R,strideWidth:z}=f;p=f.dataFormat;let W=S-1-f.padInfo.top,F=I-1-f.padInfo.left,L=p==="channelsLast",O=m.strides[0],D=L?m.strides[1]:m.strides[2],B=L?m.strides[2]:1,V=L?1:m.strides[1],K=h[0],G=L?h[1]:h[2],U=L?h[2]:1,q=L?1:h[1];for(let Q=0;Q<k;++Q)for(let ee=0;ee<$;++ee)for(let ae=0;ae<C;++ae){let ye=ae-W,j=Math.max(0,Math.ceil(ye/R)),ce=Math.min(E,(S+ye)/R);for(let be=0;be<T;++be){let ke=be-F,Ae=Math.max(0,Math.ceil(ke/z)),Pe=Math.min(_,(I+ke)/z),ie=0;for(let Le=j;Le<ce;++Le){let $e=Le*R-ye;for(let ge=Ae;ge<Pe;++ge){let ve=ge*z-ke,pe=K*Q+G*Le+U*ge,Ie=x*(S-1-$e)+v*(I-1-ve)+w*ee;for(let ze=0;ze<N;++ze){let Ye=y[pe+q*ze],Je=b[Ie+ze];ie+=Ye*Je}}}let Te=O*Q+D*ae+B*be+V*ee;g[Te]=ie}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}var cut={kernelName:Bp,backendName:"cpu",kernelFunc:uut};function dut(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;pt([s,a],"conv3d");let u=H.computeConv3DInfo(s.shape,a.shape,i,l,o),{filterDepth:c,filterHeight:d,filterWidth:h,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=u,y=g.front,b=g.left,x=g.top,v=new Er(u.outShape,s.dtype),w=n.data.get(s.dataId).values,k=n.data.get(a.dataId).values,S=v.values,I=M.computeStrides(s.shape),$=M.computeStrides(a.shape);for(let C=0;C<u.batchSize;++C){let T=C*I[0],N=C*v.strides[0];for(let E=0;E<u.outDepth;++E){let _=N+E*v.strides[1],R=E*u.strideDepth-y;for(let z=0;z<c;++z){let W=R+z*p;if(W<0||W>=u.inDepth)continue;let F=z*$[0],L=T+W*I[1];for(let O=0;O<u.outHeight;++O){let D=_+O*v.strides[2],B=O*u.strideHeight-x;for(let V=0;V<d;++V){let K=B+V*f;if(K<0||K>=u.inHeight)continue;let G=F+V*$[1],U=L+K*I[2];for(let q=0;q<u.outWidth;++q){let Q=D+q*u.outChannels,ee=q*u.strideWidth-b;for(let ae=0;ae<h;++ae){let ye=ee+ae*m;if(ye<0||ye>=u.inWidth)continue;let j=G+ae*$[2],ce=U+ye*u.inChannels,be=j;for(let ke=0;ke<u.inChannels;++ke){let Ae=w[ce+ke];for(let Pe=0;Pe<u.outChannels;++Pe)S[Q+Pe]+=Ae*k[be+Pe];be+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}var hut={kernelName:Wp,backendName:"cpu",kernelFunc:dut};function put(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;pt([s,a],"conv3dBackpropFilterV2");let u=M.computeStrides(s.shape),c=M.computeStrides(a.shape),d=H.computeConv3DInfo(s.shape,l,i,1,o),h=d.strideDepth,p=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,b=new Er(d.filterShape,"float32"),x=b.values,[v,w,k,S]=b.strides,I=n.data.get(a.dataId).values,[$,C,T,N]=c,E=n.data.get(s.dataId).values,[_,R,z,W]=u,F=d.padInfo.front,L=d.padInfo.left,O=d.padInfo.top;for(let D=0;D<m;++D){let B=Math.max(0,Math.ceil((F-D)/h)),V=Math.min(d.outDepth,(d.inDepth+F-D)/h),K=D*v;for(let G=0;G<g;++G){let U=Math.max(0,Math.ceil((O-G)/p)),q=Math.min(d.outHeight,(d.inHeight+O-G)/p),Q=G*w+K;for(let ee=0;ee<y;++ee){let ae=Math.max(0,Math.ceil((L-ee)/f)),ye=Math.min(d.outWidth,(d.inWidth+L-ee)/f),j=ee*k+Q;for(let ce=0;ce<d.inChannels;++ce){let be=ce*S+j;for(let ke=0;ke<d.outChannels;++ke){let Ae=0;for(let Pe=0;Pe<d.batchSize;++Pe){let ie=Pe*_,Te=Pe*$;for(let Le=B;Le<V;++Le){let $e=(D+Le*h-F)*R+ie,ge=Le*C+Te;for(let ve=U;ve<q;++ve){let pe=(G+ve*p-O)*z+$e,Ie=ve*T+ge;for(let ze=ae;ze<ye;++ze){let Ye=(ee+ze*f-L)*W+pe,Je=ze*N+Ie;Ae+=E[Ye+ce]*I[Je+ke]}}}}x[be+ke]=Ae}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}var fut={kernelName:Gy,backendName:"cpu",kernelFunc:put};function mut(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;pt([s],"conv3dBackpropInputV2");let u=M.computeStrides(s.shape),c=M.computeStrides(a.shape),d=H.computeConv3DInfo(l,a.shape,o,1,i),h=new Er(d.inShape,"float32"),p=h.values,[f,m,g,y]=h.strides,b=n.data.get(s.dataId).values,[x,v,w,k]=u,S=n.data.get(a.dataId).values,[I,$,C,T]=c,{batchSize:N,filterDepth:E,filterHeight:_,filterWidth:R,inChannels:z,inDepth:W,inHeight:F,inWidth:L,outChannels:O,outDepth:D,outHeight:B,outWidth:V,strideDepth:K,strideHeight:G,strideWidth:U}=d,q=E-1-d.padInfo.front,Q=_-1-d.padInfo.top,ee=R-1-d.padInfo.left;for(let ae=0;ae<N;++ae)for(let ye=0;ye<z;++ye)for(let j=0;j<W;++j){let ce=j-q,be=Math.max(0,Math.ceil(ce/K)),ke=Math.min(D,(E+ce)/K);for(let Ae=0;Ae<F;++Ae){let Pe=Ae-Q,ie=Math.max(0,Math.ceil(Pe/G)),Te=Math.min(B,(_+Pe)/G);for(let Le=0;Le<L;++Le){let $e=Le-ee,ge=Math.max(0,Math.ceil($e/U)),ve=Math.min(V,(R+$e)/U),pe=0;for(let Ie=be;Ie<ke;++Ie){let ze=Ie*K-ce;for(let Ye=ie;Ye<Te;++Ye){let Je=Ye*G-Pe;for(let Ke=ge;Ke<ve;++Ke){let Ue=Ke*U-$e,Xe=x*ae+v*Ie+w*Ye+k*Ke,ut=I*(E-1-ze)+$*(_-1-Je)+C*(R-1-Ue)+T*ye;for(let vt=0;vt<O;++vt){let An=b[Xe+vt],Rt=S[ut+vt];pe+=An*Rt}}}}p[f*ae+m*j+g*Ae+y*Le+ye]=pe}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}var gut={kernelName:Hy,backendName:"cpu",kernelFunc:mut},yut=vn(Vp,e=>Math.cos(e)),but={kernelName:Vp,backendName:"cpu",kernelFunc:yut},vut=vn(Up,e=>Math.cosh(e)),xut={kernelName:Up,backendName:"cpu",kernelFunc:vut};function wut(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,[c,d,h,p]=s.shape,f=a.shape[0],[m,g]=o,y=zt([f,m,g,p],"float32"),b=n.data.get(a.dataId).values,x=n.data.get(i.dataId).values,v=n.data.get(s.dataId).values,w=M.computeStrides(s.shape),k=M.computeStrides(y.shape);for(let S=0;S<f;S++){let I=S*4,$=b[I],C=b[I+1],T=b[I+2],N=b[I+3],E=x[S];if(E>=c)continue;let _=m>1?(T-$)*(d-1)/(m-1):0,R=g>1?(N-C)*(h-1)/(g-1):0;for(let z=0;z<m;z++){let W=m>1?$*(d-1)+z*_:.5*($+T)*(d-1);if(W<0||W>d-1){for(let F=0;F<g;F++)for(let L=0;L<p;L++){let O=L+F*k[2]+z*k[1]+S*k[0];y.values[O]=u}continue}if(l==="bilinear"){let F=Math.floor(W),L=Math.ceil(W),O=W-F;for(let D=0;D<g;D++){let B=g>1?C*(h-1)+D*R:.5*(C+N)*(h-1);if(B<0||B>h-1){for(let U=0;U<p;U++){let q=U+D*k[2]+z*k[1]+S*k[0];y.values[q]=u}continue}let V=Math.floor(B),K=Math.ceil(B),G=B-V;for(let U=0;U<p;U++){let q=U+V*w[2]+F*w[1]+E*w[0],Q=v[q];q=U+K*w[2]+F*w[1]+E*w[0];let ee=v[q];q=U+V*w[2]+L*w[1]+E*w[0];let ae=v[q];q=U+K*w[2]+L*w[1]+E*w[0];let ye=v[q],j=Q+(ee-Q)*G,ce=ae+(ye-ae)*G;q=U+D*k[2]+z*k[1]+S*k[0],y.values[q]=j+(ce-j)*O}}}else for(let F=0;F<g;++F){let L=g>1?C*(h-1)+F*R:.5*(C+N)*(h-1);if(L<0||L>h-1){for(let B=0;B<p;B++){let V=B+F*k[2]+z*k[1]+S*k[0];y.values[V]=u}continue}let O=Math.round(L),D=Math.round(W);for(let B=0;B<p;B++){let V=B+O*w[2]+D*w[1]+E*w[0],K=B+F*k[2]+z*k[1]+S*k[0];y.values[K]=v[V]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}var kut={kernelName:Ky,backendName:"cpu",kernelFunc:wut};function Sut(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;pt(s,"cumprod");let l=H.getAxesPermutation([a],s.shape.length),u=s;l!=null&&(u=Sa({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=H.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=ki(u.dtype,"int32"),h=M.makeOnesTypedArray(M.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)h[x]=i?1:p[x];else{let v=m(y,b-1);h[x]=i?p[v]*h[v]:p[x]*h[v]}}let g=n.makeTensorInfo(u.shape,d,h);if(l!=null){let y=H.getUndoAxesPermutation(l),b=Sa({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}var Iut={kernelName:qy,backendName:"cpu",kernelFunc:Sut};function Cut(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;pt(s,"cumsum");let l=H.getAxesPermutation([a],s.shape.length),u=s;l!=null&&(u=Sa({inputs:{x:s},backend:n,attrs:{perm:l}}));let c=H.getInnerMostAxes(1,s.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);let d=ki(u.dtype,"int32"),h=M.makeZerosTypedArray(M.sizeFromShape(u.shape),d),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],m=o?(y,b)=>y+f-b-1:(y,b)=>y+b;for(let y=0;y<p.length;y+=f)for(let b=0;b<f;b++){let x=m(y,b);if(b===0)h[x]=i?0:p[x];else{let v=m(y,b-1);h[x]=i?p[v]+h[v]:p[x]+h[v]}}let g=n.makeTensorInfo(u.shape,d,h);if(l!=null){let y=H.getUndoAxesPermutation(l),b=Sa({inputs:{x:g},backend:n,attrs:{perm:y}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(u),b}return g}var Nut={kernelName:jp,backendName:"cpu",kernelFunc:Cut};function Tut(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=z4(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(a),c=Xne(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var $ut={kernelName:Yx,backendName:"cpu",kernelFunc:Tut};function Eut(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r;M.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let o=s.shape[0],l=s.shape[1],u=s.shape[2],c=s.shape[3],d=l*a,h=u*a,p=c/(a*a),f=n.data.get(s.dataId).values,m=new Float32Array(o*d*h*p),g=0;for(let y=0;y<o;++y)for(let b=0;b<d;++b){let x=Math.floor(b/a),v=b%a;for(let w=0;w<h;++w){let k=Math.floor(w/a),S=w%a,I=(v*a+S)*p;for(let $=0;$<p;++$){let C=$+I+c*(k+u*(x+l*y));m[g++]=f[C]}}}return n.makeTensorInfo([o,d,h,p],s.dtype,m)}var _ut={kernelName:Xy,backendName:"cpu",kernelFunc:Eut};function Vre(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r;pt([s,a],"depthwiseConv2DNative");let c=M.computeStrides(s.shape),d=M.computeStrides(a.shape),h=l;h==null&&(h=[1,1]),M.assert(H.eitherStridesOrDilationsAreOne(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);let p=H.computeConv2DInfo(s.shape,a.shape,i,h,o,u,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,x=b.left,v=b.top,w=p.outChannels/p.inChannels,k=new Er(p.outShape,s.dtype),S=n.data.get(s.dataId).values,I=n.data.get(a.dataId).values,$=k.values;for(let C=0;C<p.batchSize;++C){let T=C*c[0],N=C*k.strides[0];for(let E=0;E<p.outHeight;++E){let _=N+E*k.strides[1],R=E*p.strideHeight-v;for(let z=0;z<f;++z){let W=R+z*g;if(W<0||W>=p.inHeight)continue;let F=z*d[0],L=T+W*c[1];for(let O=0;O<p.outWidth;++O){let D=_+O*k.strides[2],B=O*p.strideWidth-x;for(let V=0;V<m;++V){let K=B+V*y;if(K<0||K>=p.inWidth)continue;let G=F+V*d[1],U=L+K*p.inChannels,q=D,Q=G;for(let ee=0;ee<p.inChannels;++ee){let ae=S[U+ee];for(let ye=0;ye<w;++ye)$[q+ye]+=ae*I[Q+ye];q+=w,Q+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}var Aut={kernelName:Gp,backendName:"cpu",kernelFunc:Vre};function Rut(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r;pt([s,a],"depthwiseConv2dNativeBackpropFilter");let d=H.computeConv2DInfo(s.shape,c,i,o,l,u,!0),{strideHeight:h,strideWidth:p,filterHeight:f,filterWidth:m}=d,g=new Er(d.filterShape,"float32"),y=d.padInfo.left,b=d.padInfo.top,x=d.outChannels/d.inChannels,v=n.data.get(s.dataId).values,w=new Er(s.shape,s.dtype,v),k=n.data.get(a.dataId).values,S=new Er(a.shape,a.dtype,k);for(let I=0;I<f;++I){let $=Math.max(0,Math.ceil((b-I)/h)),C=Math.min(d.outHeight,(d.inHeight+b-I)/h);for(let T=0;T<m;++T){let N=Math.max(0,Math.ceil((y-T)/p)),E=Math.min(d.outWidth,(d.inWidth+y-T)/p);for(let _=0;_<d.outChannels;++_){let R=Math.trunc(_/x),z=_%x,W=0;for(let F=0;F<d.batchSize;++F)for(let L=$;L<C;++L){let O=I+L*h-b;for(let D=N;D<E;++D){let B=T+D*p-y;W+=w.get(F,O,B,R)*S.get(F,L,D,_)}}g.set(W,I,T,R,z)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}var Dut={kernelName:qN,backendName:"cpu",kernelFunc:Rut};function Out(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r;pt([s,a],"depthwiseConv2DNativeBackpropInput");let d=M.computeStrides(s.shape),h=M.computeStrides(a.shape),p=H.computeConv2DInfo(c,a.shape,i,o,l,u,!0),f=new Er(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,x=n.data.get(s.dataId).values,[v,w,k]=d,S=n.data.get(a.dataId).values,[I,$,C]=h,{batchSize:T,filterHeight:N,filterWidth:E,inChannels:_,inHeight:R,inWidth:z,outChannels:W,outHeight:F,outWidth:L,strideHeight:O,strideWidth:D}=p,B=N-1-p.padInfo.top,V=E-1-p.padInfo.left,K=W/_;for(let G=0;G<T;++G)for(let U=0;U<_;++U)for(let q=0;q<R;++q){let Q=q-B,ee=Math.max(0,Math.ceil(Q/O)),ae=Math.min(F,(N+Q)/O);for(let ye=0;ye<z;++ye){let j=ye-V,ce=Math.max(0,Math.ceil(j/D)),be=Math.min(L,(E+j)/D),ke=0;for(let Ae=ee;Ae<ae;++Ae){let Pe=Ae*O-Q;for(let ie=ce;ie<be;++ie){let Te=ie*D-j,Le=v*G+w*Ae+k*ie,$e=I*(N-1-Pe)+$*(E-1-Te)+C*U;for(let ge=0;ge<K;++ge){let ve=U*K+ge,pe=x[Le+ve],Ie=S[$e+ge];ke+=pe*Ie}}}m[g*G+y*q+b*ye+U]=ke}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}var Fut={kernelName:KN,backendName:"cpu",kernelFunc:Out};function Mut(e){let{inputs:t,backend:n}=e,{x:r}=t,s=M.sizeFromShape(r.shape),a=n.data.get(r.dataId).values,i=zt([s,s],r.dtype),o=i.values;for(let u=0;u<a.length;u++)o[u*s+u]=a[u];let l=[...r.shape,...r.shape];return n.makeTensorInfo(l,i.dtype,i.values)}var Put={kernelName:Jx,backendName:"cpu",kernelFunc:Mut},Lut={kernelName:Hp,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s}=e,{strides:a,pad:i,dilations:o}=n,l=t,u=l.data.get(r.dataId).values,c=r.shape.length,d=l.data.get(s.dataId).values,h=s.shape.length,{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:$,outShape:C}=H.computeDilation2DInfo(r.shape,s.shape,a,i,"NHWC",o),T=M.sizeFromShape(C),N=C.length,E=M.getArrayFromDType(r.dtype,T);for(let _=0;_<p;++_)for(let R=0;R<y;++R){let z=R*v-x.top;for(let W=0;W<b;++W){let F=W*w-x.left;for(let L=0;L<g;++L){let O=Number.MIN_SAFE_INTEGER;for(let B=0;B<k;++B){let V=z+B*I;if(V>=0&&V<f)for(let K=0;K<S;++K){let G=F+K*$;if(G>=0&&G<m){let U=M.locToIndex([_,V,G,L],c,M.computeStrides(r.shape)),q=M.locToIndex([B,K,L],h,M.computeStrides(s.shape)),Q=u[U]+d[q];Q>O&&(O=Q)}}}let D=M.locToIndex([_,R,W,L],N,M.computeStrides(C));E[D]=O}}}return{dataId:l.write(M.toTypedArray(E,r.dtype),C,r.dtype),shape:C,dtype:r.dtype}}},zut={kernelName:Lg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=M.toNestedArray(r.shape,u.data.get(r.dataId).values),d=M.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:$}=H.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l);M.assert(a.rank===$.length,()=>`Error in ${Lg}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);let C=M.toNestedArray($,u.data.get(a.dataId).values),T=M.makeZerosNestedTypedArray(s.shape,s.dtype);for(let N=0;N<h;++N)for(let E=0;E<g;++E){let _=E*x-b.top;for(let R=0;R<y;++R){let z=R*v-b.left;for(let W=0;W<m;++W){let F=Number.MIN_SAFE_INTEGER,L=0,O=0;for(let D=0;D<w;++D){let B=_+D*S;if(B>=0&&B<p)for(let V=0;V<k;++V){let K=z+V*I;if(K>=0&&K<f){let G=c[N][B][K][W]+d[D][V][W];G>F&&(F=G,L=D,O=V)}}}T[L][O][W]+=C[N][E][R][W]}}}return{dataId:u.write(M.toTypedArray(T,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},But={kernelName:Pg,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{let{x:r,filter:s,dy:a}=e,{strides:i,pad:o,dilations:l}=n,u=t,c=M.toNestedArray(r.shape,u.data.get(r.dataId).values),d=M.toNestedArray(s.shape,u.data.get(s.dataId).values),{batchSize:h,inHeight:p,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:k,dilationHeight:S,dilationWidth:I,outShape:$}=H.computeDilation2DInfo(r.shape,s.shape,i,o,"NHWC",l);M.assert(a.rank===$.length,()=>`Error in ${Pg}, dy must have the same rank as output ${$.length}, but got ${a.rank}`);let C=M.toNestedArray($,u.data.get(a.dataId).values),T=M.makeZerosNestedTypedArray(r.shape,r.dtype);for(let N=0;N<h;++N)for(let E=0;E<g;++E){let _=E*x-b.top;for(let R=0;R<y;++R){let z=R*v-b.left;for(let W=0;W<m;++W){let F=Number.MIN_SAFE_INTEGER,L=_<0?0:_,O=z<0?0:z;for(let D=0;D<w;++D){let B=_+D*S;if(B>=0&&B<p)for(let V=0;V<k;++V){let K=z+V*I;if(K>=0&&K<f){let G=c[N][B][K][W]+d[D][V][W];G>F&&(F=G,L=B,O=K)}}}T[N][L][O][W]+=C[N][E][R][W]}}}return{dataId:u.write(M.toTypedArray(T,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Wut(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{canvas:a,options:i}=r,{contextOptions:o,imageOptions:l}=i||{},u=(l==null?void 0:l.alpha)||1,c=(o==null?void 0:o.contextType)||"2d";if(c!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);let d=a.getContext(c,(o==null?void 0:o.contextAttributes)||{});if(d==null)throw new Error(`Could not get the context with ${c} type.`);let[h,p]=s.shape.slice(0,2),f=s.shape.length===2?1:s.shape[2],m=n.data.get(s.dataId).values,g=s.dtype==="float32"?255:1,y=new Uint8ClampedArray(p*h*4);for(let x=0;x<h*p;++x){let v=[0,0,0,255*u];for(let k=0;k<f;k++){let S=m[x*f+k];if(s.dtype==="float32"){if(S<0||S>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${S}.`)}else if(s.dtype==="int32"&&(S<0||S>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${S}.`);f===1?(v[0]=S*g,v[1]=S*g,v[2]=S*g):v[k]=S*g}let w=x*4;y[w+0]=Math.round(v[0]),y[w+1]=Math.round(v[1]),y[w+2]=Math.round(v[2]),y[w+3]=Math.round(v[3])}a.width=p,a.height=h;let b=new ImageData(y,p,h);return d.putImageData(b,0,0),s}var Vut={kernelName:XN,backendName:"cpu",kernelFunc:Wut};function Ww(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;pt(s,"sum");let o;s.dtype==="bool"?o=Kc({inputs:{x:s},backend:n,attrs:{dtype:"int32"}}):o=Ll({inputs:{x:s},backend:n});let l=o.shape.length,u=M.parseAxisParam(a,o.shape),c=H.getAxesPermutation(u,l),d=u,h=o;c!=null&&(h=Sa({inputs:{x:o},backend:n,attrs:{perm:c}}),d=H.getInnerMostAxes(d.length,l)),H.assertAxesAreInnerMostDims("sum",d,h.shape.length);let[p,f]=H.computeOutAndReduceShapes(h.shape,d),m=H.upcastType(h.dtype,"int32"),g=pI(n,p,m),y=M.sizeFromShape(f),b=n.data.get(g.dataId).values,x=n.data.get(h.dataId).values;for(let v=0;v<b.length;++v){let w=v*y,k=0;for(let S=0;S<y;++S)k+=x[w+S];b[v]=k}if(i){let v=H.expandShapeToKeepDim(g.shape,u),w=g;g=Pn({inputs:{x:g},backend:n,attrs:{shape:v}}),n.disposeIntermediateTensorInfo(w)}return n.disposeIntermediateTensorInfo(o),c!=null&&n.disposeIntermediateTensorInfo(h),g}var Uut={kernelName:Wf,backendName:"cpu",kernelFunc:Ww};function jut(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=H.decodeEinsumEquation(s,a.length);H.checkEinsumDimSizes(i.length,l,a);let{path:u,steps:c}=H.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let g of c[m]){let{permutationIndices:y,expandDims:b}=H.getEinsumPermutation(p,l[g]),x;H.isIdentityPermutation(y)?x=a[g]:(x=Sa({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));let v=x.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);M.arraysEqual(x.shape,v)||(x=Pn({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),h===null?h=x:(h=l$({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=Ww({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var Gut={kernelName:YN,backendName:"cpu",kernelFunc:jut};function Hut(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t;pt([r,s],"eluGrad");let a=new Float32Array(M.sizeFromShape(s.shape)),i=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values;for(let l=0;l<i.length;++l){let u=i[l];u>=0?a[l]=o[l]:a[l]=o[l]*(u+1)}return n.makeTensorInfo(s.shape,"float32",a)}var qut={kernelName:Yy,backendName:"cpu",kernelFunc:Hut},Kut=H.ERF_P,Xut=H.ERF_A1,Yut=H.ERF_A2,Jut=H.ERF_A3,Zut=H.ERF_A4,Qut=H.ERF_A5,ect=vn(Xp,e=>{let t=Math.sign(e),n=Math.abs(e),r=1/(1+Kut*n);return t*(1-((((Qut*r+Zut)*r+Jut)*r+Yut)*r+Xut)*r*Math.exp(-n*n))}),tct={kernelName:Xp,backendName:"cpu",kernelFunc:ect};function gI(e){let{inputs:t,backend:n,attrs:r}=e,{input:s}=t,{dim:a}=r,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(M.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),Pn({inputs:{x:s},backend:n,attrs:{shape:o}})}var nct={kernelName:Zy,backendName:"cpu",kernelFunc:gI},rct=Sr((e,t)=>e/t),J4=Jr(qp,rct),WR={kernelName:qp,backendName:"cpu",kernelFunc:J4};function Ure(e,t,n){let r=e.shape,s=r[0],a=r[1],i=n.data.get(e.dataId),o=i.complexTensorInfos.real,l=i.complexTensorInfos.imag,u=[s,a],c=M.sizeFromShape(u),d=M.getTypedArrayFromDType("float32",c),h=M.getTypedArrayFromDType("float32",c);for(let g=0;g<s;g++){let y=sp({inputs:{x:o},backend:n,attrs:{begin:[g,0],size:[1,a]}}),b=sp({inputs:{x:l},backend:n,attrs:{begin:[g,0],size:[1,a]}}),x=za({inputs:{real:y,imag:b},backend:n}),{real:v,imag:w}=sct(x,t,n),k=H.mergeRealAndImagArrays(v,w);for(let S=0;S<a;S++){let I=H.getComplexWithIndex(k,S);d[g*a+S]=I.real,h[g*a+S]=I.imag}n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x)}let p=n.makeTensorInfo(u,"float32",d),f=n.makeTensorInfo(u,"float32",h),m=za({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function sct(e,t,n){let r=M.sizeFromShape(e.shape),s=n.data.get(e.dataId),a=n.data.get(s.complexTensorInfos.real.dataId).values,i=n.data.get(s.complexTensorInfos.imag.dataId).values;if(act(r)){let o=VR(a,i,r,t,n),l=[e.shape[0],e.shape[1]];if(t){let u=n.makeTensorInfo(l,"float32",o.real),c=n.makeTensorInfo(l,"float32",o.imag),d=n.makeTensorInfo([],"float32",M.createScalarValue(r,"float32")),h=Ll({inputs:{x:d},backend:n}),p=WR.kernelFunc({inputs:{a:u,b:d},backend:n}),f=WR.kernelFunc({inputs:{a:c,b:h},backend:n}),m=n.data.get(p.dataId).values,g=n.data.get(f.dataId).values;return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return o}else{let o=H.mergeRealAndImagArrays(a,i),l=ict(o,r,t);return H.splitRealAndImagArrays(l)}}function act(e){return(e&e-1)===0}function VR(e,t,n,r,s){if(n===1)return{real:e,imag:t};let a=H.mergeRealAndImagArrays(e,t),i=n/2,o=H.complexWithEvenIndex(a),l=o.real,u=o.imag,c=[l.length],d=s.makeTensorInfo(c,"float32",l),h=s.makeTensorInfo(c,"float32",u),p=za({inputs:{real:d,imag:h},backend:s}),f=H.complexWithOddIndex(a),m=f.real,g=f.imag,y=[m.length],b=s.makeTensorInfo(y,"float32",m),x=s.makeTensorInfo(y,"float32",g),v=za({inputs:{real:b,imag:x},backend:s}),w=VR(l,u,i,r,s),k=w.real,S=w.imag,I=[k.length],$=s.makeTensorInfo(I,"float32",k),C=s.makeTensorInfo(I,"float32",S),T=za({inputs:{real:$,imag:C},backend:s}),N=VR(m,g,i,r,s),E=N.real,_=N.imag,R=[E.length],z=s.makeTensorInfo(R,"float32",E),W=s.makeTensorInfo(R,"float32",_),F=za({inputs:{real:z,imag:W},backend:s}),L=H.exponents(n,r),O=[L.real.length],D=s.makeTensorInfo(O,"float32",L.real),B=s.makeTensorInfo(O,"float32",L.imag),V=za({inputs:{real:D,imag:B},backend:s}),K=l$({inputs:{a:V,b:F},backend:s}),G=Yg({inputs:{a:T,b:K},backend:s}),U=K4({inputs:{a:T,b:K},backend:s}),q=rp({inputs:{input:G},backend:s}),Q=rp({inputs:{input:U},backend:s}),ee=Jg({inputs:{input:G},backend:s}),ae=Jg({inputs:{input:U},backend:s}),ye=Zg({inputs:[q,Q],backend:s,attrs:{axis:0}}),j=Zg({inputs:[ee,ae],backend:s,attrs:{axis:0}}),ce=s.data.get(ye.dataId).values,be=s.data.get(j.dataId).values;return s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(h),s.disposeIntermediateTensorInfo(p),s.disposeIntermediateTensorInfo(b),s.disposeIntermediateTensorInfo(x),s.disposeIntermediateTensorInfo(v),s.disposeIntermediateTensorInfo($),s.disposeIntermediateTensorInfo(C),s.disposeIntermediateTensorInfo(T),s.disposeIntermediateTensorInfo(z),s.disposeIntermediateTensorInfo(W),s.disposeIntermediateTensorInfo(F),s.disposeIntermediateTensorInfo(D),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(V),s.disposeIntermediateTensorInfo(K),s.disposeIntermediateTensorInfo(G),s.disposeIntermediateTensorInfo(U),s.disposeIntermediateTensorInfo(q),s.disposeIntermediateTensorInfo(ee),s.disposeIntermediateTensorInfo(Q),s.disposeIntermediateTensorInfo(ae),s.disposeIntermediateTensorInfo(ye),s.disposeIntermediateTensorInfo(j),{real:ce,imag:be}}function ict(e,t,n){let r=new Float32Array(t*2);for(let s=0;s<t;s++){let a=0,i=0;for(let o=0;o<t;o++){let l=H.exponent(s*o,t,n),u=H.getComplexWithIndex(e,o);a+=u.real*l.real-u.imag*l.imag,i+=u.real*l.imag+u.imag*l.real}n&&(a/=t,i/=t),H.assignToTypedArray(r,a,i,s)}return r}function oct(e){let{inputs:t,backend:n}=e,{input:r}=t,s=M.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Pn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=Ure(o,!1,n),u=Pn({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var lct={kernelName:JN,backendName:"cpu",kernelFunc:oct};function Z4(e){let{backend:t,attrs:n}=e,{shape:r,value:s,dtype:a}=n,i=a||M.inferDtype(s),o=M.getArrayFromDType(i,M.sizeFromShape(r));return cct(o,s),t.makeTensorInfo(r,i,o)}var uct={kernelName:Zx,backendName:"cpu",kernelFunc:Z4};function cct(e,t,n){e.fill(t)}var dct={kernelName:Qy,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,s=n,a=M.getTypedArrayFromDType(r.dtype,M.sizeFromShape(r.shape)),[i,o,l,u]=r.shape,c=s.data.get(r.dataId).values;for(let d=0;d<i;d++){let h=d*l*o*u;for(let p=0;p<o;p++){let f=p*(l*u);for(let m=0;m<l;m++){let g=m*u;for(let y=0;y<u;y++){let b=Math.round(l-m-1),x=h+f+g+y,v=c[x];if(b>=0&&b<l){let w=b*u,k=h+f+w+y;v=c[k]}a[x]=v}}}}return{dataId:s.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function hct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=Wre({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let g=m;if(c==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){let y=Pn({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=Yg({inputs:{a:m,b:y},backend:n}),n.disposeIntermediateTensorInfo(y)}else m=Yg({inputs:{a:m,b:i},backend:n});n.disposeIntermediateTensorInfo(g)}if(p){let g=m;if(c==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){let y=Pn({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=mI(n,m,p,y,f),n.disposeIntermediateTensorInfo(y)}else m=mI(n,m,p,o,f);n.disposeIntermediateTensorInfo(g)}return m}var pct={kernelName:jh,backendName:"cpu",kernelFunc:hct};function fct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=Vre({inputs:{x:s,filter:a},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h}});if(i){let g=m;m=Yg({inputs:{a:m,b:i},backend:n}),n.disposeIntermediateTensorInfo(g)}if(p){let g=m;m=mI(n,m,p,o,f),n.disposeIntermediateTensorInfo(g)}return m}var mct={kernelName:Gh,backendName:"cpu",kernelFunc:fct};function gct(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=M.sizeFromShape(r.shape),i=s.shape,o=i[i.length-1],[l,u,c,d]=H.prepareAndValidate(r,s);if(u===0)return n.makeTensorInfo(l,r.dtype,[]);let h=n.data.get(s.dataId).values,p=n.bufferSync(r),f=are(h,p,r.dtype,u,o,c,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,f.values)}var yct={kernelName:tb,backendName:"cpu",kernelFunc:gct};function bct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r;pt([s,a],"gatherV2");let l=M.parseAxisParam(i,s.shape)[0],u=n.data.get(a.dataId).values,c=s.shape[l];for(let v=0;v<u.length;++v){let w=u[v];M.assert(w<=c-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${c-1}]`)}let d=o;o==null&&(d=0);let h=M.sizeFromShape(a.shape),p=H.segment_util.collectGatherOpShapeInfo(s,a,l,d),f=Pn({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Pn({inputs:{x:a},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}}),g=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=n.bufferSync(f),x=ire(b,y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}var vct={kernelName:eb,backendName:"cpu",kernelFunc:bct};function xct(e){let{inputs:t,backend:n}=e,{input:r}=t,s=M.sizeFromShape(r.shape),a=r.shape[r.shape.length-1],i=s/a,o=Pn({inputs:{x:r},backend:n,attrs:{shape:[i,a]}}),l=Ure(o,!0,n),u=Pn({inputs:{x:l},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),u}var wct={kernelName:ZN,backendName:"cpu",kernelFunc:xct},kct=vn(sf,e=>Number.isFinite(e)?1:0,"bool"),Sct={kernelName:sf,backendName:"cpu",kernelFunc:kct},Ict=vn(af,e=>Math.abs(e)===1/0?1:0,"bool"),Cct={kernelName:af,backendName:"cpu",kernelFunc:Ict},Nct=vn(of,e=>Number.isNaN(e)?1:0,"bool"),Tct={kernelName:of,backendName:"cpu",kernelFunc:Nct};function $ct(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=dre(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var Ect={kernelName:ab,backendName:"cpu",kernelFunc:$ct},_ct=vn(cf,e=>Math.log1p(e)),Act={kernelName:cf,backendName:"cpu",kernelFunc:_ct},Rct=Sr((e,t)=>e&&t),Dct=Jr(ib,Rct,null,"bool"),Oct={kernelName:ib,backendName:"cpu",kernelFunc:Dct},Fct=vn(ob,e=>e?0:1,"bool"),Mct={kernelName:ob,backendName:"cpu",kernelFunc:Fct},Pct=Sr((e,t)=>e||t),Lct=Jr(lb,Pct,null,"bool"),zct={kernelName:lb,backendName:"cpu",kernelFunc:Lct};function Bct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;pt(s,"LRN");let u=s.shape[3],c=u-1,d=n.data.get(s.dataId).values,h=M.sizeFromShape(s.shape),p=new Float32Array(h);function f(m){let g=m%u,y=m-g+Math.max(0,g-a),b=m-g+Math.min(g+a,c),x=0;for(;y<=b;y++){let v=d[y];x+=v*v}return x}for(let m=0;m<h;m++){let g=f(m),y=d[m]*Math.pow(i+o*g,-l);p[m]=y}return n.makeTensorInfo(s.shape,s.dtype,p)}var Wct={kernelName:df,backendName:"cpu",kernelFunc:Bct};function Vct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;pt(i,"LRNGrad");let d=M.sizeFromShape(i.shape),h=i.shape[3],p=n.data.get(i.dataId).values,f=n.data.get(s.dataId).values,m=n.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let b=0;b<y;b++){let x=b%h,v=b-x+Math.max(0,x-o),w=b-x+Math.min(h,x+o+1),k=0;for(let S=v;S<w;S++)k+=Math.pow(f[S],2);k=u*k+l;for(let S=v;S<w;S++){let I=-2*u*c*f[S]*m[b]/k;b===S&&(I+=Math.pow(k,-c)),I*=p[b],g[S]+=I}}return n.makeTensorInfo(i.shape,s.dtype,g)}var Uct={kernelName:ub,backendName:"cpu",kernelFunc:Vct};function jre(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=n,l=s.shape,u=l.length,c=M.parseAxisParam(a,l),d=c,h=H.getAxesPermutation(d,u),p=o.data.get(s.dataId).values;if(h!=null){let v=new Array(u);for(let w=0;w<v.length;w++)v[w]=l[h[w]];p=V4(p,l,s.dtype,h,v),d=H.getInnerMostAxes(d.length,u),l=v}pt(s,"max"),H.assertAxesAreInnerMostDims("max",d,u);let[f,m]=H.computeOutAndReduceShapes(l,d),g=M.sizeFromShape(m),y=pre(p,g,f,s.dtype),b=o.write(y,f,s.dtype),x=f;return i&&(x=H.expandShapeToKeepDim(f,c)),{dataId:b,shape:x,dtype:s.dtype}}var jct={kernelName:hf,backendName:"cpu",kernelFunc:jre};function Gct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;pt(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;M.assert(H.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=H.computePool2DInfo(s.shape,a,i,u,o,l),d;if(c.filterWidth===1&&c.filterHeight===1&&M.arraysEqual(c.inShape,c.outShape))d=Ll({inputs:{x:s},backend:n});else{let h=n.data.get(s.dataId).values,p=M.computeStrides(s.shape),f=Y4(h,s.shape,s.dtype,p,c,"max");d=n.makeTensorInfo(c.outShape,s.dtype,f.values)}return d}var Hct={kernelName:ff,backendName:"cpu",kernelFunc:Gct};function qct(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r;pt(s,"maxPool3d");let c=H.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.data.get(s.dataId).values,h=Bre(d,s.shape,s.dtype,M.computeStrides(s.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}var Kct={kernelName:cb,backendName:"cpu",kernelFunc:qct};function Xct(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r;pt([s,a],"maxPool3DGrad");let c=H.computePool3DInfo(a.shape,i,o,1,l,u),d=n.bufferSync(a),h=Plt(d,c),p=c.strideDepth,f=c.strideHeight,m=c.strideWidth,g=c.dilationDepth,y=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,v=c.effectiveFilterHeight,w=c.effectiveFilterWidth,k=x-1-c.padInfo.front,S=w-1-c.padInfo.left,I=v-1-c.padInfo.top,$=zt(a.shape,"float32"),C=n.bufferSync(s);for(let T=0;T<c.batchSize;++T)for(let N=0;N<c.inChannels;++N)for(let E=0;E<c.inDepth;++E)for(let _=0;_<c.inHeight;++_)for(let R=0;R<c.inWidth;++R){let z=E-k,W=_-I,F=R-S,L=0;for(let O=0;O<x;O+=g){let D=(z+O)/p;if(!(D<0||D>=c.outDepth||Math.floor(D)!==D))for(let B=0;B<v;B+=y){let V=(W+B)/f;if(!(V<0||V>=c.outHeight||Math.floor(V)!==V))for(let K=0;K<w;K+=b){let G=(F+K)/m;if(G<0||G>=c.outWidth||Math.floor(G)!==G)continue;let U=x*v*w-1-h.get(T,D,V,G,N),q=O*v*w+B*w+K,Q=U===q?1:0;if(Q===0)continue;let ee=C.get(T,D,V,G,N);L+=ee*Q}}}$.set(L,T,E,_,R,N)}return n.makeTensorInfo($.shape,$.dtype,$.values)}var Yct={kernelName:ew,backendName:"cpu",kernelFunc:Xct};function Jct(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;pt([a,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=H.computePool2DInfo(o.shape,l,u,1,c,d),p=n.data.get(o.dataId).values,f=zt(h.outShape,o.dtype,zre(p,o.shape,o.dtype,h).values),m=h.strideHeight,g=h.strideWidth,y=h.dilationHeight,b=h.dilationWidth,x=h.effectiveFilterHeight,v=h.effectiveFilterWidth,w=v-1-h.padInfo.left,k=x-1-h.padInfo.top,S=zt(o.shape,"float32"),I=n.data.get(s.dataId).values,$=zt(s.shape,"float32",I);for(let C=0;C<h.batchSize;++C)for(let T=0;T<h.inChannels;++T)for(let N=0;N<h.inHeight;++N)for(let E=0;E<h.inWidth;++E){let _=N-k,R=E-w,z=0;for(let W=0;W<x;W+=y){let F=(_+W)/m;if(!(F<0||F>=h.outHeight||Math.floor(F)!==F))for(let L=0;L<v;L+=b){let O=(R+L)/g;if(O<0||O>=h.outWidth||Math.floor(O)!==O)continue;let D=x*v-1-f.get(C,F,O,T),B=W*v+L,V=D===B?1:0;if(V===0)continue;let K=$.get(C,F,O,T);z+=K*V}}S.set(z,C,N,E,T)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}var Zct={kernelName:Qx,backendName:"cpu",kernelFunc:Jct};function Qct(e,t,n,r,s){let a=M.computeStrides(t),i=Y4(e,t,n,a,s,"max"),o=zre(e,t,n,s,!0,r);return[i.values,o.values]}var edt={kernelName:tw,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;pt(r,"MaxPoolWithArgmax");let u=l.data.get(r.dataId).values,c=H.computePool2DInfo(r.shape,s,a,[1,1],i),[d,h]=Qct(u,r.shape,r.dtype,o,c),p=l.write(d,c.outShape,r.dtype),f=l.write(h,c.outShape,r.dtype);return[{dataId:p,shape:c.outShape,dtype:r.dtype},{dataId:f,shape:c.outShape,dtype:"int32"}]}};function tdt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=M.parseAxisParam(a,s.shape),l=H.computeOutAndReduceShapes(s.shape,o)[1],u=M.sizeFromShape(l),c=[],d=n.makeTensorInfo([],"float32",new Float32Array([u]));c.push(d);let h=Kc({inputs:{x:s},backend:n,attrs:{dtype:"float32"}});c.push(h);let p=J4({inputs:{a:h,b:d},backend:n});c.push(p);let f=Ww({inputs:{x:p},backend:n,attrs:{axis:a,keepDims:i}});return c.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var ndt={kernelName:mf,backendName:"cpu",kernelFunc:tdt};function rdt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;pt(s,"min");let o=M.parseAxisParam(a,s.shape),l=o,u=H.getAxesPermutation(l,s.shape.length),c=s;u!=null&&(c=Sa({inputs:{x:s},backend:n,attrs:{perm:u}}),l=H.getInnerMostAxes(l.length,s.shape.length)),H.assertAxesAreInnerMostDims("min",l,c.shape.length);let[d,h]=H.computeOutAndReduceShapes(c.shape,l),p=M.sizeFromShape(h),f=M.makeZerosTypedArray(M.sizeFromShape(d),c.dtype),m=n.data.get(c.dataId).values;for(let y=0;y<f.length;++y){let b=y*p,x=m[b];for(let v=0;v<p;++v){let w=m[b+v];(Number.isNaN(w)||w<x)&&(x=w)}f[y]=x}u!=null&&n.disposeIntermediateTensorInfo(c);let g=n.makeTensorInfo(d,c.dtype,f);if(i){let y=H.expandShapeToKeepDim(d,o),b=Pn({inputs:{x:g},backend:n,attrs:{shape:y}});return n.disposeIntermediateTensorInfo(g),b}return g}var sdt={kernelName:gf,backendName:"cpu",kernelFunc:rdt};function adt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,mode:i}=r;pt(s,"mirrorPad");let o=a.map((b,x)=>b[0]+s.shape[x]+b[1]),l=a.map(b=>b[0]),u=a.map((b,x)=>b[0]+s.shape[x]),c=i==="reflect"?0:1,d=n.data.get(s.dataId).values,h=s.shape.length,p=M.computeStrides(s.shape),f=M.sizeFromShape(o),m=o.length,g=M.computeStrides(o),y=M.getTypedArrayFromDType(s.dtype,f);for(let b=0;b<f;b++){let x=M.indexToLoc(b,m,g);for(let w=0;w<m;w++)x[w]<l[w]?x[w]=l[w]*2-x[w]-c:x[w]>=u[w]&&(x[w]=(u[w]-1)*2-x[w]+c);x=x.map((w,k)=>w-l[k]);let v=M.locToIndex(x,h,p);y[b]=d[v]}return{dataId:n.write(y,o,s.dtype),shape:o,dtype:s.dtype}}var idt={kernelName:bf,backendName:"cpu",kernelFunc:adt},odt=Sr((e,t)=>{let n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t}),ldt=Jr(vf,odt),udt={kernelName:vf,backendName:"cpu",kernelFunc:ldt},cdt=pd(WN());function Gre(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=s.shape.length,o=a;if(o===-1&&(o=i-1),o!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${o}`);let l=M.parseAxisParam([o],s.shape),u=jre({inputs:{x:s},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=H.expandShapeToKeepDim(u.shape,l),d=Pn({inputs:{x:u},backend:n,attrs:{shape:c}}),h=K4({inputs:{a:s,b:d},backend:n}),p=tre({inputs:{x:h},backend:n}),f=Ww({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),m=Pn({inputs:{x:f},backend:n,attrs:{shape:c}}),g=J4({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}var ddt={kernelName:Vf,backendName:"cpu",kernelFunc:Gre};function hdt(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;pt(s,"multinomial");let l=o?s:Gre({inputs:{logits:s},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],d=n.data.get(l.dataId).values,h=[u,a],p=M.makeZerosTypedArray(M.sizeFromShape(h),"int32");for(let f=0;f<u;++f){let m=f*c,g=new Float32Array(c-1);g[0]=d[m];for(let x=1;x<g.length;++x)g[x]=g[x-1]+d[m+x];let y=cdt.alea(i.toString()),b=f*a;for(let x=0;x<a;++x){let v=y();p[b+x]=g.length;for(let w=0;w<g.length;w++)if(v<g[w]){p[b+x]=w;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(h,"int32",p)}var pdt={kernelName:db,backendName:"cpu",kernelFunc:hdt},fdt=Vl.nonMaxSuppressionV3Impl;function mdt(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r;pt(s,"NonMaxSuppression");let u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,{selectedIndices:d}=fdt(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var gdt={kernelName:fb,backendName:"cpu",kernelFunc:mdt},ydt=Vl.nonMaxSuppressionV4Impl;function bdt(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r;pt(s,"NonMaxSuppressionPadded");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,{selectedIndices:h,validOutputs:p}=ydt(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var vdt={kernelName:mb,backendName:"cpu",kernelFunc:bdt},xdt=Vl.nonMaxSuppressionV5Impl;function wdt(e){let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r;pt(s,"NonMaxSuppressionWithScore");let c=n.data.get(s.dataId).values,d=n.data.get(a.dataId).values,h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=xdt(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var kdt={kernelName:gb,backendName:"cpu",kernelFunc:wdt};function Sdt(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r;pt(s,"oneHot");let u=M.sizeFromShape(s.shape),c=new Float32Array(u*i);c.fill(l);let d=n.data.get(s.dataId).values;for(let h=0;h<u;++h)d[h]>=0&&d[h]<i&&(c[h*i+d[h]]=o);return n.makeTensorInfo([...s.shape,i],a,c)}var Idt={kernelName:wf,backendName:"cpu",kernelFunc:Sdt};function yI(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){let s=rp({inputs:{input:r},backend:n}),a=yI({inputs:{x:s},backend:n}),i=Jg({inputs:{input:r},backend:n}),o=yI({inputs:{x:i},backend:n}),l=za({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Z4({backend:n,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}var Cdt={kernelName:Fb,backendName:"cpu",kernelFunc:yI};function Hre(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){let s=rp({inputs:{input:r},backend:n}),a=Hre({inputs:{x:s},backend:n}),i=Jg({inputs:{input:r},backend:n}),o=yI({inputs:{x:i},backend:n}),l=za({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Z4({backend:n,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}var Ndt={kernelName:yb,backendName:"cpu",kernelFunc:Hre};function qre(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return gI({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{M.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),M.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=gI({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=Zg({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var Tdt={kernelName:bb,backendName:"cpu",kernelFunc:qre};function $dt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;pt(s,"pad");let o=a.map((y,b)=>y[0]+s.shape[b]+y[1]),l=a.map(y=>y[0]),u=n.data.get(s.dataId).values,c=M.sizeFromShape(s.shape),d=s.shape.length,h=M.computeStrides(s.shape),p=M.sizeFromShape(o),f=o.length,m=M.computeStrides(o),g=M.getTypedArrayFromDType(s.dtype,p);i!==0&&g.fill(i);for(let y=0;y<c;y++){let b=M.indexToLoc(y,d,h).map((v,w)=>v+l[w]),x=M.locToIndex(b,f,m);g[x]=u[y]}return{dataId:n.write(g,o,s.dtype),shape:o,dtype:s.dtype}}var Kre={kernelName:kf,backendName:"cpu",kernelFunc:$dt},Edt=Sr((e,t)=>Math.pow(e,t)),_dt=Jr(Sf,Edt),Adt={kernelName:Sf,backendName:"cpu",kernelFunc:_dt};function Rdt(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,o=s.map(g=>n.data.get(g.dataId).values),l=s.map(g=>g.shape),u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values,[d,h,p]=vre(o,l,u,a.shape,a.dtype,c,i.shape),f=d.map(g=>n.makeTensorInfo([g.length],"int32",g)),m=n.makeTensorInfo(p,a.dtype,h);return f.concat([m])}var Ddt={kernelName:eT,backendName:"cpu",kernelFunc:Rdt};function Odt(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=xre(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}var Fdt={kernelName:tT,backendName:"cpu",kernelFunc:Odt};function Mdt(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.data.get(s.dataId).values,c=n.data.get(a.dataId).values,d=n.data.get(i.dataId).values,h=o.map(g=>n.data.get(g.dataId).values),p=o.map(g=>g.shape),[f,m]=wre(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}var Pdt={kernelName:nT,backendName:"cpu",kernelFunc:Mdt};function Ldt(e){let{backend:t,attrs:n}=e,{start:r,stop:s,dtype:a,step:i}=n,o=U4(r,s,i,a);return t.makeTensorInfo([o.length],a,o)}var zdt={kernelName:nw,backendName:"cpu",kernelFunc:Ldt},Bdt=vn(Nf,e=>1/e),Wdt={kernelName:Nf,backendName:"cpu",kernelFunc:Bdt};function Vdt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;pt(s,"resizeBilinear");let l=M.computeStrides(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(M.sizeFromShape([d,u,c,f])),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=0,v=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<d;k++)for(let S=0;S<u;S++){let I;i?I=v*(S+.5)-.5:I=v*S;let $=Math.max(0,Math.floor(I)),C=I-$,T=Math.min(h-1,Math.ceil(I)),N=k*l[0]+$*l[1],E=k*l[0]+T*l[1];for(let _=0;_<c;_++){let R;i?R=w*(_+.5)-.5:R=w*_;let z=Math.max(0,Math.floor(R)),W=R-z,F=Math.min(p-1,Math.ceil(R)),L=N+z*l[2],O=E+z*l[2],D=N+F*l[2],B=E+F*l[2];for(let V=0;V<f;V++){let K=m[L+V],G=m[O+V],U=m[D+V],q=m[B+V],Q=K+(U-K)*W,ee=G+(q-G)*W,ae=Q+(ee-Q)*C;g[x++]=ae}}}return n.makeTensorInfo([d,u,c,f],"float32",g)}var Udt={kernelName:Ef,backendName:"cpu",kernelFunc:Vdt};function jdt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;pt([a,s],"resizeBilinearGrad");let o=M.computeStrides(s.shape),[l,u,c,d]=s.shape,[,h,p]=a.shape,f=new Float32Array(l*u*c*d),m=[i&&h>1?u-1:u,i&&p>1?c-1:c],g=[i&&h>1?h-1:h,i&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],x=n.data.get(a.dataId).values,v=0;for(let w=0;w<l;w++){let k=w*o[0];for(let S=0;S<h;S++){let I=S*y,$=Math.floor(I),C=Math.min(Math.ceil(I),u-1),T=k+$*o[1],N=k+C*o[1],E=I-$,_=1-E;for(let R=0;R<p;R++){let z=R*b,W=Math.floor(z),F=Math.min(Math.ceil(z),c-1),L=z-W,O=1-L,D=T+W*o[2],B=T+F*o[2],V=N+W*o[2],K=N+F*o[2],G=_*O,U=_*L,q=E*O,Q=E*L;for(let ee=0;ee<d;ee++){let ae=x[v++];f[D+ee]+=ae*G,f[B+ee]+=ae*U,f[V+ee]+=ae*q,f[K+ee]+=ae*Q}}}}return n.makeTensorInfo([l,c,u,d],"float32",f)}var Gdt={kernelName:wb,backendName:"cpu",kernelFunc:jdt};function Hdt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r;pt(s,"resizeNearestNeighbor");let l=M.computeStrides(s.shape),[u,c]=o,[d,h,p,f]=s.shape,m=n.data.get(s.dataId).values,g=new Float32Array(d*u*c*f),y=[a&&u>1?h-1:h,a&&c>1?p-1:p],b=[a&&u>1?u-1:u,a&&c>1?c-1:c],x=y[0]/b[0],v=y[1]/b[1],w=0;for(let k=0;k<d;k++){let S=k*l[0];for(let I=0;I<u;I++){let $=i?x*(I+.5):x*I,C=Math.min(h-1,a?Math.round($):Math.floor($));i&&(C=Math.max(0,C));let T=S+C*l[1];for(let N=0;N<c;N++){let E=i?v*(N+.5):v*N,_=Math.min(p-1,a?Math.round(E):Math.floor(E));i&&(_=Math.max(0,_));let R=T+_*l[2];for(let z=0;z<f;z++){let W=m[R+z];g[w++]=W}}}}return n.makeTensorInfo([d,u,c,f],s.dtype,g)}var qdt={kernelName:$f,backendName:"cpu",kernelFunc:Hdt};function Kdt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r;pt([a,s],"resizeNearestNeighborGrad");let o=M.computeStrides(s.shape),l=M.computeStrides(a.shape),[u,c,d,h]=s.shape,[,p,f]=a.shape,m=new Float32Array(u*c*d*h),g=n.data.get(a.dataId).values,y=[i&&p>1?c-1:c,i&&f>1?d-1:d],b=[i&&p>1?p-1:p,i&&f>1?f-1:f],x=y[0]/b[0],v=y[1]/b[1],w=1/x,k=1/v,S=Math.ceil(w)*2+2,I=Math.ceil(k)*2+2;for(let $=0;$<u;$++){let C=$*o[0];for(let T=0;T<c;T++){let N=C+T*o[1],E=Math.floor(T*w),_=Math.floor(E-S/2);for(let R=0;R<d;R++){let z=N+R*o[2],W=Math.floor(R*k),F=Math.floor(W-I/2);for(let L=0;L<h;L++){let O=0;for(let D=0;D<S;D++){let B=D+_;if(B<0||B>=p)continue;let V=C+B*l[1],K=B*x,G=Math.min(c-1,i?Math.round(K):Math.floor(K));if(T===G)for(let U=0;U<I;U++){let q=U+F;if(q<0||q>=f)continue;let Q=V+q*l[2],ee=q*v,ae=Math.min(d-1,i?Math.round(ee):Math.floor(ee));R===ae&&(O+=g[Q+L])}}m[z+L]=O}}}}return n.makeTensorInfo(s.shape,s.dtype,m)}var Xdt={kernelName:xb,backendName:"cpu",kernelFunc:Kdt};function Ydt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r;pt(s,"reverse");let i=s.shape.length,o=M.parseAxisParam(a,s.shape);if(i===0)return Ll({inputs:{x:s},backend:n});let l=new Er(s.shape,s.dtype),u=n.bufferSync(s);for(let c=0;c<l.size;c++){let d=l.indexToLoc(c),h=d.slice();o.forEach(p=>h[p]=s.shape[p]-1-h[p]),l.set(u.get(...h),...d)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}var Jdt={kernelName:Af,backendName:"cpu",kernelFunc:Ydt},Zdt={kernelName:Mb,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=M.getTypedArrayFromDType(r.dtype,M.sizeFromShape(r.shape)),[u,c,d,h]=r.shape,[p,f]=H.getImageCenter(i,c,d),m=255,g=Math.sin(s),y=Math.cos(s),b=o.data.get(r.dataId).values;for(let x=0;x<u;x++){let v=x*d*c*h;for(let w=0;w<c;w++){let k=w*(d*h);for(let S=0;S<d;S++){let I=S*h;for(let $=0;$<h;$++){let C=[u,w,S,$],T=C[2],N=C[1],E=(T-p)*y-(N-f)*g,_=(T-p)*g+(N-f)*y;E=Math.round(E+p),_=Math.round(_+f);let R=a;if(typeof a!="number"&&($===3?R=m:R=a[$]),E>=0&&E<d&&_>=0&&_<c){let W=_*(d*h),F=E*h,L=v+W+F+$;R=b[L]}let z=v+k+I+$;l[z]=R}}}}return{dataId:o.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},Qdt=vn(Rf,e=>{let t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1}),eht={kernelName:Rf,backendName:"cpu",kernelFunc:Qdt};function tht(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=H.calculateShapes(a,s,i),h=!0,p=n.bufferSync(s),f=n.bufferSync(a),m=ih(p,f,i,d,u,l,o,c,0,h);return n.makeTensorInfo(i,m.dtype,m.values)}var nht={kernelName:kb,backendName:"cpu",kernelFunc:tht};function rht(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<t?n=s+1:r=s;return r}function sht(e,t){let n=0,r=e.length,s=0;for(;n<r;)s=Math.floor((n+r)/2),e[s]<=t?n=s+1:r=s;return r}function aht(e,t,n,r,s,a){let i=M.getArrayFromDType("int32",n*s);for(let o=0;o<n;++o){let l=e.slice(o*r,(o+1)*r),u=o*s;for(let c=0;c<s;++c)i[u+c]=a==="left"?rht(l,t[c+u]):sht(l,t[c+u])}return i}function iht(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,u=aht(o,l,s.shape[0],s.shape[1],a.shape[1],i);return n.makeTensorInfo(a.shape,"int32",u)}var oht={kernelName:Ib,backendName:"cpu",kernelFunc:iht};function lht(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t;pt([r,s,a],"select");let i=r.shape.length,o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=ki(s.dtype,a.dtype),d=M.makeZerosTypedArray(M.sizeFromShape(s.shape),c),h=0,p=i===0||i>1||s.shape.length===1?1:M.sizeFromShape(s.shape.slice(1));for(let f=0;f<o.length;f++)for(let m=0;m<p;m++)o[f]===1?d[h++]=l[f]:d[h++]=u[f];return n.makeTensorInfo(s.shape,c,d)}var uht={kernelName:Cb,backendName:"cpu",kernelFunc:lht},cht=H.SELU_SCALEALPHA,dht=H.SELU_SCALE,hht=vn(Of,e=>e>=0?dht*e:cht*(Math.exp(e)-1)),pht={kernelName:Of,backendName:"cpu",kernelFunc:hht},fht=vn(Pf,e=>e<0?-1:e>0?1:0),mht={kernelName:Pf,backendName:"cpu",kernelFunc:fht},ght=vn(Ff,e=>Math.sin(e)),yht={kernelName:Ff,backendName:"cpu",kernelFunc:ght},bht=vn(Mf,e=>Math.sinh(e)),vht={kernelName:Mf,backendName:"cpu",kernelFunc:bht},xht=11920928955078125e-23,D5=Math.log(xht)+2,wht=vn(zf,e=>{let t=e>-D5,n=e<D5,r=Math.exp(e),s;return n?s=r:t?s=e:s=Math.log(1+r),s}),kht={kernelName:zf,backendName:"cpu",kernelFunc:wht};function Sht(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;pt([s],"spaceToBatchND");let o=M.sizeFromShape(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);let u=Kre.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=H.getReshaped(u.shape,a,o,!1),d=H.getPermuted(c.length,a.length,!1),h=H.getReshapedPermuted(u.shape,a,o,!1),p=Pn({inputs:{x:u},backend:n,attrs:{shape:c}}),f=Sa({inputs:{x:p},backend:n,attrs:{perm:d}}),m=Pn({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}var Iht={kernelName:Tb,backendName:"cpu",kernelFunc:Sht};function Cht(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(a.dataId).values,c=n.data.get(i.dataId).values[0],[d,h,p,f,m]=Ire(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Nht={kernelName:rw,backendName:"cpu",kernelFunc:Cht};function Tht(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.data.get(s.dataId).values),o=n.data.get(r.dataId).values,l=Array.from(n.data.get(a.dataId).values),[u,c,d]=Cre(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var $ht={kernelName:Eb,backendName:"cpu",kernelFunc:Tht};function Eht(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=j4(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var _ht={kernelName:sw,backendName:"cpu",kernelFunc:Eht};function Aht(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);if(s.shape[0]!==a.shape[0])throw new Error("segmentIds and indices should have same size.");let i=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values,l=n.data.get(a.dataId).values,[u,c]=j4(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var Rht={kernelName:aw,backendName:"cpu",kernelFunc:Aht};function Dht(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=H.calculateShapes(a,s,o),p=!1,f=n.bufferSync(s),m;switch(a.dtype){case"bool":{let g=n.bufferSync(a),y=!!n.data.get(i.dataId).values[0];m=ih(f,g,o,h,c,u,l,d,y,p);break}case"float32":{let g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=ih(f,g,o,h,c,u,l,d,y,p);break}case"int32":{let g=n.bufferSync(a),y=n.data.get(i.dataId).values[0];m=ih(f,g,o,h,c,u,l,d,y,p);break}case"string":{let g=n.bufferSync(a),y=M.decodeString(n.data.get(i.dataId).values[0]);m=ih(f,g,o,h,c,u,l,d,y,p);break}default:throw new Error(`Unsupported type ${a.dtype}`)}return n.makeTensorInfo(o,m.dtype,m.values)}var Oht={kernelName:_b,backendName:"cpu",kernelFunc:Dht};function Fht(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=M.parseAxisParam(i,s.shape)[0],l=H.prepareSplitSize(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{let h=[...c];h[o]=d;let p=sp({inputs:{x:s},backend:n,attrs:{begin:u,size:h}});return u[o]+=d,p})}var Mht={kernelName:$b,backendName:"cpu",kernelFunc:Fht},Pht={kernelName:iw,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{let{x:n}=e,r=t;pt(n,"square");let s=r.data.get(n.dataId).values,a=new Float32Array(s.length);for(let i=0;i<s.length;++i){let o=s[i];a[i]=o*o}return{dataId:r.write(a,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Lht=vn(yd,(e,t)=>{let n=t;return isNaN(e)?NaN:e>0?1:n.alpha}),zht={kernelName:yd,backendName:"cpu",kernelFunc:Lht};function Bht(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r;pt(s,"stridedSlice");let{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Hr.sliceInfo(s.shape,a,i,o,l,u,c,d,h),w;if(m)w=Pn({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){M.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let k=Hr.computeOutShape(b,x,v),S=sp({inputs:{x:s},backend:n,attrs:{begin:b,size:k}});w=Pn({inputs:{x:S},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(S)}else{let k=n.bufferSync(s),S=$re(p,k,v,b);w=n.makeTensorInfo(f,S.dtype,S.values)}return w}var Wht={kernelName:Ab,backendName:"cpu",kernelFunc:Bht};function Vht(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.data.get(c.dataId).values,p=n.data.get(d.dataId).values,[f,m]=G4(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var Uht={kernelName:lw,backendName:"cpu",kernelFunc:Vht};function jht(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.data.get(a.dataId).values,l=n.data.get(i.dataId).values[0],[u,c,d]=H4(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var Ght={kernelName:uw,backendName:"cpu",kernelFunc:jht};function Hht(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.data.get(a.dataId).values,o=q4(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var qht={kernelName:cw,backendName:"cpu",kernelFunc:Hht},Kht=vn(Gf,e=>Math.tan(e)),Xht={kernelName:Gf,backendName:"cpu",kernelFunc:Kht},Yht=vn(Hf,e=>Math.tanh(e)),Jht={kernelName:Hf,backendName:"cpu",kernelFunc:Yht};function Zht(e){let{inputs:t,backend:n}=e,{tensor:r,indices:s,updates:a}=t,{sliceRank:i,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=H.calculateShapes(a,s,r.shape),d=!1,h=n.bufferSync(s),p=n.bufferSync(a),f=n.bufferSync(r),m=ih(h,p,r.shape,c,l,o,i,u,f,d);return n.makeTensorInfo(r.shape,m.dtype,m.values)}var Qht={kernelName:Sb,backendName:"cpu",kernelFunc:Zht};function ept(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;pt(s,"tile");let i=_re(n.bufferSync(s),a);return n.makeTensorInfo(i.shape,i.dtype,i.values)}var tpt={kernelName:gd,backendName:"cpu",kernelFunc:ept};function npt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r;pt(s,"topk");let o=n.data.get(s.dataId).values,[l,u]=Rre(o,s.shape,s.dtype,a,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}var rpt={kernelName:Rb,backendName:"cpu",kernelFunc:npt};function spt(e){let{inputs:t,attrs:n,backend:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=n,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=M.computeStrides(s.shape),b=y[0],x=y[1],v=y[2],w=M.computeStrides(g),k=w[0],S=w[1],I=w[2],$=M.getTypedArrayFromDType(s.dtype,M.sizeFromShape(g));$.fill(l);let C=r.data.get(s.dataId).values,T=r.data.get(a.dataId).values;for(let N=0;N<c;++N){let E=a.shape[0]===1?T:T.subarray(N*8,N*8+8);for(let _=0;_<f;++_)for(let R=0;R<m;++R)for(let z=0;z<p;++z){let W,F=E[6]*R+E[7]*_+1;if(F===0)continue;let L=(E[0]*R+E[1]*_+E[2])/F,O=(E[3]*R+E[4]*_+E[5])/F,D=O5(L,h,o),B=O5(O,d,o);switch(i){case"nearest":W=cpt(C,d,h,b,x,v,N,B,D,z,l);break;case"bilinear":W=dpt(C,d,h,b,x,v,N,B,D,z,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let V=N*k+_*S+R*I+z;$[V]=W}return r.makeTensorInfo(g,s.dtype,$)}return{dataId:r.write($,g,s.dtype),shape:s.shape,dtype:s.dtype}}var apt={kernelName:Db,backendName:"cpu",kernelFunc:spt};function O5(e,t,n){switch(n){case"reflect":return ipt(e,t);case"wrap":return opt(e,t);case"nearest":return upt(e,t);case"constant":default:return lpt(e)}}function ipt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=2*t;n<r&&(n=r*Math.trunc(-n/r)+n),n=n<-t?n+r:-n-1}else if(n>t-1)if(t<=1)n=0;else{let r=2*t;n-=r*Math.trunc(n/r),n>=t&&(n=r-n-1)}return M.clamp(0,n,t-1)}function opt(e,t){let n=e;if(n<0)if(t<=1)n=0;else{let r=t-1;n+=t*(Math.trunc(-n/r)+1)}else if(n>t-1)if(t<=1)n=0;else{let r=t-1;n-=t*Math.trunc(n/r)}return M.clamp(0,n,t-1)}function lpt(e,t){return e}function upt(e,t){return M.clamp(0,e,t-1)}function Uv(e,t,n,r,s,a,i,o,l,u,c){let d=i*r+o*s+l*a+u;return 0<=o&&o<t&&0<=l&&l<n?e[d]:c}function cpt(e,t,n,r,s,a,i,o,l,u,c){let d=Math.round(o),h=Math.round(l);return Uv(e,t,n,r,s,a,i,d,h,u,c)}function dpt(e,t,n,r,s,a,i,o,l,u,c){let d=Math.floor(o),h=Math.floor(l),p=d+1,f=h+1,m=(f-l)*Uv(e,t,n,r,s,a,i,d,h,u,c)+(l-h)*Uv(e,t,n,r,s,a,i,d,f,u,c),g=(f-l)*Uv(e,t,n,r,s,a,i,p,h,u,c)+(l-h)*Uv(e,t,n,r,s,a,i,p,f,u,c);return(p-o)*m+(o-d)*g}function hpt(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;pt(a,"unique");let i=r.data.get(a.dataId).values,{outputValues:o,outputShape:l,indices:u}=X4(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var ppt={kernelName:dw,backendName:"cpu",kernelFunc:hpt};function fpt(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape.length,o=s.shape[a],l=new Array(i-1),u=0;for(let p=0;p<i;p++)p!==a&&(l[u++]=s.shape[p]);let c=new Array(i).fill(0),d=s.shape.slice();d[a]=1;let h=new Array(o);for(let p=0;p<h.length;p++){c[a]=p;let f=sp({inputs:{x:s},backend:n,attrs:{begin:c,size:d}});h[p]=Pn({inputs:{x:f},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(f)}return h}var mpt={kernelName:Ob,backendName:"cpu",kernelFunc:fpt};function gpt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r;pt(s,"unsortedSegmentSum");let o=s.shape.length,l=a.shape.length,u=[],c=[],d=o-l,h=a;for(let f=0;f<d;++f){let m=gI({inputs:{input:h},backend:n,attrs:{dim:f+1}});h=m,c.push(m)}for(let f=0;f<i;++f){let m=M.createScalarValue(f,"int32"),g=n.makeTensorInfo([],"int32",m),y=Qne({inputs:{a:g,b:h},backend:n}),b=Kc({inputs:{x:y},backend:n,attrs:{dtype:"float32"}}),x=l$({inputs:{a:b,b:s},backend:n}),v=Ww({inputs:{x},backend:n,attrs:{axis:0,keepDims:!1}});u.push(v),c.push(g),c.push(y),c.push(b),c.push(x),c.push(v)}let p=qre({inputs:u,backend:n,attrs:{axis:0}});return c.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var ypt={kernelName:hw,backendName:"cpu",kernelFunc:gpt},bpt=[dlt,jit,plt,mlt,Yit,ylt,vlt,wlt,Slt,Clt,Tlt,Elt,Alt,Olt,Mlt,zlt,Wlt,Ult,Glt,ult,qlt,Xlt,Jlt,Zit,Qlt,Kit,eot,tut,Git,rut,aut,iut,lut,cut,hut,fut,gut,but,xut,kut,Iut,Nut,$ut,_ut,Aut,Dut,Fut,Put,Lut,zut,But,Vut,Gut,nlt,qut,tot,tct,not,nct,sot,lct,uct,dct,iot,lot,pct,mct,yct,vct,cot,hot,Hit,wct,sut,Sct,Cct,Tct,rlt,fot,got,Ect,bot,Act,Oct,Mct,zct,Wct,Uct,jct,xot,Hct,Kct,Yct,Zct,edt,ndt,sdt,kot,idt,udt,pdt,Iot,Not,gdt,vdt,kdt,$ot,Idt,Ndt,Tdt,Kre,Adt,alt,Aot,Ddt,Fdt,Pdt,zdt,qit,WR,Wdt,ilt,olt,llt,Udt,Gdt,qdt,Xdt,Jdt,Zdt,eht,Bot,nht,oht,uht,pht,Vot,mht,yht,vht,Uot,ddt,kht,Iht,Nht,$ht,_ht,Rht,Oht,Mht,Hot,Pht,Kot,Yot,zht,Wht,Uht,Ght,qht,elt,Uut,Xht,Jht,Qht,tpt,rpt,apt,Eot,ppt,mpt,ypt,Cdt];for(let e of bpt)pw(e);var Xre={};At(Xre,{assertNotComplex:()=>Xb,bindCanvasToFramebuffer:()=>Ept,bindColorTextureToFramebuffer:()=>C2,bindTextureToProgramUniformSampler:()=>dse,bindTextureUnit:()=>lse,bindVertexBufferToProgramAttribute:()=>UR,callAndCheck:()=>et,canBeRepresented:()=>Jre,createFragmentShader:()=>ese,createFramebuffer:()=>ose,createProgram:()=>tse,createStaticIndexBuffer:()=>sse,createStaticVertexBuffer:()=>rse,createTexture:()=>ase,createVertexShader:()=>Qre,getBatchDim:()=>ap,getExtensionOrThrow:()=>jv,getFramebufferErrorMessage:()=>hse,getMaxTexturesInShader:()=>gse,getNumChannels:()=>Tpt,getProgramUniformLocation:()=>cse,getProgramUniformLocationOrThrow:()=>use,getRowsCols:()=>ip,getShapeAs3D:()=>Hv,getTextureShapeFromLogicalShape:()=>fse,getWebGLDisjointQueryTimerVersion:()=>yse,getWebGLErrorMessage:()=>Zre,getWebGLMaxTextureSize:()=>mse,hasExtension:()=>pi,isCapableOfRenderingToFloatTexture:()=>bse,isDownloadFloatTextureEnabled:()=>vse,isReshapeFree:()=>l0,isWebGLFenceEnabled:()=>xse,isWebGLVersionEnabled:()=>GR,linkProgram:()=>nse,logShaderSourceAndInfoLog:()=>ez,resetMaxTextureSize:()=>_pt,resetMaxTexturesInShader:()=>Apt,unbindColorTextureFromFramebuffer:()=>jR,unbindTextureUnit:()=>$pt,validateFramebuffer:()=>Gv,validateProgram:()=>I2,validateTextureSize:()=>ise});var Jd={},Kk={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Yre(e,t){Jd[e]=t}function Uo(e,t){if(!(e in Jd)||t!=null){let r=xpt(e,t);if(r!==null)Jd[e]=r;else return console.log("Could not get context for WebGL version",e),null}let n=Jd[e];return n==null||n.isContextLost()?(delete Jd[e],Uo(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Jd[e])}function vpt(e){if(!xe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&e===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function xpt(e,t){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let n=t??vpt(e);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Jd[e]},!1),xe().getBool("SOFTWARE_WEBGL_ENABLED")&&(Kk.failIfMajorPerformanceCaveat=!1),e===1?n.getContext("webgl",Kk)||n.getContext("experimental-webgl",Kk):n.getContext("webgl2",Kk)}var o0;(function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"})(o0||(o0={}));var hi;(function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"})(hi||(hi={}));var xs;(function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(xs||(xs={}));function Vw(e,t){return[t,e]}function wpt(e,t){return e*t}function Xk(e){let t=M.sizeFromShape(e),n=Math.ceil(t/4);return M.sizeToSquarishShape(n)}function Kb(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function kpt(e,t){let[n,r]=Kb(e,t);return n*r*4}function Q4(e,t){let n=e,r,s,a,i,o,l,u,c,d,h;return xe().getNumber("WEBGL_VERSION")===2?(r=n.R32F,s=n.R16F,a=n.RGBA16F,i=n.RGBA32F,o=n.RED,u=4,c=1,d=n.HALF_FLOAT,h=n.FLOAT,l=n.RGBA8):(r=e.RGBA,s=e.RGBA,a=e.RGBA,i=n.RGBA,o=e.RGBA,u=4,c=4,d=t!=null?t.HALF_FLOAT_OES:null,h=e.FLOAT,l=e.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:i,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:d,textureTypeFloat:h}}function et(e,t){let n=t();return xe().getBool("DEBUG")&&Spt(e),n}function Spt(e){let t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+Zre(e,t))}var Ipt=596e-10,Cpt=65504;function Jre(e){return!!(xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||e===0||Ipt<Math.abs(e)&&Math.abs(e)<Cpt)}function Zre(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function jv(e,t){return Fu(e,()=>e.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function Qre(e,t){let n=Fu(e,()=>e.createShader(e.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(et(e,()=>e.shaderSource(n,t)),et(e,()=>e.compileShader(n)),e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function ese(e,t){let n=Fu(e,()=>e.createShader(e.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(et(e,()=>e.shaderSource(n,t)),et(e,()=>e.compileShader(n)),xe().get("ENGINE_COMPILE_ONLY"))return n;if(e.getShaderParameter(n,e.COMPILE_STATUS)===!1)throw ez(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}var Npt=/ERROR: [0-9]+:([0-9]+):/g;function ez(e,t){let n=Npt.exec(t);if(n==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(e);return}let r=+n[1],s=e.split(`
`),a=s.length.toString().length+2,i=s.map((d,h)=>M.rightPad((h+1).toString(),a)+d),o=0;for(let d=0;d<i.length;d++)o=Math.max(i[d].length,o);let l=i.slice(0,r-1),u=i.slice(r-1,r),c=i.slice(r);console.log(l.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${M.rightPad(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join(`
`))}function tse(e){return Fu(e,()=>e.createProgram(),"Unable to create WebGLProgram.")}function nse(e,t){if(et(e,()=>e.linkProgram(t)),!xe().get("ENGINE_COMPILE_ONLY")&&e.getProgramParameter(t,e.LINK_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function I2(e,t){if(et(e,()=>e.validateProgram(t)),e.getProgramParameter(t,e.VALIDATE_STATUS)===!1)throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function rse(e,t){let n=Fu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),et(e,()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function sse(e,t){let n=Fu(e,()=>e.createBuffer(),"Unable to create WebGLBuffer");return et(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n)),et(e,()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW)),n}function Tpt(){return xe().getNumber("WEBGL_VERSION")===2?1:4}function ase(e){return Fu(e,()=>e.createTexture(),"Unable to create WebGLTexture.")}function ise(e,t){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){let r=`[${e}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(e>n||t>n){let r=`[${e}x${t}]`,s=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+s+".")}}function ose(e){return Fu(e,()=>e.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function UR(e,t,n,r,s,a,i){let o=e.getAttribLocation(t,n);return o===-1?!1:(et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,r)),et(e,()=>e.vertexAttribPointer(o,s,e.FLOAT,!1,a,i)),et(e,()=>e.enableVertexAttribArray(o)),!0)}function lse(e,t,n){pse(e,n),et(e,()=>e.activeTexture(e.TEXTURE0+n)),et(e,()=>e.bindTexture(e.TEXTURE_2D,t))}function $pt(e,t){pse(e,t),et(e,()=>e.activeTexture(e.TEXTURE0+t)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function use(e,t,n){return Fu(e,()=>e.getUniformLocation(t,n),'uniform "'+n+'" not present in program.')}function cse(e,t,n){return e.getUniformLocation(t,n)}function dse(e,t,n,r){et(e,()=>lse(e,t,r)),et(e,()=>e.uniform1i(n,r))}function Ept(e){et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),et(e,()=>e.viewport(0,0,e.canvas.width,e.canvas.height)),et(e,()=>e.scissor(0,0,e.canvas.width,e.canvas.height))}function C2(e,t,n){et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,n)),et(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0))}function jR(e,t){et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,t)),et(e,()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0))}function Gv(e){let t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+hse(e,t))}function hse(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Fu(e,t,n){let r=et(e,()=>t());if(r==null)throw new Error(n);return r}function pse(e,t){let n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+e.TEXTURE0;if(r<e.TEXTURE0||r>n){let s=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${s}.`)}}function ap(e,t=2){return M.sizeFromShape(e.slice(0,e.length-t))}function ip(e){if(e.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function Hv(e){let t=[1,1,1];return e.length===0||e.length===1&&e[0]===1||(t=[ap(e),...ip(e)]),t}function fse(e,t=!1){let n=xe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=xe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&xe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),t&&(n=n*2,r=r*2,e=e.map((o,l)=>l>=e.length-2?M.nearestLargerEven(e[l]):e[l]),e.length===1&&(e=[2,e[0]])),e.length!==2&&(e=M.squeezeShape(e).newShape);let s=M.sizeFromShape(e),a=null;e.length<=1&&s<=n?a=[1,s]:e.length===2&&e[0]<=n&&e[1]<=n?a=e:e.length===3&&e[0]*e[1]<=n&&e[2]<=n?a=[e[0]*e[1],e[2]]:e.length===3&&e[0]<=n&&e[1]*e[2]<=n?a=[e[0],e[1]*e[2]]:e.length===4&&e[0]*e[1]*e[2]<=n&&e[3]<=n?a=[e[0]*e[1]*e[2],e[3]]:e.length===4&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(a=[e[0],e[1]*e[2]*e[3]]);let i=a!=null&&Math.max(...a)>r&&Math.min(...a)<=(t?2:1)&&Math.min(...a)>0;if(a==null||i)if(t){let o=ap(e),l=2,u=2;e.length&&([l,u]=ip(e)),s=o*(l/2)*(u/2),a=M.sizeToSquarishShape(s).map(c=>c*2)}else a=M.sizeToSquarishShape(s);return a}function Yk(e){return e%2===0}function l0(e,t){if(e=e.slice(-2),t=t.slice(-2),M.arraysEqual(e,t)||!e.length||!t.length||e[0]===0||e[1]===0||t[0]===0||t[1]===0)return!0;if(e.length!==t.length){let n=e[e.length-1],r=t[t.length-1];if(n===r||Yk(n)&&Yk(r)&&(e[0]===1||t[0]===1))return!0}return e[1]===t[1]&&Yk(e[0])&&Yk(t[0])}var N2,T2;function mse(e){if(N2==null){let t=Uo(e);N2=t.getParameter(t.MAX_TEXTURE_SIZE)}return N2}function _pt(){N2=null}function Apt(){T2=null}function gse(e){if(T2==null){let t=Uo(e);T2=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,T2)}function yse(e){if(e===0)return 0;let t,n=Uo(e);return pi(n,"EXT_disjoint_timer_query_webgl2")&&e===2?t=2:pi(n,"EXT_disjoint_timer_query")?t=1:t=0,t}function pi(e,t){return e.getExtension(t)!=null}function GR(e){try{if(Uo(e)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function bse(e){if(e===0)return!1;let t=Uo(e);if(e===1){if(!pi(t,"OES_texture_float"))return!1}else if(!pi(t,"EXT_color_buffer_float"))return!1;return HR(t)}function vse(e){if(e===0)return!1;let t=Uo(e);if(e===1){if(!pi(t,"OES_texture_float")||!pi(t,"WEBGL_color_buffer_float"))return!1}else{if(pi(t,"EXT_color_buffer_float"))return HR(t);let n="EXT_color_buffer_half_float";if(pi(t,n)){let r=t.getExtension(n);return Rpt(t,r)}return!1}return HR(t)}function HR(e){let t=Q4(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);let r=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let s=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(r),s}function Rpt(e,t){let n=Q4(e,t),r=e.createTexture();e.bindTexture(e.TEXTURE_2D,r),e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);let s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,r,0);let a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(r),e.deleteFramebuffer(s),a}function xse(e){return e!==2?!1:Uo(e).fenceSync!=null}function Xb(e,t){Array.isArray(e)||(e=[e]),e.forEach(n=>{n!=null&&M.assert(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var mt=xe();mt.registerFlag("HAS_WEBGL",()=>mt.getNumber("WEBGL_VERSION")>0);mt.registerFlag("WEBGL_VERSION",()=>GR(2)?2:GR(1)?1:0);mt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);mt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>mt.get("WEBGL_VERSION")===2);mt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);mt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);mt.registerFlag("WEBGL_PACK",()=>mt.getBool("HAS_WEBGL"));mt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_CLIP",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_REDUCE",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_LAZILY_UNPACK",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_CONV_IM2COL",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>mt.getBool("WEBGL_PACK"));mt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>mse(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>gse(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let e=mt.getNumber("WEBGL_VERSION");return e===0?0:yse(e)});mt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>mt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!gw.isMobile());mt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>bse(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>mt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:mt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));mt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>vse(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>xse(mt.getNumber("WEBGL_VERSION")));mt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>mt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);mt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)});mt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>gw.isMobile()?1:-1,e=>{if(typeof e!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&e!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)});mt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);mt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);mt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);mt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);mt.registerFlag("WEBGL_EXP_CONV",()=>!1);mt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>mt.getBool("IS_TEST"));mt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);mt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);mt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);mt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function la(){let e,t,n,r,s,a,i,o,l,u;return xe().getNumber("WEBGL_VERSION")===2?(e="#version 300 es",t="in",n="out",r="in",s="texture",a="outputColor",i="out vec4 outputColor;",o=xe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",u=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(e="",t="attribute",n="varying",r="varying",s="texture2D",a="gl_FragColor",i="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,u=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:e,attribute:t,varyingVs:n,varyingFs:r,texture2D:s,output:a,defineOutput:i,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function em(e,t,n="index"){let r=M.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / ${s}`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * ${s}`:`index -= ${e[a]} * ${s}`;return`${i}; ${o};`}).join("")}function u$(e,t,n="index"){let r=M.computeStrides(t);return r.map((s,a)=>{let i=`int ${e[a]} = ${n} / outShapeStrides[${a}]`,o=a===r.length-1?`int ${e[a+1]} = ${n} - ${e[a]} * outShapeStrides[${a}]`:`index -= ${e[a]} * outShapeStrides[${a}]`;return`${i}; ${o};`}).join("")}function Dpt(e,t){let n=e.length,r=e.map(a=>`${t}[${a}]`),s=new Array(n-1);s[n-2]=r[n-1];for(let a=n-3;a>=0;--a)s[a]=`(${s[a+1]} * ${r[a+1]})`;return s}function Opt(e,t,n="index"){let r=e.map((a,i)=>i),s=Dpt(r,t);return s.map((a,i)=>{let o=`int ${e[i]} = ${n} / ${s[i]}`,l=i===s.length-1?`int ${e[i+1]} = ${n} - ${e[i]} * ${s[i]}`:`index -= ${e[i]} * ${s[i]}`;return`${o}; ${l};`}).join("")}function tz(e){let t=M.computeStrides(e).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function nz(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var wse=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:kse}=H;function Fpt(e,t,n){let r=[];if(e.forEach(h=>{let p=M.sizeFromShape(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){let{uniformShape:f}=rz(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(f.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});let s=r.join(`
`),a=e.map(h=>Mpt(h,t,n.packedInputs,n.enableShapeUniforms)).join(`
`),i=t.texShape,o=la(),l=zpt(o),u,c,d=Vpt(o);return t.isPacked?(u=Ppt(t.logicalShape,i,n.enableShapeUniforms),c=Wpt(o)):(u=Lpt(t.logicalShape,i,n.enableShapeUniforms),c=Bpt(o)),n.packedInputs&&(d+=Hpt),[d,l,c,s,u,a,n.userCode].join(`
`)}function Yb(e,t=!1){let n=e.shapeInfo.logicalShape;switch(n.length){case 0:return sft(e,t);case 1:return ift(e,t);case 2:return lft(e,t);case 3:return cft(e,t);case 4:return hft(e,t);case 5:return pft(e);case 6:return fft(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function Sse(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return rft(e);case 1:return aft(e,t);case 2:return oft(e,t);case 3:return uft(e,t);default:return dft(e,t)}}function Mpt(e,t,n=!1,r){let s="";n?s+=Sse(e,r):s+=Yb(e,r);let a=e.shapeInfo.logicalShape,i=t.logicalShape;return a.length<=i.length&&(n?s+=mft(e,t):s+=gft(e,t)),s}function Ppt(e,t,n){switch(e.length){case 0:return Ise();case 1:return qpt(e,t,n);case 2:return tft(e,t,n);case 3:return Xpt(e,t,n);default:return Jpt(e,t,n)}}function Lpt(e,t,n){switch(e.length){case 0:return Ise();case 1:return Kpt(e,t,n);case 2:return nft(e,t,n);case 3:return Ypt(e,t,n);case 4:return Zpt(e,t,n);case 5:return Qpt(e,t);case 6:return eft(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}function zpt(e){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${e.texture2D}(textureSampler, uv).r;
    }
  `}function Bpt(e){return`
    void setOutput(float val) {
      ${e.output} = vec4(val, 0, 0, 0);
    }
  `}function Wpt(e){return`
    void setOutput(vec4 val) {
      ${e.output} = val;
    }
  `}function Vpt(e){return`${e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e.varyingFs} vec2 resultUV;
    ${e.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${e.defineSpecialNaN}
    ${e.defineSpecialInf}
    ${e.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Upt}
    ${jpt}
    ${Gpt}
  `}var Upt=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,jpt=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Gpt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Hpt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Ise(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function qpt(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Kpt(e,t,n){return t[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Xpt(e,t,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[2]/2),a=s*Math.ceil(e[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec3(b, r, c);
    }
  `}function Ypt(e,t,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${u$(["r","c","d"],e)}
    return ivec3(r, c, d);
  }
`;let r=em(["r","c","d"],e);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Jpt(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],s=Math.ceil(e[e.length-1]/2),a=s*Math.ceil(e[e.length-2]/2),i=a,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)i*=e[e.length-u-1],o=`
      int b${u} = index / ${i};
      index -= b${u} * ${i};
    `+o,l=`b${u}, `+l;return`
    ivec${e.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec${e.length}(${l});
    }
  `}function Zpt(e,t,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${u$(["r","c","d","d2"],e)}
      return ivec4(r, c, d, d2);
    }
  `;let r=em(["r","c","d","d2"],e);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function Qpt(e,t){let n=em(["r","c","d","d2","d3"],e);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function eft(e,t){let n=em(["r","c","d","d2","d3","d4"],e);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function tft(e,t,n){let r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(M.arraysEqual(e,t))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;let s=Math.ceil(e[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${s});
      int c = imod(index, ${s}) * 2;

      return ivec2(r, c);
    }
  `}function nft(e,t,n){return M.arraysEqual(e,t)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:e[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:e[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${e[1]};
      int c = index - r * ${e[1]};
      return ivec2(r, c);
    }
  `}function tm(e){return`offset${e}`}function rft(e){let t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),r=la();return`
    vec4 ${n}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function sft(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;let[s,a]=e.shapeInfo.texShape;if(s===1&&a===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;let i=tm(n);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${i});
      return sampleTexture(${n}, uv);
    }
  `;let[o,l]=e.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${i});
      return sampleTexture(${n}, uv);
    }
  `}function aft(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e.shapeInfo.texShape,a=la();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${n}, uv);
    }
  `;let i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${a.texture2D}(${n}, uv);
    }
  `}function ift(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Jb(e)}
      }
    `;let s=e.shapeInfo.texShape,a=s[0],i=s[1];if(i===1&&a===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;let o=tm(n);return i===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${a}.0);
        return sampleTexture(${n}, uv);
      }
    `:a===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${a}, ${i}, index + ${o});
      return sampleTexture(${n}, uv);
    }
  `}function oft(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=a[0],o=a[1],l=la();if(a!=null&&M.arraysEqual(n,a))return t?`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${i}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${s}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;let u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=Math.ceil(n[1]/2);return`
    vec4 ${s}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function lft(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape;if(a!=null&&M.arraysEqual(n,a)){if(t)return`
      float ${s}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;let h=a[0],p=a[1];return`
    float ${s}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${h}.0);
      return sampleTexture(${r}, uv);
    }
  `}let{newShape:i,keptDims:o}=M.squeezeShape(n),l=i;if(l.length<n.length){let h=Zb(e,l),p=["row","col"];return`
      ${Yb(h,t)}
      float ${s}(int row, int col) {
        return ${s}(${Qb(p,o)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Jb(e)}
      }
    `;let u=a[0],c=a[1],d=tm(r);return c===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${r}, uv);
    }
  `:u===1?t?`
      float ${s}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${s}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${s}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${u}, ${c}, index);
    return sampleTexture(${r}, uv);
  }
`}function uft(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=e.shapeInfo.texShape,i=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(n[0]===1){let h=n.slice(1),p=[1,2],f=Zb(e,h),m=["b","row","col"];return`
        ${Sse(f,t)}
        vec4 ${s}(int b, int row, int col) {
          return ${s}(${Qb(m,p)});
        }
      `}let o=la();if(t)return`
    vec4 ${s}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;let l=i[0],u=i[1],c=Math.ceil(n[2]/2),d=c*Math.ceil(n[1]/2);return`
    vec4 ${s}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${u}, ${d}, ${c}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function cft(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[1]*n[2],i=n[2],{newShape:o,keptDims:l}=M.squeezeShape(n),u=o;if(u.length<n.length){let m=Zb(e,u),g=["row","col","depth"];return`
        ${Yb(m,t)}
        float ${s}(int row, int col, int depth) {
          return ${s}(${Qb(g,l)});
        }
      `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${i}, 1)));
        ${Jb(e)}
      }
    `;let c=e.shapeInfo.texShape,d=c[0],h=c[1],p=e.shapeInfo.flatOffset;if(h===a&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${s}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${h}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(h===i&&p==null)return t?`
      float ${s}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${s}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;let f=tm(r);return t?`
    float ${s}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${s}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${h}, index);
        return sampleTexture(${r}, uv);
      }
  `}function dft(e,t){let n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=la();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${s.texture2D}(${n}, uv);
    }
  `;let a=e.shapeInfo.logicalShape,i=a.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],d=Math.ceil(a[i-1]/2),h=d*Math.ceil(a[i-2]/2),p="int b, int row, int col",f=`b * ${h} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<i-1;m++)p=`int b${m}, `+p,h*=a[i-m-1],f=`b${m} * ${h} + `+f;return`
    vec4 ${r}(${p}) {
      int index = ${f};
      int texR = index / ${c};
      int texC = index - texR * ${c};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});
      return ${s.texture2D}(${n}, uv);
    }
  `}function hft(e,t){let n=e.shapeInfo.logicalShape,r=e.name,s="get"+r.charAt(0).toUpperCase()+r.slice(1),a=n[3],i=n[2]*a,o=n[1]*i,{newShape:l,keptDims:u}=M.squeezeShape(n);if(l.length<n.length){let b=Zb(e,l),x=["row","col","depth","depth2"];return`
      ${Yb(b,t)}
      float ${s}(int row, int col, int depth, int depth2) {
        return ${s}(${Qb(x,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${i}, ${a}, 1)));
        ${Jb(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1],f=`int stride2 = ${r}Shape[3];`,m=`int stride1 = ${r}Shape[2] * stride2;`,g=`int stride0 = ${r}Shape[1] * stride1;`;if(p===o&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(p===a&&c==null)return t?`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${s}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${r}, uv);
      }
    `;let y=tm(r);return t?`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${s}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${h}, ${p}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function pft(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[4],a=t[3]*s,i=t[2]*a,o=t[1]*i,{newShape:l,keptDims:u}=M.squeezeShape(t);if(l.length<t.length){let m=Zb(e,l),g=["row","col","depth","depth2","depth3"];return`
      ${Yb(m)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Qb(g,u)});
      }
    `}if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${i}, ${a}, ${s})) +
          depth3;
        ${Jb(e)}
      }
    `;let c=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],p=d[1];if(p===o&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===s&&c==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;let f=tm(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${i} + depth * ${a} +
          depth2 * ${s} + depth3 + ${f};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function fft(e){let t=e.shapeInfo.logicalShape,n=e.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:s,keptDims:a}=M.squeezeShape(t);if(s.length<t.length){let g=Zb(e,s),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Yb(g)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Qb(y,a)});
      }
    `}let i=t[5],o=t[4]*i,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${c}, ${u}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Jb(e)}
      }
    `;let d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,p=h[0],f=h[1];if(f===c&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${u}, ${l}, ${o}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===i&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${n}, uv);
      }
    `;let m=tm(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${c} + col * ${u} + depth * ${l} +
          depth2 * ${o} + depth3 * ${i} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Jb(e){let t=e.name,n=M.sizeFromShape(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function mft(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=e.shapeInfo.logicalShape.length,i=t.logicalShape.length,o=kse(e.shapeInfo.logicalShape,t.logicalShape),l=Tn(i),u=i-a,c,d=["x","y","z","w","u","v"];a===0?c="":i<2&&o.length>=1?c="coords = 0;":c=o.map(g=>`coords.${d[g+u]} = 0;`).join(`
`);let h="";i<2&&a>0?h="coords":h=e.shapeInfo.logicalShape.map((g,y)=>`coords.${d[y+u]}`).join(", ");let p="return outputValue;",f=M.sizeFromShape(e.shapeInfo.logicalShape)===1,m=M.sizeFromShape(t.logicalShape)===1;if(a===1&&!f&&!m)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!m)i===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){let g=a-2,y=a-1;o.indexOf(g)>-1&&o.indexOf(y)>-1?p="return vec4(outputValue.x);":o.indexOf(g)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(y)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${l} coords = getOutputCoords();
      ${c}
      vec4 outputValue = get${r}(${h});
      ${p}
    }
  `}function gft(e,t){let n=e.name,r=n.charAt(0).toUpperCase()+n.slice(1),s="get"+r+"AtOutCoords",a=t.texShape,i=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&e.shapeInfo.flatOffset==null&&M.arraysEqual(i,a))return`
      float ${s}() {
        return sampleTexture(${n}, resultUV);
      }
    `;let u=Tn(l),c=kse(e.shapeInfo.logicalShape,t.logicalShape),d=l-o,h,p=["x","y","z","w","u","v"];o===0?h="":l<2&&c.length>=1?h="coords = 0;":h=c.map(m=>`coords.${p[m+d]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=e.shapeInfo.logicalShape.map((m,g)=>`coords.${p[g+d]}`).join(", "),`
    float ${s}() {
      ${u} coords = getOutputCoords();
      ${h}
      return get${r}(${f});
    }
  `}function Tn(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function rz(e,t,n){let{newShape:r,keptDims:s}=M.squeezeShape(t),a=t.length,i=e&&a===3&&t[0]===1,o=i?t.slice(1):r,l=!e&&a>1&&!M.arraysEqual(t,n)&&r.length<a||i;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:s}}function Zb(e,t){let n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function Qb(e,t){return t.map(n=>e[n]).join(", ")}function yft(e,t,n,r){let s=n.map((c,d)=>{let h={logicalShape:c.shape,texShape:c.isUniform?null:c.texData.texShape,isUniform:c.isUniform,isPacked:c.isUniform?!1:c.texData.isPacked,flatOffset:null};return c.texData!=null&&c.texData.slice!=null&&c.texData.slice.flatOffset>0&&(h.flatOffset=c.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:h}}),a=s.map(c=>c.shapeInfo),i={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=Fpt(s,i,t),l=ese(e.gl,o),u=e.createProgram(l);return xe().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:a,outShapeInfo:i},Cse(e,t,u)))}function Cse(e,t,n){let r=[],s=[],a,i,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),xe().getNumber("WEBGL_VERSION")===1&&(l=e.getUniformLocation(n,"INFINITY",!1));let c=!1;for(let d of t.variableNames){let h={name:d,uniform:e.getUniformLocation(n,d,c),offset:e.getUniformLocation(n,`offset${d}`,c)};t.enableShapeUniforms&&(h.shape=e.getUniformLocation(n,`${d}Shape`,c),h.texShape=e.getUniformLocation(n,`${d}TexShape`,c)),r.push(h)}if(t.enableShapeUniforms&&(a=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),i=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(let d of t.customUniforms)s.push(e.getUniformLocation(n,d.name,c));return{variablesLocations:r,customUniformLocations:s,infLoc:l,nanLoc:u,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:i}}function F5(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach((n,r)=>{let s=n.logicalShape,a=t[r],i=a.shape;if(!M.arraysEqual(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(n.isUniform&&a.isUniform)return;let o=n.texShape,l=a.isUniform?null:a.texData.texShape;if(!M.arraysEqual(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function bft(e,t,n,r,s){t.program.enableShapeUniforms||(F5(t.inShapeInfos,n),F5([t.outShapeInfo],[r]));let a=r.texData.texture,i=r.texData.texShape;r.texData.isPacked?e.setOutputPackedMatrixTexture(a.texture,i[0],i[1]):e.setOutputMatrixTexture(a.texture,i[0],i[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),xe().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&e.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){let u=n[l],{uniform:c,offset:d,shape:h,texShape:p}=t.variablesLocations[l];if(h){let{uniformShape:f}=rz(t.program.packedInputs,u.shape,u.texData.texShape);switch(f.length){case 1:e.gl.uniform1iv(h,new Int32Array(f));break;case 2:e.gl.uniform2iv(h,new Int32Array(f));break;case 3:e.gl.uniform3iv(h,new Int32Array(f));break;case 4:e.gl.uniform4iv(h,new Int32Array(f));break}}if(p&&e.gl.uniform2i(p,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(M.sizeFromShape(u.shape)<2)e.gl.uniform1f(c,u.uniformValues[0]);else{let f=u.uniformValues;f instanceof Float32Array||(f=new Float32Array(f)),e.gl.uniform1fv(c,f)}continue}u.texData.slice!=null&&d!=null&&e.gl.uniform1i(d,u.texData.slice.flatOffset),e.setInputMatrixTexture(u.texData.texture.texture,c,l)}}let o=t.outShapeLocation;if(o)switch(r.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){let l=M.computeStrides(r.shape);switch(r.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(l));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(l));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(l));break}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&s)for(let l=0;l<t.program.customUniforms.length;++l){let u=t.program.customUniforms[l],c=t.customUniformLocations[l],d=s[l];if(u.type==="float")e.gl.uniform1fv(c,d);else if(u.type==="vec2")e.gl.uniform2fv(c,d);else if(u.type==="vec3")e.gl.uniform3fv(c,d);else if(u.type==="vec4")e.gl.uniform4fv(c,d);else if(u.type==="int")e.gl.uniform1iv(c,d);else if(u.type==="ivec2")e.gl.uniform2iv(c,d);else if(u.type==="ivec3")e.gl.uniform3iv(c,d);else if(u.type==="ivec4")e.gl.uniform4iv(c,d);else throw Error(`uniform type ${u.type} is not supported yet.`)}e.executeProgram()}function vft(e,t,n){let r="";t.concat(n).forEach(i=>{let o=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!i.isUniform){let l=i.texData.texShape,{useSqueezeShape:u,uniformShape:c,keptDims:d}=rz(e.packedInputs,i.shape,l),h="",p="",f="";if(c.length===1&&e.packedInputs){let w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];h=`${w[0]>1}_${w[1]>1}`}else if(c.length===2&&!e.packedInputs)p=`${c[0]>1}_${c[1]>1}`;else if(c.length>2&&!e.packedInputs){let w=M.computeStrides(c);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}let m=i.shape.length,g=c.length===2&&M.arraysEqual(i.shape,l),y=M.sizeFromShape(i.shape)===1,b=H.getBroadcastDims(i.shape,n.shape),x=!e.packedInputs&&m===n.shape.length&&M.arraysEqual(l,n.texData.texShape),v=e.packedInputs||c.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${m}_${x}_${u?d:""}_${c.length}_${y}_${b}_${g}_${h}_${p}_${f}_${v}_${o}`}else{let l=i.isUniform?"uniform":i.texData.texShape;r+=`${i.shape}_${l}_${o}`}});let s=e.userCode,a=e.constructor.name;return a+="_"+r+"_"+s+`${xe().getNumber("WEBGL_VERSION")}`,a}function zs(e){return xe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}var xft=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=o0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=la();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?u$(["r","c","d"],e):em(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}},wft=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=o0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=la();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?u$(["r","c","d"],e):em(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}},kft=class{constructor(e){this.variableNames=["A"],this.outTexUsage=hi.DOWNLOAD;let t=la();this.outputShape=e,this.userCode=`
      ${wse}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}},Sft=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=hi.DOWNLOAD;let t=la();this.outputShape=e,this.userCode=`
      ${wse}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}},Ift={R:0,G:1,B:2,A:3},M5=class{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];let r=la();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){let o=n[i];a+=`
          if(offset == ${i}) {
            result = values[${Ift[o]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?nz():tz(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${r.texture2D}(A, uv);
          ${a}
        }
        ${r.output} = vec4(${s}, 0., 0., 0.);
      }
    `}},Cft=class{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=la();this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let r="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let o=a*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${o}] = values[0];
            } else if (offset == 1) {
              result[${o}] = values[1];
            } else if (offset == 2) {
              result[${o}] = values[2];
            } else {
              result[${o}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?nz():tz(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${n.output} = ${s};
        }
    `}},Nse={};At(Nse,{bindVertexProgramAttributeStreams:()=>Fse,createBufferFromOutputTexture:()=>Lse,createFloat16MatrixTexture:()=>Ase,createFloat16PackedMatrixTexture:()=>Ose,createFloat32MatrixTexture:()=>_se,createIndexBuffer:()=>Ese,createPackedMatrixTexture:()=>Dse,createUnsignedBytesMatrixTexture:()=>Rse,createVertexBuffer:()=>$se,createVertexShader:()=>Tse,downloadByteEncodedFloatMatrixFromOutputTexture:()=>Bse,downloadFloat32MatrixFromBuffer:()=>zse,downloadMatrixFromPackedOutputTexture:()=>Vse,downloadPackedMatrixFromBuffer:()=>Wse,getInternalFormatForFloat16MatrixTexture:()=>az,getInternalFormatForFloat16PackedMatrixTexture:()=>lz,getInternalFormatForFloat32MatrixTexture:()=>sz,getInternalFormatForPackedMatrixTexture:()=>oz,getInternalFormatForUnsignedBytesMatrixTexture:()=>iz,uploadDenseMatrixToTexture:()=>Mse,uploadPixelDataToTexture:()=>Pse});function Tse(e){let t=la(),n=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Qre(e,n)}function $se(e){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return rse(e,t)}function Ese(e){let t=new Uint16Array([0,1,2,2,1,3]);return sse(e,t)}function Uw(e,t,n,r,s,a){ise(t,n);let i=ase(e),o=e.TEXTURE_2D;return et(e,()=>e.bindTexture(o,i)),et(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE)),et(e,()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE)),et(e,()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST)),et(e,()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST)),xe().getNumber("WEBGL_VERSION")===1?et(e,()=>e.texImage2D(o,0,r,t,n,0,s,a,null)):et(e,()=>e.texStorage2D(o,1,r,t,n)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null)),{texture:i,texShape:[n,t]}}function sz(e){return e.internalFormatFloat}function _se(e,t,n,r){let[s,a]=Vw(t,n);return Uw(e,s,a,sz(r),r.textureFormatFloat,e.FLOAT)}function az(e){return e.internalFormatHalfFloat}function Ase(e,t,n,r){let[s,a]=Vw(t,n);return Uw(e,s,a,az(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function iz(e){return e.downloadTextureFormat}function Rse(e,t,n,r){let[s,a]=Vw(t,n);return Uw(e,s,a,iz(r),e.RGBA,e.UNSIGNED_BYTE)}function oz(e){return e.internalFormatPackedFloat}function Dse(e,t,n,r){let[s,a]=Kb(t,n);return Uw(e,s,a,oz(r),e.RGBA,e.FLOAT)}function lz(e){return e.internalFormatPackedHalfFloat}function Ose(e,t,n,r){let[s,a]=Kb(t,n);return Uw(e,s,a,lz(r),e.RGBA,r.textureTypeHalfFloat)}function Fse(e,t,n){return et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,n)),UR(e,t,"clipSpacePos",n,3,20,0)&&UR(e,t,"uv",n,2,20,12)}function Mse(e,t,n,r,s,a){et(e,()=>e.bindTexture(e.TEXTURE_2D,t));let i,o,l;s instanceof Uint8Array?(i=new Uint8Array(n*r*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(i=new Float32Array(n*r*4),o=e.FLOAT,l=a.internalFormatPackedFloat),i.set(s),xe().getNumber("WEBGL_VERSION")===2?et(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,r,e.RGBA,o,i)):et(e,()=>e.texImage2D(e.TEXTURE_2D,0,l,n,r,0,e.RGBA,o,i)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Pse(e,t,n){et(e,()=>e.bindTexture(e.TEXTURE_2D,t)),n.data instanceof Uint8Array?xe().getNumber("WEBGL_VERSION")===2?et(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data)):et(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data)):xe().getNumber("WEBGL_VERSION")===2?et(e,()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n)):et(e,()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)),et(e,()=>e.bindTexture(e.TEXTURE_2D,null))}function Lse(e,t,n,r){let s=e.createBuffer();et(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s));let a=4*4*t*n;return et(e,()=>e.bufferData(e.PIXEL_PACK_BUFFER,a,e.STREAM_READ)),et(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0)),et(e,()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null)),s}function zse(e,t,n){let r=e,s=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,s),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),s}function Bse(e,t,n,r){let[s,a]=Vw(t,n),i=4,o=new Uint8Array(wpt(t*n,i));return et(e,()=>e.readPixels(0,0,s,a,r.downloadTextureFormat,e.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function Wse(e,t,n,r,s,a,i,o){let l=e,u=new Float32Array(kpt(a,i));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}function Vse(e,t,n){let r=new Float32Array(t*n*4);return et(e,()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,r)),r}var $2=class{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];let t=xe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,Yre(t,e)):this.gl=Uo(t),e=this.gl,xe().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>et(s,()=>s.createVertexArray()),this.bindVertexArray=a=>et(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>et(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>et(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>et(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>et(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>et(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>et(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",r="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),xe().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=jv(this.gl,s),pi(this.gl,a))this.textureHalfFloatExtension=jv(this.gl,a);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),pi(this.gl,r))this.colorBufferHalfFloatExtension=jv(this.gl,r);else if(xe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",pi(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(pi(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=$se(this.gl),this.indexBuffer=Ese(this.gl),this.framebuffer=ose(this.gl),this.textureConfig=Q4(this.gl,this.textureHalfFloatExtension)}get debug(){return xe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;et(e,()=>e.finish()),et(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),et(e,()=>e.deleteFramebuffer(this.framebuffer)),et(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),et(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),et(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),_se(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Ase(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Rse(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Pse(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,r){this.throwIfDisposed(),Mse(this.gl,e,t,n,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Ose(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Dse(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(jR(this.gl,this.framebuffer),this.outputTexture=null),et(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Bse(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,r,s,a){return Wse(this.gl,e,t,n,r,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return zse(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let r=Lse(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(xe().getBool("WEBGL_FENCE_API_ENABLED")){let r=e,s=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=r.clientWaitSync(s,0,0);return a===r.ALREADY_SIGNALED||a===r.CONDITION_SATISFIED},t=s}else xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Vse(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=Tse(t));let n=tse(t);et(t,()=>t.attachShader(n,this.vertexShader)),et(t,()=>t.attachShader(n,e)),nse(t,n);let r=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&I2(t,r),r}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);let t=this.gl;et(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),Fse(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(et(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&I2(this.gl,this.program),et(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?use(this.gl,e,t):cse(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),et(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),dse(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[r,s]=Kb(t,n);this.setOutputMatrixTextureDriver(e,r,s)}setOutputMatrixWriteRegion(e,t,n,r){this.setOutputMatrixWriteRegionDriver(n,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,n,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&I2(this.gl,this.program),Gv(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}et(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),et(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=jv(this.gl,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(r.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await M.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,r=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),r=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=Nft(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in xe().platform&&(n=xe().platform.setTimeoutCustom.bind(xe().platform)),M.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),C2(this.gl,e,this.framebuffer),this.debug&&Gv(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(C2(this.gl,this.outputTexture,this.framebuffer),this.debug&&Gv(this.gl)):jR(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let r=this.gl;C2(r,e,this.framebuffer),this.debug&&Gv(r),this.outputTexture=e,et(r,()=>r.viewport(0,0,t,n)),et(r,()=>r.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,r){this.throwIfDisposed(),et(this.gl,()=>this.gl.scissor(e,t,n,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Nft(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}var{addImpl:Tft,bincountImpl:Use,bincountReduceImpl:$ft,bitwiseAndImpl:Eft,castImpl:_ft,ceilImpl:Aft,concatImpl:Rft,equalImpl:Dft,expImpl:Oft,expm1Impl:Fft,floorImpl:Mft,gatherNdImpl:Pft,gatherV2Impl:Lft,greaterImpl:zft,greaterEqualImpl:Bft,lessImpl:Wft,lessEqualImpl:Vft,linSpaceImpl:Uft,logImpl:jft,maxImpl:Gft,maximumImpl:Hft,minimumImpl:qft,multiplyImpl:Kft,negImpl:Xft,notEqualImpl:Yft,prodImpl:Jft,raggedGatherImpl:Zft,raggedRangeImpl:Qft,raggedTensorToTensorImpl:emt,rangeImpl:tmt,rsqrtImpl:nmt,scatterImpl:rmt,sigmoidImpl:smt,simpleAbsImpl:jse,sliceImpl:amt,sparseFillEmptyRowsImpl:imt,sparseReshapeImpl:omt,sparseSegmentReductionImpl:Gse,sqrtImpl:lmt,staticRegexReplaceImpl:umt,stridedSliceImpl:cmt,stringNGramsImpl:dmt,stringSplitImpl:hmt,stringToHashBucketFastImpl:pmt,subImpl:fmt,tileImpl:mmt,topKImpl:gmt,transposeImpl:uz,uniqueImpl:ymt}=P4;function Hse(e,t){return["x","y","z","w","u","v"].slice(0,t).map(n=>`${e}.${n}`)}function Xs(e,t){return t===1?[e]:Hse(e,t)}function bmt(e,t){if(e===1)return"rc";let n="";for(let r=0;r<e;r++)n+=t[r],r<e-1&&(n+=",");return n}var vmt=class{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=zs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=Xs("rc",this.rank),n=Tn(this.rank),r=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let r=0;r<=1;r++){let s=`${n===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}},qse=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let n="";for(let r=0;r<4;r++){let s="thisRC = rc;";r%2===1&&(s+="thisRC.z += 1;"),r>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${xmt(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?nz():tz(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function xmt(e,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?Opt(["r","c","d"],"inputShape"):em(["r","c","d"],e)}
      return ivec3(r, c, d);
    }
  `}var wmt=class{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){let r=L5(t,n),s=z5(e,r,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=P5(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let o=this.freeTextures[s].pop();return this.usedTextures[s].push(o),o}let i;return r===xs.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===xs.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===xs.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===xs.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===xs.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,r){if(this.freeTextures==null)return;let s=L5(n,r),a=z5(t,s,r);a in this.freeTextures||(this.freeTextures[a]=[]);let i=P5(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,r),o=xe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");o!==-1&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[a],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function kmt(e,t){let n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F||t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function P5(e,t,n,r,s){let a=Smt(t,r),i;if(s){let[l,u]=Kb(e[0],e[1]);i=l*u}else{let[l,u]=Vw(e[0],e[1]);i=l*u}let o=kmt(n,a);return i*o}function Smt(e,t){switch(e){case xs.PACKED_2X2_FLOAT32:return oz(t);case xs.PACKED_2X2_FLOAT16:return lz(t);case xs.UNPACKED_FLOAT32:return sz(t);case xs.UNPACKED_FLOAT16:return az(t);case xs.PACKED_4X1_UNSIGNED_BYTE:return iz(t);default:throw new Error(`Unknown physical texture type ${e}`)}}function Imt(e){return xe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?xs.PACKED_2X2_FLOAT32:xs.UNPACKED_FLOAT32:e?xs.PACKED_2X2_FLOAT16:xs.UNPACKED_FLOAT16}function L5(e,t){if(e===hi.UPLOAD)return xs.PACKED_2X2_FLOAT32;if(e===hi.RENDER||e==null)return Imt(t);if(e===hi.DOWNLOAD||e===hi.PIXELS)return xs.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function z5(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}var yl=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},oo="if (isnan(x)) return x;",Cmt="return x;",B5="return abs(x);",Nmt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Tmt=oo+`
  return (x < 0.0) ? 0.0 : x;
`,$mt=oo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Xu="return x;",Emt="return 1.0 / (1.0 + exp(-1.0 * x));",_mt="return x;",Amt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Rmt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dmt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Omt="return 1.0 / (1.0 + exp(-1.0 * x));",uc=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}},Fmt=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let t=e.length,n=Xs("rc",t),r=Tn(t),s=bmt(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}},Mmt=Vl.whereImpl,Pmt=1e-7,Lmt=1e-4,GE={};function zmt(e){return e in GE||(GE[e]={}),GE[e]}var Bmt=xe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Wmt=600;function Vmt(){return xe().global.screen==null?1024:xe().global.screen.height*xe().global.screen.width*window.devicePixelRatio*Wmt/1024/1024}var cz=class Kse extends jx{nextDataId(){return Kse.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!xe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(t!=null){if(t instanceof $2)n=t;else{let r=Uo(xe().getNumber("WEBGL_VERSION"),t);n=new $2(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let r=Uo(xe().getNumber("WEBGL_VERSION"));n=new $2(r),this.binaryCache=zmt(xe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new wmt(this.gpgpu),this.numMBBeforeWarning=Vmt(),this.texData=new VN(this,Fi())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,n,r,s,a,i){let o=this.makeTensorInfo(n,r),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:t,texShape:[s,a]},l.texShape=[s,a];let u=Hv(n),c=new M5(u,!1,i),d=this.runWebGLProgram(c,[o],r,[[s,a]]);return d.shape=n,l.texture=null,this.disposeIntermediateTensorInfo(o),d.dataId}write(t,n,r){if((xe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||xe().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:r,values:t,usage:hi.UPLOAD,refCount:1}),s}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){let n=this.texData.get(t);n.refCount++}decRef(t){if(this.texData.has(t)){let n=this.texData.get(t);n.refCount--}}move(t,n,r,s,a){if(xe().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:s,values:n,usage:hi.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){let n=this.texData.get(t),{values:r,dtype:s,complexTensorInfos:a,slice:i,shape:o,isPacked:l}=n;if(i!=null){let h;l?h=new uc(o,Xu):h=new yl(o,Xu);let p=this.runWebGLProgram(h,[{dataId:t,shape:o,dtype:s}],s),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(r!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return r;let u=this.activeTimers!=null,c;u&&(c=M.now());let d;if(s==="complex64"){let h=this.readSync(a.real.dataId),p=this.readSync(a.imag.dataId);d=H.mergeRealAndImagArrays(h,p)}else d=this.getValuesFromTexture(t);return u&&(this.downloadWaitMs+=M.now()-c),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){let f=this.pendingRead.get(t);return new Promise(m=>f.push(m))}let n=this.texData.get(t),{values:r,shape:s,slice:a,dtype:i,complexTensorInfos:o,isPacked:l}=n;if(a!=null){let f;l?f=new uc(s,Xu):f=new yl(s,Xu);let m=this.runWebGLProgram(f,[{dataId:t,shape:s,dtype:i}],i),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(r!=null)return this.convertAndCacheOnCPU(t);if(xe().getBool("DEBUG")&&!xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&xe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let u=null,c;if(i!=="complex64"&&xe().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(t);let f=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(f.texture.texture,...Xk(s))}this.pendingRead.set(t,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(i==="complex64"){let f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),m=f[0],g=f[1];d=H.mergeRealAndImagArrays(m,g)}else if(u==null)d=this.getValuesFromTexture(t);else{let f=M.sizeFromShape(s);d=this.gpgpu.downloadFloat32MatrixFromBuffer(u,f)}if(c!=null&&this.disposeIntermediateTensorInfo(c),u!=null){let f=this.gpgpu.gl;et(f,()=>f.deleteBuffer(u))}let h=this.convertAndCacheOnCPU(t,d),p=this.pendingRead.get(t);return this.pendingRead.delete(t),p.forEach(f=>f(h)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&Fi().removeDataId(t,this),this.pendingDeletes--),h}readToGPU(t,n={}){let r=this.texData.get(t),{values:s,shape:a,slice:i,dtype:o,isPacked:l,texture:u}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let p;l?p=new uc(a,Xu):p=new yl(a,Xu);let f=this.runWebGLProgram(p,[{dataId:t,shape:a,dtype:o}],o),m=this.readToGPU(f,n);return this.disposeIntermediateTensorInfo(f),m}if(u==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let c=this.decode(t,n.customTexShape),d=Fi().makeTensorFromTensorInfo(c),h=this.texData.get(c.dataId);return Object.assign({tensorRef:d},h.texture)}bufferSync(t){let n=this.readSync(t.dataId);if(t.dtype==="string")try{let r=n.map(s=>M.decodeString(s));return zt(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return zt(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let n=0;n<t.length;n++){let r=t[n];if(!Jre(r))throw xe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:n,dtype:r,isPacked:s}=this.texData.get(t),a=M.sizeFromShape(n);if(xe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let h=this.decode(t),p=this.texData.get(h.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...Xk(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(h),f}let i=xe().getBool("WEBGL_PACK")&&s===!0,o=i?Hv(n):n,l=i?new Sft(o):new kft(o),u=this.runWebGLProgram(l,[{shape:o,dtype:r,dataId:t}],"float32"),c=this.texData.get(u.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(c.texture.texture,c.texShape[0],c.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(u),d}timerAvailable(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){let n=this.activeTimers,r=[],s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,t();let a=M.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=M.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let l=await Promise.all(a);o.kernelMs=M.sum(l),o.getExtraProfileInfo=()=>l.map((u,c)=>({name:i[c],ms:u})).map(u=>`${u.name}: ${u.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:M.now(),endMs:null}}endTimer(t){return xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=M.now(),t)}async getQueryTime(t){if(xe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let n=t;return n.endMs-n.startMs}disposeData(t,n=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(n?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!n&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);let{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(t),!0}releaseGPUData(t){let{texture:n,dtype:r,texShape:s,usage:a,isPacked:i,slice:o}=this.texData.get(t),l=o&&o.origDataId||t,u=this.dataRefCount.get(l);u>1?this.dataRefCount.set(l,u-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,r),this.textureManager.releaseTexture(n,s,a,i)));let c=this.texData.get(t);c.texture=null,c.texShape=null,c.isPacked=!1,c.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,n=Bmt){return xe().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&M.sizeFromShape(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(t){H.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=t.dataSync();return Mmt(t.shape,n)}packedUnaryOp(t,n,r){let s=new uc(t.shape,n),a=this.compileAndRun(s,[t],r);return Fi().makeTensorFromTensorInfo(a)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let s=jse(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,s)}if(xe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,B5,t.dtype);let n=new yl(t.shape,B5),r=this.compileAndRun(n,[t]);return Fi().makeTensorFromTensorInfo(r)}makeTensorInfo(t,n,r){let s;if(n==="string"&&r!=null&&r.length>0&&M.isString(r[0])){let a=r.map(i=>M.encodeString(i));s=this.write(a,t,n)}else s=this.write(r,t,n);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:n}}makeOutput(t,n,r){return Fi().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,r),this)}unpackTensor(t){let n=new Fmt(t.shape);return this.runWebGLProgram(n,[t],t.dtype)}packTensor(t){let n=new vmt(t.shape);return this.runWebGLProgram(n,[t],t.dtype,null,!0)}packedReshape(t,n){let r=[ap(t.shape),...ip(t.shape)],s={dtype:t.dtype,shape:r,dataId:t.dataId},a=[ap(n),...ip(n)],i=new qse(a,r),o=!0,l=[r],u=this.runWebGLProgram(i,[s],t.dtype,l,o);return{dataId:u.dataId,shape:n,dtype:u.dtype}}decode(t,n){let r=this.texData.get(t),{isPacked:s,shape:a,dtype:i}=r;if(n!=null){let h=M.sizeFromShape(a),p=n[0]*n[1]*4;M.assert(h<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let o=Hv(a),l;s?l=new wft(o):l=new xft(o);let u=!0,c=[n??Xk(o)],d=this.runWebGLProgram(l,[{shape:o,dtype:i,dataId:t}],i,c,u,n);return{dtype:i,shape:a,dataId:d.dataId}}runWebGLProgram(t,n,r,s,a=!1,i){let o=this.makeTensorInfo(t.outputShape,r),l=this.texData.get(o.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===o0.DENSE){let y=i??Xk(t.outputShape);l.texShape=y.map(b=>b*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),M.sizeFromShape(o.shape)===0)return l.values=M.getTypedArrayFromDType(o.dtype,0),o;let u=[],c=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!t.packedInputs&&M.sizeFromShape(y.shape)<=xe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};t.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!t.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),u.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!l0(b.shape,y.shape)){let x=y,v=y.shape;y.shape=b.shape,y=this.packedReshape(y,v),u.push(y),b=this.texData.get(y.dataId),x.shape=v}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);let d={shape:o.shape,texData:l,isUniform:!1},h=vft(t,c,d),p=this.getAndSaveBinary(h,()=>yft(this.gpgpu,t,c,d)),f=this.activeTimers!=null,m;f&&(m=this.startTimer()),xe().get("ENGINE_COMPILE_ONLY")||bft(this.gpgpu,p,c,d,s),u.forEach(y=>this.disposeIntermediateTensorInfo(y)),f&&(m=this.endTimer(m),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(m)}));let g=xe().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){let y=M.now();y-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!xe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&a===!1){let y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(t,n,r,s,a=!1){return r=r||n[0].dtype,this.runWebGLProgram(t,n,r,s,a)}getAndSaveBinary(t,n){return t in this.binaryCache||(this.binaryCache[t]=n()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(xe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ue(()=>{if(!xe().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=xe().getBool("DEBUG");xe().set("DEBUG",!1);let n=this.abs(bt(1e-8)).dataSync()[0];if(xe().set("DEBUG",t),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Pmt:Lmt}uploadToGPU(t){let n=this.texData.get(t),{shape:r,dtype:s,values:a,texture:i,usage:o,isPacked:l}=n;if(i!=null)return;let u=this.activeTimers!=null,c;u&&(c=M.now());let d=n.texShape;if(d==null&&(d=fse(r,l),n.texShape=d),a!=null){let h=Hv(r),p,f=d[1],m=d[0],g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(l||!g)&&([f,m]=Kb(d[0],d[1])),l?p=new Cft(h,g):p=new M5(h,g);let y=g?[m,f]:d,b=this.makeTensorInfo(y,s),x=this.texData.get(b.dataId);g?x.usage=hi.PIXELS:x.usage=hi.UPLOAD,x.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,m,a);let v=[[m,f]],w=this.runWebGLProgram(p,[b],s,v,!0),k=this.texData.get(w.dataId);n.texShape=k.texShape,n.isPacked=k.isPacked,n.usage=k.usage,xe().get("ENGINE_COMPILE_ONLY")?this.disposeData(w.dataId):(n.texture=k.texture,n.values=null,this.texData.delete(w.dataId)),this.disposeIntermediateTensorInfo(b),u&&(this.uploadWaitMs+=M.now()-c)}else{let h=this.acquireTexture(d,o,s,l);n.texture=h}}convertAndCacheOnCPU(t,n){let r=this.texData.get(t),{dtype:s}=r;return n!=null&&(r.values=Umt(n,s)),r.values}acquireTexture(t,n,r,s){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,n,s)}computeBytes(t,n){return t[0]*t[1]*M.bytesPerElement(n)}checkCompileCompletion(){for(let[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){let t=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(n));return Promise.all(t)}else{for(let[,n]of Object.entries(this.binaryCache)){let r=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await QP(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(ez(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);let{variablesLocations:n,customUniformLocations:r,infLoc:s,nanLoc:a,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:l}=Cse(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=n,t.customUniformLocations=r,t.infLoc=s,t.nanLoc=a,t.outShapeLocation=i,t.outShapeStridesLocation=o,t.outTexShapeLocation=l}}createTensorFromGPUData(t,n,r){t.channels=t.channels||"RGBA";let{texture:s,height:a,width:i,channels:o}=t,l=Fi().backend;if(!l.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let u=l.writeTexture(s,n,r,a,i,o);return Fi().makeTensorFromDataId(u,n,r,l)}};cz.nextDataId=0;function Umt(e,t){if(t==="float32"||t==="complex64")return e;if(t==="int32"||t==="bool"){let n=t==="int32"?new Int32Array(e.length):new Uint8Array(e.length);for(let r=0;r<n.length;++r)n[r]=Math.round(e[r]);return n}else throw new Error(`Unknown dtype ${t}`)}var jmt="4.16.0";function Xse(){xe().set("WEBGL_FORCE_F16_TEXTURES",!0)}gw.isBrowser()&&iT("webgl",()=>new cz,2);var Gmt={forceHalfFloat:Xse},dz=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,op=class{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=H.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=zs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}},nm=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`,ev=class{constructor(e,t,n,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=H.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=zs(s);let a="";if(r)if(s===0||M.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Tn(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let i=Xs("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${i[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${i[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ti(e){let{inputs:t,backend:n}=e,{x:r}=t;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}var Hmt={kernelName:rf,backendName:"webgl",kernelFunc:ti};function Id(e){let{inputs:t,backend:n}=e,{real:r,imag:s}=t,a=n.makeTensorInfo(r.shape,"complex64"),i=n.texData.get(a.dataId),o=ti({inputs:{x:r},backend:n}),l=ti({inputs:{x:s},backend:n});return i.complexTensorInfos={real:o,imag:l},a}var qmt={kernelName:GN,backendName:"webgl",kernelFunc:Id},Yse="return (a < 0.) ? b * a : a;",Jse=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Kmt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{alpha:a}=r,i=n.makeTensorInfo([],"float32",M.createScalarValue(a,"float32")),o=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ev(Jse,s.shape,i.shape):new op(Yse,s.shape,i.shape),l=n.runWebGLProgram(o,[s,i],"float32");return n.disposeIntermediateTensorInfo(i),l}var Xmt={kernelName:lf,backendName:"webgl",kernelFunc:Kmt},Zse="return (a < 0.) ? b * a : a;",Qse=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Ymt(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ev(Qse,r.shape,s.shape):new op(Zse,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],"float32")}var Jmt={kernelName:If,backendName:"webgl",kernelFunc:Ymt},tv="if (isnan(x)) return x;";function tn({opSnippet:e,packedOpSnippet:t,cpuKernelImpl:n,dtype:r}){return({inputs:s,backend:a})=>{let{x:i}=s,o=a,l=r||i.dtype;if(o.shouldExecuteOnCPU([i])&&n!=null){let d=o.texData.get(i.dataId),h=n(d.values,l);return o.makeTensorInfo(i.shape,l,h)}let u=xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,c;return u?c=new uc(i.shape,t):c=new yl(i.shape,e),o.runWebGLProgram(c,[i],l)}}function $s({opSnippet:e,packedOpSnippet:t,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:a}){return({inputs:i,backend:o})=>{let{a:l,b:u}=i,c=o;if(r&&l.dtype==="complex64"){let f=c.texData.get(l.dataId),m=c.texData.get(u.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(x=>{let[v,w]=x,k={dataId:v.dataId,dtype:v.dtype,shape:l.shape},S={dataId:w.dataId,dtype:w.dtype,shape:u.shape},I=new op(e,l.shape,u.shape);return c.runWebGLProgram(I,[k,S],ki(v.dtype,w.dtype))}),b=Id({inputs:{real:g,imag:y},backend:c});return c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(y),b}let d=a||ki(l.dtype,u.dtype);if((l.dtype==="string"||u.dtype==="string"||c.shouldExecuteOnCPU([l,u]))&&s!=null){let f=c.texData.get(l.dataId).values,m=c.texData.get(u.dataId).values,g=l.dtype==="string"?H.fromUint8ToStringArray(f):f,y=l.dtype==="string"?H.fromUint8ToStringArray(m):m,[b,x]=s(l.shape,u.shape,g,y,d),v=c.makeTensorInfo(x,d),w=c.texData.get(v.dataId);return w.values=b,v}let h=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,p;return h?p=new ev(t,l.shape,u.shape,n):p=new op(e,l.shape,u.shape),c.runWebGLProgram(p,[l,u],d)}}function u0(e,t=!1){if(e==="linear")return t?_mt:Cmt;if(e==="relu")return t?Rmt:Tmt;if(e==="elu")return t?Amt:Nmt;if(e==="relu6")return t?Dmt:$mt;if(e==="prelu")return t?Qse:Zse;if(e==="leakyrelu")return t?Jse:Yse;if(e==="sigmoid")return t?Omt:Emt;throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}var eae=class{constructor(e,t,n,r=!1,s=!1,a=!1,i=null,o=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=zs(this.outputShape.length);let u=r?e[1]:e[2],c=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",g="";i&&(o?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:m=`vec4 activation(vec4 x) {
          ${i}
        }`,g="result = activation(result);");let y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",x="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(x=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${x};
        for (int i = 0; i < ${c}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${f[0]});
          result += (${p[1]} * ${f[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${g}

        setOutput(result);
      }
    `}},W5={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},V5=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=H.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}},U5="return a * b;";function hz(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=H.upcastType(r.dtype,s.dtype);if(r.dtype==="complex64"){let o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),u=new V5(W5.REAL,r.shape,s.shape),c=new V5(W5.IMAG,r.shape,s.shape),d=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:s.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:s.shape}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=Id({inputs:{real:h,imag:p},backend:n});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}if(n.shouldExecuteOnCPU([r,s])){let o=n.texData.get(r.dataId),l=n.texData.get(s.dataId),[u,c]=Kft(r.shape,s.shape,o.values,l.values,a),d=n.makeTensorInfo(c,a),h=n.texData.get(d.dataId);return h.values=u,d}let i;return xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new ev(U5,r.shape,s.shape):i=new op(U5,r.shape,s.shape),n.runWebGLProgram(i,[r,s],a)}var Zmt={kernelName:xf,backendName:"webgl",kernelFunc:hz};function Qmt(e,t,n){let r=[ap(e.shape),...ip(e.shape)],s={dtype:e.dtype,shape:r,dataId:e.dataId},a=[ap(t),...ip(t)],i=new qse(a,r),o=!0,l=[r],u=n.runWebGLProgram(i,[s],e.dtype,l,o);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function Qe(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{shape:a}=r,i=n,o=M.sizeFromShape(s.shape),l=M.inferFromImplicitShape(a,o),u=M.sizeFromShape(l);M.assert(o===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);let c=i.texData.get(s.dataId);return c.isPacked&&!l0(s.shape,l)&&!(c.texture!==null&&l0(c.shape,l))?Qmt(s,l,i):(i.incRef(s.dataId),{dataId:s.dataId,shape:l,dtype:s.dtype})}var egt={kernelName:vb,backendName:"webgl",kernelFunc:Qe},j5=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i=Math.floor(n/4)*4,o=n%4,l="sumValue += dot(values, ones);";if(t!=null){let c=1/t;l=`sumValue += dot(values * ${M.isInt(c)?c.toPrecision(2):c}, ones);`}let u="";s%n>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${o===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${o===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${o===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}},tgt=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:r,inSize:s,outSize:a}=e;this.outputShape=[r,a];let i="0.0",o="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",o="min"):t==="max"&&(i="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let u=Math.floor(n/4)*4,c=n%4,d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${o}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${o}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(i="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(i="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${c===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function ngt(e){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let n=t.length?t[t.length-1].outSize:e[1],r=H.computeOptimalWindowSize(n);t.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return t}function rm(e,t,n,r){let s=ngt(e.shape),a=e;for(let i=0;i<s.length;i++){let{inSize:o,windowSize:l,outSize:u}=s[i],c,d;n==="mean"?c=i===0?new j5({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new j5({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):c=new tgt({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),d=a,a=r.runWebGLProgram(c,[a],t),d.dataId!==e.dataId&&r.disposeIntermediateTensorInfo(d)}return a}var rgt=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let r=Tn(this.rank),s=sgt(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function sgt(e){let t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let s=0;s<e.length;s++)r[e[s]]=n[s];return r.join()}var agt=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let r=Tn(this.rank),s=Hse("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];let i=`vec2(${a.slice(-2).join()})`,o=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${o}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${o}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function c$(e,t,n){let r=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new agt(e.shape,t):new rgt(e.shape,t);return n.runWebGLProgram(r,[e],e.dtype)}function igt(e,t,n,r){let s=t,a=e.shape.length,i=M.parseAxisParam(s,e.shape),o=i,l=H.getAxesPermutation(o,a),u=l!=null,c=e;u&&(c=c$(e,l,r),o=H.getInnerMostAxes(o.length,a)),H.assertAxesAreInnerMostDims("sum",o,a);let[d,h]=H.computeOutAndReduceShapes(c.shape,o),p=d;n&&(p=H.expandShapeToKeepDim(d,i));let f=M.sizeFromShape(h),m=M.sizeFromShape(e.shape)/f,g=Qe({inputs:{x:c},attrs:{shape:[m,f]},backend:r}),y=aT(e.dtype),b=rm(g,y,"sum",r),x=Qe({inputs:{x:b},attrs:{shape:p},backend:r});return r.disposeIntermediateTensorInfo(g),r.disposeIntermediateTensorInfo(b),u&&r.disposeIntermediateTensorInfo(c),x}function d$(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r;return igt(s,a,i,n)}var ogt={kernelName:Wf,backendName:"webgl",kernelFunc:d$};function na(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{perm:a}=r,i=n,o=s.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=s.shape[a[c]];let u;if(i.shouldExecuteOnCPU([s])){let c=i.texData.get(s.dataId).values,d=uz(c,s.shape,s.dtype,a,l);u=i.makeTensorInfo(l,s.dtype);let h=i.texData.get(u.dataId);h.values=d}else u=c$(s,a,i);return u}var lgt={kernelName:au,backendName:"webgl",kernelFunc:na},tae=1e3;function bI({a:e,b:t,transposeA:n,transposeB:r,backend:s,bias:a=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:l=null}){let u=e.shape.length,c=t.shape.length,d=n?e.shape[u-2]:e.shape[u-1],h=r?t.shape[c-1]:t.shape[c-2],p=n?e.shape[u-1]:e.shape[u-2],f=r?t.shape[c-2]:t.shape[c-1],m=e.shape.slice(0,-2),g=t.shape.slice(0,-2),y=M.sizeFromShape(m),b=M.sizeFromShape(g),x=Pb.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([p,f]);M.assert(d===h,()=>`Error in matMul: inner shapes (${d}) and (${h}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${r} must match.`);let v=n?[y,d,p]:[y,p,d],w=r?[b,f,h]:[b,h,f],k=Qe({inputs:{x:e},backend:s,attrs:{shape:v}}),S=Qe({inputs:{x:t},backend:s,attrs:{shape:w}}),I=[k,S],$=Math.max(y,b),C=n?k.shape[1]:k.shape[2],T=a!=null,N=i!=null,E=l==="leakyrelu",_=l!=null?u0(l,!0):null,R=T||N||E||_!=null,z;if((p===1||f===1)&&C>tae&&R===!1){let F=k,L=S;n&&(F=na({inputs:{x:k},backend:s,attrs:{perm:[0,2,1]}}),I.push(F)),r&&(L=na({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),I.push(L));let O=f!==1,D=f===1,B=F;O&&(B=Qe({inputs:{x:F},backend:s,attrs:{shape:[$,C,1]}}),I.push(B));let V=f===1?2:1,K=L;D&&(K=Qe({inputs:{x:L},backend:s,attrs:{shape:[$,1,C]}}),I.push(K));let G=hz({inputs:{a:B,b:K},backend:s});z=d$({inputs:{x:G},backend:s,attrs:{axis:V,keepDims:!0}}),I.push(G)}else{let F=ki(e.dtype,t.dtype),L=new eae(v,w,[$,p,f],n,r,T,_,N,E),O=[k,S];if(a!=null&&O.push(a),N&&O.push(i),E){let D=s.makeTensorInfo([],"float32",M.createScalarValue(o,"float32"));O.push(D),I.push(D)}z=s.runWebGLProgram(L,O,F)}let W=Qe({inputs:{x:z},backend:s,attrs:{shape:x}});I.push(z);for(let F of I)s.disposeIntermediateTensorInfo(F);return W}function ugt(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r;return bI({a:s,b:a,transposeA:l,transposeB:u,backend:n,bias:i,preluActivationWeights:o,leakyreluAlpha:d,activation:c})}var cgt={kernelName:Uh,backendName:"webgl",kernelFunc:ugt},G5="return abs(x);";function dgt(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){let a=n.texData.get(r.dataId),i=jse(a.values);return n.makeTensorInfo(r.shape,r.dtype,i)}let s;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new uc(r.shape,G5):s=new yl(r.shape,G5),n.runWebGLProgram(s,[r],r.dtype)}var hgt={kernelName:Fy,backendName:"webgl",kernelFunc:dgt},pgt=oo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,fgt=tn({opSnippet:pgt}),mgt={kernelName:Tp,backendName:"webgl",kernelFunc:fgt},ggt=oo+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,ygt=tn({opSnippet:ggt}),bgt={kernelName:$p,backendName:"webgl",kernelFunc:ygt},H5="return a + b;",vgt=$s({opSnippet:H5,packedOpSnippet:H5,supportsComplex:!0,cpuKernelImpl:Tft}),xgt={kernelName:fd,backendName:"webgl",kernelFunc:vgt},wgt=class{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}},kgt=class{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let r=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}};function E2(e){let{inputs:t,backend:n}=e,r=t;if(r.length===1)return ti({inputs:{x:r[0]},backend:n});if(r.length>xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let o=Math.floor(r.length/2),l=E2({inputs:r.slice(0,o),backend:n}),u=E2({inputs:r.slice(o),backend:n});return E2({inputs:[l,u],backend:n})}let s=r.map(o=>o.dtype).reduce((o,l)=>ki(o,l)),a=r.map(o=>o.shape),i=xe().getBool("WEBGL_PACK")?new kgt(r[0].shape,a):new wgt(r[0].shape,a);return n.runWebGLProgram(i,r,s)}var Sgt={kernelName:Ep,backendName:"webgl",kernelFunc:E2};function Igt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=M.parseAxisParam(a,s.shape),u=l,c=H.getAxesPermutation(u,o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),u=H.getInnerMostAxes(u.length,o)),H.assertAxesAreInnerMostDims("all",u,o);let[h,p]=H.computeOutAndReduceShapes(d.shape,u),f=M.sizeFromShape(p),m=Qe({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=rm(m,m.dtype,"all",n),y;if(i){let b=H.expandShapeToKeepDim(h,l);y=Qe({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Qe({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}var Cgt={kernelName:My,backendName:"webgl",kernelFunc:Igt};function Ngt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=M.parseAxisParam(a,s.shape),u=l,c=H.getAxesPermutation(u,o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),u=H.getInnerMostAxes(u.length,o)),H.assertAxesAreInnerMostDims("any",u,o);let[h,p]=H.computeOutAndReduceShapes(d.shape,u),f=M.sizeFromShape(p),m=Qe({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=rm(m,m.dtype,"any",n),y;if(i){let b=H.expandShapeToKeepDim(h,l);y=Qe({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Qe({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}var Tgt={kernelName:Py,backendName:"webgl",kernelFunc:Ngt},$gt=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:r,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${o};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}},Egt=class{constructor(e,t,n,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,M.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),r||this.variableNames.push("bestIndicesA");let i=this.outputShape,o=i.length,l=Tn(o),u=Xs("coords",o),c,d;if(a===1){d=o+1;let S=Tn(d);c=`
        ${S} sourceLocR = ${S}(${u.join()}, 0);
        ++${u[o-1]};
        ${S} sourceLocG = ${S}(${u.join()}, 0);
        ++${u[o-2]};
        ${S} sourceLocA = ${S}(${u.join()}, 0);
        --${u[o-1]};
        ${S} sourceLocB = ${S}(${u.join()}, 0);
        --${u[o-2]};`}else d=o,c=`
        ${l} sourceLocR = coords;
        ++${u[o-1]};
        ${l} sourceLocG = coords;
        ++${u[o-2]};
        ${l} sourceLocA = coords;
        --${u[o-1]};
        ${l} sourceLocB = coords;
        --${u[o-2]};`;let h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],f=h.map(S=>"int "+S),m=Xs("sourceLocR",d-1).concat("inIdx.r"),g=Xs("sourceLocG",d-1).concat("inIdx.g"),y=Xs("sourceLocB",d-1).concat("inIdx.b"),b=Xs("sourceLocA",d-1).concat("inIdx.a"),x=n==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()})));`,w=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,k=r?"":`
      float getBestIndicesAChannel(${f.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${f.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${k}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[o-1]} < ${i[o-1]-1};
        bool hasNextRow = ${u[o-2]} < ${i[o-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${x}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function nae(e,t,n,r=null){let s=t.shape[0],a=t.shape[1];r!=null&&(s=r.shape[0],a=r.shape[1]);let i=H.computeOptimalWindowSize(a),o={windowSize:i,inSize:a,batchSize:s,outSize:Math.ceil(a/i)},l=new $gt(o,n,r==null),u=[t];r!=null&&u.push(r);let c=e.runWebGLProgram(l,u,"int32");if(c.shape[1]===1)return c;let d=nae(e,t,n,c);return e.disposeIntermediateTensorInfo(c),d}function rae(e,t,n,r=null){let s=r!=null?r.shape:t.shape,a=s[s.length-1],i=H.computeOptimalWindowSize(a),o=new Egt(s,i,n,r==null),l=r==null?[t]:[t,r],u=e.runWebGLProgram(o,l,"int32");if(u.shape.length===t.shape.length){let c=rae(e,t,n,u);return e.disposeIntermediateTensorInfo(u),c}return u}function sae(e,t,n,r){let s=[n];if(H.assertAxesAreInnerMostDims("arg"+r.charAt(0).toUpperCase()+r.slice(1),s,t.shape.length),!xe().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let a=[],i=e.texData.get(t.dataId),o=i!==null&&i.isPacked,l=t;o&&(l=e.unpackTensor(t),a.push(l));let[u,c]=H.computeOutAndReduceShapes(l.shape,s),d=M.sizeFromShape(c),h=Qe({inputs:{x:l},backend:e,attrs:{shape:[-1,d]}});a.push(h);let p=nae(e,h,r);a.push(p);let f=Qe({inputs:{x:p},backend:e,attrs:{shape:u}});return a.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}return rae(e,t,r)}function _gt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=M.parseAxisParam(a,s.shape),o=H.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=na({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=H.getInnerMostAxes(i.length,l.shape.length)),H.assertAxesAreInnerMostDims("argMax",[i[0]],l.shape.length);let c=sae(n,l,i[0],"max");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var Agt={kernelName:Ly,backendName:"webgl",kernelFunc:_gt};function Rgt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a}=r,i=M.parseAxisParam(a,s.shape),o=H.getAxesPermutation(i,s.shape.length),l=s,u=[];o!=null&&(l=na({inputs:{x:s},backend:n,attrs:{perm:o}}),u.push(l),i=H.getInnerMostAxes(i.length,l.shape.length)),H.assertAxesAreInnerMostDims("argMin",[i[0]],l.shape.length);let c=sae(n,l,i[0],"min");return u.forEach(d=>n.disposeIntermediateTensorInfo(d)),c}var Dgt={kernelName:zy,backendName:"webgl",kernelFunc:Rgt},Ogt=oo+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Fgt=tn({opSnippet:Ogt}),Mgt={kernelName:_p,backendName:"webgl",kernelFunc:Fgt},Pgt=oo+"return log(x + sqrt(x * x + 1.0));",Lgt=tn({opSnippet:Pgt}),zgt={kernelName:Ap,backendName:"webgl",kernelFunc:Lgt},Bgt=oo+`
  return atan(x);
`,Wgt=tn({opSnippet:Bgt}),Vgt={kernelName:Rp,backendName:"webgl",kernelFunc:Wgt},Ugt=dz+`
  return atan(a, b);
`,jgt=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nm+`
  return result;
`,Ggt=$s({opSnippet:Ugt,packedOpSnippet:jgt}),Hgt={kernelName:Op,backendName:"webgl",kernelFunc:Ggt},qgt=oo+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Kgt=tn({opSnippet:qgt}),Xgt={kernelName:Dp,backendName:"webgl",kernelFunc:Kgt},c0=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;let f=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(f||(y="-1.0 / 1e-20"),n){let S=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${o});
        const ivec2 pads = ivec2(${h}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${S} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?s?m:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let b="max",x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(x="avgValue / max(count, 1.0)");let v=Math.floor(a/4)*4,w=a%4,k=`
      if (${f}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${p});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${k}
          }

          int xC = xCCorner + ${v};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${k}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${k}
          }
        }
        setOutput(${x});
      }
    `}},pz=class{constructor(e,t,n,r=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let b=t==="avg",x="0.0";if(b||(x="-1.0 / 1e-20"),n){let $=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${o}, ${l});
        const ivec3 pads = ivec3(${m}, ${g}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${f};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${$} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +
                      wR * ${f} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let v="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / max(count, 1.0)");let k=Math.floor(a/4)*4,S=a%4,I=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${o}, ${l});
      const ivec3 pads = ivec3(${m}, ${g}, ${y});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${k}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${I}
            }

            int xC = xCCorner + ${k};
            if (${S===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${S===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${I}
            } else if (${S===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${I}
            }
          }
        }
        setOutput(${w});
      }
    `}};function Ygt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Xb(s,"avgPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;M.assert(H.eitherStridesOrDilationsAreOne(i,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=H.computePool2DInfo(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&M.arraysEqual(c.inShape,c.outShape))return ti({inputs:{x:s},backend:n});let d=new c0(c,"avg",!1);return n.runWebGLProgram(d,[s],"float32")}var Jgt={kernelName:Fp,backendName:"webgl",kernelFunc:Ygt};function Zgt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=[1,1,1],d=H.computePool3DInfo(s.shape,a,i,c,o,l,u),h=new pz(d,"avg",!1);return n.runWebGLProgram(h,[s],"float32")}var Qgt={kernelName:By,backendName:"webgl",kernelFunc:Zgt},eyt=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,d=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${c});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},tyt=class{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=d-1-e.padInfo.top,m=h-1-e.padInfo.left,g=1/(t*n*r);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${f}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function nyt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=H.computePool3DInfo(i.shape,o,l,d,u,c),p=new tyt(h);return n.runWebGLProgram(p,[s],i.dtype)}var ryt={kernelName:qx,backendName:"webgl",kernelFunc:nyt};function syt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a;Xb([s,a],"avgPoolGrad");let{filterSize:o,strides:l,pad:u}=r,c=H.computePool2DInfo(i.shape,o,l,1,u),d=new eyt(c);return n.runWebGLProgram(d,[s],i.dtype)}var ayt={kernelName:Hx,backendName:"webgl",kernelFunc:syt};function iyt(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;return bI({a:s,b:a,transposeA:i,transposeB:o,backend:n})}var oyt={kernelName:Mp,backendName:"webgl",kernelFunc:iyt},lyt=class{constructor(e,t,n,r,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],H.assertAndGetBroadcastShape(e,t),H.assertAndGetBroadcastShape(e,n);let i="0.0";r!=null&&(H.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="1.0";s!=null&&(H.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${o};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}},uyt=class{constructor(e,t,n,r,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],H.assertAndGetBroadcastShape(e,t),H.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";r!=null&&(H.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let o="vec4(1.0)";s!=null&&(H.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${o};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}},cyt=({inputs:e,backend:t,attrs:n})=>{let{x:r,mean:s,variance:a,offset:i,scale:o}=e;M.assert(s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),M.assert(i==null||s.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),M.assert(o==null||s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);let u=[r,s,a],c=null;i!=null&&(c=i.shape,u.push(i));let d=null;o!=null&&(d=o.shape,u.push(o));let h=xe().getBool("WEBGL_PACK_NORMALIZATION")?new uyt(r.shape,s.shape,a.shape,c,d,l):new lyt(r.shape,s.shape,a.shape,c,d,l);return t.runWebGLProgram(h,u,u[0].dtype)},dyt={kernelName:ef,backendName:"webgl",kernelFunc:cyt},hyt=class{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;let t=Tn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=pyt(this.rank),r,s=e.map((a,i)=>`sourceLoc.${qR[i]} = start[${i}] + coords.${qR[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${n}));
      }
    `}},qR=["x","y","z","w","u","v"];function pyt(e){if(e===1)return"sourceLoc";if(e<=6)return qR.slice(0,e).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}var fyt=class{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Tn(this.rank),n=Xs("coords",this.rank),r=Xs("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,a=`getChannel(getSource(${r.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${a};
        --${r[this.rank-1]};
      }
    `,o=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,c)=>`start[${c}]`).join()});`:e.map((u,c)=>`${r[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${o}
        setOutput(result);
      }
    `}};function myt(e,t,n,r){let s=r.texData.get(e.dataId),a=r.makeTensorInfo(n,e.dtype),i=r.texData.get(a.dataId);Object.assign(i,s),i.refCount=1,i.shape=n,i.dtype=e.dtype;let o=Hr.computeFlatOffset(t,M.computeStrides(e.shape));s.slice&&(o+=s.slice.flatOffset),i.slice={flatOffset:o,origDataId:s.slice&&s.slice.origDataId||e.dataId};let l=r.dataRefCount.get(i.slice.origDataId)||1;return r.dataRefCount.set(i.slice.origDataId,l+1),a}function nv(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,size:i}=r,[o,l]=Hr.parseSliceParams(s,a,i);if(Hr.assertParamsValid(s,o,l),M.sizeFromShape(l)===0)return n.makeTensorInfo(l,s.dtype,[]);if(n.shouldExecuteOnCPU([s])||s.dtype==="string"){let d=n.texData.get(s.dataId),h=amt(d.values,o,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,h)}let{isPacked:u}=n.texData.get(s.dataId),c=Hr.isSliceContinous(s.shape,o,l);if(u||!c){let d=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fyt(l):new hyt(l),h=[o];return n.runWebGLProgram(d,[s],s.dtype,h)}return n.uploadToGPU(s.dataId),myt(s,o,l,n)}var gyt={kernelName:Nb,backendName:"webgl",kernelFunc:nv},yyt=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r;M.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((b,x)=>b*x),l=H.getReshaped(s.shape,a,o),u=H.getPermuted(l.length,a.length),c=H.getReshapedPermuted(s.shape,a,o),d=H.getSliceBeginCoords(i,a.length),h=H.getSliceSize(c,i,a.length),p=[],f=Qe({inputs:{x:s},backend:n,attrs:{shape:l}}),m=na({inputs:{x:f},backend:n,attrs:{perm:u}}),g=Qe({inputs:{x:m},backend:n,attrs:{shape:c}}),y=nv({inputs:{x:g},backend:n,attrs:{begin:d,size:h}});return p.push(f),p.push(m),p.push(g),p.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},byt={kernelName:Wy,backendName:"webgl",kernelFunc:yyt};function vyt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i}=r,o=n.readSync(s.dataId),l=n.readSync(a.dataId),u=Use(o,l,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,u)}var xyt={kernelName:Vy,backendName:"webgl",kernelFunc:vyt},wyt=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,kyt=`
  return float(int(a.r) & int(b.r));
`;function Syt(e){let{inputs:t,backend:n}=e,{a:r,b:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS"),i=xe().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([r,s])||i===1){let l=n.texData.get(r.dataId).values,u=n.texData.get(s.dataId).values,[c,d]=Eft(r.shape,s.shape,l,u,r.dtype),h=n.makeTensorInfo(d,r.dtype),p=n.texData.get(h.dataId);return p.values=c,h}let o;return a?o=new ev(wyt,r.shape,s.shape,!1):o=new op(kyt,r.shape,s.shape),n.runWebGLProgram(o,[r,s],r.dtype)}var Iyt={kernelName:Uy,backendName:"webgl",kernelFunc:Syt};function Cyt(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.readSync(r.dataId),i=n.readSync(s.dataId),o=H.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}var Nyt={kernelName:Kx,backendName:"webgl",kernelFunc:Cyt},Tyt="return float(a != b);",aae=$s({opSnippet:Tyt,cpuKernelImpl:Yft,dtype:"bool"}),$yt={kernelName:pb,backendName:"webgl",kernelFunc:aae};function jw(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ti({inputs:{x:s.complexTensorInfos.real},backend:n})}var Eyt={kernelName:rT,backendName:"webgl",kernelFunc:jw},_yt="return float(int(x));";function Ayt(e,t){let n=new yl(e.shape,_yt),r=t.runWebGLProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function KR(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dtype:a}=r;if(a==="complex64"){if(s.dtype==="complex64")return ti({inputs:{x:s},backend:n});let i=sr(s.shape),o=KR({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),l=Id({inputs:{real:o,imag:i},backend:n});return i.dispose(),n.disposeIntermediateTensorInfo(o),l}if(s.dtype==="complex64"){let i=jw({inputs:{input:s},backend:n}),o=KR({inputs:{x:i},backend:n,attrs:{dtype:a}});return n.disposeIntermediateTensorInfo(i),o}if(!M.hasEncodingLoss(s.dtype,a)){let i=ti({inputs:{x:s},backend:n});return{dataId:i.dataId,shape:i.shape,dtype:a}}if(n.shouldExecuteOnCPU([s])){let i=n.texData.get(s.dataId).values,[o,l,u]=_ft(i,s.shape,s.dtype,a);return n.makeTensorInfo(o,l,u)}if(a==="int32")return Ayt(s,n);if(a==="bool"){let i=n.makeTensorInfo([],"bool",M.getTypedArrayFromDType("bool",1)),o=aae({inputs:{a:s,b:i},backend:n});return n.disposeIntermediateTensorInfo(i),o}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${a}`)}var Ryt={kernelName:Pp,backendName:"webgl",kernelFunc:KR},q5="return ceil(x);",Dyt=tn({opSnippet:q5,packedOpSnippet:q5,cpuKernelImpl:Aft}),Oyt={kernelName:Lp,backendName:"webgl",kernelFunc:Dyt},Fyt=class{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}},Myt=class{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Pyt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o;xe().getBool("WEBGL_PACK_CLIP")?o=new Myt(s.shape):o=new Fyt(s.shape);let l=[[a],[i]];return n.runWebGLProgram(o,[s],s.dtype,l)}var Lyt={kernelName:md,backendName:"webgl",kernelFunc:Pyt},zyt=class{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function K5(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}function Byt(e){let{inputs:t,backend:n}=e,{x:r}=t,s=n.texData.get(r.dataId),a=new zyt(r.shape),i=[K5(r,s.complexTensorInfos.real),K5(r,s.complexTensorInfos.imag)];return n.runWebGLProgram(a,i,i[0].dtype)}var Wyt={kernelName:Xx,backendName:"webgl",kernelFunc:Byt},Vyt=class{constructor(e){this.outputShape=[],this.outputShape=H.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let r=t.length,s=t[t.length-1];n.push(`else setOutput(getT${r}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}},Uyt=class{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=H.computeOutShape(e,t);let n=this.outputShape,r=n.length,s=Tn(r),a=Xs("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((f,m)=>`T${m}`);let o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];let l=i[t],u=i.slice(-2),c=i.join(),d=`if (${l} < ${o[0]}) {
        return getChannel(
            getT0(${c}), vec2(${u.join()}));
        }`;for(let f=1;f<o.length;f++){let m=o[f-1];d+=`
        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {
          return getChannel(
            getT${f}(${Jk(i,l,m)}),
            vec2(${Jk(u,l,m)}));
        }`}let h=o.length,p=o[o.length-1];d+=`
        return getChannel(
          getT${h}(${Jk(i,l,p)}),
          vec2(${Jk(u,l,p)}));`,this.userCode=`
      float getValue(${i.map(f=>"int "+f)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[r-1]} = ${a[r-1]} + 1;
        if (${a[r-1]} < ${n[r-1]}) {
          result.g = getValue(${a});
        }

        ${a[r-2]} = ${a[r-2]} + 1;
        if (${a[r-2]} < ${n[r-2]}) {
          result.a = getValue(${a});
        }

        ${a[r-1]} = ${a[r-1]} - 1;
        if (${a[r-2]} < ${n[r-2]} &&
            ${a[r-1]} < ${n[r-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function Jk(e,t,n){let r=e.indexOf(t);return e.map((s,a)=>a===r?`${s} - ${n}`:s).join()}function h$(e){let{inputs:t,backend:n}=e,{input:r}=t,s=n.texData.get(r.dataId);return ti({inputs:{x:s.complexTensorInfos.imag},backend:n})}var jyt={kernelName:QN,backendName:"webgl",kernelFunc:h$};function qv(e,t,n){let r=e[0].dtype;if(r==="complex64"){let p=e.map(b=>jw({inputs:{input:b},backend:n})),f=e.map(b=>h$({inputs:{input:b},backend:n})),m=qv(p,t,n),g=qv(f,t,n),y=Id({inputs:{real:m,imag:g},backend:n});return p.forEach(b=>n.disposeIntermediateTensorInfo(b)),f.forEach(b=>n.disposeIntermediateTensorInfo(b)),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),y}let s=n.shouldExecuteOnCPU(e);if(r==="string"&&(s=!0),s){let p=e.map(v=>{let w=[-1,M.sizeFromShape(v.shape.slice(t))];return Qe({inputs:{x:v},backend:n,attrs:{shape:w}})}),f=p.map(v=>({vals:n.readSync(v.dataId),shape:v.shape})),m=H.computeOutShape(p.map(v=>v.shape),1),g=p[0].shape[0]===1,y=Rft(f,m,r,g),b=H.computeOutShape(e.map(v=>v.shape),t),x=n.makeTensorInfo(b,r,y);return p.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}let a=e.filter(p=>M.sizeFromShape(p.shape)>0),i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&a[0].shape.length>1;if(a.length===1){let p=i?new yl(e[0].shape,Xu):new uc(e[0].shape,Xu);return n.runWebGLProgram(p,e,r)}let o=xe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(a.length>o){let p=[];for(let m=0;m<a.length;m+=o){let g=a.slice(m,m+o);p.push(qv(g,t,n))}let f=qv(p,t,n);for(let m of p)n.disposeIntermediateTensorInfo(m);return f}if(i){let p=new Uyt(a.map(f=>f.shape),t);return n.runWebGLProgram(p,a,r)}let{tensors2D:l,outShape:u}=Gyt(a,t,n),c=new Vyt(l.map(p=>p.shape)),d=n.runWebGLProgram(c,l,r);l.forEach(p=>n.disposeIntermediateTensorInfo(p));let h=Qe({inputs:{x:d},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(d),h}function Gyt(e,t,n){let r=H.computeOutShape(e.map(s=>s.shape),t);return{tensors2D:e.map(s=>Qe({inputs:{x:s},attrs:{shape:[-1,M.sizeFromShape(s.shape.slice(t))]},backend:n})),outShape:r}}function iae(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r,a=M.parseAxisParam(s,t[0].shape)[0],i=t.map(u=>u.shape);H.assertParamsConsistent(i,a);let o=H.computeOutShape(t.map(u=>u.shape),a);if(M.sizeFromShape(o)===0)return n.makeTensorInfo(o,t[0].dtype,[]);let l=t.filter(u=>M.sizeFromShape(u.shape)>0);return l.length===1?ti({inputs:{x:l[0]},backend:n}):qv(l,a,n)}var Hyt={kernelName:jy,backendName:"webgl",kernelFunc:iae},oae=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,y=m?2:3,b=m?3:1,x="",v="";n&&(r?x=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?x=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:x=`
          float activation(float x) {
            ${n}
          }
        `,v="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${x}

      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${f===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${f===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${f===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${v}
        setOutput(result);
      }
    `}},qyt=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,r=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,f=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${o};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${f===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${f===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${f===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},lae=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zs(this.outputShape.length);let a=e.padInfo.left,i=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u,d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<u;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<u;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(c+1)/2;m++){let g=m*2;if(d+=`
           xC = xCCorner + ${g*o};
           `,i===1){if(g<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,o===1&&g>0?d+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<u)){let y=a%2===0?M.nearestLargerEven(o):o;o%2===0&&a%2===1||o%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${y};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,o>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:d+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):y===1?d+=`
                     xC${g+1} = xTexelC${g};
                     `:d+=`
                     xCOffset = xC + ${y};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<u&&(d+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<u&&(d+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<u&&(d+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let h="",p="";n&&(r?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:h=`vec4 activation(vec4 x) {
           ${n}
         }`,p="result = activation(result);");let f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${f}
         ${p}
         setOutput(result);
       }
     `}},Kyt=class{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=zs(this.outputShape.length);let{dataFormat:n}=t,r=la(),s=n==="channelsLast",a=s?1:2,i=s?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let u=0;u<=1;u++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.z + ${c};
          pos = rc.y + ${u};

          ${o}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+c}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}};function vI(e,t){let n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&n===1&&e[0]>1?[e[0],1]:null}function uae({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let l=e.shape,u=r.texData.get(e.dataId),c=n.inChannels,d=l[0]*l[1]*l[2],h=n.outChannels,p=n.dataFormat==="channelsLast",f=!1,m=!1,g,y=[];if(a!=null){let b=vI(a.shape,p);b!=null&&(a=Qe({inputs:{x:a},backend:r,attrs:{shape:b}}),y.push(a))}if(s!=null){let b=vI(s.shape,p);b!=null&&(s=Qe({inputs:{x:s},backend:r,attrs:{shape:b}}),y.push(s))}if(!((d===1||h===1)&&c>tae)&&u.isPacked&&p&&u.texture!=null&&l[2]%2!==0&&M.arraysEqual(u.shape.slice(-3),l.slice(-3))){let b=l[0]*l[1]*(l[2]+1),x={dataId:e.dataId,shape:[1,b,n.inChannels],dtype:e.dtype},v=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,M.assert(l0(u.shape,x.shape),()=>`packed reshape ${u.shape} to ${x.shape} isn't free`);let w=Qe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(w);let k=bI({a:x,b:w,backend:r,transposeA:f,transposeB:m,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i}),S=r.texData.get(k.dataId);M.assert(S.isPacked,()=>"batchMatMul result is expected to be packed"),u.shape=v,S.shape=n.outShape,g=ti({inputs:{x:k},backend:r}),g.shape=n.outShape,y.push(k)}else{let b=n.outHeight*n.outWidth,x=Qe({inputs:{x:e},backend:r,attrs:{shape:p?[n.batchSize,b,n.inChannels]:[n.batchSize,n.inChannels,b]}}),v=Qe({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),w=bI({a:p?x:v,b:p?v:x,transposeA:!p,transposeB:m,backend:r,bias:s,activation:o,preluActivationWeights:a,leakyreluAlpha:i});g=Qe({inputs:{x:w},backend:r,attrs:{shape:n.outShape}}),y.push(x),y.push(v),y.push(w)}for(let b of y)r.disposeIntermediateTensorInfo(b);return g}function cae({x:e,filter:t,convInfo:n,backend:r,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:o=null}){let{filterWidth:l,filterHeight:u,inChannels:c,outWidth:d,outHeight:h,dataFormat:p}=n,f=p==="channelsLast",m=l*u*c,g=h*d,y=[n.batchSize,m,g],b=!0,x=!1,v=[];if(a!=null){let F=vI(a.shape,f);F!=null&&(a=Qe({inputs:{x:a},backend:r,attrs:{shape:F}}),v.push(a))}if(s!=null){let F=vI(s.shape,f);F!=null&&(s=Qe({inputs:{x:s},backend:r,attrs:{shape:F}}),v.push(s))}let w=Qe({inputs:{x:t},backend:r,attrs:{shape:[1,m,M.sizeFromShape(t.shape)/m]}});v.push(w);let k=new Kyt(y,n),S=[e.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],I=r.runWebGLProgram(k,[e],"float32",S),$=Qe({inputs:{x:I},backend:r,attrs:{shape:y}});v.push(I),v.push($);let C=s!=null,T=a!=null,N=o==="leakyrelu",E=o?u0(o,!0):null,_=new eae(f?$.shape:w.shape,f?w.shape:$.shape,f?[n.batchSize,g,n.outChannels]:[n.batchSize,n.outChannels,g],b,x,C,E,T,N),R=f?[$,w]:[w,$];if(s&&R.push(s),T&&R.push(a),N){let F=r.makeTensorInfo([],"float32",M.createScalarValue(i,"float32"));R.push(F),v.push(F)}let z=r.runWebGLProgram(_,R,"float32"),W=Qe({inputs:{x:z},backend:r,attrs:{shape:n.outShape}});v.push(z);for(let F of v)r.disposeIntermediateTensorInfo(F);return W}function Xyt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=r,d=H.convertConv2DDataFormat(l),h=H.computeConv2DInfo(s.shape,a.shape,i,u,o,c,!1,d),p;if(h.filterHeight===1&&h.filterWidth===1&&h.dilationHeight===1&&h.dilationWidth===1&&h.strideHeight===1&&h.strideWidth===1&&(h.padInfo.type==="SAME"||h.padInfo.type==="VALID"))p=uae({x:s,filter:a,convInfo:h,backend:n});else if(h.strideWidth<=2&&d==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){let m=new lae(h),g=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];p=n.runWebGLProgram(m,[s,a],"float32",g)}else if(xe().getBool("WEBGL_CONV_IM2COL"))p=cae({x:s,filter:a,convInfo:h,backend:n});else{let m=new oae(h);p=n.runWebGLProgram(m,[s,a],"float32")}let f=Qe({inputs:{x:p},backend:n,attrs:{shape:h.outShape}});return n.disposeIntermediateTensorInfo(p),f}var Yyt={kernelName:zp,backendName:"webgl",kernelFunc:Xyt},Jyt=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Zyt=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=a?1:2,u=a?2:3,c=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Qyt=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},ebt=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,r=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${o}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function tbt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=r,d=H.convertConv2DDataFormat(l),h=H.computeConv2DInfo(s.shape,c,i,1,o,u,!1,d),p=new Jyt(h);return n.runWebGLProgram(p,[s,a],"float32")}var nbt={kernelName:HN,backendName:"webgl",kernelFunc:tbt},rbt=class{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=zs(this.outputShape.length);let t=e.filterHeight,n=e.filterWidth,r=t-1-e.padInfo.top,s=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${r}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            int wCPerm = ${n} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}};function sbt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{inputShape:i,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=r,d=H.convertConv2DDataFormat(u),h=H.computeConv2DInfo(i,a.shape,o,1,l,c,!1,d);if(xe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){let p=[[h.strideHeight,h.strideWidth]],f=new rbt(h);return n.runWebGLProgram(f,[s,a],"float32",p)}else{let p=new Zyt(h);return n.runWebGLProgram(p,[s,a],"float32")}}var abt={kernelName:Bp,backendName:"webgl",kernelFunc:sbt};function ibt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=H.computeConv3DInfo(s.shape,a.shape,i,l,o),c=new qyt(u);return n.runWebGLProgram(c,[s,a],"float32")}var obt={kernelName:Wp,backendName:"webgl",kernelFunc:ibt};function lbt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r,u=H.computeConv3DInfo(s.shape,l,i,1,o),c=new Qyt(u);return n.runWebGLProgram(c,[s,a],"float32")}var ubt={kernelName:Gy,backendName:"webgl",kernelFunc:lbt};function cbt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r,u=H.computeConv3DInfo(l,a.shape,o,1,i),c=new ebt(u);return n.runWebGLProgram(c,[s,a],"float32")}var dbt={kernelName:Hy,backendName:"webgl",kernelFunc:cbt},hbt=tv+`
  return cos(x);
`,pbt=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${nm}
  return result;
`,fbt=tn({opSnippet:hbt,packedOpSnippet:pbt}),mbt={kernelName:Vp,backendName:"webgl",kernelFunc:fbt},gbt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,ybt=tn({opSnippet:gbt}),bbt={kernelName:Up,backendName:"webgl",kernelFunc:ybt},vbt=class{constructor(e,t,n,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,i,o,l]=e,[u]=t,[c,d]=n;this.outputShape=[u,c,d,l];let h=r==="bilinear"?1:0,[p,f]=[`${i-1}.0`,`${o-1}.0`],[m,g,y]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,x,v]=d>1?[`${(o-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${x};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${f} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}},xbt=e=>{let{inputs:t,backend:n,attrs:r}=e,{image:s,boxes:a,boxInd:i}=t,{cropSize:o,method:l,extrapolationValue:u}=r,c=new vbt(s.shape,a.shape,o,l,u);return n.runWebGLProgram(c,[s,a,i],"float32")},wbt={kernelName:Ky,backendName:"webgl",kernelFunc:xbt},d0;(function(e){e.Prod="*",e.Sum="+"})(d0||(d0={}));var X5=class{constructor(e,t,n,r){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,a=this.op===d0.Prod?"1.0":"0.0",i=n?a:`getX(${Y5(s,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],l="",u="";n?(l=r?`end != ${o-1}`:"end != 0",u=r?"end + 1":"end - 1"):(l=r?`end + pow2 < ${o}`:"end >= pow2",u=r?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Tn(s)} coords = getOutputCoords();
        int end = ${J5(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${J5(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${Y5(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function Y5(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.x, ${t}.y`;if(e===3)return`${t}.x, ${t}.y, ${t}.z`;if(e===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function J5(e,t,n){if(e===1)return`${t}`;if(e===2)return`${t}.y`;if(e===3)return`${t}.z`;if(e===4)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function dae(e,t,n,r,s,a){let i=t.shape.length,o=H.getAxesPermutation([r],i),l=t;o!=null&&(l=na({inputs:{x:t},backend:n,attrs:{perm:o}}));let u=H.getInnerMostAxes(1,i)[0];if(u!==i-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);let c=l.shape[u],d=ti({inputs:{x:l},backend:n});for(let h=0;h<=Math.ceil(Math.log2(c))-1;h++){let p=new X5(e,l.shape,!1,a),f=[[h]],m=d;d=n.runWebGLProgram(p,[d],d.dtype,f),n.disposeIntermediateTensorInfo(m)}if(s){let h=new X5(e,l.shape,s,a),p=d;d=n.runWebGLProgram(h,[d],d.dtype),n.disposeIntermediateTensorInfo(p)}if(o!=null){let h=H.getUndoAxesPermutation(o),p=na({inputs:{x:d},backend:n,attrs:{perm:h}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),p}return d}function kbt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return dae(d0.Prod,s,n,a,i,o)}var Sbt={kernelName:qy,backendName:"webgl",kernelFunc:kbt};function Ibt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r;return dae(d0.Sum,s,n,a,i,o)}var Cbt={kernelName:jp,backendName:"webgl",kernelFunc:Ibt};function Nbt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,weights:a}=t,{size:i,binaryOutput:o}=r;if(s.shape.length===1){let l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=Use(l,u,a.dtype,a.shape,i);return n.makeTensorInfo([i],a.dtype,c)}else if(s.shape.length===2){let l=n.bufferSync(s),u=n.bufferSync(a),c=$ft(l,u,i,o);return n.makeTensorInfo(c.shape,a.dtype,c.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var Tbt={kernelName:Yx,backendName:"webgl",kernelFunc:Nbt},$bt=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Ebt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,h=u*a,p=c/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=new $bt(f,a,i);return n.runWebGLProgram(m,[s],s.dtype)}var _bt={kernelName:Xy,backendName:"webgl",kernelFunc:Ebt},hae=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zs(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,o=e.outChannels/e.inChannels,l="",u="";n&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,u="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${u}
        setOutput(result);
      }
    `}},pae=class{constructor(e,t=!1,n=null,r=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=zs(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,d=c,h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<c;g++)h+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;h+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let g=0;g<c;g++)h+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){let y=g*2;if(h+=`
          xC = xCCorner + ${y*l};
          `,o===1){if(y<c&&(i%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?h+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<c)){let b=i%2===0?M.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                    } else {
                     xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                    }
                    `:h+=`
                    xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                    `):b===1?h+=`
                    xC${y+1} = xTexelC${y};
                    `:h+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<c&&(i%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<c&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<c&&(h+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<c&&(h+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<c&&(h+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let p="",f="";n&&(r?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:p=`vec4 activation(vec4 x) {
          ${n}
        }`,f="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${f}
        setOutput(result);
      }
    `}};function Abt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l,dimRoundingMode:u}=r,c=l;c==null&&(c=[1,1]),M.assert(H.eitherStridesOrDilationsAreOne(i,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);let d=H.computeConv2DInfo(s.shape,a.shape,i,c,o,u,!0),h;xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?h=new pae(d):h=new hae(d);let p=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(h,[s,a],"float32",p)}var Rbt={kernelName:Gp,backendName:"webgl",kernelFunc:Abt},Dbt=class{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,r=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Obt=class{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,r=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${o}; dm++) {
              int d2 = d1 * ${o} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Fbt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=r,d=H.computeConv2DInfo(s.shape,c,i,o,l,u,!0),h=new Dbt(d);return n.runWebGLProgram(h,[s,a],"float32")}var Mbt={kernelName:qN,backendName:"webgl",kernelFunc:Fbt};function Pbt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{strides:i,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=r,d=H.computeConv2DInfo(c,a.shape,i,o,l,u,!0),h=new Obt(d);return n.runWebGLProgram(h,[s,a],"float32")}var Lbt={kernelName:KN,backendName:"webgl",kernelFunc:Pbt},zbt=class{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Bbt(e){let{inputs:t,backend:n}=e,{x:r}=t,s=[...r.shape,...r.shape],a=M.sizeFromShape(r.shape),i=Qe({inputs:{x:r},backend:n,attrs:{shape:[a]}}),o=new zbt(a),l=n.runWebGLProgram(o,[i],i.dtype),u=Qe({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),u}var Wbt={kernelName:Jx,backendName:"webgl",kernelFunc:Bbt},Vbt=class{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:r,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${c}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${o}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Ubt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r,u=H.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",l),c,d=new Vbt(u);c=n.runWebGLProgram(d,[s,a],"float32");let h=Qe({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),h}var jbt={kernelName:Hp,backendName:"webgl",kernelFunc:Ubt};function Gbt(e){let{inputs:t,backend:n,attrs:r}=e,{equation:s}=r,a=t,{allDims:i,summedDims:o,idDims:l}=H.decodeEinsumEquation(s,a.length);H.checkEinsumDimSizes(i.length,l,a);let{path:u,steps:c}=H.getEinsumComputePath(o,l),d=c.length,h=null,p=i.length,f=[];for(let m=0;m<d;++m){for(let g of c[m]){let{permutationIndices:y,expandDims:b}=H.getEinsumPermutation(p,l[g]),x;H.isIdentityPermutation(y)?x=a[g]:(x=na({inputs:{x:a[g]},backend:n,attrs:{perm:y}}),f.push(x));let v=x.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);M.arraysEqual(x.shape,v)||(x=Qe({inputs:{x},backend:n,attrs:{shape:v}}),f.push(x)),h===null?h=x:(h=hz({inputs:{a:x,b:h},backend:n}),f.push(h))}m<d-1&&(u[m]>=0&&(h=d$({inputs:{x:h},backend:n,attrs:{axis:u[m]-(i.length-p),keepDims:!1}}),f.push(h)),p--)}for(let m of f)m!==h&&n.disposeIntermediateTensorInfo(m);return h}var Hbt={kernelName:YN,backendName:"webgl",kernelFunc:Gbt},qbt="return (x >= 0.0) ? x : (exp(x) - 1.0);",Kbt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Xbt=tn({opSnippet:qbt,packedOpSnippet:Kbt}),Ybt={kernelName:Kp,backendName:"webgl",kernelFunc:Xbt},Jbt="return (b >= 0.0) ? a : a * (b + 1.0);",Zbt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Qbt=e=>{let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=xe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ev(Zbt,r.shape,s.shape):new op(Jbt,r.shape,s.shape);return n.runWebGLProgram(a,[r,s],r.dtype)},evt={kernelName:Yy,backendName:"webgl",kernelFunc:Qbt},tvt=`
  return vec4(equal(a, b));
`,nvt="return float(a == b);",rvt=$s({opSnippet:nvt,packedOpSnippet:tvt,dtype:"bool",cpuKernelImpl:Dft}),svt={kernelName:Jy,backendName:"webgl",kernelFunc:rvt},avt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${H.ERF_P};
  float a1 = ${H.ERF_A1};
  float a2 = ${H.ERF_A2};
  float a3 = ${H.ERF_A3};
  float a4 = ${H.ERF_A4};
  float a5 = ${H.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,ivt=tn({opSnippet:avt}),ovt={kernelName:Xp,backendName:"webgl",kernelFunc:ivt},lvt=tv+`
  return exp(x);
`,uvt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,fae=tn({opSnippet:lvt,packedOpSnippet:uvt,cpuKernelImpl:Oft,dtype:"float32"}),cvt={kernelName:Yp,backendName:"webgl",kernelFunc:fae};function XR(e){let{inputs:t,attrs:n,backend:r}=e,{dim:s}=n,{input:a}=t,i=a.shape.length,o=a.shape.slice(),l=s;return s<0&&(M.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+s+1),o.splice(l,0,1),Qe({inputs:{x:a},backend:r,attrs:{shape:o}})}var dvt={kernelName:Zy,backendName:"webgl",kernelFunc:XR},Z5="return exp(x) - 1.0;",hvt=tn({opSnippet:Z5,packedOpSnippet:Z5,cpuKernelImpl:Fft}),pvt={kernelName:Jp,backendName:"webgl",kernelFunc:hvt},Q5=class{constructor(e,t,n){this.variableNames=["real","imag"];let r=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${r}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function mae(e,t,n){let r=n.texData.get(e.dataId),s=M.sizeFromShape(e.shape),a=e.shape[e.shape.length-1],i=s/a,o=Qe({inputs:{x:e},backend:n,attrs:{shape:[i,a]}}),l=o.shape,u=new Q5("real",l,t),c=new Q5("imag",l,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],h=n.runWebGLProgram(u,d,"float32"),p=n.runWebGLProgram(c,d,"float32"),f=Id({inputs:{real:h,imag:p},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p);let m=Qe({inputs:{x:f},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(f),m}function fvt(e){let{inputs:t,backend:n}=e,{input:r}=t;return mae(r,!1,n)}var mvt={kernelName:JN,backendName:"webgl",kernelFunc:fvt},gvt=class{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Gw(e){let{backend:t,attrs:n}=e,{shape:r,value:s}=n,{dtype:a}=n;if(a=a||M.inferDtype(s),a==="string"){let i=M.getArrayFromDType(a,M.sizeFromShape(r));return i.fill(s),t.makeTensorInfo(r,a,i)}else{let i=new gvt(r,s),o=[[s]];return t.runWebGLProgram(i,[],a,o)}}var yvt={kernelName:Zx,backendName:"webgl",kernelFunc:Gw},bvt=class{constructor(e){this.variableNames=["Image"],this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}},vvt={kernelName:Qy,backendName:"webgl",kernelFunc:({inputs:e,backend:t})=>{let{image:n}=e,r=t,s=new bvt(n.shape);return r.runWebGLProgram(s,[n],n.dtype)}},e6="return floor(x);",xvt=tn({opSnippet:e6,packedOpSnippet:e6,cpuKernelImpl:Mft}),wvt={kernelName:Zp,backendName:"webgl",kernelFunc:xvt},kvt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Svt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Ivt=$s({opSnippet:kvt,packedOpSnippet:Svt,dtype:"int32"}),Cvt={kernelName:Qp,backendName:"webgl",kernelFunc:Ivt},Nvt=class{constructor(e){this.variableNames=["A"];let t=la(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}},Tvt=class{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let t=la(),[n,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}},$vt={kernelName:YS,backendName:"webgl",kernelFunc:Evt},gm,HE=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Evt(e){let{inputs:t,backend:n,attrs:r}=e,{pixels:s}=t,{numChannels:a}=r,i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,[l,u]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],c=[u,l],d=[u,l,a];if(o||i){let m=xe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(gm==null||m!==HE)&&(HE=m,gm=document.createElement("canvas").getContext("2d",{willReadFrequently:HE})),gm.canvas.width=l,gm.canvas.height=u,gm.drawImage(s,0,0,l,u),s=gm.canvas}let h=n.makeTensorInfo(c,"int32");n.texData.get(h.dataId).usage=hi.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(h.dataId),s);let p=xe().getBool("WEBGL_PACK")?new Tvt(d):new Nvt(d),f=n.runWebGLProgram(p,[h],"int32");return n.disposeData(h.dataId),f}function _vt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=r,m=H.convertConv2DDataFormat(c),g=H.computeConv2DInfo(s.shape,a.shape,l,d,u,h,!1,m),y,b=[],x=i!=null,v=o!=null,w=p==="leakyrelu",k=()=>{let I=[s,a],$=(C,T)=>{if(T==="NCHW"&&C.shape.length===1&&C.shape[0]!==1){let N=Qe({inputs:{x:C},backend:n,attrs:{shape:[C.shape[0],1,1]}});return b.push(N),N}return C};if(x&&I.push($(i,c)),v&&I.push($(o,c)),w){let C=n.makeTensorInfo([],"float32",M.createScalarValue(f,"float32"));I.push(C),b.push(C)}return I};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=uae({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(g.strideWidth<=2&&m==="channelsLast"&&xe().getBool("WEBGL_EXP_CONV")){let I=p?u0(p,!0):null,$=new lae(g,x,I,v,w),C=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],T=k();y=n.runWebGLProgram($,T,"float32",C)}else if(xe().getBool("WEBGL_CONV_IM2COL"))y=cae({x:s,filter:a,convInfo:g,backend:n,bias:i,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{let I=p?u0(p,!1):null,$=new oae(g,x,I,v,w),C=k();y=n.runWebGLProgram($,C,"float32")}let S=Qe({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach(I=>n.disposeIntermediateTensorInfo(I)),S}var Avt={kernelName:jh,backendName:"webgl",kernelFunc:_vt};function Rvt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,f=[],m=c;m==null&&(m=[1,1]),M.assert(H.eitherStridesOrDilationsAreOne(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);let g=H.computeConv2DInfo(s.shape,a.shape,l,m,u,d,!0),y=xe().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=h?u0(h,y):null,x=[s,a],v=i!=null,w=o!=null,k=h==="leakyrelu";if(v&&x.push(i),w&&x.push(o),k){let C=n.makeTensorInfo([],"float32",M.createScalarValue(p,"float32"));x.push(C),f.push(C)}let S;y?S=new pae(g,v,b,w,k):S=new hae(g,v,b,w,k);let I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],$=n.runWebGLProgram(S,x,"float32",I);return f.forEach(C=>n.disposeIntermediateTensorInfo(C)),$}var Dvt={kernelName:Gh,backendName:"webgl",kernelFunc:Rvt},Ovt=class{constructor(e,t,n,r){this.sliceDim=e,this.strides=t,this.paramsShape=r,this.variableNames=["x","indices"],this.outputShape=n;let s=Tn(n.length),a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function Fvt(e){let{inputs:t,backend:n}=e,{params:r,indices:s}=t,a=s.shape,i=a[a.length-1],o=M.sizeFromShape(r.shape),[l,u,c,d]=H.prepareAndValidate(r,s),h=Qe({inputs:{x:s},backend:n,attrs:{shape:[u,i]}}),p=Qe({inputs:{x:r},backend:n,attrs:{shape:[M.sizeFromShape(r.shape)/c,c]}});if(n.shouldExecuteOnCPU([r,s])||r.dtype==="string"){let y=n.readSync(s.dataId),b=n.bufferSync(r),x=Pft(y,b,r.dtype,u,i,c,d,r.shape,o);return n.makeTensorInfo(l,r.dtype,x.values)}let f=new Ovt(i,d,[u,c],r.shape),m=n.runWebGLProgram(f,[p,h],p.dtype),g=Qe({inputs:{x:m},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}var Mvt={kernelName:tb,backendName:"webgl",kernelFunc:Fvt},Pvt=class{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;let n=Tn(this.rank),r=Lvt(e);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${r}));
      }
    `}};function Lvt(e,t){let n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<e.length;s++)s===2?r.push("index"):r.push(`${n[s]}`);return r.join()}function gae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,indices:a}=t,{axis:i,batchDims:o}=r,l=M.parseAxisParam(i,s.shape)[0];if(xe().get("DEBUG")){let b=n.readSync(a.dataId),x=s.shape[l];for(let v=0;v<b.length;++v){let w=b[v];M.assert(w<=x-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${x-1}]`)}}let u=H.segment_util.collectGatherOpShapeInfo(s,a,l,o),c=M.sizeFromShape(a.shape),d=[],h=Qe({inputs:{x:s},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=Qe({inputs:{x:a},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});d.push(h),d.push(p);let f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([s,a])||s.dtype==="string"){let b=n.bufferSync(p),x=n.bufferSync(h),v=Lft(x,b,f);return d.forEach(w=>n.disposeIntermediateTensorInfo(w)),n.makeTensorInfo(u.outputShape,v.dtype,v.values)}let m=new Pvt(h.shape,f),g=n.runWebGLProgram(m,[h,p],h.dtype);d.push(g);let y=Qe({inputs:{x:g},backend:n,attrs:{shape:u.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}var zvt={kernelName:eb,backendName:"webgl",kernelFunc:gae},Bvt="return float(a > b);",Wvt=`
  return vec4(greaterThan(a, b));
`,Vvt=$s({opSnippet:Bvt,packedOpSnippet:Wvt,cpuKernelImpl:zft,dtype:"bool"}),Uvt={kernelName:nb,backendName:"webgl",kernelFunc:Vvt},jvt="return float(a >= b);",Gvt=`
  return vec4(greaterThanEqual(a, b));
`,Hvt=$s({opSnippet:jvt,packedOpSnippet:Gvt,dtype:"bool",cpuKernelImpl:Bft}),qvt={kernelName:nf,backendName:"webgl",kernelFunc:Hvt};function Kvt(e){let{inputs:t,backend:n}=e,{input:r}=t;return mae(r,!0,n)}var Xvt={kernelName:ZN,backendName:"webgl",kernelFunc:Kvt},Yvt="return float(!isnan(x) && !isinf(x));",Jvt=tn({opSnippet:Yvt,dtype:"bool"}),Zvt={kernelName:sf,backendName:"webgl",kernelFunc:Jvt},Qvt="return float(isinf(x));",e1t=tn({opSnippet:Qvt,dtype:"bool"}),t1t={kernelName:af,backendName:"webgl",kernelFunc:e1t},n1t="return float(isnan(x));",r1t=tn({opSnippet:n1t,dtype:"bool"}),s1t={kernelName:of,backendName:"webgl",kernelFunc:r1t},a1t="return float(a < b);",i1t=`
  return vec4(lessThan(a, b));
`,o1t=$s({opSnippet:a1t,packedOpSnippet:i1t,cpuKernelImpl:Wft,dtype:"bool"}),l1t={kernelName:rb,backendName:"webgl",kernelFunc:o1t},u1t="return float(a <= b);",c1t=`
  return vec4(lessThanEqual(a, b));
`,d1t=$s({opSnippet:u1t,packedOpSnippet:c1t,cpuKernelImpl:Vft,dtype:"bool"}),h1t={kernelName:sb,backendName:"webgl",kernelFunc:d1t};function p1t(e){let{backend:t,attrs:n}=e,{start:r,stop:s,num:a}=n,i=Uft(r,s,a);return t.makeTensorInfo([i.length],"float32",i)}var f1t={kernelName:ab,backendName:"webgl",kernelFunc:p1t},m1t=tv+`
  return x < 0.0 ? 0./0. : log(x);
`,g1t=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,y1t=tn({opSnippet:m1t,packedOpSnippet:g1t,cpuKernelImpl:jft}),b1t={kernelName:uf,backendName:"webgl",kernelFunc:y1t},v1t=tv+`
  return log(1.0 + x);
`,x1t=tn({opSnippet:v1t}),w1t={kernelName:cf,backendName:"webgl",kernelFunc:x1t},k1t="return float(a >= 1.0 && b >= 1.0);",S1t=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,I1t=$s({opSnippet:k1t,packedOpSnippet:S1t,dtype:"bool"}),C1t={kernelName:ib,backendName:"webgl",kernelFunc:I1t},N1t="return float(!(x >= 1.0));",T1t=tn({opSnippet:N1t}),$1t={kernelName:ob,backendName:"webgl",kernelFunc:T1t},E1t="return float(a >= 1.0 || b >= 1.0);",_1t=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,A1t=$s({opSnippet:E1t,packedOpSnippet:_1t,dtype:"bool"}),R1t={kernelName:lb,backendName:"webgl",kernelFunc:A1t},D1t=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[];let a=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${l})`:s===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${o};
        setOutput(val);
      }
    `}},O1t=class{constructor(e,t,n,r,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=t,i=e[3]-1;this.outputShape=e;let o,l=`float(${n}) + float(${r}) * sum`;s===.5?o=`inversesqrt(${l})`:s===1?o=`1.0/(${l})`:o=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${o};
        setOutput(result);
      }
    `}},F1t=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r,u=xe().getBool("WEBGL_PACK_NORMALIZATION")?new O1t(s.shape,a,i,o,l):new D1t(s.shape,a,i,o,l);return n.runWebGLProgram(u,[s],s.dtype)},M1t={kernelName:df,backendName:"webgl",kernelFunc:F1t},P1t=class{constructor(e,t,n,r,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=r,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}},L1t=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r,d=new P1t(s.shape,o,l,u,c);return n.runWebGLProgram(d,[s,a,i],s.dtype)},z1t={kernelName:ub,backendName:"webgl",kernelFunc:L1t};function B1t(e,t,n,r){let s=M.sizeFromShape(t),a=M.sizeFromShape(e.shape)/s,i=Qe({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=rm(i,e.dtype,"max",r),l=Qe({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}function yae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reductionIndices:a,keepDims:i}=r,o=s.shape.length,l=M.parseAxisParam(a,s.shape),u=l,c=H.getAxesPermutation(u,o),d=c!=null,h=n.shouldExecuteOnCPU([s]),p=s;if(d){if(h){let b=n.texData.get(p.dataId).values,x=new Array(o);for(let k=0;k<x.length;k++)x[k]=s.shape[c[k]];let v=uz(b,s.shape,s.dtype,c,x);p=n.makeTensorInfo(x,s.dtype);let w=n.texData.get(p.dataId);w.values=v}else p=c$(s,c,n);u=H.getInnerMostAxes(u.length,o)}H.assertAxesAreInnerMostDims("max",u,o);let[f,m]=H.computeOutAndReduceShapes(p.shape,u),g=f;i&&(g=H.expandShapeToKeepDim(f,l));let y;if(h){let b=n.texData.get(p.dataId).values,x=Gft(b,M.sizeFromShape(m),g,s.dtype);y=n.makeTensorInfo(g,s.dtype);let v=n.texData.get(y.dataId);v.values=x}else y=B1t(p,m,g,n);return d&&n.disposeIntermediateTensorInfo(p),y}var W1t={kernelName:hf,backendName:"webgl",kernelFunc:yae},V1t=dz+`
  return max(a, b);
`,U1t=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nm+`
  return result;
`,j1t=$s({opSnippet:V1t,packedOpSnippet:U1t,cpuKernelImpl:Hft}),G1t={kernelName:pf,backendName:"webgl",kernelFunc:j1t};function H1t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;Xb(s,"maxPool");let{filterSize:a,strides:i,pad:o,dimRoundingMode:l}=r,u=1;M.assert(H.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=H.computePool2DInfo(s.shape,a,i,u,o,l);if(c.filterWidth===1&&c.filterHeight===1&&M.arraysEqual(c.inShape,c.outShape))return ti({inputs:{x:s},backend:n});let d=new c0(c,"max",!1);return n.runWebGLProgram(d,[s],s.dtype)}var q1t={kernelName:ff,backendName:"webgl",kernelFunc:H1t};function K1t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dataFormat:l,dimRoundingMode:u}=r,c=[1,1,1],d=H.computePool3DInfo(s.shape,a,i,c,o,u,l),h=new pz(d,"max",!1);return n.runWebGLProgram(h,[s],s.dtype)}var X1t={kernelName:cb,backendName:"webgl",kernelFunc:K1t},Y1t=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,r=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,o=a-1-e.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},J1t=class{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,r=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${o};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Z1t(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,i=a,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=r,d=[1,1,1],h=H.computePool3DInfo(i.shape,o,l,d,u,c),p=new pz(h,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new J1t(h),g=n.runWebGLProgram(m,[s,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}var Q1t={kernelName:ew,backendName:"webgl",kernelFunc:Z1t};function e0t(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a,output:i}=t,o=a;Xb([a,i],"maxPoolGrad");let{filterSize:l,strides:u,pad:c,dimRoundingMode:d}=r,h=H.computePool2DInfo(o.shape,l,u,1,c,d),p=!0,f=new c0(h,"max",p),m=n.runWebGLProgram(f,[o],o.dtype),g=new Y1t(h),y=n.runWebGLProgram(g,[s,m],o.dtype);return n.disposeIntermediateTensorInfo(m),y}var t0t={kernelName:Qx,backendName:"webgl",kernelFunc:e0t};function n0t(e,t,n,r){let s=new c0(n,"max",!1),a=r.runWebGLProgram(s,[e],"float32");s=new c0(n,"max",!0,!0,t);let i=r.runWebGLProgram(s,[e],"float32");return[a,i]}var r0t={kernelName:tw,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{filterSize:s,strides:a,pad:i,includeBatchInIndex:o}=t,l=n;M.assert(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);let u=[1,1];M.assert(H.eitherStridesOrDilationsAreOne(a,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);let c=H.computePool2DInfo(r.shape,s,a,u,i),[d,h]=n0t(r,o,c,l);return[d,h]}};function s0t(e,t,n,r){let s=M.sizeFromShape(t),a=M.sizeFromShape(e.shape)/s,i=Qe({inputs:{x:e},attrs:{shape:[a,s]},backend:r}),o=rm(i,"float32","mean",r),l=Qe({inputs:{x:o},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(o),l}var a0t={kernelName:mf,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{x:r}=e,{keepDims:s,axis:a}=t,i=n,o=r.shape.length,l=M.parseAxisParam(a,r.shape),u=l,c=H.getAxesPermutation(u,o),d=c!=null,h=i.shouldExecuteOnCPU([r]),p=[],f=r;if(d){if(h){let x=i.texData.get(f.dataId).values,v=new Array(o);for(let S=0;S<v.length;S++)v[S]=r.shape[c[S]];let w=uz(x,r.shape,r.dtype,c,v);f=i.makeTensorInfo(v,r.dtype);let k=i.texData.get(f.dataId);k.values=w}else f=c$(r,c,i);p.push(f),u=H.getInnerMostAxes(u.length,o)}H.assertAxesAreInnerMostDims("sum",u,o);let[m,g]=H.computeOutAndReduceShapes(f.shape,u),y=m;s&&(y=H.expandShapeToKeepDim(m,l));let b=s0t(f,g,y,i);for(let x of p)i.disposeIntermediateTensorInfo(x);return b}};function i0t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=M.parseAxisParam(a,s.shape),u=l,c=H.getAxesPermutation(u,o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),u=H.getInnerMostAxes(u.length,s.shape.length)),H.assertAxesAreInnerMostDims("min",u,o);let[h,p]=H.computeOutAndReduceShapes(d.shape,u),f=M.sizeFromShape(p),m=Qe({inputs:{x:d},backend:n,attrs:{shape:[-1,f]}}),g=rm(m,m.dtype,"min",n),y;if(i){let b=H.expandShapeToKeepDim(h,l);y=Qe({inputs:{x:g},backend:n,attrs:{shape:b}})}else y=Qe({inputs:{x:g},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(g),c!=null&&n.disposeIntermediateTensorInfo(d),y}var o0t={kernelName:gf,backendName:"webgl",kernelFunc:i0t},l0t=dz+`
  return min(a, b);
`,u0t=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nm+`
  return result;
`,c0t=$s({opSnippet:l0t,packedOpSnippet:u0t,cpuKernelImpl:qft}),d0t={kernelName:yf,backendName:"webgl",kernelFunc:c0t},h0t=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map((u,c)=>u[0]+e[c]+u[1]);let r=e.length,s=Tn(r),a=t.map(u=>u[0]).join(","),i=t.map((u,c)=>u[0]+e[c]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=n==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${o}));
      }
    `}},p0t=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,f)=>p[0]+e[f]+p[1]);let r=e.length,s=Tn(r),a=t.map(p=>p[0]).join(","),i=t.map((p,f)=>p[0]+e[f]).join(","),o=Xs("rc",r),l=Xs("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=n==="reflect"?0:1,h="";if(r===1){let p=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let p=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${o[r-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${o[r-2]} += 1;
        if(${o[r-2]} < ${this.outputShape[r-2]}) {
          ${p}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${o[r-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}},f0t=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{paddings:s,mode:a}=n,i=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new p0t(r.shape,s,a):new h0t(r.shape,s,a);return t.runWebGLProgram(i,[r],r.dtype)},m0t={kernelName:bf,backendName:"webgl",kernelFunc:f0t},g0t=`if (b == 0.0) return NAN;
  return mod(a, b);`,y0t=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+nm+`
  return result;
`,b0t=$s({opSnippet:g0t,packedOpSnippet:y0t}),v0t={kernelName:vf,backendName:"webgl",kernelFunc:b0t},x0t=class{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}},w0t=`
if (a == b) {
  return 1.0;
};
return a / b;`,k0t=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,bae=$s({opSnippet:w0t,packedOpSnippet:k0t,checkOutOfBounds:!0}),S0t={kernelName:qp,backendName:"webgl",kernelFunc:bae},t6="return a - b;",vae=$s({opSnippet:t6,packedOpSnippet:t6,supportsComplex:!0,cpuKernelImpl:fmt}),I0t={kernelName:jf,backendName:"webgl",kernelFunc:vae};function xae(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{dim:a}=r,i=M.parseAxisParam([a],s.shape),o=yae({inputs:{x:s},backend:n,attrs:{reductionIndices:i,keepDims:!1}}),l=H.expandShapeToKeepDim(o.shape,i),u=Qe({inputs:{x:o},backend:n,attrs:{shape:l}}),c=vae({inputs:{a:s,b:u},backend:n}),d=fae({inputs:{x:c},backend:n}),h=d$({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:!1}}),p=Qe({inputs:{x:h},backend:n,attrs:{shape:l}}),f=bae({inputs:{a:d,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),f}var C0t={kernelName:Vf,backendName:"webgl",kernelFunc:xae};function N0t(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r,l=o?s:xae({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),u=l.shape[0],c=l.shape[1],d=new x0t(u,c,a),h=[[i]],p=n.runWebGLProgram(d,[l],"int32",h);return o||n.disposeIntermediateTensorInfo(l),p}var T0t={kernelName:db,backendName:"webgl",kernelFunc:N0t},$0t=oo+`
  return -x;
`,E0t=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function _0t(e){let{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){let a=n.texData.get(r.dataId),[i,o]=Xft(a.values,r.shape,r.dtype);return n.makeTensorInfo(o,r.dtype,i)}let s;return xe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new uc(r.shape,E0t):s=new yl(r.shape,$0t),n.runWebGLProgram(s,[r],r.dtype)}var A0t={kernelName:hb,backendName:"webgl",kernelFunc:_0t},R0t=Vl.nonMaxSuppressionV3Impl;function D0t(e){H.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),{selectedIndices:d}=R0t(u,c,i,o,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}var O0t={kernelName:fb,backendName:"webgl",kernelFunc:D0t},F0t=Vl.nonMaxSuppressionV4Impl;function M0t(e){H.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),{selectedIndices:h,validOutputs:p}=F0t(c,d,i,o,l,u);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}var P0t={kernelName:mb,backendName:"webgl",kernelFunc:M0t},L0t=Vl.nonMaxSuppressionV5Impl;function z0t(e){H.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:n,attrs:r}=e,{boxes:s,scores:a}=t,{maxOutputSize:i,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=r,c=n.readSync(s.dataId),d=n.readSync(a.dataId),h=i,p=o,f=l,m=u,{selectedIndices:g,selectedScores:y}=L0t(c,d,h,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var B0t={kernelName:gb,backendName:"webgl",kernelFunc:z0t},W0t=class{constructor(e,t,n,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${n}),
                      float(index == coords.y)));
      }
    `}},V0t=e=>{let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=M.sizeFromShape(s.shape),c=new W0t(u,i,o,l),d=Qe({inputs:{x:s},backend:n,attrs:{shape:[u]}}),h=n.runWebGLProgram(c,[d],a);n.disposeIntermediateTensorInfo(d);let p=[...s.shape,i],f=Qe({inputs:{x:h},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(h),f},U0t={kernelName:wf,backendName:"webgl",kernelFunc:V0t};function xI(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="complex64"){let s=jw({inputs:{input:r},backend:n}),a=xI({inputs:{x:s},backend:n}),i=h$({inputs:{input:r},backend:n}),o=xI({inputs:{x:i},backend:n}),l=Id({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Gw({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}var j0t={kernelName:Fb,backendName:"webgl",kernelFunc:xI};function wae(e){let{inputs:t,backend:n}=e,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){let s=jw({inputs:{input:r},backend:n}),a=wae({inputs:{x:s},backend:n}),i=h$({inputs:{input:r},backend:n}),o=xI({inputs:{x:i},backend:n}),l=Id({inputs:{real:a,imag:o},backend:n});return n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(o),l}else return Gw({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}var G0t={kernelName:yb,backendName:"webgl",kernelFunc:wae};function H0t(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return XR({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{M.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),M.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=XR({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=iae({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeIntermediateTensorInfo(c)),u}var q0t={kernelName:bb,backendName:"webgl",kernelFunc:H0t},K0t=class{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);let r=e.length,s=Tn(r),a=t.map(l=>l[0]).join(","),i=t.map((l,u)=>l[0]+e[u]).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${o}));
        }
      }
    `}},X0t=class{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);let r=e.length,s=Tn(r),a=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),o=Xs("rc",r),l=Xs("source",r),u=`${o[r-1]} < ${this.outputShape[r-1]}`,c=r===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${o[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${o[r-2]} += 1;
       if(${o[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${o[r-1]} += 1;
         if(${u}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",p="";for(let f=0,m=r===1?2:4;f<m;f++)p+=`
        ${d[f]}
        if (${h}) {
          result[${f}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${f}] = getChannel(getX(${l.join()}), ${c});
        }
      `;p+=r===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}},kae=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{paddings:a,constantValue:i}=r;if(M.sizeFromShape(s.shape)===0){let u=a.map((c,d)=>c[0]+s.shape[d]+c[1]);return Gw({backend:n,attrs:{shape:u,value:i,dtype:s.dtype}})}let o=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new X0t(s.shape,a,i):new K0t(s.shape,a,i),l=[[i]];return n.runWebGLProgram(o,[s],s.dtype,l)},Y0t={kernelName:kf,backendName:"webgl",kernelFunc:kae},J0t=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Z0t=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+nm+`
  return result;
`,Q0t=$s({opSnippet:J0t,packedOpSnippet:Z0t}),ext={kernelName:Sf,backendName:"webgl",kernelFunc:Q0t};function txt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,keepDims:i}=r,o=s.shape.length,l=[],u=M.parseAxisParam(a,s.shape),c=u,d=H.getAxesPermutation(c,o),h=s;d!=null&&(h=na({inputs:{x:s},backend:n,attrs:{perm:d}}),c=H.getInnerMostAxes(c.length,o),l.push(h)),H.assertAxesAreInnerMostDims("prod",c,o);let p;if(n.shouldExecuteOnCPU([h])){let f=n.texData.get(h.dataId).values,{outVals:m,outShape:g,outDtype:y}=Jft(h.shape,h.dtype,f,c);p=n.makeTensorInfo(g,y,m)}else{let[f,m]=H.computeOutAndReduceShapes(h.shape,c),g=M.sizeFromShape(m),y=Qe({inputs:{x:h},backend:n,attrs:{shape:[-1,g]}}),b=aT(s.dtype),x=rm(y,b,"prod",n);p=Qe({inputs:{x},backend:n,attrs:{shape:f}}),l.push(y),l.push(x)}if(i){l.push(p);let f=H.expandShapeToKeepDim(p.shape,u);p=Qe({inputs:{x:p},backend:n,attrs:{shape:f}})}return l.forEach(f=>n.disposeIntermediateTensorInfo(f)),p}var nxt={kernelName:Cf,backendName:"webgl",kernelFunc:txt};function rxt(e){let{inputs:t,backend:n,attrs:r}=e,{paramsNestedSplits:s,paramsDenseValues:a,indices:i}=t,{outputRaggedRank:o}=r,l=s.map(y=>n.readSync(y.dataId)),u=s.map(y=>y.shape),c=n.readSync(a.dataId),d=n.readSync(i.dataId),[h,p,f]=Zft(l,u,c,a.shape,a.dtype,d,i.shape,o),m=h.map(y=>n.makeTensorInfo([y.length],"int32",y)),g=n.makeTensorInfo(f,a.dtype,p);return m.concat([g])}var sxt={kernelName:eT,backendName:"webgl",kernelFunc:rxt};function axt(e){let{inputs:t,backend:n}=e,{starts:r,limits:s,deltas:a}=t,i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=Qft(i,r.shape,r.dtype,o,s.shape,l,a.shape),d=n.makeTensorInfo([u.length],"int32",u),h=n.makeTensorInfo([c.length],r.dtype,c);return[d,h]}var ixt={kernelName:tT,backendName:"webgl",kernelFunc:axt};function oxt(e){let{inputs:t,backend:n,attrs:r}=e,{shape:s,values:a,defaultValue:i,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=r,u=n.readSync(s.dataId),c=n.readSync(a.dataId),d=n.readSync(i.dataId),h=o.map(g=>n.readSync(g.dataId)),p=o.map(g=>g.shape),[f,m]=emt(u,s.shape,c,a.shape,a.dtype,d,i.shape,h,p,l);return n.makeTensorInfo(f,a.dtype,m)}var lxt={kernelName:nT,backendName:"webgl",kernelFunc:oxt},Sae=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=tmt(r,s,a,i);return t.makeTensorInfo([o.length],i,o)},uxt={kernelName:nw,backendName:"webgl",kernelFunc:Sae},cxt="return 1.0 / x;",dxt=tn({opSnippet:cxt}),hxt={kernelName:Nf,backendName:"webgl",kernelFunc:dxt},pxt=oo+`
  return (x < 0.0) ? 0.0 : x;
`,fxt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,mxt=tn({opSnippet:pxt,packedOpSnippet:fxt}),gxt={kernelName:Tf,backendName:"webgl",kernelFunc:mxt},yxt=oo+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,bxt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,vxt=tn({opSnippet:yxt,packedOpSnippet:bxt}),xxt={kernelName:_f,backendName:"webgl",kernelFunc:vxt},wxt=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}},kxt=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Sxt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new kxt(s.shape,l,u,a,i):new wxt(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],"float32")}var Ixt={kernelName:Ef,backendName:"webgl",kernelFunc:Sxt},Cxt=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Nxt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Cxt(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var Txt={kernelName:wb,backendName:"webgl",kernelFunc:Nxt},$xt=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;s?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/c[0]},
          ${u[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${o}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}},Ext=class{constructor(e,t,n,r,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,i,o,l]=e;this.outputShape=[a,t,n,l];let u=[r&&t>1?i-1:i,r&&n>1?o-1:o],c=[r&&t>1?t-1:t,r&&n>1?n-1:n],d=r?"0.5":"0.0",h;s?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/c[0]},
          ${u[1]/c[1]},
          ${u[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${o}.0,
                                     ${o}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function _xt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s}=t,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,c=xe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Ext(s.shape,l,u,a,i):new $xt(s.shape,l,u,a,i);return n.runWebGLProgram(c,[s],s.dtype)}var Axt={kernelName:$f,backendName:"webgl",kernelFunc:_xt},Rxt=class{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;let[,r,s]=t,[,a,i]=e,o=[n&&a>1?r-1:r,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],u=o[0]/l[0],c=o[1]/l[1],d=1/u,h=1/c,p=Math.ceil(d)*2+2,f=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${c});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${f});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${o[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${o[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Dxt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=new Rxt(a.shape,s.shape,i);return n.runWebGLProgram(o,[a],a.dtype)}var Oxt={kernelName:xb,backendName:"webgl",kernelFunc:Dxt},Fxt=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,o)=>r(o)).join(","),a=Tn(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}},Mxt=class{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let r=Xs("rc",n),s=`${r[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${r[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Tn(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${o(r.slice())};
          if(${s}){
            result.g = ${l(r.slice())};
          }
          if(${a}) {
            result.b = ${u(r.slice())};
            if(${s}) {
              result.a = ${c(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function o(p){return d(p)}function l(p){return p[n-1]="("+p[n-1]+" + 1)",d(p)}function u(p){return p[n-2]="("+p[n-2]+" + 1)",d(p)}function c(p){return p[n-1]="("+p[n-1]+" + 1)",p[n-2]="("+p[n-2]+" + 1)",d(p)}function d(p){let f=e.map((y,b)=>h(b,p)),m=f.join(","),g=f.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function h(p,f){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${f[p]} - 1`:`${f[p]}`}}};function Pxt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=s.shape.length,o=M.parseAxisParam(a,s.shape);if(i===0)return ti({inputs:{x:s},backend:n});let l=xe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mxt(s.shape,o):new Fxt(s.shape,o);return n.runWebGLProgram(l,[s],s.dtype)}var Lxt={kernelName:Af,backendName:"webgl",kernelFunc:Pxt},zxt=class{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],r=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}},Bxt={kernelName:Mb,backendName:"webgl",kernelFunc:({inputs:e,attrs:t,backend:n})=>{let{image:r}=e,{radians:s,fillValue:a,center:i}=t,o=n,l=new zxt(r.shape,a),[u,c]=H.getImageCenter(i,r.shape[1],r.shape[2]),d=[[u,c,Math.sin(s),Math.cos(s)]];return o.runWebGLProgram(l,[r],r.dtype,d)}},Wxt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Vxt=tn({opSnippet:Wxt}),Uxt={kernelName:Rf,backendName:"webgl",kernelFunc:Vxt},jxt="return inversesqrt(x);",Gxt=tn({opSnippet:jxt,cpuKernelImpl:nmt}),Hxt={kernelName:Df,backendName:"webgl",kernelFunc:Gxt},fz=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let l=Tn(s.length),u=Tn(a.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${g};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}},qxt=class{constructor(e,t,n,r,s,a,i=!0,o=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;let l=Tn(s.length),u=Tn(a.length),c="";n===1?c="i":n===2&&(c="i, j");let d=`getIndices(${c})`,h="";r===1?h="i":r===2&&(h="i, coords[1]");let p=`getUpdates(${h})`,f="";o&&(f="coords[0], coords[1]");let m=`getDefaultValue(${f})`,g=t>1?"strides[j]":"strides",y=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${g};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${y};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}};function Kxt(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s,updates:a}=t,{shape:i}=r,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=H.calculateShapes(a,s,i),h=[d/u,u];if(d===0)return n.makeTensorInfo(i,s.dtype);let p=Qe({inputs:{x:s},backend:n,attrs:{shape:[l,o]}}),f=Qe({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0])),g;xe().getBool("WEBGL_PACK")?g=new qxt(l,o,p.shape.length,f.shape.length,c,h):g=new fz(l,o,p.shape.length,f.shape.length,c,h);let y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=Qe({inputs:{x:y},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}var Xxt={kernelName:kb,backendName:"webgl",kernelFunc:Kxt},Yxt=class{constructor(e,t,n,r){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=xe().getNumber("WEBGL_VERSION")===2?s:a,o=r==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${o} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Jxt(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r,o=new Yxt(s.shape[0],s.shape[1],a.shape[1],i),l=[[s.shape[1]]];return n.runWebGLProgram(o,[s,a],"int32",l)}var Zxt={kernelName:Ib,backendName:"webgl",kernelFunc:Jxt},Qxt=class{constructor(e,t,n){this.variableNames=["c","a","b"],this.outputShape=t;let r,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",r="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&o.push(`${i[u]}`);r=o.join(),s=l.join()}let a=Tn(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function ewt(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=new Qxt(r.shape.length,s.shape,s.shape.length);return n.runWebGLProgram(i,[r,s,a],ki(s.dtype,a.dtype))}var twt={kernelName:Cb,backendName:"webgl",kernelFunc:ewt},nwt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${H.SELU_SCALEALPHA};
  float scale = ${H.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,rwt=tn({opSnippet:nwt}),swt={kernelName:Of,backendName:"webgl",kernelFunc:rwt},awt=tv+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,iwt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,owt=tn({opSnippet:awt,packedOpSnippet:iwt,cpuKernelImpl:smt}),lwt={kernelName:Lf,backendName:"webgl",kernelFunc:owt},uwt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,cwt=tn({opSnippet:uwt}),dwt={kernelName:Pf,backendName:"webgl",kernelFunc:cwt},hwt=tv+`
  return sin(x);
`,pwt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${nm}
  return result;
`,fwt=tn({opSnippet:hwt,packedOpSnippet:pwt}),mwt={kernelName:Ff,backendName:"webgl",kernelFunc:fwt},gwt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,ywt=tn({opSnippet:gwt}),bwt={kernelName:Mf,backendName:"webgl",kernelFunc:ywt},vwt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,xwt=tn({opSnippet:vwt}),wwt={kernelName:zf,backendName:"webgl",kernelFunc:xwt},kwt=e=>{let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r;M.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let o=a.reduce((y,b)=>y*b),l=[[0,0]];l.push(...i);for(let y=1+a.length;y<s.shape.length;++y)l.push([0,0]);let u=[],c=kae({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=H.getReshaped(c.shape,a,o,!1),h=H.getPermuted(d.length,a.length,!1),p=H.getReshapedPermuted(c.shape,a,o,!1),f=Qe({inputs:{x:c},backend:n,attrs:{shape:d}}),m=na({inputs:{x:f},backend:n,attrs:{perm:h}}),g=Qe({inputs:{x:m},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(m),u.forEach(y=>n.disposeIntermediateTensorInfo(y)),g},Swt={kernelName:Tb,backendName:"webgl",kernelFunc:kwt};function Iwt(e){let{inputs:t,backend:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=t;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(s.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${s.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let o=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(a.dataId),c=n.readSync(i.dataId)[0],[d,h,p,f,m]=imt(o,r.shape,r.dtype,l,s.dtype,u,c);return[n.makeTensorInfo(h,r.dtype,d),n.makeTensorInfo([h[0]],s.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),n.makeTensorInfo([m.length],r.dtype,new Int32Array(m))]}var Cwt={kernelName:rw,backendName:"webgl",kernelFunc:Iwt};function Nwt(e){let{inputs:t,backend:n}=e,{inputIndices:r,inputShape:s,newShape:a}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=Array.from(n.readSync(s.dataId)),o=n.readSync(r.dataId),l=Array.from(n.readSync(a.dataId)),[u,c,d]=omt(o,r.shape,r.dtype,i,l);return[n.makeTensorInfo(c,r.dtype,u),n.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}var Twt={kernelName:Eb,backendName:"webgl",kernelFunc:Nwt};function $wt(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=Gse(i,r.shape,r.dtype,o,l,!0);return n.makeTensorInfo(c,r.dtype,u)}var Ewt={kernelName:sw,backendName:"webgl",kernelFunc:$wt};function _wt(e){let{inputs:t,backend:n}=e,{data:r,indices:s,segmentIds:a}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${s.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);let i=n.readSync(r.dataId),o=n.readSync(s.dataId),l=n.readSync(a.dataId),[u,c]=Gse(i,r.shape,r.dtype,o,l);return n.makeTensorInfo(c,r.dtype,u)}var Awt={kernelName:aw,backendName:"webgl",kernelFunc:_wt};function Rwt(e){let{inputs:t,backend:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=t,{outputShape:o}=r,{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=H.calculateShapes(a,s,o),p=!1;if(a.dtype==="string"){let y=n.bufferSync(s),b=n.bufferSync(a),x=M.decodeString(n.readSync(i.dataId)[0]),v=rmt(y,b,o,h,c,u,l,d,x,p);return n.makeTensorInfo(o,v.dtype,v.values)}let f=new fz(u,l,s.shape.length,a.shape.length,d,[h,1],p),m=n.runWebGLProgram(f,[a,s,i],a.dtype),g=Qe({inputs:{x:m},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(m),g}var Dwt={kernelName:_b,backendName:"webgl",kernelFunc:Rwt};function Owt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=r,o=M.parseAxisParam(i,s.shape)[0],l=H.prepareSplitSize(s,a,o),u=s.shape.length,c=new Array(u).fill(0),d=s.shape.slice();return l.map(h=>{let p=[...d];p[o]=h;let f=nv({inputs:{x:s},backend:n,attrs:{begin:c,size:p}});return c[o]+=h,f})}var Fwt={kernelName:$b,backendName:"webgl",kernelFunc:Owt},n6="return sqrt(x);",Mwt=tn({opSnippet:n6,packedOpSnippet:n6,cpuKernelImpl:lmt}),Pwt={kernelName:Bf,backendName:"webgl",kernelFunc:Mwt},Lwt="return x * x;",zwt=tn({opSnippet:Lwt}),Bwt={kernelName:iw,backendName:"webgl",kernelFunc:zwt},r6="return (a - b) * (a - b);",Wwt=$s({opSnippet:r6,packedOpSnippet:r6}),Vwt={kernelName:Uf,backendName:"webgl",kernelFunc:Wwt};function Uwt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");let a=n.readSync(s.dataId),i=H.fromUint8ToStringArray(a),o=umt(i,"string",r);return n.makeTensorInfo(s.shape,"string",o)}var jwt={kernelName:ow,backendName:"webgl",kernelFunc:Uwt};function Gwt({inputs:e,attrs:t,backend:n}){let{x:r}=e,s=oo+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,a=new yl(r.shape,s);return n.runWebGLProgram(a,[r],r.dtype)}var Hwt={kernelName:yd,backendName:"webgl",kernelFunc:Gwt},qwt=class{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;let r=n.length,s=Tn(n.length),a=Tn(n.length),i="";if(r===1)i="coords * strides + begin";else{let o=0;i=n.map((l,u)=>(o++,n.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${o-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function Kwt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Hr.sliceInfo(s.shape,a,i,o,l,u,c,d,h),w;if(m)w=Qe({inputs:{x:s},backend:n,attrs:{shape:f}});else if(g||y){M.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let S=Hr.computeOutShape(b,x,v),I=nv({inputs:{x:s},backend:n,attrs:{begin:b,size:S}});w=Qe({inputs:{x:I},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(I)}else if(n.shouldExecuteOnCPU([s])){let S=n.readSync(s.dataId),I=zt(s.shape,s.dtype,S),$=cmt(p,I,v,b);w=n.makeTensorInfo(f,s.dtype,$.values)}else{let S=new qwt(b,v,p);w=n.runWebGLProgram(S,[s],s.dtype)}let k=Qe({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}var Xwt={kernelName:Ab,backendName:"webgl",kernelFunc:Kwt};function Ywt(e){let{inputs:t,backend:n,attrs:r}=e,{separator:s,nGramWidths:a,leftPad:i,rightPad:o,padWidth:l,preserveShortSequences:u}=r,{data:c,dataSplits:d}=t,h=n.readSync(c.dataId),p=n.readSync(d.dataId),[f,m]=dmt(h,p,s,a,i,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(d.shape,"int32",m)]}var Jwt={kernelName:lw,backendName:"webgl",kernelFunc:Ywt};function Zwt(e){let{inputs:t,backend:n,attrs:r}=e,{skipEmpty:s}=r,{input:a,delimiter:i}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let o=n.readSync(a.dataId),l=n.readSync(i.dataId)[0],[u,c,d]=hmt(o,l,s),h=c.length;return[n.makeTensorInfo([h,2],"int32",u),n.makeTensorInfo([h],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(d))]}var Qwt={kernelName:uw,backendName:"webgl",kernelFunc:Zwt};function ekt(e){let{inputs:t,backend:n,attrs:r}=e,{numBuckets:s}=r,{input:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(s<=0)throw new Error("Number of buckets must be at least 1");let i=n.readSync(a.dataId),o=pmt(i,s);return n.makeTensorInfo(a.shape,"int32",o)}var tkt={kernelName:cw,backendName:"webgl",kernelFunc:ekt},nkt="return tan(x);",rkt=tn({opSnippet:nkt}),skt={kernelName:Gf,backendName:"webgl",kernelFunc:rkt},akt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,ikt=tn({opSnippet:akt}),okt={kernelName:Hf,backendName:"webgl",kernelFunc:ikt};function lkt(e){let{inputs:t,backend:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=t,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:d}=H.calculateShapes(i,a,s.shape),h=[d/u,u];if(d===0)return n.makeTensorInfo(s.shape,a.dtype);let p=Qe({inputs:{x:a},backend:n,attrs:{shape:[l,o]}}),f=Qe({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),m=Qe({inputs:{x:s},backend:n,attrs:{shape:h}}),g=new fz(l,o,p.shape.length,f.shape.length,c,h,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=Qe({inputs:{x:y},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}var ukt={kernelName:Sb,backendName:"webgl",kernelFunc:lkt},ckt=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let r=Tn(this.rank),s=dkt(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function dkt(e){let t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${e[0]})`;let n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let s=0;s<e.length;s++)r.push(`imod(${n[s]}, ${e[s]})`);return r.join()}function Iae(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{reps:a}=r;if(s.dtype==="string"||s.shape.length>5){let o=n.readSync(s.dataId),l=s.dtype==="string"?o.map(d=>M.decodeString(d)):o,u=zt(s.shape,s.dtype,l),c=mmt(u,a);return n.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new ckt(s.shape,a);return n.runWebGLProgram(i,[s],s.dtype)}var hkt={kernelName:gd,backendName:"webgl",kernelFunc:Iae},pkt=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},fkt=class{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Od(e,t){t!==null&&e.disposeIntermediateTensorInfo(t)}function s6(e){let t=1;for(;t<e;)t*=2;return t}function mkt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{k:a,sorted:i}=r,o=xe().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=xe().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=s.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([s])||c<o||a>l){let $=n.readSync(s.dataId),[C,T]=gmt($,u,s.dtype,a,i);return[n.makeTensorInfo(C.shape,C.dtype,C.values),n.makeTensorInfo(T.shape,T.dtype,T.values)]}if(a===0)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(c===1)return[s,Gw({attrs:{shape:u,dtype:"int32",value:0},backend:n})];let d=n.texData.get(s.dataId),h=d!==null&&d.isPacked,p=h?n.unpackTensor(s):s,f=M.sizeFromShape(u)/c,m=Qe({inputs:{x:p},attrs:{shape:[f,c]},backend:n});h&&Od(n,p);let g=s6(a),y=s6(c),b=null,x=()=>b===null?[m,m]:[m,b],v=($,C,T)=>{let N=x(),E=new pkt(T),_=[[c],[b===null?1:0],[Number.NEGATIVE_INFINITY],[$],[C]],R=b;b=n.runWebGLProgram(E,N,"int32",_),Od(n,R)};for(let $=1;$<g;$*=2){let C=$*2;for(let T=$;T>=1;T/=2)v(C,T,[f,y])}for(let $=y;$>g;$/=2){let C=x(),T=new fkt([f,$/2]),N=[[c],[b===null?1:0],[g]],E=b;b=n.runWebGLProgram(T,C,"int32",N),Od(n,E);let _=g/2,R=_*2;for(let z=_;z>=1;z/=2)v(R,z,b.shape)}let w=b;b=nv({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,a]}}),Od(n,w);let k=gae({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});Od(n,m);let S=u.slice(0,-1);S.push(a),w=b,b=Qe({inputs:{x:b},attrs:{shape:S},backend:n}),Od(n,w);let I=k;return k=Qe({inputs:{x:k},attrs:{shape:S},backend:n}),Od(n,I),[k,b]}var gkt={kernelName:Rb,backendName:"webgl",kernelFunc:mkt},ykt=class{constructor(e,t,n,r,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;let i=n==="nearest"?1:2,o;switch(r){case"constant":o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4;break;default:o=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${o} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${o} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function bkt(e){let{inputs:t,backend:n,attrs:r}=e,{image:s,transforms:a}=t,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=new ykt(d,h,i,o,l,g);return n.runWebGLProgram(y,[s,a],"float32")}var vkt={kernelName:Db,backendName:"webgl",kernelFunc:bkt};function xkt(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t;Xb(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=r.readSync(a.dataId),{outputValues:o,outputShape:l,indices:u}=ymt(i,s,a.shape,a.dtype);return[r.makeTensorInfo(l,a.dtype,o),r.makeTensorInfo([u.length],"int32",u)]}var wkt={kernelName:dw,backendName:"webgl",kernelFunc:xkt};function kkt(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s,o=i.shape.length,l=s.shape[a],u=new Array(o-1),c=0;for(let m=0;m<o;m++)m!==a&&(u[c++]=i.shape[m]);let d=[],h=new Array(o).fill(0),p=i.shape.slice();p[a]=1;let f=new Array(l);for(let m=0;m<f.length;m++){h[a]=m;let g=nv({inputs:{x:i},backend:n,attrs:{begin:h,size:p}}),y=Qe({inputs:{x:g},backend:n,attrs:{shape:u}});f[m]=y,d.push(g)}return d.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}var Skt={kernelName:Ob,backendName:"webgl",kernelFunc:kkt},Ikt=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,r=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[r,i];let o="0.0",l="sumValue",u=Math.floor(n/4)*4,c=n%4,d=`
        sumValue += dot(values, segFilter);
    `,h="";s%n>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${o};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}};function Ckt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,segmentIds:a}=t,{numSegments:i}=r,o=s.shape.length,l=[],u=0,c=H.getAxesPermutation([u],o),d=s;c!=null&&(d=na({inputs:{x:s},backend:n,attrs:{perm:c}}),l.push(d),u=H.getInnerMostAxes(1,o)[0]);let h=H.segment_util.computeOutShape(d.shape,u,i),p=M.sizeFromShape([d.shape[u]]),f=Qe({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}});l.push(f);let m=aT(s.dtype),g=(v,w,k,S,I)=>{let $=v.shape[0],C=v.shape[1],T=H.segment_util.segOpComputeOptimalWindowSize(C,I),N={windowSize:T,inSize:C,batchSize:$,numSegments:I},E=new Ikt(N,w),_=n.compileAndRun(E,[v,k],S);if(l.push(_),_.shape[1]===I)return _;let R=Sae({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),z=Iae({inputs:{x:R},backend:n,attrs:{reps:[C/T]}});return l.push(R),l.push(z),g(_,w,z,S,I)},y=g(f,"unsortedSegmentSum",a,m,i),b=Qe({inputs:{x:y},backend:n,attrs:{shape:h}}),x=b;if(c!=null){l.push(b);let v=H.getUndoAxesPermutation(c);x=na({inputs:{x},backend:n,attrs:{perm:v}})}return l.forEach(v=>n.disposeIntermediateTensorInfo(v)),x}var Nkt={kernelName:hw,backendName:"webgl",kernelFunc:Ckt},Tkt=[cgt,hgt,mgt,bgt,xgt,Sgt,Cgt,Tgt,Agt,Dgt,Mgt,zgt,Vgt,Hgt,Xgt,Jgt,Qgt,ryt,ayt,oyt,dyt,byt,xyt,Iyt,Nyt,Ryt,Oyt,Lyt,qmt,Wyt,Hyt,Yyt,nbt,abt,obt,ubt,dbt,mbt,bbt,wbt,Sbt,Cbt,Tbt,_bt,Rbt,Mbt,Lbt,Wbt,jbt,Hbt,Ybt,evt,svt,ovt,cvt,dvt,pvt,mvt,yvt,vvt,wvt,Cvt,$vt,Avt,Dvt,Mvt,zvt,Uvt,qvt,Hmt,Xvt,jyt,Zvt,t1t,s1t,Xmt,l1t,h1t,f1t,b1t,w1t,C1t,$1t,R1t,M1t,z1t,W1t,G1t,q1t,X1t,Q1t,t0t,r0t,a0t,o0t,d0t,m0t,v0t,T0t,Zmt,A0t,O0t,P0t,B0t,$yt,U0t,G0t,q0t,Y0t,ext,Jmt,nxt,sxt,ixt,lxt,uxt,Eyt,S0t,hxt,gxt,xxt,egt,Ixt,Txt,Axt,Oxt,Lxt,Bxt,Uxt,Hxt,Xxt,Zxt,twt,swt,lwt,dwt,mwt,bwt,gyt,C0t,wwt,Swt,Cwt,Twt,Ewt,Awt,Dwt,Fwt,Pwt,Bwt,Vwt,jwt,Hwt,Xwt,Jwt,Qwt,tkt,I0t,ogt,skt,okt,ukt,hkt,gkt,vkt,lgt,wkt,Skt,Nkt,j0t];for(let e of Tkt)pw(e);var sn;(function(e){e[e.float32=0]="float32",e[e.int32=1]="int32",e[e.bool=2]="bool",e[e.string=3]="string",e[e.complex64=4]="complex64"})(sn||(sn={}));var h0;(function(e){e[e.linear=0]="linear",e[e.relu=1]="relu",e[e.relu6=2]="relu6",e[e.prelu=3]="prelu",e[e.leakyrelu=4]="leakyrelu",e[e.sigmoid=5]="sigmoid",e[e.elu=6]="elu"})(h0||(h0={}));var Cae;function $kt(e){Cae=e.wasm.cwrap(Uh,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Ekt(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a,bias:i,preluActivationWeights:o}=t;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:d}=r,h=n.dataIdMap.get(s.dataId).id,p=n.dataIdMap.get(a.dataId).id,f=0;if(i!=null){let I=n.dataIdMap.get(i.dataId);if(I.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${I.shape.length}.`);f=I.id}let m=o==null?0:n.dataIdMap.get(o.dataId).id,g=h0[c];if(g==null)throw new Error(`${c} activation not yet supported for FusedConv2D in the wasm backend.`);let y=l?s.shape[2]:s.shape[1],b=u?a.shape[1]:a.shape[2],x=Pb.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)),v=n.makeOutput([...x,y,b],s.dtype),w=n.dataIdMap.get(v.dataId).id,k=new Uint8Array(new Int32Array(s.shape).buffer),S=new Uint8Array(new Int32Array(a.shape).buffer);return Cae(h,k,s.shape.length,p,S,a.shape.length,l,u,g,f,m,d||0,w),v}var _kt={kernelName:Uh,backendName:"wasm",setupFunc:$kt,kernelFunc:Ekt};function Jt(e,t){let n;function r(a){n=a.wasm.cwrap(e,null,["number","number","number"])}function s(a){let{backend:i,inputs:{x:o}}=a,l=i.dataIdMap.get(o.dataId).id,u=i.makeOutput(o.shape,t||o.dtype),c=i.dataIdMap.get(u.dataId).id;return M.sizeFromShape(u.shape)===0||n(l,sn[o.dtype],c),u}return{kernelName:e,backendName:"wasm",setupFunc:r,kernelFunc:s}}var Akt=Jt(Fy),Rkt=Jt(Tp),Dkt=Jt($p);function Fr(e,t,n){let r;function s(i){r=i.wasm.cwrap(e,null,["number","array","number","number","array","number","number","number"])}function a(i){let{backend:o,inputs:l}=i,{a:u,b:c}=l,d=o.dataIdMap.get(u.dataId).id,h=o.dataIdMap.get(c.dataId).id,p=n??u.dtype,f=H.assertAndGetBroadcastShape(u.shape,c.shape),m=o.makeOutput(f,p);if(M.sizeFromShape(f)===0)return m;let g=new Uint8Array(new Int32Array(u.shape).buffer),y=new Uint8Array(new Int32Array(c.shape).buffer),b=o.dataIdMap.get(m.dataId).id;return r(d,g,u.shape.length,h,y,c.shape.length,sn[u.dtype],b),m}return{kernelName:e,backendName:"wasm",setupFunc:s,kernelFunc:a}}var Okt=Fr(fd),Nae;function Fkt(e){Nae=e.wasm.cwrap(Ep,null,["array","number","number","number"])}function Mkt(e){let{inputs:t,backend:n}=e,r=n.makeOutput(t[0].shape,t[0].dtype);if(M.sizeFromShape(r.shape)===0)return r;let s=t.map(o=>n.dataIdMap.get(o.dataId).id),a=new Uint8Array(new Int32Array(s).buffer),i=n.dataIdMap.get(r.dataId).id;return Nae(a,s.length,sn[r.dtype],i),r}var Pkt={kernelName:Ep,backendName:"wasm",setupFunc:Fkt,kernelFunc:Mkt};function p$(e){let{inputs:{x:t},backend:n}=e;if(t.dtype==="string")return Js(n.readSync(t.dataId),t.shape,t.dtype);let r=n.makeOutput(t.shape,t.dtype),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(r).set(s),r}var Lkt={kernelName:rf,backendName:"wasm",kernelFunc:p$},Tae;function zkt(e){Tae=e.wasm.cwrap(au,null,["number","array","number","number","number","array","number"])}function Xc(e){let{inputs:t,backend:n,attrs:r}=e,[s,a]=Wkt(t.x.shape,r.perm),i=!0;for(let f=0;f<a.length;f++)a[f]!==f&&(i=!1);let o=Bkt(t.x.shape,r.perm),l={dataId:t.x.dataId,shape:s,dtype:t.x.dtype};if(i){let f=p$({inputs:t,backend:n});return f.shape=o,f}let u=n.makeOutput(o,l.dtype),c=n.dataIdMap.get(l.dataId).id,d=n.dataIdMap.get(u.dataId).id,h=new Uint8Array(new Int32Array(a).buffer),p=new Uint8Array(new Int32Array(l.shape).buffer);return Tae(c,p,l.shape.length,sn[l.dtype],d,h,a.length),u}function Bkt(e,t){let n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];return n}function Wkt(e,t){let n=[],r=[];for(let s=0;s<e.length;++s)e[s]!==1&&n.push(e[s]),e[t[s]]!==1&&r.push(t[s]);for(let s=0;s<r.length;++s){let a=-1;for(let i=0;i<r.length;++i)r[i]>=s&&(a===-1||r[a]>r[i])&&(a=i);r[a]=s}return[n,r]}var Vkt={kernelName:au,backendName:"wasm",kernelFunc:Xc,setupFunc:zkt};function Cd(e,t,n){let r=e.shape,s=e.shape.length,a=M.parseAxisParam(t,r),i=a,o=H.getAxesPermutation(i,s),l=null,u=!1;if(o!=null){let c=new Array(s);for(let h=0;h<c.length;h++)c[h]=r[o[h]];i=H.getInnerMostAxes(i.length,s),l=Xc({inputs:{x:e},attrs:{perm:o},backend:n});let d=n.dataIdMap.get(e.dataId).id;n.dataIdMap.get(l.dataId).id!==d&&(u=!0)}return{transposed:l,originalAxes:a,axes:i,inputWasTransposed:u}}var $ae;function Ukt(e){$ae=e.wasm.cwrap(My,null,["number, number, number"])}function jkt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Cd(i,s,t);if(h){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;H.assertAxesAreInnerMostDims("all",c,p);let[f,m]=H.computeOutAndReduceShapes(l.shape,c),g=M.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(M.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;$ae(o,g,b)}if(h&&t.disposeData(u.dataId),a){let b=H.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var Gkt={kernelName:My,backendName:"wasm",setupFunc:Ukt,kernelFunc:jkt},Eae;function Hkt(e){Eae=e.wasm.cwrap(Py,null,["number, number, number"])}function qkt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Cd(i,s,t);if(h){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;H.assertAxesAreInnerMostDims("any",c,p);let[f,m]=H.computeOutAndReduceShapes(l.shape,c),g=M.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(M.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;Eae(o,g,b)}if(h&&t.disposeData(u.dataId),a){let b=H.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var Kkt={kernelName:Py,backendName:"wasm",setupFunc:Hkt,kernelFunc:qkt};function _ae(e){let t;function n(s){t=s.wasm.cwrap(e,null,["number","number","number","number","number"])}function r(s){let{backend:a,inputs:i,attrs:o}=s,{axis:l}=o,{x:u}=i,c=a.dataIdMap.get(u.dataId).id,d=c,h=u,{transposed:p,axes:f,inputWasTransposed:m}=Cd(u,l,a);if(m){let w=a.dataIdMap.get(p.dataId).id;w!==c&&(h=p,d=w)}let g=h.shape.slice(0,-1),y=a.makeOutput(g,"int32"),b=a.dataIdMap.get(y.dataId).id,x=M.sizeFromShape(y.shape),v=h.shape[f[0]];return t(d,sn[h.dtype],x,v,b),m&&a.disposeData(p.dataId),y}return{kernelName:e,backendName:"wasm",setupFunc:n,kernelFunc:r}}var Xkt=_ae(Ly),Ykt=_ae(zy),Jkt=Jt(_p),Zkt=Jt(Ap),Qkt=Jt(Rp),e2t=Fr(Op),t2t=Jt(Dp),Aae;function n2t(e){Aae=e.wasm.cwrap(Fp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function r2t(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=H.computePool2DInfo(s.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.strideHeight,b=c.strideWidth,x=c.inChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);if(c.dilationWidth!==1||c.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${c.dilationHeight}, ${c.dilationWidth}].`);let v=r.makeOutput(c.outShape,"float32"),w=r.dataIdMap.get(v.dataId).id;return Aae(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,y,b,x,w),v}var s2t={kernelName:Fp,backendName:"wasm",setupFunc:n2t,kernelFunc:r2t},Rae;function a2t(e){Rae=e.wasm.cwrap("AvgPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function i2t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=H.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.makeOutput(c.outShape,s.dtype);return Rae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var o2t={kernelName:By,backendName:"wasm",setupFunc:a2t,kernelFunc:i2t},Dae;function l2t(e){Dae=e.wasm.cwrap("AvgPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function u2t(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=H.computePool3DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return Dae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left,c.filterDepth,c.filterHeight,c.filterWidth),d}var c2t={kernelName:qx,backendName:"wasm",setupFunc:l2t,kernelFunc:u2t},Oae;function d2t(e){Oae=e.wasm.cwrap("AvgPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function h2t(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l}=r,u=H.computePool2DInfo(a.shape,i,o,1,l),c=n.makeOutput(a.shape,a.dtype);return Oae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.effectiveFilterHeight,u.effectiveFilterWidth,u.padInfo.top,u.padInfo.left,u.filterHeight,u.filterWidth),c}var p2t={kernelName:Hx,backendName:"wasm",setupFunc:d2t,kernelFunc:h2t};function ba(e){let{inputs:t,attrs:n}=e,{x:r}=t,{shape:s}=n,a=M.sizeFromShape(r.shape),i=M.inferFromImplicitShape(s,a);return M.assert(a===M.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${r.shape}. New shape and old shape must have the same number of elements.`),e.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}var f2t={kernelName:vb,backendName:"wasm",kernelFunc:ba},Fae;function m2t(e){Fae=e.wasm.cwrap(Mp,null,["number","array","number","number","array","number","number","number","number"])}function g2t(e){let{inputs:t,backend:n,attrs:r}=e,{a:s,b:a}=t,{transposeA:i,transposeB:o}=r;if(s.dtype!=="float32"||a.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let l=s.shape.length,u=a.shape.length,c=i?s.shape[l-2]:s.shape[l-1],d=o?a.shape[u-1]:a.shape[u-2],h=i?s.shape[l-1]:s.shape[l-2],p=o?a.shape[u-2]:a.shape[u-1],f=s.shape.slice(0,-2),m=a.shape.slice(0,-2),g=M.sizeFromShape(f),y=M.sizeFromShape(m),b=Pb.assertAndGetBroadcastShape(s.shape.slice(0,-2),a.shape.slice(0,-2)).concat([h,p]);M.assert(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${s.shape} and ${a.shape} and transposeA=${i} and transposeB=${o} must match.`);let x=i?[g,c,h]:[g,h,c],v=o?[y,p,d]:[y,d,p],w=ba({inputs:{x:s},backend:n,attrs:{shape:x}}),k=ba({inputs:{x:a},backend:n,attrs:{shape:v}}),S=n.dataIdMap.get(w.dataId).id,I=n.dataIdMap.get(k.dataId).id,$=i?w.shape[2]:w.shape[1],C=o?k.shape[1]:k.shape[2],T=Math.max(g,y),N=n.makeOutput([T,$,C],w.dtype),E=n.dataIdMap.get(N.dataId).id,_=new Uint8Array(new Int32Array(w.shape).buffer),R=new Uint8Array(new Int32Array(k.shape).buffer);return Fae(S,_,w.shape.length,I,R,k.shape.length,i,o,E),n.disposeData(w.dataId),n.disposeData(k.dataId),N.shape=b,N}var y2t={kernelName:Mp,backendName:"wasm",setupFunc:m2t,kernelFunc:g2t};function lp(e){let{inputs:{x:t},attrs:{begin:n,size:r},backend:s}=e,[a,i]=Hr.parseSliceParams(t,n,r),o=Hr.isSliceContinous(t.shape,a,i),l=s.readSync(t.dataId),u=s.makeOutput(i,t.dtype),c=M.computeStrides(t.shape),d=s.dataIdMap.get(u.dataId);if(o){let f=Hr.computeFlatOffset(a,c);return t.dtype==="string"?d.stringBytes=l.slice(f,f+M.sizeFromShape(i)):s.typedArrayFromHeap(u).set(l.subarray(f,f+M.sizeFromShape(i))),u}if(t.dtype==="string"){let f=fI(l,a,i,t.shape,t.dtype);return d.stringBytes=f,u}let h=s.typedArrayFromHeap(u),p=t.shape.length;if(p===2)b2t(l,c[0],h,a,i);else if(p===3)v2t(l,c[0],c[1],h,a,i);else if(p===4)x2t(l,c[0],c[1],c[2],h,a,i);else{let f=fI(l,a,i,t.shape,t.dtype);h.set(f)}return u}function b2t(e,t,n,r,s){let a=0,i=r[0],o=r[1],l=i+s[0];for(let u=i;u<l;u++){let c=u*t+o;n.set(e.subarray(c,c+s[1]),a),a+=s[1]}}function v2t(e,t,n,r,s,a){let i=0,o=s[0],l=s[1],u=s[2],c=o+a[0],d=l+a[1];for(let h=o;h<c;h++)for(let p=l;p<d;p++){let f=h*t+p*n+u;r.set(e.subarray(f,f+a[2]),i),i+=a[2]}}function x2t(e,t,n,r,s,a,i){let o=0,l=a[0],u=a[1],c=a[2],d=l+i[0],h=u+i[1],p=c+i[2],f=a[3];for(let m=l;m<d;m++)for(let g=u;g<h;g++)for(let y=c;y<p;y++){let b=m*t+g*n+y*r+f;s.set(e.subarray(b,b+i[3]),o),o+=i[3]}}var w2t={kernelName:Nb,backendName:"wasm",kernelFunc:lp};function k2t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,crops:i}=r,o=a.reduce((y,b)=>y*b),l=H.getReshaped(s.shape,a,o),u=H.getPermuted(l.length,a.length),c=H.getReshapedPermuted(s.shape,a,o),d=H.getSliceBeginCoords(i,a.length),h=H.getSliceSize(c,i,a.length),p=ba({inputs:{x:s},backend:n,attrs:{shape:l}}),f=Xc({inputs:{x:p},backend:n,attrs:{perm:u}}),m=ba({inputs:{x:f},backend:n,attrs:{shape:c}}),g=lp({inputs:{x:m},backend:n,attrs:{begin:d,size:h}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(m.dataId),g}var S2t={kernelName:Wy,backendName:"wasm",kernelFunc:k2t},Mae;function I2t(e){Mae=e.wasm.cwrap(Vy,null,["number","number","boolean","number","number","number"])}function C2t(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i}=r,o=a.shape.reduce((d,h)=>d*h,1)!==0,l=s.shape.length===1?[i]:[s.shape[0],i],u=t.makeOutput(l,a.dtype);function c(d){return t.dataIdMap.get(d.dataId).id}return Mae(c(s),i,o,c(a),sn[a.dtype],c(u)),u}var N2t={kernelName:Vy,backendName:"wasm",setupFunc:I2t,kernelFunc:C2t},T2t=Fr(Uy);function $2t(e){let{inputs:t,backend:n}=e,{s0:r,s1:s}=t,a=n.typedArrayFromHeap(r),i=n.typedArrayFromHeap(s),o=H.assertAndGetBroadcastShape(Array.from(a),Array.from(i));return n.makeOutput([o.length],"int32",void 0,new Int32Array(o))}var E2t={kernelName:Kx,backendName:"wasm",kernelFunc:$2t};function Nd(e){let{inputs:{x:t},attrs:{dtype:n},backend:r}=e,s=r.makeOutput(t.shape,n),a=r.typedArrayFromHeap(t);return r.typedArrayFromHeap(s).set(a),s}var _2t={kernelName:Pp,backendName:"wasm",kernelFunc:Nd},A2t=Jt(Lp),Pae;function R2t(e){Pae=e.wasm.cwrap(md,null,["number","number","number","number"])}function D2t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{clipValueMin:a,clipValueMax:i}=r,o=n.dataIdMap.get(s.dataId).id,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(l.dataId).id;return Pae(o,a,i,u),l}var O2t={kernelName:md,backendName:"wasm",setupFunc:R2t,kernelFunc:D2t};function Lae(e){let{inputs:t,backend:n}=e,r=M.parseAxisParam(e.attrs.axis,t[0].shape)[0],s=t.map(p=>p.shape);H.assertParamsConsistent(s,r);let a=H.computeOutShape(t.map(p=>p.shape),r),i=t.filter(p=>M.sizeFromShape(p.shape)>0);if(i.length===1)return p$({inputs:{x:i[0]},backend:n});let o=n.makeOutput(a,t[0].dtype);if(M.sizeFromShape(a)===0)return o;if(i[0].dtype==="string"){let p=i.map(x=>{let v=[-1,M.sizeFromShape(x.shape.slice(r))];return ba({inputs:{x},backend:n,attrs:{shape:v}})}),f=p.map(x=>({vals:n.readSync(x.dataId),shape:x.shape}));a=H.computeOutShape(p.map(x=>x.shape),1);let m=p[0].shape[0]===1,g=B4(f,a,t[0].dtype,m),y=H.computeOutShape(i.map(x=>x.shape),r);o.shape=y;let b=n.dataIdMap.get(o.dataId);return b.stringBytes=H.fromStringArrayToUint8(g),p.forEach(x=>n.disposeData(x.dataId)),o}let l=M.sizeFromShape(i[0].shape.slice(0,r)),u=0,c=i.map(p=>{let f=M.sizeFromShape(p.shape.slice(r));return u+=f,f}),d=i.map(p=>n.typedArrayFromHeap(p)),h=n.typedArrayFromHeap(o);for(let p=0;p<l;p++){let f=p*u;for(let m=0;m<d.length;m++){let g=c[m],y=p*g,b=d[m].subarray(y,y+g);h.set(b,f),f+=g}}return o}var F2t={kernelName:jy,backendName:"wasm",kernelFunc:Lae},zae;function M2t(e){zae=e.wasm.cwrap(zp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function P2t(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d,dataFormat:h}=n,p=H.convertConv2DDataFormat(h),f=H.computeConv2DInfo(s.shape,a.shape,l,u,c,d,!1,p),m=f.filterHeight,g=f.filterWidth,y=f.padInfo.top,b=f.padInfo.right,x=f.padInfo.bottom,v=f.padInfo.left,w=f.dilationHeight,k=f.dilationWidth,S=f.strideHeight,I=f.strideWidth,$=f.inChannels,C=f.outChannels,T=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let N=r.makeOutput(f.outShape,"float32"),E=r.dataIdMap.get(N.dataId).id;return zae(i,s.shape[0],s.shape[1],s.shape[2],o,m,g,y,b,x,v,T,w,k,S,I,$,C,E),N}var L2t={kernelName:zp,backendName:"wasm",setupFunc:M2t,kernelFunc:P2t},Bae;function z2t(e){Bae=e.wasm.cwrap(Bp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function B2t(e){let{backend:t,inputs:n,attrs:r}=e,{dy:s,filter:a}=n,{strides:i,pad:o,dataFormat:l,dimRoundingMode:u,inputShape:c}=r,d=1,h=H.convertConv2DDataFormat(l),p=H.computeConv2DInfo(c,a.shape,i,d,o,u,!1,h),{batchSize:f,filterHeight:m,filterWidth:g,inChannels:y,inHeight:b,inWidth:x,outChannels:v,outHeight:w,outWidth:k,strideHeight:S,strideWidth:I}=p,$=m-1-p.padInfo.top,C=g-1-p.padInfo.left,T=p.dataFormat==="channelsLast",N=M.computeStrides(p.inShape),E=M.computeStrides(s.shape),[_,R,z]=M.computeStrides(a.shape),W=N[0],F=T?N[1]:N[2],L=T?N[2]:1,O=T?1:N[1],D=E[0],B=T?E[1]:E[2],V=T?E[2]:1,K=T?1:E[1],G=t.makeOutput(p.inShape,"float32"),U=t.dataIdMap.get(G.dataId).id,q=t.dataIdMap.get(s.dataId).id,Q=t.dataIdMap.get(a.dataId).id;return Bae(q,Q,f,m,g,b,x,y,w,k,v,S,I,$,C,_,R,z,W,F,L,O,D,B,V,K,U),G}var W2t={kernelName:Bp,backendName:"wasm",setupFunc:z2t,kernelFunc:B2t},Wae;function V2t(e){Wae=e.wasm.cwrap(Wp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function U2t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor x must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=H.computeConv3DInfo(s.shape,a.shape,i,l,o),c=n.makeOutput(u.outShape,s.dtype);return Wae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var j2t={kernelName:Wp,backendName:"wasm",setupFunc:V2t,kernelFunc:U2t},Vae;function G2t(e){Vae=e.wasm.cwrap(Gy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function H2t(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,dy:a}=t,{strides:i,pad:o,filterShape:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=H.computeConv3DInfo(s.shape,l,i,1,o),c=n.makeOutput(u.filterShape,a.dtype);return Vae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var q2t={kernelName:Gy,backendName:"wasm",setupFunc:G2t,kernelFunc:H2t},Uae;function K2t(e){Uae=e.wasm.cwrap(Hy,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function X2t(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,filter:a}=t,{pad:i,strides:o,inputShape:l}=r;if(s.dtype!=="float32")throw new Error(`Tensor dy must have dtype float32, got ${s.dtype}`);if(a.dtype!=="float32")throw new Error(`Tensor filter must have dtype float32, got ${a.dtype}`);let u=H.computeConv3DInfo(l,a.shape,o,1,i),c=n.makeOutput(u.inShape,s.dtype);return Uae(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(c.dataId).id,u.batchSize,u.inDepth,u.inHeight,u.inWidth,u.inChannels,u.outDepth,u.outHeight,u.outWidth,u.outChannels,u.strideDepth,u.strideHeight,u.strideWidth,u.dilationDepth,u.dilationHeight,u.dilationWidth,u.filterDepth,u.filterHeight,u.filterWidth,u.padInfo.front,u.padInfo.top,u.padInfo.left),c}var Y2t={kernelName:Hy,backendName:"wasm",setupFunc:K2t,kernelFunc:X2t},J2t=Jt(Vp),Z2t=Jt(Up),YR;(function(e){e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest"})(YR||(YR={}));var jae;function Q2t(e){jae=e.wasm.cwrap(Ky,null,["number","number","number","number","array","number","number","number","number","number"])}function eSt(e){let{backend:t,inputs:n,attrs:r}=e,{method:s,extrapolationValue:a,cropSize:i}=r,{image:o,boxes:l,boxInd:u}=n,c=l.shape[0],[d,h]=i,p=[c,d,h,o.shape[3]],f=t.dataIdMap.get(o.dataId),m;o.dtype!=="float32"&&(m=Nd({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(m.dataId));let g=f.id,y=t.dataIdMap.get(l.dataId).id,b=t.dataIdMap.get(u.dataId).id,x=t.makeOutput(p,"float32"),v=t.dataIdMap.get(x.dataId).id,w=new Uint8Array(new Int32Array(o.shape).buffer);return jae(g,y,b,c,w,d,h,YR[s],a,v),m!=null&&t.disposeData(m.dataId),x}var tSt={kernelName:Ky,backendName:"wasm",setupFunc:Q2t,kernelFunc:eSt},Gae;function nSt(e){Gae=e.wasm.cwrap(qy,null,["number","number","number","number","number","number"])}function rSt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,l=s.shape.length;M.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumprod does not support ${s.dtype} tensors in the WASM backend`);let u=H.getAxesPermutation([a],l),c=s;u!==null&&(c=Xc({inputs:{x:s},attrs:{perm:u},backend:n}));let d=H.getInnerMostAxes(1,l)[0];H.assertAxesAreInnerMostDims("cumprod",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;Gae(f,i?1:0,o?1:0,p,m,sn[s.dtype]);let g=h;if(u!==null){let y=H.getUndoAxesPermutation(u);g=Xc({inputs:{x:h},attrs:{perm:y},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}var sSt={kernelName:qy,backendName:"wasm",setupFunc:nSt,kernelFunc:rSt},Hae;function aSt(e){Hae=e.wasm.cwrap(jp,null,["number","number","number","number","number","number"])}function iSt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{axis:a,exclusive:i,reverse:o}=r,l=s.shape.length;M.assert(s.dtype==="float32"||s.dtype==="int32",()=>`cumsum does not support ${s.dtype} tensors in the WASM backend`);let u=H.getAxesPermutation([a],l),c=s;u!==null&&(c=Xc({inputs:{x:s},attrs:{perm:u},backend:n}));let d=H.getInnerMostAxes(1,l)[0];H.assertAxesAreInnerMostDims("cumsum",[d],l);let h=n.makeOutput(c.shape,c.dtype),p=c.shape[d],f=n.dataIdMap.get(c.dataId).id,m=n.dataIdMap.get(h.dataId).id;Hae(f,i?1:0,o?1:0,p,m,sn[s.dtype]);let g=h;if(u!==null){let y=H.getUndoAxesPermutation(u);g=Xc({inputs:{x:h},attrs:{perm:y},backend:n}),n.disposeData(c.dataId),n.disposeData(h.dataId)}return g}var oSt={kernelName:jp,backendName:"wasm",setupFunc:aSt,kernelFunc:iSt},qae;function lSt(e){qae=e.wasm.cwrap("DenseBincount",null,["number","array","number","number","boolean","number","number","boolean","number"])}function uSt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,weights:a}=n,{size:i,binaryOutput:o}=r,l=a.shape.reduce((h,p)=>h*p,1)!==0,u=s.shape.length===1?[i]:[s.shape[0],i],c=t.makeOutput(u,a.dtype);function d(h){return t.dataIdMap.get(h.dataId).id}return qae(d(s),new Uint8Array(new Int32Array(s.shape).buffer),s.shape.length,i,l,d(a),sn[a.dtype],o,d(c)),c}var cSt={kernelName:Yx,backendName:"wasm",setupFunc:lSt,kernelFunc:uSt},Kae;function dSt(e){Kae=e.wasm.cwrap(Xy,null,["number","number","number","array","number","array","array","number","number"])}function hSt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{blockSize:a,dataFormat:i}=r,o=s.shape[0],l=i==="NHWC"?s.shape[1]:s.shape[2],u=i==="NHWC"?s.shape[2]:s.shape[3],c=i==="NHWC"?s.shape[3]:s.shape[1],d=l*a,h=u*a,p=c/(a*a),f=i==="NHWC"?[o,d,h,p]:[o,p,d,h],m=t.makeOutput(f,"float32"),g=t.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(M.computeStrides(s.shape)).buffer),b=new Uint8Array(new Int32Array(f).buffer),x=new Uint8Array(new Int32Array(M.computeStrides(f)).buffer),v=t.dataIdMap.get(m.dataId).id;return Kae(g,a,i==="NHWC"?1:0,y,s.shape.length-1,b,x,f.length,v),m}var pSt={kernelName:Xy,backendName:"wasm",setupFunc:dSt,kernelFunc:hSt},Xae;function fSt(e){Xae=e.wasm.cwrap(Gp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function mSt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a}=t,i=r.dataIdMap.get(s.dataId).id,o=r.dataIdMap.get(a.dataId).id,{strides:l,dilations:u,pad:c,dimRoundingMode:d}=n,h=u??[1,1],p=H.computeConv2DInfo(s.shape,a.shape,l,h,c,d,!0),f=p.filterHeight,m=p.filterWidth,g=p.padInfo.top,y=p.padInfo.right,b=p.padInfo.bottom,x=p.padInfo.left,v=p.dilationHeight,w=p.dilationWidth,k=p.strideHeight,S=p.strideWidth,I=p.inChannels,$=p.outChannels,C=p.padInfo.type==="SAME"?1:0;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let T=r.makeOutput(p.outShape,"float32"),N=r.dataIdMap.get(T.dataId).id;return Xae(i,s.shape[0],s.shape[1],s.shape[2],o,f,m,g,y,b,x,C,v,w,k,S,I,$,N),T}var gSt={kernelName:Gp,backendName:"wasm",setupFunc:fSt,kernelFunc:mSt},Yae;function ySt(e){Yae=e.wasm.cwrap("Diag",null,["number","number","number","number"])}function bSt(e){let{inputs:t,backend:n}=e,{x:r}=t,s=M.sizeFromShape(r.shape),a=n.makeOutput([...r.shape,...r.shape],r.dtype);return Yae(n.dataIdMap.get(r.dataId).id,sn[r.dtype],s,n.dataIdMap.get(a.dataId).id),a}var vSt={kernelName:Jx,backendName:"wasm",setupFunc:ySt,kernelFunc:bSt},Jae;function xSt(e){Jae=e.wasm.cwrap(Hp,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wSt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a}=t,{strides:i,pad:o,dilations:l}=r;if(s.dtype!==a.dtype)throw new Error(`Dilation2D error: x must have the same dtype as filter. Got ${s.dtype} and ${a.dtype}`);let u=H.computeDilation2DInfo(s.shape,a.shape,i,o,"NHWC",l),c=n.makeOutput(u.outShape,s.dtype);return Jae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(c.dataId).id,sn[s.dtype],u.batchSize,u.inChannels,u.inHeight,u.inWidth,u.outHeight,u.outWidth,u.strideHeight,u.strideWidth,u.dilationHeight,u.dilationWidth,u.filterHeight,u.filterWidth,u.padInfo.top,u.padInfo.left),c}var kSt={kernelName:Hp,backendName:"wasm",setupFunc:xSt,kernelFunc:wSt},Zae;function SSt(e){Zae=e.wasm.cwrap(Lg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ISt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropFilter error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let c=H.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u),d=n.makeOutput(a.shape,a.dtype);return Zae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,sn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var CSt={kernelName:Lg,backendName:"wasm",setupFunc:SSt,kernelFunc:ISt},Qae;function NSt(e){Qae=e.wasm.cwrap(Pg,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function TSt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,filter:a,dy:i}=t,{strides:o,pad:l,dilations:u}=r;if(s.dtype!==a.dtype||s.dtype!==i.dtype)throw new Error(`Dilation2DBackpropInput error: x must have the same dtype as filter and dy. Got ${s.dtype}, ${a.dtype}, and ${i.dtype}`);let c=H.computeDilation2DInfo(s.shape,a.shape,o,l,"NHWC",u),d=n.makeOutput(s.shape,s.dtype);return Qae(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,sn[s.dtype],c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.filterHeight,c.filterWidth,c.padInfo.top,c.padInfo.left),d}var $St={kernelName:Pg,backendName:"wasm",setupFunc:NSt,kernelFunc:TSt},ESt=Jt(Kp),eie;function _St(e){eie=e.wasm.cwrap(Yy,null,["number","number","number"])}function ASt(e){let{inputs:t,backend:n}=e,{dy:r,y:s}=t,a=n.makeOutput(s.shape,"float32"),i=o=>n.dataIdMap.get(o.dataId).id;return eie(i(s),i(r),i(a)),a}var RSt={kernelName:Yy,backendName:"wasm",setupFunc:_St,kernelFunc:ASt},DSt=!1,OSt=Fr(Jy,DSt,"bool"),FSt=Jt(Xp),MSt=Jt(Yp,"float32");function JR(e){let{inputs:t,attrs:n,backend:r}=e,{input:s}=t,{dim:a}=n,i=s.shape.length,o=s.shape.slice(),l=a;return a<0&&(M.assert(-(i+1)<=a,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),l=i+a+1),o.splice(l,0,1),ba({inputs:{x:s},backend:r,attrs:{shape:o}})}var PSt={kernelName:Zy,backendName:"wasm",kernelFunc:JR},LSt=Jt(Jp,"float32");function tie(e){let{attrs:{shape:t,value:n},backend:r}=e,{attrs:{dtype:s}}=e;s=s||M.inferDtype(n);let a=r.makeOutput(t,s);return r.typedArrayFromHeap(a).fill(n),a}var zSt={kernelName:Zx,backendName:"wasm",kernelFunc:tie},nie;function BSt(e){nie=e.wasm.cwrap(Qy,null,["number","number","number","number","number","number"])}function WSt(e){let{inputs:t,backend:n}=e,{image:r}=t,s=n.makeOutput(r.shape,r.dtype),a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,[o,l,u,c]=r.shape;return nie(a,o,l,u,c,i),s}var VSt={kernelName:Qy,backendName:"wasm",kernelFunc:WSt,setupFunc:BSt},USt=Jt(Zp),jSt=Fr(Qp),rie;function GSt(e){rie=e.wasm.cwrap(ef,null,["number","number","number","number","number","number","number"])}function HSt(e){let{backend:t,inputs:n,attrs:r}=e,{varianceEpsilon:s}=r,{x:a,mean:i,variance:o,offset:l,scale:u}=n,c=t.dataIdMap.get(a.dataId).id,d=t.dataIdMap.get(i.dataId).id,h=t.dataIdMap.get(o.dataId).id,p=l!=null?t.dataIdMap.get(l.dataId).id:0,f=u!=null?t.dataIdMap.get(u.dataId).id:0,m=t.makeOutput(a.shape,a.dtype);if(M.sizeFromShape(a.shape)===0)return m;let g=t.dataIdMap.get(m.dataId).id;return rie(c,d,h,p,f,s,g),m}var qSt={kernelName:ef,backendName:"wasm",setupFunc:GSt,kernelFunc:HSt},sie;function KSt(e){sie=e.wasm.cwrap(jh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function XSt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=H.computeConv2DInfo(s.shape,a.shape,l,c,u,h),g=h0[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=r.dataIdMap.get(s.dataId).id,b=r.dataIdMap.get(a.dataId).id,x=m.outChannels,v=0;if(i!=null){let V=r.dataIdMap.get(i.dataId);if(V.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${V.shape.length}.`);if(V.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${V.shape}) does not match the number of output channels (${x})`);v=V.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,$=m.padInfo.bottom,C=m.padInfo.left,T=m.dilationHeight,N=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,R=m.inChannels,z=m.padInfo.type==="SAME"?1:0,W=m.batchSize,F=m.inHeight,L=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),D=r.dataIdMap.get(O.dataId).id,B=o==null?0:r.dataIdMap.get(o.dataId).id;return sie(y,W,F,L,b,w,k,v,S,I,$,C,z,T,N,E,_,R,x,g,B,f||0,D),O}var YSt={kernelName:jh,backendName:"wasm",setupFunc:KSt,kernelFunc:XSt},aie;function JSt(e){aie=e.wasm.cwrap(Gh,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ZSt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s,filter:a,bias:i,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dataFormat:d,dimRoundingMode:h,activation:p,leakyreluAlpha:f}=n,m=H.computeConv2DInfo(s.shape,a.shape,l,c,u,h,!0),g=h0[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=r.dataIdMap.get(s.dataId).id,b=r.dataIdMap.get(a.dataId).id,x=m.outChannels,v=0;if(i!=null){let V=r.dataIdMap.get(i.dataId);if(V.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${V.shape.length}.`);if(V.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${V.shape}) does not match the number of output channels (${x})`);v=V.id}let w=m.filterHeight,k=m.filterWidth,S=m.padInfo.top,I=m.padInfo.right,$=m.padInfo.bottom,C=m.padInfo.left,T=m.dilationHeight,N=m.dilationWidth,E=m.strideHeight,_=m.strideWidth,R=m.inChannels,z=m.padInfo.type==="SAME"?1:0,W=m.batchSize,F=m.inHeight,L=m.inWidth;if(d!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${d}'. Please use 'NHWC'.`);let O=r.makeOutput(m.outShape,"float32"),D=r.dataIdMap.get(O.dataId).id,B=o==null?0:r.dataIdMap.get(o.dataId).id;return aie(y,W,F,L,b,w,k,v,S,I,$,C,z,T,N,E,_,R,x,g,B,f||0,D),O}var QSt={kernelName:Gh,backendName:"wasm",setupFunc:JSt,kernelFunc:ZSt},iie;function eIt(e){iie=e.wasm.cwrap(tb,null,["number","number","number","number","number","number","array","number"])}function tIt(e){let{backend:t,inputs:n}=e,{params:r,indices:s}=n,[a,i,o,l]=ZP.prepareAndValidate(r,s),u=t.makeOutput(a,r.dtype);if(i===0)return u;let c=s.shape,d=c[c.length-1],h=t.dataIdMap.get(r.dataId).id,p=t.dataIdMap.get(s.dataId).id,f=new Uint8Array(new Int32Array(l).buffer),m=t.dataIdMap.get(u.dataId).id;return iie(h,sn[r.dtype],p,i,d,o,f,m),u}var nIt={kernelName:tb,backendName:"wasm",setupFunc:eIt,kernelFunc:tIt},oie;function rIt(e){oie=e.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function sIt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s,indices:a}=n,{axis:i,batchDims:o}=r,l=M.parseAxisParam(i,s.shape)[0],u=t.readSync(a.dataId),c=s.shape[l];for(let S=0;S<u.length;++S){let I=u[S];M.assert(I<=c-1&&I>=0,()=>`GatherV2: the index value ${I} is not in [0, ${c-1}]`)}let d=H.segment_util.collectGatherOpShapeInfo(s,a,l,o),h=ba({inputs:{x:s},attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]},backend:t}),p=M.sizeFromShape(a.shape),f=ba({inputs:{x:a},attrs:{shape:[d.batchSize,p/d.batchSize]},backend:t}),m=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize],g=t.makeOutput(m,s.dtype);if(M.sizeFromShape(s.shape)===0)return g;let y=h.shape.length-1,b=t.dataIdMap.get(h.dataId).id,x=t.dataIdMap.get(f.dataId).id,v=t.dataIdMap.get(g.dataId).id,w=new Uint8Array(new Int32Array(M.computeStrides(h.shape)).buffer),k=new Uint8Array(new Int32Array(M.computeStrides(m)).buffer);return oie(b,sn[s.dtype],w,y,x,d.batchSize,k,v),t.disposeData(h.dataId),t.disposeData(f.dataId),g.shape=d.outputShape,g}var aIt={kernelName:eb,backendName:"wasm",setupFunc:rIt,kernelFunc:sIt},iIt=!1,oIt=Fr(nb,iIt,"bool"),lIt=!1,uIt=Fr(nf,lIt,"bool"),cIt=Jt(sf,"bool"),dIt=Jt(af,"bool"),hIt=Jt(of,"bool"),lie;function pIt(e){lie=e.wasm.cwrap(lf,null,["number","number","number","number"])}function fIt(e){let{inputs:{x:t},attrs:{alpha:n},backend:r}=e,s=r.dataIdMap.get(t.dataId).id,a=r.makeOutput(t.shape,"float32");if(M.sizeFromShape(t.shape)!==0){let i=r.dataIdMap.get(a.dataId).id;lie(s,sn[t.dtype],n,i)}return a}var mIt={kernelName:lf,backendName:"wasm",setupFunc:pIt,kernelFunc:fIt},gIt=!1,yIt=Fr(rb,gIt,"bool"),bIt=!1,vIt=Fr(sb,bIt,"bool"),uie;function xIt(e){uie=e.wasm.cwrap(ab,null,["number","number","number","number"])}function wIt(e){let{attrs:t,backend:n}=e,{start:r,stop:s,num:a}=t,i=Math.floor(a),o=n.makeOutput([i],"float32");return uie(n.dataIdMap.get(o.dataId).id,r,s,i),o}var kIt={kernelName:ab,backendName:"wasm",setupFunc:xIt,kernelFunc:wIt},SIt=Jt(uf),IIt=Jt(cf),CIt=!1,NIt=Fr(ib,CIt,"bool"),TIt=Jt(ob),$It=!1,EIt=Fr(lb,$It,"bool"),_It=!1,AIt=Fr(cZ,_It,"bool"),cie;function RIt(e){cie=e.wasm.cwrap(df,null,["number","number","number","number","number","number","number"])}function DIt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{depthRadius:a,bias:i,alpha:o,beta:l}=r;if(s.dtype!=="float32")throw new Error("LRN error: x must have dtype float32");let u=n.makeOutput(s.shape,s.dtype);return cie(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(u.dataId).id,s.shape[3],a,i,o,l),u}var OIt={kernelName:df,backendName:"wasm",setupFunc:RIt,kernelFunc:DIt},die;function FIt(e){die=e.wasm.cwrap(ub,null,["number","number","number","number","number","number","number","number","number"])}function MIt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s,y:a,dy:i}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=r;if(s.dtype!=="float32"||a.dtype!=="float32"||i.dtype!=="float32")throw new Error("LRNGrad error: x, y, and dy must have dtype float32");let d=n.makeOutput(s.shape,s.dtype);return die(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(i.dataId).id,n.dataIdMap.get(d.dataId).id,i.shape[3],o,l,u,c),d}var PIt={kernelName:ub,backendName:"wasm",setupFunc:FIt,kernelFunc:MIt},hie;function LIt(e){hie=e.wasm.cwrap(hf,null,["number","number","number","number"])}function zIt(e){let{backend:t,inputs:n,attrs:r}=e,{reductionIndices:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=i,{transposed:u,axes:c,originalAxes:d,inputWasTransposed:h}=Cd(i,s,t);if(h){let b=t.dataIdMap.get(u.dataId).id;l=u,o=b}let p=l.shape.length;H.assertAxesAreInnerMostDims("max",c,p);let[f,m]=H.computeOutAndReduceShapes(l.shape,c),g=M.sizeFromShape(m),y=t.makeOutput(f,i.dtype);if(M.sizeFromShape(l.shape)!==0){let b=t.dataIdMap.get(y.dataId).id;hie(o,sn[i.dtype],g,b)}if(h&&t.disposeData(u.dataId),a){let b=H.expandShapeToKeepDim(y.shape,d);y.shape=b}return y}var BIt={kernelName:hf,backendName:"wasm",setupFunc:LIt,kernelFunc:zIt},WIt=Fr(pf),pie;function VIt(e){pie=e.wasm.cwrap(ff,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function UIt(e){let{inputs:t,attrs:n,backend:r}=e,s=t.x,a=r.dataIdMap.get(s.dataId).id;M.assert(s.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${s.dtype}.`);let{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=n,c=H.computePool2DInfo(s.shape,i,o,1,l,u),d=c.filterHeight,h=c.filterWidth,p=c.padInfo.top,f=c.padInfo.right,m=c.padInfo.bottom,g=c.padInfo.left,y=c.dilationHeight,b=c.dilationWidth,x=c.strideHeight,v=c.strideWidth,w=c.inChannels,k=c.outChannels;if(c.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${c.dataFormat}'. Please use 'channelsLast'.`);let S=r.makeOutput(c.outShape,"float32"),I=r.dataIdMap.get(S.dataId).id;return pie(a,s.shape[0],s.shape[1],s.shape[2],d,h,p,f,m,g,y,b,x,v,w,k,I),S}var jIt={kernelName:ff,backendName:"wasm",setupFunc:VIt,kernelFunc:UIt},fie;function GIt(e){fie=e.wasm.cwrap("MaxPool3D",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function HIt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,dimRoundingMode:l,dataFormat:u}=r,c=H.computePool3DInfo(s.shape,a,i,1,o,l,u),d=n.makeOutput(c.outShape,s.dtype);return fie(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var qIt={kernelName:cb,backendName:"wasm",setupFunc:GIt,kernelFunc:HIt},mie;function KIt(e){mie=e.wasm.cwrap("MaxPool3DGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function XIt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=H.computePool3DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return mie(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inDepth,c.inHeight,c.inWidth,c.outDepth,c.outHeight,c.outWidth,c.strideDepth,c.strideHeight,c.strideWidth,c.dilationDepth,c.dilationHeight,c.dilationWidth,c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.front,c.padInfo.top,c.padInfo.left),d}var YIt={kernelName:ew,backendName:"wasm",setupFunc:KIt,kernelFunc:XIt},gie;function JIt(e){gie=e.wasm.cwrap("MaxPoolGrad",null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ZIt(e){let{inputs:t,backend:n,attrs:r}=e,{dy:s,input:a}=t,{filterSize:i,strides:o,pad:l,dimRoundingMode:u}=r,c=H.computePool2DInfo(a.shape,i,o,1,l,u),d=n.makeOutput(a.shape,a.dtype);return gie(n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),d}var QIt={kernelName:Qx,backendName:"wasm",setupFunc:JIt,kernelFunc:ZIt},yie;function eCt(e){yie=e.wasm.cwrap("MaxPoolWithArgmax",null,["number","number","number","number","boolean","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function tCt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{filterSize:a,strides:i,pad:o,includeBatchInIndex:l}=r;M.assert(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);let u=[1,1];M.assert(H.eitherStridesOrDilationsAreOne(i,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${u}'`);let c=H.computePool2DInfo(s.shape,a,i,[1,1],o),d=n.makeOutput(c.outShape,s.dtype),h=n.makeOutput(c.outShape,"int32");return yie(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(d.dataId).id,n.dataIdMap.get(h.dataId).id,sn[s.dtype],l,c.batchSize,c.inChannels,c.inHeight,c.inWidth,c.outHeight,c.outWidth,c.strideHeight,c.strideWidth,c.dilationHeight,c.dilationWidth,c.effectiveFilterHeight,c.effectiveFilterWidth,c.padInfo.top,c.padInfo.left),[d,h]}var nCt={kernelName:tw,backendName:"wasm",setupFunc:eCt,kernelFunc:tCt},bie;function rCt(e){bie=e.wasm.cwrap(mf,null,["number, number, number"])}function sCt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Cd(i,s,t),f=d;if(p){let v=t.dataIdMap.get(c.dataId).id;v!==o&&(u=c,l=v,f=H.getInnerMostAxes(f.length,u.shape.length))}H.assertAxesAreInnerMostDims("mean",f,u.shape.length);let[m,g]=H.computeOutAndReduceShapes(u.shape,f),y=M.sizeFromShape(g),b=u;u.dtype!=="float32"&&(b=Nd({backend:t,inputs:{x:u},attrs:{dtype:"float32"}}),l=t.dataIdMap.get(b.dataId).id);let x=t.makeOutput(m,"float32");if(M.sizeFromShape(u.shape)!==0){let v=t.dataIdMap.get(x.dataId).id;bie(l,y,v)}if(p&&t.disposeData(c.dataId),a){let v=H.expandShapeToKeepDim(x.shape,h);x.shape=v}return u.dtype!=="float32"&&t.disposeData(b.dataId),x}var aCt={kernelName:mf,backendName:"wasm",setupFunc:rCt,kernelFunc:sCt},vie;function iCt(e){vie=e.wasm.cwrap(gf,null,["number","number","number","number"])}function oCt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Cd(i,s,t);if(p){let x=t.dataIdMap.get(c.dataId).id;x!==o&&(u=c,l=x)}let f=u.shape.length;H.assertAxesAreInnerMostDims("min",d,f);let[m,g]=H.computeOutAndReduceShapes(u.shape,d),y=M.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(M.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;vie(l,sn[i.dtype],y,x)}if(p&&t.disposeData(c.dataId),a){let x=H.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var lCt={kernelName:gf,backendName:"wasm",setupFunc:iCt,kernelFunc:oCt},uCt=Fr(yf),ZR;(function(e){e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric"})(ZR||(ZR={}));var xie;function cCt(e){xie=e.wasm.cwrap(bf,null,["number","array","number","number","array","array","number","number"])}function dCt(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,mode:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]),i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return xie(i,u,t.shape.length,sn[t.dtype],h,p,ZR[s],l),o}var hCt={kernelName:bf,backendName:"wasm",kernelFunc:dCt,setupFunc:cCt},wie;function pCt(e){wie=e.wasm.cwrap(Vf,null,["number","number","number","number"])}function kie(e){let{backend:t,inputs:{logits:n},attrs:{dim:r}}=e,s=t.dataIdMap.get(n.dataId).id,a=t.makeOutput(n.shape,n.dtype),i=t.dataIdMap.get(a.dataId).id,o=n.shape[r],l=M.sizeFromShape(n.shape)/o;return M.sizeFromShape(a.shape)===0||wie(s,i,o,l),a}var fCt={kernelName:Vf,backendName:"wasm",setupFunc:pCt,kernelFunc:kie},Sie;function mCt(e){Sie=e.wasm.cwrap(db,null,["number","number","number","number","number","number"])}function gCt(e){let{inputs:t,backend:n,attrs:r}=e,{logits:s}=t,{numSamples:a,seed:i,normalized:o}=r;if(s.dtype!=="float32")throw new Error(`Tensor logits must have dtype float32, got ${s.dtype}`);let l=o?s:kie({inputs:{logits:s},backend:n,attrs:{dim:s.shape.length-1}}),[u,c]=l.shape,d=n.makeOutput([u,a],"int32");return Sie(n.dataIdMap.get(l.dataId).id,u,c,a,i,n.dataIdMap.get(d.dataId).id),o||n.disposeData(l.dataId),d}var yCt={kernelName:db,backendName:"wasm",setupFunc:mCt,kernelFunc:gCt},bCt=Fr(vf),vCt=Fr(xf),xCt=Jt(hb);function mz(e,t){let n=new Int32Array(e.wasm.HEAPU8.buffer,t,4),r=n[0],s=n[1],a=n[2],i=n[3];return e.wasm._free(t),{pSelectedIndices:r,selectedSize:s,pSelectedScores:a,pValidOutputs:i}}var Iie;function wCt(e){Iie=e.wasm.cwrap(fb,"number",["number","number","number","number","number"])}function kCt(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i}=r,{boxes:o,scores:l}=n,u=t.dataIdMap.get(o.dataId).id,c=t.dataIdMap.get(l.dataId).id,d=Iie(u,c,a,s,i),{pSelectedIndices:h,selectedSize:p,pSelectedScores:f,pValidOutputs:m}=mz(t,d);return t.wasm._free(f),t.wasm._free(m),t.makeOutput([p],"int32",h)}var SCt={kernelName:fb,backendName:"wasm",setupFunc:wCt,kernelFunc:kCt},Cie;function ICt(e){Cie=e.wasm.cwrap(mb,"number",["number","number","number","number","number","bool"])}function CCt(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,padToMaxOutputSize:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=Cie(c,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=mz(t,h);t.wasm._free(m);let y=t.makeOutput([f],"int32",p),b=t.makeOutput([],"int32",g);return[y,b]}var NCt={kernelName:mb,backendName:"wasm",setupFunc:ICt,kernelFunc:CCt},Nie;function TCt(e){Nie=e.wasm.cwrap(gb,"number",["number","number","number","number","number","number"])}function $Ct(e){let{backend:t,inputs:n,attrs:r}=e,{iouThreshold:s,maxOutputSize:a,scoreThreshold:i,softNmsSigma:o}=r,{boxes:l,scores:u}=n,c=t.dataIdMap.get(l.dataId).id,d=t.dataIdMap.get(u.dataId).id,h=Nie(c,d,a,s,i,o),{pSelectedIndices:p,selectedSize:f,pSelectedScores:m,pValidOutputs:g}=mz(t,h);t.wasm._free(g);let y=t.makeOutput([f],"int32",p),b=t.makeOutput([f],"float32",m);return[y,b]}var ECt={kernelName:gb,backendName:"wasm",setupFunc:TCt,kernelFunc:$Ct},_Ct=!1,ACt=Fr(pb,_Ct,"bool"),Tie;function RCt(e){Tie=e.wasm.cwrap(wf,null,["number","number","number","number","number"])}function DCt(e){let{inputs:t,backend:n,attrs:r}=e,{indices:s}=t,{dtype:a,depth:i,onValue:o,offValue:l}=r,u=n.makeOutput([...s.shape,i],a),c=n.dataIdMap.get(u.dataId).id,d=n.dataIdMap.get(s.dataId).id;return Tie(d,i,o,l,c),u}var OCt={kernelName:wf,backendName:"wasm",setupFunc:RCt,kernelFunc:DCt};function FCt(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(1),r}var MCt={kernelName:yb,backendName:"wasm",kernelFunc:FCt};function PCt(e){let{inputs:t,backend:n,attrs:r}=e,{axis:s}=r;if(t.length===1)return JR({inputs:{input:t[0]},backend:n,attrs:{dim:s}});let a=t[0].shape,i=t[0].dtype;t.forEach(c=>{M.assertShapesMatch(a,c.shape,"All tensors passed to stack must have matching shapes"),M.assert(i===c.dtype,()=>"All tensors passed to stack must have matching dtypes")});let o=[],l=t.map(c=>{let d=JR({inputs:{input:c},backend:n,attrs:{dim:s}});return o.push(d),d}),u=Lae({inputs:l,backend:n,attrs:{axis:s}});return o.forEach(c=>n.disposeData(c.dataId)),u}var LCt={kernelName:bb,backendName:"wasm",kernelFunc:PCt},$ie;function zCt(e){$ie=e.wasm.cwrap(kf,null,["number","array","number","number","array","array","number","number"])}function BCt(e){let{inputs:{x:t},backend:n,attrs:{paddings:r,constantValue:s}}=e,a=r.map((f,m)=>f[0]+t.shape[m]+f[1]);if(M.sizeFromShape(t.shape)===0)return tie({backend:n,attrs:{shape:a,value:s,dtype:t.dtype}});let i=n.dataIdMap.get(t.dataId).id,o=n.makeOutput(a,t.dtype),l=n.dataIdMap.get(o.dataId).id,u=new Uint8Array(new Int32Array(t.shape).buffer),c=r.map(f=>f[0]),d=r.map(f=>f[1]),h=new Uint8Array(new Int32Array(c).buffer),p=new Uint8Array(new Int32Array(d).buffer);return $ie(i,u,t.shape.length,sn[t.dtype],h,p,s,l),o}var Eie={kernelName:kf,backendName:"wasm",kernelFunc:BCt,setupFunc:zCt},WCt=Fr(Sf),_ie;function VCt(e){_ie=e.wasm.cwrap(If,null,["number","number","number"])}function UCt(e){let{inputs:t,backend:n}=e,{x:r,alpha:s}=t,a=n.dataIdMap.get(r.dataId).id,i=n.dataIdMap.get(s.dataId).id,o=a,l=r,u=l;l.dtype!=="float32"&&(u=Nd({backend:n,inputs:{x:r},attrs:{dtype:"float32"}}),o=n.dataIdMap.get(u.dataId).id);let c=n.makeOutput(r.shape,"float32"),d=n.dataIdMap.get(c.dataId).id;return _ie(o,i,d),l.dtype!=="float32"&&n.disposeData(u.dataId),c}var jCt={kernelName:If,backendName:"wasm",setupFunc:VCt,kernelFunc:UCt},Aie;function GCt(e){Aie=e.wasm.cwrap(Cf,null,["number","number","number","number"])}function HCt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Cd(i,s,t),f=d;if(p){let x=t.dataIdMap.get(c.dataId).id;x!==o&&(u=c,l=x,f=H.getInnerMostAxes(f.length,u.shape.length))}H.assertAxesAreInnerMostDims("prod",f,u.shape.length);let[m,g]=H.computeOutAndReduceShapes(u.shape,f),y=M.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(M.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;Aie(l,y,sn[b.dtype],x)}if(p&&t.disposeData(c.dataId),a){let x=H.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var qCt={kernelName:Cf,backendName:"wasm",setupFunc:GCt,kernelFunc:HCt},KCt=e=>{let{backend:t,attrs:n}=e,{start:r,stop:s,step:a,dtype:i}=n,o=U4(r,s,a,i),l=t.makeOutput([o.length],i);return t.typedArrayFromHeap(l).set(o),l},XCt={kernelName:nw,backendName:"wasm",kernelFunc:KCt},YCt=Fr(qp),JCt=Jt(Nf),ZCt=Jt(Tf),QCt=Jt(_f),Rie;function eNt(e){Rie=e.wasm.cwrap(Ef,null,["number","number","number","number","number","number","number","number","number","number"])}function tNt(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,h,p]=s.shape,f=[c,l,u,p],m=t.dataIdMap.get(s.dataId),g;m.dtype!=="float32"&&(g=Nd({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),m=t.dataIdMap.get(g.dataId));let y=m.id,b=t.makeOutput(f,"float32");if(M.sizeFromShape(s.shape)===0)return b;let x=t.dataIdMap.get(b.dataId).id;return Rie(y,c,d,h,p,l,u,a?1:0,i?1:0,x),g!=null&&t.disposeData(g.dataId),b}var nNt={kernelName:Ef,backendName:"wasm",setupFunc:eNt,kernelFunc:tNt},Die;function rNt(e){Die=e.wasm.cwrap(wb,null,["number","number","number","array","array","boolean"])}function sNt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),l=n.dataIdMap.get(s.dataId),u;return l.dtype!=="float32"&&(u=Nd({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),Die(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var aNt={kernelName:wb,backendName:"wasm",setupFunc:rNt,kernelFunc:sNt},Oie;function iNt(e){Oie=e.wasm.cwrap($f,null,["number","number","number","number","number","number","number","number","number","number"])}function oNt(e){let{backend:t,inputs:n,attrs:r}=e,{images:s}=n,{alignCorners:a,halfPixelCenters:i,size:o}=r,[l,u]=o,[c,d,h,p]=s.shape,f=[c,l,u,p],m=t.makeOutput(f,"float32");if(M.sizeFromShape(s.shape)===0)return m;let g=t.dataIdMap.get(s.dataId),y;g.dtype!=="float32"&&(y=Nd({backend:t,inputs:{x:s},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(y.dataId));let b=g.id,x=t.dataIdMap.get(m.dataId).id;return Oie(b,c,d,h,p,l,u,a?1:0,i?1:0,x),y!=null&&t.disposeData(y.dataId),m}var lNt={kernelName:$f,backendName:"wasm",setupFunc:iNt,kernelFunc:oNt},Fie;function uNt(e){Fie=e.wasm.cwrap(xb,null,["number","number","number","array","array","boolean"])}function cNt(e){let{inputs:t,backend:n,attrs:r}=e,{images:s,dy:a}=t,{alignCorners:i}=r,o=n.makeOutput(s.shape,"float32"),l=n.dataIdMap.get(s.dataId),u;return l.dtype!=="float32"&&(u=Nd({backend:n,inputs:{x:s},attrs:{dtype:"float32"}}),l=n.dataIdMap.get(u.dataId)),Fie(n.dataIdMap.get(s.dataId).id,n.dataIdMap.get(a.dataId).id,n.dataIdMap.get(o.dataId).id,new Uint8Array(new Int32Array(s.shape).buffer),new Uint8Array(new Int32Array(a.shape).buffer),i),u!=null&&n.disposeData(u.dataId),o}var dNt={kernelName:xb,backendName:"wasm",setupFunc:uNt,kernelFunc:cNt},Mie;function hNt(e){Mie=e.wasm.cwrap(Af,null,["number","array","number","array","number","number"])}function pNt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{dims:a}=r,i=M.parseAxisParam(a,s.shape);if(s.shape.length===0)return p$({inputs:{x:s},backend:n});let o=n.makeOutput(s.shape,s.dtype),l=n.dataIdMap.get(s.dataId).id,u=n.dataIdMap.get(o.dataId).id,c=new Uint8Array(new Int32Array(i).buffer),d=new Uint8Array(new Int32Array(s.shape).buffer);Mie(l,c,i.length,d,s.shape.length,u);let h=ba({inputs:{x:o},attrs:{shape:s.shape},backend:n});return n.disposeData(o.dataId),h}var fNt={kernelName:Af,backendName:"wasm",kernelFunc:pNt,setupFunc:hNt},Pie;function mNt(e){Pie=e.wasm.cwrap(Mb,null,["number","number","number","number","number","number","number","number","array","number","number"])}function gNt(e){let{inputs:t,backend:n,attrs:r}=e,{image:s}=t,{radians:a,fillValue:i,center:o}=r,l=n.makeOutput(s.shape,s.dtype),u=n.dataIdMap.get(s.dataId).id,c=n.dataIdMap.get(l.dataId).id,[d,h,p,f]=s.shape,[m,g]=H.getImageCenter(o,h,p),y=i===0,b=255,x=typeof i=="number"?[i,i,i,y?0:b]:[...i,b],v=new Uint8Array(new Int32Array(x).buffer);return Pie(u,d,h,p,f,a,m,g,v,x.length,c),l}var yNt={kernelName:Mb,backendName:"wasm",kernelFunc:gNt,setupFunc:mNt},bNt=Jt(Rf),vNt=Jt(Df),Lie;function xNt(e){Lie=e.wasm.cwrap(kb,null,["number","number","number","number","number","number","array","number","number"])}function wNt(e){let{backend:t,inputs:n,attrs:r}=e,{indices:s,updates:a}=n,{shape:i}=r,o=t.makeOutput(i,a.dtype);if(M.sizeFromShape(i)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ET.calculateShapes(a,s,i),p=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(a.dataId).id,m=new Uint8Array(new Int32Array(d).buffer),g=t.dataIdMap.get(o.dataId).id;return Lie(p,f,sn[a.dtype],l,u,c,m,h,g),o}var kNt={kernelName:kb,backendName:"wasm",setupFunc:xNt,kernelFunc:wNt},zie;function SNt(e){zie=e.wasm.cwrap(Ib,null,["number","number","number","number","number","number","bool","number"])}function INt(e){let{inputs:t,backend:n,attrs:r}=e,{sortedSequence:s,values:a}=t,{side:i}=r;if(s.dtype!==a.dtype)throw new Error(`SearchSorted error: sorted_sequence must have the same dtype as values. Got ${s.dtype} and ${a.dtype}`);let o=n.makeOutput(a.shape,"int32");function l(u){return n.dataIdMap.get(u.dataId).id}return zie(l(s),l(a),s.shape[0],s.shape[1],a.shape[1],sn[s.dtype],i==="left",l(o)),o}var CNt={kernelName:Ib,backendName:"wasm",setupFunc:SNt,kernelFunc:INt},Bie;function NNt(e){Bie=e.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function TNt(e){let{inputs:t,backend:n}=e,{condition:r,t:s,e:a}=t,i=n.dataIdMap.get(r.dataId).id,o=n.dataIdMap.get(s.dataId).id,l=n.dataIdMap.get(a.dataId).id,u=n.makeOutput(s.shape,s.dtype),c=n.dataIdMap.get(u.dataId).id,d=r.shape.length,h=s.shape.length,p=d===0||d>1||h===1?1:M.sizeFromShape(s.shape.slice(1));return Bie(i,o,l,p,c),u}var $Nt={kernelName:Cb,backendName:"wasm",kernelFunc:TNt,setupFunc:NNt},ENt=Jt(Of),Wie;function _Nt(e){Wie=e.wasm.cwrap(Lf,null,["number","number"])}function ANt(e){let{backend:t,inputs:{x:n}}=e,r=t.dataIdMap.get(n.dataId).id,s=t.makeOutput(n.shape,n.dtype),a=t.dataIdMap.get(s.dataId).id;return M.sizeFromShape(s.shape)===0||Wie(r,a),s}var RNt={kernelName:"Sigmoid",backendName:"wasm",setupFunc:_Nt,kernelFunc:ANt},DNt=Jt(Pf),ONt=Jt(Ff),FNt=Jt(Mf),MNt=Jt(zf);function PNt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,{blockShape:a,paddings:i}=r,o=M.sizeFromShape(a),l=[[0,0]];l.push(...i);for(let g=1+a.length;g<s.shape.length;++g)l.push([0,0]);let u=Eie.kernelFunc({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),c=H.getReshaped(u.shape,a,o,!1),d=H.getPermuted(c.length,a.length,!1),h=H.getReshapedPermuted(u.shape,a,o,!1),p=ba({inputs:{x:u},backend:n,attrs:{shape:c}}),f=Xc({inputs:{x:p},backend:n,attrs:{perm:d}}),m=ba({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeData(u.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}var LNt={kernelName:Tb,backendName:"wasm",kernelFunc:PNt},Vie;function zNt(e){Vie=e.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function BNt(e){let{backend:t,inputs:n}=e,{indices:r,values:s,denseShape:a,defaultValue:i}=n,o=r.shape[0],l=r.shape[1],u=t.readSync(a.dataId)[0],c=[o+u,l],d=t.dataIdMap.get(r.dataId).id,h=t.dataIdMap.get(s.dataId).id,p=t.dataIdMap.get(i.dataId).id,f=t.makeOutput(c,r.dtype),m=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(c.slice(0,1),s.dtype),y=t.dataIdMap.get(g.dataId).id,b=t.makeOutput([u],"bool"),x=t.dataIdMap.get(b.dataId).id,v=t.makeOutput([o],r.dtype),w=t.dataIdMap.get(v.dataId).id,k=t.makeOutput([4],"int32"),S=t.dataIdMap.get(k.dataId).id,I=Vie(d,h,sn[s.dtype],o,u,l,p,m,y,x,w,S),$=t.readSync(k.dataId),C;switch($[0]){case 1:{C=H.getSparseFillEmptyRowsIndicesDenseShapeMismatch($[1]);break}case 2:{C=H.getSparseFillEmptyRowsNegativeIndexErrorMessage($[1],$[2]);break}case 3:C=H.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage($[1],$[2],$[3]);break;default:C=""}if(t.disposeData(k.dataId),C)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(b.dataId),t.disposeData(v.dataId),new Error(C);let T=f,N=g;return I!==c[0]&&(T=lp({inputs:{x:f},attrs:{begin:0,size:[I,l]},backend:t}),N=lp({inputs:{x:g},attrs:{begin:0,size:I},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[T,N,b,v]}var WNt={kernelName:rw,backendName:"wasm",setupFunc:zNt,kernelFunc:BNt},Uie;function VNt(e){Uie=e.wasm.cwrap(Eb,null,["number","number","number","number","number","number","number"])}function UNt(e){let{backend:t,inputs:n}=e,{inputIndices:r,inputShape:s,newShape:a}=n;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(s.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${s.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);let i=t.dataIdMap.get(r.dataId).id,o=t.dataIdMap.get(s.dataId).id,l=t.dataIdMap.get(a.dataId).id,u=r.shape[0],c=M.sizeFromShape(a.shape),d=t.makeOutput([u,c],r.dtype),h=t.dataIdMap.get(d.dataId).id,p=t.makeOutput([c],a.dtype),f=t.dataIdMap.get(p.dataId).id,m=t.makeOutput([3],"int32"),g=t.dataIdMap.get(m.dataId).id;Uie(i,o,l,u,h,f,g);let y=t.readSync(m.dataId),b;switch(y[0]){case 0:{b=H.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(y[1],y[2]);break}case 1:{b=H.getSparseReshapeNegativeOutputDimErrorMessage(y[1],y[2]);break}case 2:b=H.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(s.dataId)),v=Array.from(t.readSync(p.dataId));b=H.getSparseReshapeInputOutputMultipleErrorMessage(x,v);break}case 4:{let x=Array.from(t.readSync(s.dataId)),v=Array.from(t.readSync(p.dataId));b=H.getSparseReshapeInputOutputMismatchErrorMessage(x,v);break}default:b=""}if(t.disposeData(m.dataId),b)throw t.disposeData(d.dataId),t.disposeData(p.dataId),new Error(b);return[d,p]}var jNt={kernelName:Eb,backendName:"wasm",setupFunc:VNt,kernelFunc:UNt},jie;function Gie(e){jie=e.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Hie(e,t){let{backend:n,inputs:r}=e,{data:s,indices:a,segmentIds:i}=r,o=a.shape[0],l=n.readSync(i.dataId,o-1,o)[0],u=o>0?l+1:0;if(u<0)throw new Error(H.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=s.shape.slice();c[0]=u;let d=n.dataIdMap.get(s.dataId).id,h=n.dataIdMap.get(a.dataId).id,p=n.dataIdMap.get(i.dataId).id,f=n.makeOutput(c,s.dtype),m=n.dataIdMap.get(f.dataId).id,g=n.makeOutput([4],"int32"),y=n.dataIdMap.get(g.dataId).id;jie(d,sn[s.dtype],s.shape[0],h,p,m,y,t,0);let b=n.readSync(g.dataId),x;switch(b[0]){case 0:{x=H.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{x=H.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:x=H.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(b[1],b[2]);break;case 3:x=H.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(b[1],b[2],b[3]);break;default:x=""}if(n.disposeData(g.dataId),x)throw n.disposeData(f.dataId),new Error(x);return f}function GNt(e){return Hie(e,!0)}var HNt={kernelName:sw,backendName:"wasm",setupFunc:Gie,kernelFunc:GNt};function qNt(e){return Hie(e,!1)}var KNt={kernelName:aw,backendName:"wasm",setupFunc:Gie,kernelFunc:qNt},qie;function XNt(e){qie=e.wasm.cwrap(_b,null,["number","number","number","number","number","number","number","number","array","number","number"])}function YNt(e){let{backend:t,inputs:n,attrs:r}=e,{sparseIndices:s,sparseValues:a,defaultValue:i}=n,{outputShape:o}=r,l=t.makeOutput(o,i.dtype);if(M.sizeFromShape(o)===0)return l;let{sliceRank:u,numUpdates:c,sliceSize:d,strides:h,outputSize:p}=H.calculateShapes(a,s,o),f=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,g=t.dataIdMap.get(i.dataId).id,y=new Uint8Array(new Int32Array(h).buffer),b=t.dataIdMap.get(l.dataId).id;return qie(f,m,a.shape.length,g,sn[i.dtype],u,c,d,y,p,b),l}var JNt={kernelName:_b,backendName:"wasm",setupFunc:XNt,kernelFunc:YNt};function ZNt(e){let{inputs:t,attrs:n,backend:r}=e,{x:s}=t,{numOrSizeSplits:a,axis:i}=n,o=M.parseAxisParam(i,s.shape)[0],l=H.prepareSplitSize(s,a,o),u=new Array(s.shape.length).fill(0),c=s.shape.slice();return l.map(d=>{let h=[...c];h[o]=d;let p=lp({inputs:{x:s},attrs:{begin:u,size:h},backend:r});return u[o]+=d,p})}var QNt={kernelName:$b,backendName:"wasm",kernelFunc:ZNt},eTt=Jt(Bf),tTt=Jt(iw),nTt=Fr(Uf),Kie;function rTt(e){Kie=e.wasm.cwrap(yd,null,["number","number","number","number"])}function sTt(e){let{backend:t,inputs:n,attrs:r}=e,{alpha:s}=r,{x:a}=n,i=t.dataIdMap.get(a.dataId).id,o=t.makeOutput(a.shape,a.dtype),l=t.dataIdMap.get(o.dataId).id;return Kie(i,s,sn[a.dtype],l),o}var aTt={kernelName:yd,backendName:"wasm",setupFunc:rTt,kernelFunc:sTt},Xie;function iTt(e){Xie=e.wasm.cwrap(Ab,null,["number","array","number","array","array","array","array","array","number","number"])}function oTt(e){let{backend:t,inputs:n,attrs:r}=e,{x:s}=n,{begin:a,end:i,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:h}=r,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:x,strides:v}=Hr.sliceInfo(s.shape,a,i,o,l,u,c,d,h),w;if(m)w=ba({inputs:{x:s},backend:t,attrs:{shape:f}});else if(g||y){M.assert(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);let k=Hr.computeOutShape(b,x,v),S=lp({inputs:{x:s},backend:t,attrs:{begin:b,size:k}});w=ba({inputs:{x:S},backend:t,attrs:{shape:f}}),t.disposeData(S.dataId)}else{let k=t.makeOutput(p,"float32"),S=t.dataIdMap.get(s.dataId).id,I=new Uint8Array(new Int32Array(M.computeStrides(s.shape)).buffer),$=new Uint8Array(new Int32Array(b).buffer),C=new Uint8Array(new Int32Array(x).buffer),T=new Uint8Array(new Int32Array(v).buffer),N=new Uint8Array(new Int32Array(p).buffer),E=new Uint8Array(new Int32Array(M.computeStrides(p)).buffer),_=t.dataIdMap.get(k.dataId).id;Xie(S,I,s.shape.length,$,C,T,N,E,p.length,_),w=ba({inputs:{x:k},backend:t,attrs:{shape:f}}),t.disposeData(k.dataId)}return w}var lTt={kernelName:Ab,backendName:"wasm",setupFunc:iTt,kernelFunc:oTt};function uTt(e){let{backend:t,inputs:n,attrs:r}=e,{data:s,dataSplits:a}=n,{separator:i,nGramWidths:o,leftPad:l,rightPad:u,padWidth:c,preserveShortSequences:d}=r,h=t.readSync(s.dataId),p=t.readSync(a.dataId),[f,m]=G4(h,p,i,o,l,u,c,d),g=t.makeOutput([f.length],"string"),y=t.dataIdMap.get(g.dataId);y.stringBytes=f;let b=t.makeOutput(a.shape,"int32");return t.typedArrayFromHeap(b).set(m),[g,b]}var cTt={kernelName:lw,backendName:"wasm",kernelFunc:uTt};function dTt(e){let{backend:t,inputs:n,attrs:r}=e,{input:s,delimiter:a}=n,{skipEmpty:i}=r,o=t.readSync(s.dataId),l=t.readSync(a.dataId),[u,c,d]=H4(o,l[0],i),h=c.length,p=t.makeOutput([h,2],"int32");t.typedArrayFromHeap(p).set(u);let f=t.makeOutput([h],"string"),m=t.dataIdMap.get(f.dataId);m.stringBytes=c;let g=t.makeOutput([2],"int32");return t.typedArrayFromHeap(g).set(d),[p,f,g]}var hTt={kernelName:uw,backendName:"wasm",kernelFunc:dTt};function pTt(e){let{backend:t,inputs:n,attrs:r}=e,{input:s}=n,{numBuckets:a}=r,i=t.readSync(s.dataId),o=q4(i,a),l=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(l).set(o),l}var fTt={kernelName:cw,backendName:"wasm",kernelFunc:pTt},mTt=Fr(jf),Yie;function gTt(e){Yie=e.wasm.cwrap(Wf,null,["number","number","number","number"])}function yTt(e){let{backend:t,inputs:n,attrs:r}=e,{axis:s,keepDims:a}=r,{x:i}=n,o=t.dataIdMap.get(i.dataId).id,l=o,u=i,{transposed:c,axes:d,originalAxes:h,inputWasTransposed:p}=Cd(i,s,t),f=d;if(p){let x=t.dataIdMap.get(c.dataId).id;x!==o&&(u=c,l=x,f=H.getInnerMostAxes(f.length,u.shape.length))}H.assertAxesAreInnerMostDims("sum",f,u.shape.length);let[m,g]=H.computeOutAndReduceShapes(u.shape,f),y=M.sizeFromShape(g),b=t.makeOutput(m,u.dtype);if(M.sizeFromShape(u.shape)!==0){let x=t.dataIdMap.get(b.dataId).id;Yie(l,y,sn[b.dtype],x)}if(p&&t.disposeData(c.dataId),a){let x=H.expandShapeToKeepDim(b.shape,h);b.shape=x}return b}var bTt={kernelName:Wf,backendName:"wasm",setupFunc:gTt,kernelFunc:yTt},vTt=Jt(Gf),xTt=Jt(Hf),Jie;function wTt(e){Jie=e.wasm.cwrap(Sb,null,["number","number","number","number","number","number","array","number","number","number"])}function kTt(e){let{backend:t,inputs:n,attrs:r}=e,{tensor:s,indices:a,updates:i}=n,o=t.makeOutput(s.shape,s.dtype);if(M.sizeFromShape(s.shape)===0)return o;let{sliceRank:l,numUpdates:u,sliceSize:c,strides:d,outputSize:h}=ET.calculateShapes(i,a,s.shape),p=t.dataIdMap.get(a.dataId).id,f=t.dataIdMap.get(i.dataId).id,m=t.dataIdMap.get(s.dataId).id,g=new Uint8Array(new Int32Array(d).buffer),y=t.dataIdMap.get(o.dataId).id;return Jie(p,f,sn[i.dtype],l,u,c,g,h,y,m),o}var STt={kernelName:Sb,backendName:"wasm",setupFunc:wTt,kernelFunc:kTt},Zie;function ITt(e){Zie=e.wasm.cwrap(gd,null,["number","array","number","array","number","number"])}function CTt(e){let{inputs:t,backend:n,attrs:r}=e,{x:s}=t,a=n.dataIdMap.get(s.dataId).id,{reps:i}=r,o=new Array(s.shape.length);for(let h=0;h<o.length;h++)o[h]=s.shape[h]*i[h];let l=new Uint8Array(new Int32Array(s.shape).buffer),u=new Uint8Array(new Int32Array(o).buffer),c=n.makeOutput(o,s.dtype),d=n.dataIdMap.get(c.dataId).id;return Zie(a,l,s.shape.length,u,o.length,sn[c.dtype],d),c}var NTt={kernelName:gd,backendName:"wasm",setupFunc:ITt,kernelFunc:CTt},Qie;function TTt(e){Qie=e.wasm.cwrap(Rb,null,["number","array","number","number","number","bool","number","number"])}var $Tt=({inputs:e,backend:t,attrs:n})=>{let{x:r}=e,{k:s,sorted:a}=n,i=t.dataIdMap.get(r.dataId).id,o=new Uint8Array(new Int32Array(r.shape).buffer),l=r.shape.slice();l[l.length-1]=s;let u=t.makeOutput(l,r.dtype),c=t.dataIdMap.get(u.dataId).id,d=t.makeOutput(l,"int32"),h=t.dataIdMap.get(d.dataId).id;return Qie(i,o,r.shape.length,sn[r.dtype],s,a,c,h),[u,d]},ETt={kernelName:Rb,backendName:"wasm",setupFunc:TTt,kernelFunc:$Tt},eoe;function _Tt(e){eoe=e.wasm.cwrap(Db,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function ATt(e){let{backend:t,inputs:n,attrs:r}=e,{image:s,transforms:a}=n,{interpolation:i,fillMode:o,fillValue:l,outputShape:u}=r,[c,d,h,p]=s.shape,[f,m]=u??[d,h],g=[c,f,m,p],y=new Uint8Array(new Int32Array(M.computeStrides(s.shape)).buffer),b=new Uint8Array(new Int32Array(M.computeStrides(g)).buffer),x=t.makeOutput(g,s.dtype),v=t.dataIdMap.get(x.dataId).id,w=t.dataIdMap.get(s.dataId).id,k=t.dataIdMap.get(a.dataId).id,S=i==="nearest"?1:2,I;switch(o){case"constant":I=1;break;case"reflect":I=2;break;case"wrap":I=3;break;case"nearest":I=4;break;default:I=1;break}return eoe(w,k,a.shape[0]>1,c,f,m,p,h,d,y,s.shape.length-1,b,g.length-1,S,I,l,v),x}var RTt={kernelName:Db,backendName:"wasm",setupFunc:_Tt,kernelFunc:ATt};function DTt(e){let{inputs:t,attrs:n,backend:r}=e,{axis:s}=n,{x:a}=t,{outputValues:i,outputShape:o,indices:l}=X4(r.readSync(a.dataId),s,a.shape,a.dtype);return[r.makeOutput(o,a.dtype,void 0,i),r.makeOutput([l.length],"int32",void 0,l)]}var OTt={kernelName:dw,backendName:"wasm",kernelFunc:DTt};function FTt(e){let{inputs:t,backend:n,attrs:r}=e,{value:s}=t,{axis:a}=r;a<0&&(a+=s.shape.length);let i=s.shape[a],o=s.shape.length,l=new Array(o-1),u=0;for(let p=0;p<o;p++)p!==a&&(l[u++]=s.shape[p]);let c=new Array(i),d=new Array(o).fill(0),h=s.shape.slice();h[a]=1;for(let p=0;p<c.length;p++)d[a]=p,c[p]=lp({inputs:{x:s},attrs:{begin:d,size:h},backend:n});return c.map(({dataId:p,dtype:f})=>({dataId:p,dtype:f,shape:l}))}var MTt={kernelName:Ob,backendName:"wasm",kernelFunc:FTt};function PTt(e){let{inputs:{x:t},backend:n}=e,r=n.makeOutput(t.shape,t.dtype);return n.typedArrayFromHeap(r).fill(0),r}var LTt={kernelName:Fb,backendName:"wasm",kernelFunc:PTt},zTt=[_kt,Akt,Rkt,Dkt,Okt,Pkt,Gkt,Kkt,Xkt,Ykt,Jkt,Zkt,Qkt,e2t,t2t,s2t,p2t,o2t,c2t,y2t,S2t,N2t,T2t,E2t,_2t,A2t,O2t,F2t,L2t,W2t,j2t,q2t,Y2t,J2t,Z2t,tSt,sSt,oSt,cSt,pSt,gSt,vSt,kSt,CSt,$St,ESt,RSt,OSt,FSt,MSt,PSt,LSt,zSt,VSt,USt,jSt,qSt,YSt,QSt,nIt,aIt,oIt,uIt,Lkt,cIt,dIt,hIt,mIt,yIt,vIt,kIt,IIt,SIt,NIt,TIt,EIt,AIt,OIt,PIt,BIt,WIt,jIt,qIt,YIt,QIt,nCt,aCt,lCt,uCt,hCt,yCt,bCt,vCt,xCt,SCt,NCt,ECt,ACt,OCt,MCt,LCt,Eie,WCt,jCt,qCt,XCt,YCt,JCt,ZCt,QCt,f2t,nNt,aNt,lNt,dNt,fNt,yNt,bNt,vNt,kNt,CNt,$Nt,ENt,RNt,DNt,ONt,FNt,w2t,fCt,MNt,LNt,WNt,jNt,HNt,KNt,JNt,QNt,eTt,tTt,nTt,aTt,lTt,cTt,hTt,fTt,mTt,bTt,vTt,xTt,STt,NTt,ETt,RTt,Vkt,OTt,MTt,LTt];for(let e of zTt)pw(e);var QR=xe();QR.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});QR.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(QR.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var a6=pd(xHe()),BTt=pd(wHe()),i6=pd(kHe()),o6=a6.default||a6,WTt=i6.default||i6,toe=class extends jx{constructor(e){super(),this.wasm=e,this.dataIdNextNumber=1,this.wasm.tfjs.initWithThreadsCount(noe),eD=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new VN(this,Fi())}write(e,t,n){let r={id:this.dataIdNextNumber++};return this.move(r,e,t,n,1),r}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=M.now();return e(),{kernelMs:M.now()-t}}move(e,t,n,r,s){let a=this.dataIdNextNumber++;if(r==="string"){let u=t;this.dataIdMap.set(e,{id:a,stringBytes:u,shape:n,dtype:r,memoryOffset:null,refCount:s});return}let i=M.sizeFromShape(n),o=i*M.bytesPerElement(r),l=this.wasm._malloc(o)>>>0;this.dataIdMap.set(e,{id:a,memoryOffset:l,shape:n,dtype:r,refCount:s}),this.wasm.tfjs.registerTensor(a,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,o),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:r,dtype:s,shape:a,stringBytes:i}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(n==null||n>=i.length)?i:i.slice(t,n);t=t||0,n=n||M.sizeFromShape(a);let o=M.bytesPerElement(s),l=this.wasm.HEAPU8.slice(r+t*o,r+n*o);return jTt(l.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n,r){let s;if(n==null)s=this.write(r??null,e,t);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=M.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,i,n)}return{dataId:s,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let r=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=M.sizeFromShape(e);switch(t){case"float32":return new Float32Array(r,s,a);case"int32":return new Int32Array(r,s,a);case"bool":return new Uint8Array(r,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function VTt(e){return(t,n)=>(M.fetch(e,{credentials:"same-origin"}).then(r=>{r.ok||t.env.a(`failed to load wasm binary file at '${e}'`),r.arrayBuffer().then(s=>{WebAssembly.instantiate(s,t).then(a=>{n(a.instance,a.module)})})}),{})}function l6(e,t,n){if(wI!=null)return wI;let r="tfjs-backend-wasm.wasm";return e&&t?r="tfjs-backend-wasm-threaded-simd.wasm":e&&(r="tfjs-backend-wasm-simd.wasm"),c1!=null&&c1[r]!=null?c1[r]:n+r}async function UTt(){let[e,t]=await Promise.all([xe().getAsync("WASM_HAS_SIMD_SUPPORT"),xe().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((n,r)=>{let s={};s.locateFile=(o,l)=>{if(o.endsWith(".worker.js")){let u=BTt.wasmWorkerContents.replace(/\n/g,"\\n"),c=new Blob([u],{type:"application/javascript"});return URL.createObjectURL(c)}return o.endsWith(".wasm")?l6(e,t,Kv??l):l+o},gz&&(s.instantiateWasm=VTt(l6(e,t,Kv??"")));let a=!1;s.onAbort=()=>{a||d1||(d1=!0,r({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"}))};let i;t&&e&&wI==null?(s.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+o6.toString()],{type:"text/javascript"}),i=o6(s)):i=WTt(s),i.then(o=>{a=!0,d1=!1;let l=null;o.tfjs={init:o.cwrap("init",null,[]),initWithThreadsCount:o.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:o.cwrap("get_threads_count","number",[]),registerTensor:o.cwrap("register_tensor",null,["number","number","number"]),disposeData:o.cwrap("dispose_data",l,["number"]),dispose:o.cwrap("dispose",l,[])},n({wasm:o})}).catch(r)})}function jTt(e,t){switch(t){case"float32":return new Float32Array(e);case"int32":return new Int32Array(e);case"bool":return new Uint8Array(e);default:throw new Error(`Unknown dtype ${t}`)}}var GTt=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],wI=null,Kv=null,c1={},d1=!1,gz=!1;function HTt(e,t=!1){if(CZ("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),d1)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");wI=e,gz=t}function qTt(e,t=!1){if(d1)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof e=="string")Kv=e;else{c1=e;let n=GTt.filter(r=>c1[r]==null);if(n.length>0)throw new Error(`There were no entries found for the following binaries: ${n.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}gz=t}var noe=-1,eD=-1;function KTt(e){noe=e}function XTt(){if(eD===-1)throw new Error("WASM backend not initialized.");return eD}var YTt="4.16.0",JTt=2;iT("wasm",async()=>{let{wasm:e}=await UTt();return new toe(e)},JTt);var u6="4.16.0",ZTt="4.16.0",QTt="4.16.0",e$t="4.16.0",t$t="4.16.0",n$t={tfjs:u6,"tfjs-core":u6,"tfjs-converter":ZTt,"tfjs-backend-cpu":QTt,"tfjs-backend-webgl":e$t,"tfjs-backend-wasm":t$t},yz={};SM(yz,{AnchorPosition:()=>yoe,DrawBox:()=>xoe,DrawBoxOptions:()=>voe,DrawFaceLandmarks:()=>Moe,DrawFaceLandmarksOptions:()=>Foe,DrawTextField:()=>Iz,DrawTextFieldOptions:()=>Sz,drawContour:()=>ju,drawDetections:()=>m$t,drawFaceExpressions:()=>E$t,drawFaceLandmarks:()=>A$t});function ju(e,t,n=!1){if(e.beginPath(),t.slice(1).forEach(({x:r,y:s},a)=>{let i=t[a];e.moveTo(i.x,i.y),e.lineTo(r,s)}),n){let r=t[t.length-1],s=t[0];if(!r||!s)return;e.moveTo(r.x,r.y),e.lineTo(s.x,s.y)}e.stroke()}var r$t={};SM(r$t,{computeReshapedDimensions:()=>ioe,getCenterPoint:()=>vz,isDimensions:()=>nD,isEven:()=>tD,isFloat:()=>aoe,isTensor:()=>rv,isTensor1D:()=>s$t,isTensor2D:()=>soe,isTensor3D:()=>Hw,isTensor4D:()=>ou,isValidNumber:()=>xh,isValidProbablitiy:()=>a$t,range:()=>Qg,round:()=>bz});var vh=class roe{constructor(t,n){if(!xh(t)||!xh(n))throw new Error(`Dimensions.constructor - expected width and height to be valid numbers, instead have ${JSON.stringify({width:t,height:n})}`);this._width=t,this._height=n}get width(){return this._width}get height(){return this._height}reverse(){return new roe(1/this.width,1/this.height)}};function rv(e,t){return e instanceof Bt&&e.shape.length===t}function s$t(e){return rv(e,1)}function soe(e){return rv(e,2)}function Hw(e){return rv(e,3)}function ou(e){return rv(e,4)}function aoe(e){return e%1!==0}function tD(e){return e%2===0}function bz(e,t=2){let n=10**t;return Math.floor(e*n)/n}function nD(e){return e&&e.width&&e.height}function ioe({width:e,height:t},n){let r=n/Math.max(t,e);return new vh(Math.round(e*r),Math.round(t*r))}function vz(e){return e.reduce((t,n)=>t.add(n),new xn(0,0)).div(new xn(e.length,e.length))}function Qg(e,t,n){return Array(e).fill(0).map((r,s)=>t+s*n)}function xh(e){return!!e&&e!==1/0&&e!==-1/0&&!Number.isNaN(e)||e===0}function a$t(e){return xh(e)&&e>=0&&e<=1}var xn=class Ud{constructor(t,n){this._x=t,this._y=n}get x(){return this._x}get y(){return this._y}add(t){return new Ud(this.x+t.x,this.y+t.y)}sub(t){return new Ud(this.x-t.x,this.y-t.y)}mul(t){return new Ud(this.x*t.x,this.y*t.y)}div(t){return new Ud(this.x/t.x,this.y/t.y)}abs(){return new Ud(Math.abs(this.x),Math.abs(this.y))}magnitude(){return Math.sqrt(this.x**2+this.y**2)}floor(){return new Ud(Math.floor(this.x),Math.floor(this.y))}},up=class yo{static isRect(t){return!!t&&[t.x,t.y,t.width,t.height].every(xh)}static assertIsValidBox(t,n,r=!1){if(!yo.isRect(t))throw new Error(`${n} - invalid box: ${JSON.stringify(t)}, expected object with properties x, y, width, height`);if(!r&&(t.width<0||t.height<0))throw new Error(`${n} - width (${t.width}) and height (${t.height}) must be positive numbers`)}constructor(t,n=!0){let r=t||{},s=[r.left,r.top,r.right,r.bottom].every(xh),a=[r.x,r.y,r.width,r.height].every(xh);if(!a&&!s)throw new Error(`Box.constructor - expected box to be IBoundingBox | IRect, instead have ${JSON.stringify(r)}`);let[i,o,l,u]=a?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top];yo.assertIsValidBox({x:i,y:o,width:l,height:u},"Box.constructor",n),this._x=i,this._y=o,this._width=l,this._height=u}get x(){return this._x}get y(){return this._y}get width(){return this._width}get height(){return this._height}get left(){return this.x}get top(){return this.y}get right(){return this.x+this.width}get bottom(){return this.y+this.height}get area(){return this.width*this.height}get topLeft(){return new xn(this.left,this.top)}get topRight(){return new xn(this.right,this.top)}get bottomLeft(){return new xn(this.left,this.bottom)}get bottomRight(){return new xn(this.right,this.bottom)}round(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.round(a));return new yo({x:t,y:n,width:r,height:s})}floor(){let[t,n,r,s]=[this.x,this.y,this.width,this.height].map(a=>Math.floor(a));return new yo({x:t,y:n,width:r,height:s})}toSquare(){let{x:t,y:n,width:r,height:s}=this,a=Math.abs(r-s);return r<s&&(t-=a/2,r+=a),s<r&&(n-=a/2,s+=a),new yo({x:t,y:n,width:r,height:s})}rescale(t){let n=nD(t)?t.width:t,r=nD(t)?t.height:t;return new yo({x:this.x*n,y:this.y*r,width:this.width*n,height:this.height*r})}pad(t,n){let[r,s,a,i]=[this.x-t/2,this.y-n/2,this.width+t,this.height+n];return new yo({x:r,y:s,width:a,height:i})}clipAtImageBorders(t,n){let{x:r,y:s,right:a,bottom:i}=this,o=Math.max(r,0),l=Math.max(s,0),u=a-o,c=i-l,d=Math.min(u,t-o),h=Math.min(c,n-l);return new yo({x:o,y:l,width:d,height:h}).floor()}shift(t,n){let{width:r,height:s}=this,a=this.x+t,i=this.y+n;return new yo({x:a,y:i,width:r,height:s})}padAtBorders(t,n){let r=this.width+1,s=this.height+1,a=1,i=1,o=r,l=s,u=this.left,c=this.top,d=this.right,h=this.bottom;return d>n&&(o=-d+n+r,d=n),h>t&&(l=-h+t+s,h=t),u<1&&(l=2-u,u=1),c<1&&(l=2-c,c=1),{dy:i,edy:l,dx:a,edx:o,y:c,ey:h,x:u,ex:d,w:r,h:s}}calibrate(t){return new yo({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()}},ooe=class extends up{constructor(e,t,n,r,s=!1){super({left:e,top:t,right:n,bottom:r},s)}},loe=class uoe{constructor(t,n,r,s,a){this._imageDims=new vh(a.width,a.height),this._score=t,this._classScore=n,this._className=r,this._box=new up(s).rescale(this._imageDims)}get score(){return this._score}get classScore(){return this._classScore}get className(){return this._className}get box(){return this._box}get imageDims(){return this._imageDims}get imageWidth(){return this.imageDims.width}get imageHeight(){return this.imageDims.height}get relativeBox(){return new up(this._box).rescale(this.imageDims.reverse())}forSize(t,n){return new uoe(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:n})}},to=class coe extends loe{constructor(t,n,r){super(t,t,"",n,r)}forSize(t,n){let{score:r,relativeBox:s,imageDims:a}=super.forSize(t,n);return new coe(r,s,a)}};function i$t(e,t,n=!0){let r=Math.max(0,Math.min(e.right,t.right)-Math.max(e.left,t.left)),s=Math.max(0,Math.min(e.bottom,t.bottom)-Math.max(e.top,t.top)),a=r*s;return n?a/(e.area+t.area-a):a/Math.min(e.area,t.area)}function o$t(e){let t=e.map(o=>o.x),n=e.map(o=>o.y),r=t.reduce((o,l)=>l<o?l:o,1/0),s=n.reduce((o,l)=>l<o?l:o,1/0),a=t.reduce((o,l)=>o<l?l:o,0),i=n.reduce((o,l)=>o<l?l:o,0);return new ooe(r,s,a,i)}function l$t(e,t,n,r=!0){let s=t.map((i,o)=>({score:i,boxIndex:o})).sort((i,o)=>i.score-o.score).map(i=>i.boxIndex),a=[];for(;s.length>0;){let i=s.pop();a.push(i);let o=s,l=[];for(let u=0;u<o.length;u++){let c=o[u],d=e[i],h=e[c];l.push(i$t(d,h,r))}s=s.filter((u,c)=>l[c]<=n)}return a}function qw(e,t){return ue(()=>{let[n,r,s]=t,a=Ka([...e.shape.slice(0,3),1],n,"float32"),i=Ka([...e.shape.slice(0,3),1],r,"float32"),o=Ka([...e.shape.slice(0,3),1],s,"float32"),l=In([a,i,o],3);return nt(e,l)})}function u$t(e,t=!1){return ue(()=>{let[n,r]=e.shape.slice(1);if(n===r)return e;let s=Math.abs(n-r),a=Math.round(s*(t?.5:1)),i=n>r?2:1,o=d=>{let h=e.shape.slice();return h[i]=d,Ka(h,0,"float32")},l=o(a),u=s-l.shape[i],c=[t&&u?o(u):null,e,l].filter(d=>!!d).map(d=>je(d,"float32"));return In(c,i)})}function qE(e){return 1/(1+Math.exp(-e))}var doe=class extends up{constructor(e,t,n,r,s=!1){super({x:e,y:t,width:n,height:r},s)}},c$t=.5,d$t=.43,h$t=.45,p0=class{constructor(e,t,n=new xn(0,0)){let{width:r,height:s}=t;this._imgDims=new vh(r,s),this._shift=n,this._positions=e.map(a=>a.mul(new xn(r,s)).add(n))}get shift(){return new xn(this._shift.x,this._shift.y)}get imageWidth(){return this._imgDims.width}get imageHeight(){return this._imgDims.height}get positions(){return this._positions}get relativePositions(){return this._positions.map(e=>e.sub(this._shift).div(new xn(this.imageWidth,this.imageHeight)))}forSize(e,t){return new this.constructor(this.relativePositions,{width:e,height:t})}shiftBy(e,t){return new this.constructor(this.relativePositions,this._imgDims,new xn(e,t))}shiftByPoint(e){return this.shiftBy(e.x,e.y)}align(e,t={}){if(e){let s=e instanceof to?e.box.floor():new up(e);return this.shiftBy(s.x,s.y).align(null,t)}let{useDlibAlignment:n,minBoxPadding:r}={useDlibAlignment:!1,minBoxPadding:.2,...t};return n?this.alignDlib():this.alignMinBbox(r)}alignDlib(){let e=this.getRefPointsForAlignment(),[t,n,r]=e,s=c=>r.sub(c).magnitude(),a=(s(t)+s(n))/2,i=Math.floor(a/h$t),o=vz(e),l=Math.floor(Math.max(0,o.x-c$t*i)),u=Math.floor(Math.max(0,o.y-d$t*i));return new doe(l,u,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+u))}alignMinBbox(e){let t=o$t(this.positions);return t.pad(t.width*e,t.height*e)}getRefPointsForAlignment(){throw new Error("getRefPointsForAlignment not implemented by base class")}},hoe=class extends p0{getJawOutline(){return this.positions.slice(0,17)}getLeftEyeBrow(){return this.positions.slice(17,22)}getRightEyeBrow(){return this.positions.slice(22,27)}getNose(){return this.positions.slice(27,36)}getLeftEye(){return this.positions.slice(36,42)}getRightEye(){return this.positions.slice(42,48)}getMouth(){return this.positions.slice(48,68)}getRefPointsForAlignment(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(vz)}};function f0(e){return e.detection instanceof to}function rD(e,t){return{...e,detection:t}}function poe(){let e=window.fetch;if(!e)throw new Error("fetch - missing fetch implementation for browser environment");return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:()=>document.createElement("canvas"),createImageElement:()=>document.createElement("img"),createVideoElement:()=>document.createElement("video"),fetch:e,readFile:()=>{throw new Error("readFile - filesystem not available for browser environment")}}}function xz(){return typeof global=="object"&&typeof process<"u"&&process.versions!=null&&process.versions.node!=null}function foe(e){let t="";if(!e&&xz())try{e=ZGe("fs")}catch(n){t=n.toString()}return{readFile:e?n=>new Promise((r,s)=>{e.readFile(n,(a,i)=>a?s(a):r(i))}):()=>{throw new Error(`readFile - failed to require fs in nodejs environment with error: ${t}`)}}}function moe(){let e=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,n=global.Video||global.HTMLVideoElement,r=()=>{if(e)return new e;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},s=()=>{if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=()=>{if(n)return new n;throw new Error("createVideoElement - missing Video implementation for nodejs environment")},i=global.fetch,o=foe();return{Canvas:e||class{},CanvasRenderingContext2D:global.CanvasRenderingContext2D||class{},Image:t||class{},ImageData:global.ImageData||class{},Video:global.HTMLVideoElement||class{},createCanvasElement:r,createImageElement:s,createVideoElement:a,fetch:i,...o}}function goe(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}var Zr;function p$t(){if(!Zr)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return Zr}function sD(e){Zr=e}function wz(){return goe()?sD(poe()):xz()?sD(moe()):null}function f$t(e){if(Zr||wz(),!Zr)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");let{Canvas:t=Zr.Canvas,Image:n=Zr.Image}=e;Zr.Canvas=t,Zr.Image=n,Zr.createCanvasElement=e.createCanvasElement||(()=>new t),Zr.createImageElement=e.createImageElement||(()=>new n),Zr.ImageData=e.ImageData||Zr.ImageData,Zr.Video=e.Video||Zr.Video,Zr.fetch=e.fetch||Zr.fetch,Zr.readFile=e.readFile||Zr.readFile}var Ia={getEnv:p$t,setEnv:sD,initialize:wz,createBrowserEnv:poe,createFileSystem:foe,createNodejsEnv:moe,monkeyPatch:f$t,isBrowser:goe,isNodejs:xz};wz();function kz(e){return!Ia.isNodejs()&&typeof e=="string"?document.getElementById(e):e}function Yc(e){let{Canvas:t,CanvasRenderingContext2D:n}=Ia.getEnv();if(e instanceof n)return e;let r=kz(e);if(!(r instanceof t))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");let s=r.getContext("2d",{willReadFrequently:!0});if(!s)throw new Error("resolveContext2d - canvas 2d context is null");return s}var yoe=(e=>(e.TOP_LEFT="TOP_LEFT",e.TOP_RIGHT="TOP_RIGHT",e.BOTTOM_LEFT="BOTTOM_LEFT",e.BOTTOM_RIGHT="BOTTOM_RIGHT",e))(yoe||{}),Sz=class{constructor(e={}){let{anchorPosition:t,backgroundColor:n,fontColor:r,fontSize:s,fontStyle:a,padding:i}=e;this.anchorPosition=t||"TOP_LEFT",this.backgroundColor=n||"rgba(0, 0, 0, 0.5)",this.fontColor=r||"rgba(255, 255, 255, 1)",this.fontSize=s||14,this.fontStyle=a||"Georgia",this.padding=i||4}},Iz=class boe{constructor(t,n,r={}){this.text=typeof t=="string"?[t]:t instanceof boe?t.text:t,this.anchor=n,this.options=new Sz(r)}measureWidth(t){let{padding:n}=this.options;return this.text.map(r=>t.measureText(r).width).reduce((r,s)=>r<s?s:r,0)+2*n}measureHeight(){let{fontSize:t,padding:n}=this.options;return this.text.length*t+2*n}getUpperLeft(t,n){let{anchorPosition:r}=this.options,s=r==="BOTTOM_RIGHT"||r==="TOP_RIGHT",a=r==="BOTTOM_LEFT"||r==="BOTTOM_RIGHT",i=this.measureWidth(t),o=this.measureHeight(),l=s?this.anchor.x-i:this.anchor.x,u=a?this.anchor.y-o:this.anchor.y;if(n){let{width:c,height:d}=n,h=Math.max(Math.min(l,c-i),0),p=Math.max(Math.min(u,d-o),0);return{x:h,y:p}}return{x:l,y:u}}draw(t){let n=kz(t),r=Yc(n),{backgroundColor:s,fontColor:a,fontSize:i,fontStyle:o,padding:l}=this.options;r.font=`${i}px ${o}`;let u=this.measureWidth(r),c=this.measureHeight();r.fillStyle=s;let d=this.getUpperLeft(r,n);r.fillRect(d.x,d.y,u,c),r.fillStyle=a,this.text.forEach((h,p)=>{let f=l+d.x,m=l+d.y+(p+1)*i;r.fillText(h,f,m)})}},voe=class{constructor(e={}){let{boxColor:t,lineWidth:n,label:r,drawLabelOptions:s}=e;this.boxColor=t||"rgba(0, 0, 255, 1)",this.lineWidth=n||2,this.label=r;let a={anchorPosition:"BOTTOM_LEFT",backgroundColor:this.boxColor};this.drawLabelOptions=new Sz({...a,...s})}},xoe=class{constructor(e,t={}){this.box=new up(e),this.options=new voe(t)}draw(e){let t=Yc(e),{boxColor:n,lineWidth:r}=this.options,{x:s,y:a,width:i,height:o}=this.box;t.strokeStyle=n,t.lineWidth=r,t.strokeRect(s,a,i,o);let{label:l}=this.options;l&&new Iz([l],{x:s-r/2,y:a},this.options.drawLabelOptions).draw(e)}};function m$t(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof to?n.score:f0(n)?n.detection.score:void 0,s=n instanceof to?n.box:f0(n)?n.detection.box:new up(n),a=r?`${bz(r)}`:void 0;new xoe(s,{label:a}).draw(e)})}function woe(e){let{Image:t,Video:n}=Ia.getEnv();return e instanceof t&&e.complete||e instanceof n&&e.readyState>=3}function g$t(e){return new Promise((t,n)=>{(e instanceof Ia.getEnv().Canvas||woe(e))&&t(null);function r(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),n(a))}function s(a){a.currentTarget&&(a.currentTarget.removeEventListener("load",s),a.currentTarget.removeEventListener("error",r),t(a))}e.addEventListener("load",s),e.addEventListener("error",r)})}function Cz(e){let{Image:t,Video:n}=Ia.getEnv();return e instanceof t?new vh(e.naturalWidth,e.naturalHeight):e instanceof n?new vh(e.videoWidth,e.videoHeight):new vh(e.width,e.height)}function kI({width:e,height:t}){let{createCanvasElement:n}=Ia.getEnv(),r=n();return r.width=e,r.height=t,r}function f$(e,t){let{ImageData:n}=Ia.getEnv();if(!(e instanceof n)&&!woe(e))throw new Error("createCanvasFromMedia - media has not finished loading yet");let{width:r,height:s}=t||Cz(e),a=kI({width:r,height:s});return e instanceof n?Yc(a).putImageData(e,0,0):Yc(a).drawImage(e,0,0,r,s),a}async function y$t(e,t){let n=t||Ia.getEnv().createCanvasElement(),[r,s,a]=e.shape.slice(ou(e)?1:0),i=ue(()=>e.as3D(r,s,a).toInt());return await Rw.toPixels(i,n),i.dispose(),n}function c6(e){let{Image:t,Canvas:n,Video:r}=Ia.getEnv();return e instanceof t||e instanceof n||e instanceof r}function b$t(e,t,n=!1){let{Image:r,Canvas:s}=Ia.getEnv();if(!(e instanceof r||e instanceof s))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");if(t<=0)return kI({width:1,height:1});let a=Cz(e),i=t/Math.max(a.height,a.width),o=i*a.width,l=i*a.height,u=kI({width:t,height:t}),c=e instanceof s?e:f$(e),d=Math.abs(o-l)/2,h=n&&o<l?d:0,p=n&&l<o?d:0;return c.width>0&&c.height>0&&Yc(u).drawImage(c,h,p,o,l),u}var SI=class{constructor(e,t=!1){if(this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],this._inputSize=0,!Array.isArray(e))throw new Error(`NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have ${e}`);this._treatAsBatchInput=t,this._batchSize=e.length,e.forEach((n,r)=>{if(Hw(n)){this._imageTensors[r]=n,this._inputDimensions[r]=n.shape;return}if(ou(n)){let a=n.shape[0];if(a!==1)throw new Error(`NetInput - tf.Tensor4D with batchSize ${a} passed, but not supported in input array`);this._imageTensors[r]=n,this._inputDimensions[r]=n.shape.slice(1);return}let s=n instanceof Ia.getEnv().Canvas?n:f$(n);this._canvases[r]=s,this._inputDimensions[r]=[s.height,s.width,3]})}get imageTensors(){return this._imageTensors}get canvases(){return this._canvases}get isBatchInput(){return this.batchSize>1||this._treatAsBatchInput}get batchSize(){return this._batchSize}get inputDimensions(){return this._inputDimensions}get inputSize(){return this._inputSize}get reshapedInputDimensions(){return Qg(this.batchSize,0,1).map((e,t)=>this.getReshapedInputDimensions(t))}getInput(e){return this.canvases[e]||this.imageTensors[e]}getInputDimensions(e){return this._inputDimensions[e]}getInputHeight(e){return this._inputDimensions[e][0]}getInputWidth(e){return this._inputDimensions[e][1]}getReshapedInputDimensions(e){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");let t=this.getInputWidth(e),n=this.getInputHeight(e);return ioe({width:t,height:n},this.inputSize)}toBatchTensor(e,t=!0){return this._inputSize=e,ue(()=>{let n=Qg(this.batchSize,0,1).map(r=>{let s=this.getInput(r);if(s instanceof Bt){let a=ou(s)?s:is(s);return a=u$t(a,t),(a.shape[1]!==e||a.shape[2]!==e)&&(a=di.resizeBilinear(a,[e,e],!1,!1)),a.as3D(e,e,3)}if(s instanceof Ia.getEnv().Canvas)return Rw.fromPixels(b$t(s,e,t));throw new Error(`toBatchTensor - at batchIdx ${r}, expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have ${s}`)});return _r(n.map(r=>je(r,"float32"))).as4D(this.batchSize,e,e,3)})}};async function ra(e){if(e instanceof SI)return e;let t=Array.isArray(e)?e:[e];if(!t.length)throw new Error("toNetInput - empty array passed as input");let n=s=>Array.isArray(e)?` at input index ${s}:`:"",r=t.map(kz);return r.forEach((s,a)=>{if(!c6(s)&&!Hw(s)&&!ou(s))throw typeof t[a]=="string"?new Error(`toNetInput -${n(a)} string passed, but could not resolve HTMLElement for element id ${t[a]}`):new Error(`toNetInput -${n(a)} expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id`);if(ou(s)){let i=s.shape[0];if(i!==1)throw new Error(`toNetInput -${n(a)} tf.Tensor4D with batchSize ${i} passed, but not supported in input array`)}}),await Promise.all(r.map(s=>c6(s)&&g$t(s))),new SI(r,Array.isArray(e))}async function koe(e,t){let{Canvas:n}=Ia.getEnv(),r=e;if(!(e instanceof n)){let a=await ra(e);if(a.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");let i=a.getInput(0);r=i instanceof n?i:await y$t(i)}let s=Yc(r);return t.map(a=>a instanceof to?a.forSize(r.width,r.height).box.floor():a).map(a=>a.clipAtImageBorders(r.width,r.height)).map(({x:a,y:i,width:o,height:l})=>{let u=kI({width:o,height:l});return o>0&&l>0&&Yc(u).putImageData(s.getImageData(a,i,o,l),0,0),u})}async function Soe(e,t){if(!Hw(e)&&!ou(e))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(ou(e)&&e.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return ue(()=>{let[n,r,s]=e.shape.slice(ou(e)?1:0);return t.map(a=>a instanceof to?a.forSize(r,n).box:a).map(a=>a.clipAtImageBorders(r,n)).filter(a=>a.width>0&&a.height>0).map(({x:a,y:i,width:o,height:l})=>Ub(e.as3D(n,r,s),[i,a,0],[l,o,s]))})}async function v$t(e,t){let{fetch:n}=Ia.getEnv(),r=await n(e,t);if(!(r.status<400))throw new Error(`failed to fetch: (${r.status}) ${r.statusText}, from url: ${r.url}`);return r}async function x$t(e){return(await v$t(e)).json()}function Ioe(e,t){let n=`${t}-weights_manifest.json`;if(!e)return{modelBaseUri:"",manifestUri:n};if(e==="/")return{modelBaseUri:"/",manifestUri:`/${n}`};let r=e.startsWith("http://")?"http://":e.startsWith("https://")?"https://":"";e=e.replace(r,"");let s=e.split("/").filter(o=>o),a=e.endsWith(".json")?s[s.length-1]:n,i=r+(e.endsWith(".json")?s.slice(0,s.length-1):s).join("/");return i=e.startsWith("/")?`/${i}`:i,{modelBaseUri:i,manifestUri:i==="/"?`/${a}`:`${i}/${a}`}}async function w$t(e,t){let{manifestUri:n,modelBaseUri:r}=Ioe(e,t),s=await x$t(n);return ws.loadWeights(s,r)}function Coe(e,t,n=!1){let{width:r,height:s}=n?Cz(t):t;return e.width=r,e.height=s,{width:r,height:s}}var Td=class{constructor(e){this._params=void 0,this._paramMappings=[],this._name=e}get params(){return this._params}get paramMappings(){return this._paramMappings}get isLoaded(){return!!this.params}getParamFromPath(e){let{obj:t,objProp:n}=this.traversePropertyPath(e);return t[n]}reassignParamFromPath(e,t){let{obj:n,objProp:r}=this.traversePropertyPath(e);n[r].dispose(),n[r]=t}getParamList(){return this._paramMappings.map(({paramPath:e})=>({path:e,tensor:this.getParamFromPath(e)}))}getTrainableParams(){return this.getParamList().filter(e=>e.tensor instanceof Hh)}getFrozenParams(){return this.getParamList().filter(e=>!(e.tensor instanceof Hh))}variable(){this.getFrozenParams().forEach(({path:e,tensor:t})=>{this.reassignParamFromPath(e,t.variable())})}freeze(){this.getTrainableParams().forEach(({path:e,tensor:t})=>{let n=Js(t.dataSync());t.dispose(),this.reassignParamFromPath(e,n)})}dispose(e=!0){this.getParamList().forEach(t=>{if(e&&t.tensor.isDisposed)throw new Error(`param tensor has already been disposed for path ${t.path}`);t.tensor.dispose()}),this._params=void 0}serializeParams(){return new Float32Array(this.getParamList().map(({tensor:e})=>Array.from(e.dataSync())).reduce((e,t)=>e.concat(t)))}async load(e){if(e instanceof Float32Array){this.extractWeights(e);return}await this.loadFromUri(e)}async loadFromUri(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromUri - expected model uri`);let t=await w$t(e,this.getDefaultModelName());this.loadFromWeightMap(t)}async loadFromDisk(e){if(e&&typeof e!="string")throw new Error(`${this._name}.loadFromDisk - expected model file path`);let{readFile:t}=Ia.getEnv(),{manifestUri:n,modelBaseUri:r}=Ioe(e,this.getDefaultModelName()),s=l=>Promise.all(l.map(u=>t(u).then(c=>typeof c=="string"?Buffer.from(c):c.buffer))),a=ws.weightsLoaderFactory(s),i=JSON.parse((await t(n)).toString()),o=await a(i,r);this.loadFromWeightMap(o)}loadFromWeightMap(e){let{paramMappings:t,params:n}=this.extractParamsFromWeightMap(e);this._paramMappings=t,this._params=n}extractWeights(e){let{paramMappings:t,params:n}=this.extractParams(e);this._paramMappings=t,this._params=n}traversePropertyPath(e){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");let t=e.split("/").reduce((s,a)=>{if(!s.nextObj.hasOwnProperty(a))throw new Error(`traversePropertyPath - object does not have property ${a}, for path ${e}`);return{obj:s.nextObj,objProp:a,nextObj:s.nextObj[a]}},{nextObj:this.params}),{obj:n,objProp:r}=t;if(!n||!r||!(n[r]instanceof Bt))throw new Error(`traversePropertyPath - parameter is not a tensor, for path ${e}`);return{obj:n,objProp:r}}};function fi(e,t,n){return ue(()=>{let r=Vb(e,t.depthwise_filter,t.pointwise_filter,n,"same");return r=De(r,t.bias),r})}function KE(e,t,n=!1){return ue(()=>{let r=gn(n?De(ta(e,t.conv0.filters,[2,2],"same"),t.conv0.bias):fi(e,t.conv0,[2,2])),s=fi(r,t.conv1,[1,1]),a=gn(De(r,s)),i=fi(a,t.conv2,[1,1]);return gn(De(r,De(s,i)))})}function Zk(e,t,n=!1,r=!0){return ue(()=>{let s=gn(n?De(ta(e,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):fi(e,t.conv0,r?[2,2]:[1,1])),a=fi(s,t.conv1,[1,1]),i=gn(De(s,a)),o=fi(i,t.conv2,[1,1]),l=gn(De(s,De(a,o))),u=fi(l,t.conv3,[1,1]);return gn(De(s,De(a,De(o,u))))})}function h1(e,t,n="same",r=!1){return ue(()=>{let s=De(ta(e,t.filters,[1,1],n),t.bias);return r?gn(s):s})}function $d(e,t){Object.keys(e).forEach(n=>{t.some(r=>r.originalPath===n)||e[n].dispose()})}function Nz(e,t){return(n,r,s,a)=>{let i=Uc(e(n*r*s*s),[s,s,n,r]),o=dn(e(r));return t.push({paramPath:`${a}/filters`},{paramPath:`${a}/bias`}),{filters:i,bias:o}}}function Noe(e,t){return(n,r,s)=>{let a=Tl(e(n*r),[n,r]),i=dn(e(r));return t.push({paramPath:`${s}/weights`},{paramPath:`${s}/bias`}),{weights:a,bias:i}}}var Toe=class{constructor(e,t,n){this.depthwise_filter=e,this.pointwise_filter=t,this.bias=n}};function Tz(e,t){return(n,r,s)=>{let a=Uc(e(9*n),[3,3,n,1]),i=Uc(e(n*r),[1,1,n,r]),o=dn(e(r));return t.push({paramPath:`${s}/depthwise_filter`},{paramPath:`${s}/pointwise_filter`},{paramPath:`${s}/bias`}),new Toe(a,i,o)}}function $z(e){return t=>{let n=e(`${t}/depthwise_filter`,4),r=e(`${t}/pointwise_filter`,4),s=e(`${t}/bias`,1);return new Toe(n,r,s)}}function sm(e,t){return(n,r,s)=>{let a=e[n];if(!rv(a,r))throw new Error(`expected weightMap[${n}] to be a Tensor${r}D, instead have ${a}`);return t.push({originalPath:n,paramPath:s||n}),a}}function Ed(e){let t=e;function n(s){let a=t.slice(0,s);return t=t.slice(s),a}function r(){return t}return{extractWeights:n,getRemainingWeights:r}}function $oe(e,t){let n=Nz(e,t),r=Tz(e,t);function s(i,o,l,u=!1){let c=u?n(i,o,3,`${l}/conv0`):r(i,o,`${l}/conv0`),d=r(o,o,`${l}/conv1`),h=r(o,o,`${l}/conv2`);return{conv0:c,conv1:d,conv2:h}}function a(i,o,l,u=!1){let{conv0:c,conv1:d,conv2:h}=s(i,o,l,u),p=r(o,o,`${l}/conv3`);return{conv0:c,conv1:d,conv2:h,conv3:p}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:a}}function k$t(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),{extractDenseBlock4Params:s}=$oe(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2"),l=s(128,256,"dense3");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o,dense3:l}}}function Eoe(e){return t=>{let n=e(`${t}/filters`,4),r=e(`${t}/bias`,1);return{filters:n,bias:r}}}function _oe(e,t){let n=sm(e,t),r=Eoe(n),s=$z(n);function a(o,l=!1){let u=l?r(`${o}/conv0`):s(`${o}/conv0`),c=s(`${o}/conv1`),d=s(`${o}/conv2`);return{conv0:u,conv1:c,conv2:d}}function i(o,l=!1){let u=l?r(`${o}/conv0`):s(`${o}/conv0`),c=s(`${o}/conv1`),d=s(`${o}/conv2`),h=s(`${o}/conv3`);return{conv0:u,conv1:c,conv2:d,conv3:h}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:i}}function S$t(e){let t=[],{extractDenseBlock4Params:n}=_oe(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2"),dense3:n("dense3")};return $d(e,t),{params:r,paramMappings:t}}var Aoe=class extends Td{constructor(){super("FaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceFeatureExtractor - load model before inference");return ue(()=>{let n=je(e.toBatchTensor(112,!0),"float32"),r=qw(n,[122.782,117.001,104.298]).div(255),s=Zk(r,t.dense0,!0);return s=Zk(s,t.dense1),s=Zk(s,t.dense2),s=Zk(s,t.dense3),s=_u(s,[7,7],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await ra(e))}getDefaultModelName(){return"face_feature_extractor_model"}extractParamsFromWeightMap(e){return S$t(e)}extractParams(e){return k$t(e)}};function aD(e,t){return ue(()=>De(Mt(e,t.weights),t.bias))}function I$t(e,t,n){let r=[],{extractWeights:s,getRemainingWeights:a}=Ed(e),i=Noe(s,r)(t,n,"fc");if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{paramMappings:r,params:{fc:i}}}function C$t(e){let t=[],n=sm(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:r("fc")};return $d(e,t),{params:s,paramMappings:t}}function Roe(e){let t={},n={};return Object.keys(e).forEach(r=>{let s=r.startsWith("fc")?n:t;s[r]=e[r]}),{featureExtractorMap:t,classifierMap:n}}var Doe=class extends Td{constructor(e,t){super(e),this._faceFeatureExtractor=t}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ue(()=>{let n=e instanceof SI?this.faceFeatureExtractor.forwardInput(e):e;return aD(n.as2D(n.shape[0],-1),t.fc)})}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return I$t(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=Roe(e);return this.faceFeatureExtractor.loadFromWeightMap(t),C$t(n)}extractParams(e){let t=this.getClassifierChannelsIn(),n=this.getClassifierChannelsOut(),r=n*t+n,s=e.slice(0,e.length-r),a=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(s),this.extractClassifierParams(a)}},d6=["neutral","happy","sad","angry","fearful","disgusted","surprised"],Ez=class{constructor(e){if(this.neutral=0,this.happy=0,this.sad=0,this.angry=0,this.fearful=0,this.disgusted=0,this.surprised=0,e.length!==7)throw new Error(`FaceExpressions.constructor - expected probabilities.length to be 7, have: ${e.length}`);d6.forEach((t,n)=>{this[t]=e[n]})}asSortedArray(){return d6.map(e=>({expression:e,probability:this[e]})).sort((e,t)=>t.probability-e.probability)}},N$t=class extends Doe{constructor(e=new Aoe){super("FaceExpressionNet",e)}forwardInput(e){return ue(()=>wd(this.runNet(e)))}async forward(e){return this.forwardInput(await ra(e))}async predictExpressions(e){let t=await ra(e),n=await this.forwardInput(t),r=await Promise.all(hr(n).map(async a=>{let i=a.dataSync();return a.dispose(),i}));n.dispose();let s=r.map(a=>new Ez(a));return t.isBatchInput?s:s[0]}getDefaultModelName(){return"face_expression_model"}getClassifierChannelsIn(){return 256}getClassifierChannelsOut(){return 7}};function T$t(e){return e.expressions instanceof Ez}function $$t(e,t){return{...e,expressions:t}}function E$t(e,t,n=.1,r){(Array.isArray(t)?t:[t]).forEach(s=>{let a=s instanceof Ez?s:T$t(s)?s.expressions:void 0;if(!a)throw new Error("drawFaceExpressions - expected faceExpressions to be FaceExpressions | WithFaceExpressions<{}> or array thereof");let i=a.asSortedArray().filter(l=>l.probability>n),o=f0(s)?s.detection.box.bottomLeft:r||new xn(0,0);new Iz(i.map(l=>`${l.expression} (${bz(l.probability)})`),o).draw(e)})}function _z(e){return f0(e)&&e.landmarks instanceof p0&&e.unshiftedLandmarks instanceof p0&&e.alignedRect instanceof to}function _$t(e){let t=l=>l*180/Math.PI,n=(l,u)=>Math.sqrt((l.x-u.x)**2+(l.y-u.y)**2),r={roll:void 0,pitch:void 0,yaw:void 0},s=(l,u,c)=>{let d=Math.floor(l.x-u.x),h=Math.floor(u.x-c.x);return d-h},a=(l,u)=>{let c=Math.hypot(u.x-l.x,u.y-l.y),d=u.y-l.y,h=Math.asin(d/c),p=t(h),f=Math.floor(90-p),m=u.x-l.x<0?-1:1;return f*m},i=(l,u,c)=>{let d=n(l,c),h=new xn((l.x+c.x)/2,(l.y+c.y)/2),p=n(u,h),f=Math.atan(p/d),m=Math.floor(t(f)),g=h.y-u.y<0?-1:1;return m*g};if(!e||!e.positions||e.positions.length!==68)return r;let o=e.positions;return r.roll=a(o[27],o[66]),r.pitch=i(o[14],o[30],o[2]),r.yaw=s(o[14],o[33],o[2]),r}function Ooe(e,t){let{box:n}=e.detection,r=t.shiftBy(n.x,n.y),s=r.align(),{imageDims:a}=e.detection,i=new to(e.detection.score,s.rescale(a.reverse()),a),o=_$t(t);return{...e,landmarks:r,unshiftedLandmarks:t,alignedRect:i,angle:o}}var Foe=class{constructor(e={}){let{drawLines:t=!0,drawPoints:n=!0,lineWidth:r,lineColor:s,pointSize:a,pointColor:i}=e;this.drawLines=t,this.drawPoints=n,this.lineWidth=r||1,this.pointSize=a||2,this.lineColor=s||"rgba(0, 255, 255, 1)",this.pointColor=i||"rgba(255, 0, 255, 1)"}},Moe=class{constructor(e,t={}){this.faceLandmarks=e,this.options=new Foe(t)}draw(e){let t=Yc(e),{drawLines:n,drawPoints:r,lineWidth:s,lineColor:a,pointSize:i,pointColor:o}=this.options;if(n&&this.faceLandmarks instanceof hoe&&(t.strokeStyle=a,t.lineWidth=s,ju(t,this.faceLandmarks.getJawOutline()),ju(t,this.faceLandmarks.getLeftEyeBrow()),ju(t,this.faceLandmarks.getRightEyeBrow()),ju(t,this.faceLandmarks.getNose()),ju(t,this.faceLandmarks.getLeftEye(),!0),ju(t,this.faceLandmarks.getRightEye(),!0),ju(t,this.faceLandmarks.getMouth(),!0)),r){t.strokeStyle=o,t.fillStyle=o;let l=u=>{t.beginPath(),t.arc(u.x,u.y,i,0,2*Math.PI),t.fill()};this.faceLandmarks.positions.forEach(l)}}};function A$t(e,t){(Array.isArray(t)?t:[t]).forEach(n=>{let r=n instanceof p0?n:_z(n)?n.landmarks:void 0;if(!r)throw new Error("drawFaceLandmarks - expected faceExpressions to be FaceLandmarks | WithFaceLandmarks<WithFaceDetection<{}>> or array thereof");new Moe(r).draw(e)})}function R$t(e,t){let n=Nz(e,t),r=Tz(e,t);function s(i,o,l){let u=r(i,o,`${l}/separable_conv0`),c=r(o,o,`${l}/separable_conv1`),d=n(i,o,1,`${l}/expansion_conv`);return{separable_conv0:u,separable_conv1:c,expansion_conv:d}}function a(i,o){let l=r(i,i,`${o}/separable_conv0`),u=r(i,i,`${o}/separable_conv1`),c=r(i,i,`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:n,extractSeparableConvParams:r,extractReductionBlockParams:s,extractMainBlockParams:a}}function D$t(e,t){let n=[],{extractWeights:r,getRemainingWeights:s}=Ed(e),{extractConvParams:a,extractSeparableConvParams:i,extractReductionBlockParams:o,extractMainBlockParams:l}=R$t(r,n),u=a(3,32,3,"entry_flow/conv_in"),c=o(32,64,"entry_flow/reduction_block_0"),d=o(64,128,"entry_flow/reduction_block_1"),h={conv_in:u,reduction_block_0:c,reduction_block_1:d},p={};Qg(t,0,1).forEach(y=>{p[`main_block_${y}`]=l(128,`middle_flow/main_block_${y}`)});let f=o(128,256,"exit_flow/reduction_block"),m=i(256,512,"exit_flow/separable_conv"),g={reduction_block:f,separable_conv:m};if(s().length!==0)throw new Error(`weights remaing after extract: ${s().length}`);return{paramMappings:n,params:{entry_flow:h,middle_flow:p,exit_flow:g}}}function O$t(e,t){let n=sm(e,t),r=Eoe(n),s=$z(n);function a(o){let l=s(`${o}/separable_conv0`),u=s(`${o}/separable_conv1`),c=r(`${o}/expansion_conv`);return{separable_conv0:l,separable_conv1:u,expansion_conv:c}}function i(o){let l=s(`${o}/separable_conv0`),u=s(`${o}/separable_conv1`),c=s(`${o}/separable_conv2`);return{separable_conv0:l,separable_conv1:u,separable_conv2:c}}return{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}}function F$t(e,t){let n=[],{extractConvParams:r,extractSeparableConvParams:s,extractReductionBlockParams:a,extractMainBlockParams:i}=O$t(e,n),o=r("entry_flow/conv_in"),l=a("entry_flow/reduction_block_0"),u=a("entry_flow/reduction_block_1"),c={conv_in:o,reduction_block_0:l,reduction_block_1:u},d={};Qg(t,0,1).forEach(m=>{d[`main_block_${m}`]=i(`middle_flow/main_block_${m}`)});let h=a("exit_flow/reduction_block"),p=s("exit_flow/separable_conv"),f={reduction_block:h,separable_conv:p};return $d(e,n),{params:{entry_flow:c,middle_flow:d,exit_flow:f},paramMappings:n}}function Poe(e,t,n){return De(ta(e,t.filters,n,"same"),t.bias)}function XE(e,t,n=!0){let r=n?gn(e):e;return r=fi(r,t.separable_conv0,[1,1]),r=fi(gn(r),t.separable_conv1,[1,1]),r=Qr(r,[3,3],[2,2],"same"),r=De(r,Poe(e,t.expansion_conv,[2,2])),r}function M$t(e,t){let n=fi(gn(e),t.separable_conv0,[1,1]);return n=fi(gn(n),t.separable_conv1,[1,1]),n=fi(gn(n),t.separable_conv2,[1,1]),n=De(n,e),n}var P$t=class extends Td{constructor(e){super("TinyXception"),this._numMainBlocks=e}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyXception - load model before inference");return ue(()=>{let n=je(e.toBatchTensor(112,!0),"float32"),r=qw(n,[122.782,117.001,104.298]).div(255),s=gn(Poe(r,t.entry_flow.conv_in,[2,2]));return s=XE(s,t.entry_flow.reduction_block_0,!1),s=XE(s,t.entry_flow.reduction_block_1),Qg(this._numMainBlocks,0,1).forEach(a=>{s=M$t(s,t.middle_flow[`main_block_${a}`])}),s=XE(s,t.exit_flow.reduction_block),s=gn(fi(s,t.exit_flow.separable_conv,[1,1])),s})}async forward(e){return this.forwardInput(await ra(e))}getDefaultModelName(){return"tiny_xception_model"}extractParamsFromWeightMap(e){return F$t(e,this._numMainBlocks)}extractParams(e){return D$t(e,this._numMainBlocks)}};function L$t(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),s=Noe(n,t),a=s(512,1,"fc/age"),i=s(512,2,"fc/gender");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{fc:{age:a,gender:i}}}}function z$t(e){let t=[],n=sm(e,t);function r(a){let i=n(`${a}/weights`,2),o=n(`${a}/bias`,1);return{weights:i,bias:o}}let s={fc:{age:r("fc/age"),gender:r("fc/gender")}};return $d(e,t),{params:s,paramMappings:t}}var B$t=(e=>(e.FEMALE="female",e.MALE="male",e))(B$t||{}),W$t=class extends Td{constructor(e=new P$t(2)){super("AgeGenderNet"),this._faceFeatureExtractor=e}get faceFeatureExtractor(){return this._faceFeatureExtractor}runNet(e){let{params:t}=this;if(!t)throw new Error(`${this._name} - load model before inference`);return ue(()=>{let n=e instanceof SI?this.faceFeatureExtractor.forwardInput(e):e,r=_u(n,[7,7],[2,2],"valid").as2D(n.shape[0],-1),s=aD(r,t.fc.age).as1D(),a=aD(r,t.fc.gender);return{age:s,gender:a}})}forwardInput(e){return ue(()=>{let{age:t,gender:n}=this.runNet(e);return{age:t,gender:wd(n)}})}async forward(e){return this.forwardInput(await ra(e))}async predictAgeAndGender(e){let t=await ra(e),n=await this.forwardInput(t),r=hr(n.age),s=hr(n.gender),a=r.map((o,l)=>({ageTensor:o,genderTensor:s[l]})),i=await Promise.all(a.map(async({ageTensor:o,genderTensor:l})=>{let u=o.dataSync()[0],c=l.dataSync()[0],d=c>.5,h=d?"male":"female",p=d?c:1-c;return o.dispose(),l.dispose(),{age:u,gender:h,genderProbability:p}}));return n.age.dispose(),n.gender.dispose(),t.isBatchInput?i:i[0]}getDefaultModelName(){return"age_gender_model"}dispose(e=!0){this.faceFeatureExtractor.dispose(e),super.dispose(e)}loadClassifierParams(e){let{params:t,paramMappings:n}=this.extractClassifierParams(e);this._params=t,this._paramMappings=n}extractClassifierParams(e){return L$t(e)}extractParamsFromWeightMap(e){let{featureExtractorMap:t,classifierMap:n}=Roe(e);return this.faceFeatureExtractor.loadFromWeightMap(t),z$t(n)}extractParams(e){let t=e.slice(0,e.length-1539),n=e.slice(e.length-1539);return this.faceFeatureExtractor.extractWeights(t),this.extractClassifierParams(n)}},Loe=class extends Doe{postProcess(e,t,n){let r=n.map(({width:a,height:i})=>{let o=t/Math.max(i,a);return{width:a*o,height:i*o}}),s=r.length;return ue(()=>{let a=(u,c)=>_r([Ka([68],u,"float32"),Ka([68],c,"float32")],1).as2D(1,136).as1D(),i=(u,c)=>{let{width:d,height:h}=r[u];return c(d,h)?Math.abs(d-h)/2:0},o=u=>i(u,(c,d)=>c<d),l=u=>i(u,(c,d)=>d<c);return e.mul(Ka([s,136],t,"float32")).sub(_r(Array.from(Array(s),(u,c)=>a(o(c),l(c))))).div(_r(Array.from(Array(s),(u,c)=>a(r[c].width,r[c].height))))})}forwardInput(e){return ue(()=>{let t=this.runNet(e);return this.postProcess(t,e.inputSize,e.inputDimensions.map(([n,r])=>({height:n,width:r})))})}async forward(e){return this.forwardInput(await ra(e))}async detectLandmarks(e){let t=await ra(e),n=ue(()=>hr(this.forwardInput(t))),r=await Promise.all(n.map(async(s,a)=>{let i=Array.from(s.dataSync()),o=i.filter((u,c)=>tD(c)),l=i.filter((u,c)=>!tD(c));return new hoe(Array(68).fill(0).map((u,c)=>new xn(o[c],l[c])),{height:t.getInputHeight(a),width:t.getInputWidth(a)})}));return n.forEach(s=>s.dispose()),t.isBatchInput?r:r[0]}getClassifierChannelsOut(){return 136}},V$t=class extends Loe{constructor(e=new Aoe){super("FaceLandmark68Net",e)}getDefaultModelName(){return"face_landmark_68_model"}getClassifierChannelsIn(){return 256}};function U$t(e){let t=[],{extractDenseBlock3Params:n}=_oe(e,t),r={dense0:n("dense0",!0),dense1:n("dense1"),dense2:n("dense2")};return $d(e,t),{params:r,paramMappings:t}}function j$t(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),{extractDenseBlock3Params:s}=$oe(n,t),a=s(3,32,"dense0",!0),i=s(32,64,"dense1"),o=s(64,128,"dense2");if(r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{paramMappings:t,params:{dense0:a,dense1:i,dense2:o}}}var G$t=class extends Td{constructor(){super("TinyFaceFeatureExtractor")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("TinyFaceFeatureExtractor - load model before inference");return ue(()=>{let n=je(e.toBatchTensor(112,!0),"float32"),r=qw(n,[122.782,117.001,104.298]).div(255),s=KE(r,t.dense0,!0);return s=KE(s,t.dense1),s=KE(s,t.dense2),s=_u(s,[14,14],[2,2],"valid"),s})}async forward(e){return this.forwardInput(await ra(e))}getDefaultModelName(){return"face_feature_extractor_tiny_model"}extractParamsFromWeightMap(e){return U$t(e)}extractParams(e){return j$t(e)}},H$t=class extends Loe{constructor(e=new G$t){super("FaceLandmark68TinyNet",e)}getDefaultModelName(){return"face_landmark_68_tiny_model"}getClassifierChannelsIn(){return 128}};function q$t(e,t){return De(oe(e,t.weights),t.biases)}function Az(e,t,n,r,s="same"){let{filters:a,bias:i}=t.conv,o=ta(e,a,n,s);return o=De(o,i),o=q$t(o,t.scale),r?gn(o):o}function K$t(e,t){return Az(e,t,[1,1],!0)}function zoe(e,t){return Az(e,t,[1,1],!1)}function Boe(e,t){return Az(e,t,[2,2],!0,"valid")}function X$t(e,t){function n(o,l,u){let c=e(o),d=c.length/(l*u*u);if(aoe(d))throw new Error(`depth has to be an integer: ${d}, weights.length: ${c.length}, numFilters: ${l}, filterSize: ${u}`);return ue(()=>Lt(Uc(c,[l,d,u,u]),[2,3,1,0]))}function r(o,l,u,c){let d=n(o,l,u),h=dn(e(l));return t.push({paramPath:`${c}/filters`},{paramPath:`${c}/bias`}),{filters:d,bias:h}}function s(o,l){let u=dn(e(o)),c=dn(e(o));return t.push({paramPath:`${l}/weights`},{paramPath:`${l}/biases`}),{weights:u,biases:c}}function a(o,l,u,c){let d=r(o,l,u,`${c}/conv`),h=s(l,`${c}/scale`);return{conv:d,scale:h}}function i(o,l,u,c,d=!1){let h=a((d?.5:1)*o,l,u,`${c}/conv1`),p=a(o,l,u,`${c}/conv2`);return{conv1:h,conv2:p}}return{extractConvLayerParams:a,extractResidualLayerParams:i}}function Y$t(e){let{extractWeights:t,getRemainingWeights:n}=Ed(e),r=[],{extractConvLayerParams:s,extractResidualLayerParams:a}=X$t(t,r),i=s(4704,32,7,"conv32_down"),o=a(9216,32,3,"conv32_1"),l=a(9216,32,3,"conv32_2"),u=a(9216,32,3,"conv32_3"),c=a(36864,64,3,"conv64_down",!0),d=a(36864,64,3,"conv64_1"),h=a(36864,64,3,"conv64_2"),p=a(36864,64,3,"conv64_3"),f=a(147456,128,3,"conv128_down",!0),m=a(147456,128,3,"conv128_1"),g=a(147456,128,3,"conv128_2"),y=a(589824,256,3,"conv256_down",!0),b=a(589824,256,3,"conv256_1"),x=a(589824,256,3,"conv256_2"),v=a(589824,256,3,"conv256_down_out"),w=ue(()=>Lt(Tl(t(256*128),[128,256]),[1,0]));if(r.push({paramPath:"fc"}),n().length!==0)throw new Error(`weights remaing after extract: ${n().length}`);return{params:{conv32_down:i,conv32_1:o,conv32_2:l,conv32_3:u,conv64_down:c,conv64_1:d,conv64_2:h,conv64_3:p,conv128_down:f,conv128_1:m,conv128_2:g,conv256_down:y,conv256_1:b,conv256_2:x,conv256_down_out:v,fc:w},paramMappings:r}}function J$t(e,t){let n=sm(e,t);function r(i){let o=n(`${i}/scale/weights`,1),l=n(`${i}/scale/biases`,1);return{weights:o,biases:l}}function s(i){let o=n(`${i}/conv/filters`,4),l=n(`${i}/conv/bias`,1),u=r(i);return{conv:{filters:o,bias:l},scale:u}}function a(i){return{conv1:s(`${i}/conv1`),conv2:s(`${i}/conv2`)}}return{extractConvLayerParams:s,extractResidualLayerParams:a}}function Z$t(e){let t=[],{extractConvLayerParams:n,extractResidualLayerParams:r}=J$t(e,t),s=n("conv32_down"),a=r("conv32_1"),i=r("conv32_2"),o=r("conv32_3"),l=r("conv64_down"),u=r("conv64_1"),c=r("conv64_2"),d=r("conv64_3"),h=r("conv128_down"),p=r("conv128_1"),f=r("conv128_2"),m=r("conv256_down"),g=r("conv256_1"),y=r("conv256_2"),b=r("conv256_down_out"),{fc:x}=e;if(t.push({originalPath:"fc",paramPath:"fc"}),!soe(x))throw new Error(`expected weightMap[fc] to be a Tensor2D, instead have ${x}`);let v={conv32_down:s,conv32_1:a,conv32_2:i,conv32_3:o,conv64_down:l,conv64_1:u,conv64_2:c,conv64_3:d,conv128_down:h,conv128_1:p,conv128_2:f,conv256_down:m,conv256_1:g,conv256_2:y,conv256_down_out:b,fc:x};return $d(e,t),{params:v,paramMappings:t}}function Zo(e,t){let n=K$t(e,t.conv1);return n=zoe(n,t.conv2),n=De(n,e),n=gn(n),n}function Qk(e,t){let n=Boe(e,t.conv1);n=zoe(n,t.conv2);let r=_u(e,2,2,"valid"),s=sr(r.shape),a=r.shape[3]!==n.shape[3];if(r.shape[1]!==n.shape[1]||r.shape[2]!==n.shape[2]){let i=[...n.shape];i[1]=1;let o=sr(i);n=In([n,o],1);let l=[...n.shape];l[2]=1;let u=sr(l);n=In([n,u],2)}return r=a?In([r,s],3):r,n=De(r,n),n=gn(n),n}var Q$t=class extends Td{constructor(){super("FaceRecognitionNet")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("FaceRecognitionNet - load model before inference");return ue(()=>{let n=je(e.toBatchTensor(150,!0),"float32"),r=qw(n,[122.782,117.001,104.298]).div(255),s=Boe(r,t.conv32_down);s=Qr(s,3,2,"valid"),s=Zo(s,t.conv32_1),s=Zo(s,t.conv32_2),s=Zo(s,t.conv32_3),s=Qk(s,t.conv64_down),s=Zo(s,t.conv64_1),s=Zo(s,t.conv64_2),s=Zo(s,t.conv64_3),s=Qk(s,t.conv128_down),s=Zo(s,t.conv128_1),s=Zo(s,t.conv128_2),s=Qk(s,t.conv256_down),s=Zo(s,t.conv256_1),s=Zo(s,t.conv256_2),s=Qk(s,t.conv256_down_out);let a=s.mean([1,2]);return Mt(a,t.fc)})}async forward(e){return this.forwardInput(await ra(e))}async computeFaceDescriptor(e){var t;if((t=e==null?void 0:e.shape)!=null&&t.some(a=>a<=0))return new Float32Array(128);let n=await ra(e),r=ue(()=>hr(this.forwardInput(n))),s=await Promise.all(r.map(a=>a.data()));return r.forEach(a=>a.dispose()),n.isBatchInput?s:s[0]}getDefaultModelName(){return"face_recognition_model"}extractParamsFromWeightMap(e){return Z$t(e)}extractParams(e){return Y$t(e)}};function eEt(e,t){return{...e,descriptor:t}}function tEt(e,t){return{...e,age:t}}function nEt(e,t,n){return{...e,gender:t,genderProbability:n}}function rEt(e,t){function n(l,u){let c=Uc(e(9*l),[3,3,l,1]),d=dn(e(l)),h=dn(e(l)),p=dn(e(l)),f=dn(e(l));return t.push({paramPath:`${u}/filters`},{paramPath:`${u}/batch_norm_scale`},{paramPath:`${u}/batch_norm_offset`},{paramPath:`${u}/batch_norm_mean`},{paramPath:`${u}/batch_norm_variance`}),{filters:c,batch_norm_scale:d,batch_norm_offset:h,batch_norm_mean:p,batch_norm_variance:f}}function r(l,u,c,d,h){let p=Uc(e(l*u*c*c),[c,c,l,u]),f=dn(e(u));return t.push({paramPath:`${d}/filters`},{paramPath:`${d}/${h?"batch_norm_offset":"bias"}`}),{filters:p,bias:f}}function s(l,u,c,d){let{filters:h,bias:p}=r(l,u,c,d,!0);return{filters:h,batch_norm_offset:p}}function a(l,u,c){let d=n(l,`${c}/depthwise_conv`),h=s(l,u,1,`${c}/pointwise_conv`);return{depthwise_conv:d,pointwise_conv:h}}function i(){let l=s(3,32,3,"mobilenetv1/conv_0"),u=a(32,64,"mobilenetv1/conv_1"),c=a(64,128,"mobilenetv1/conv_2"),d=a(128,128,"mobilenetv1/conv_3"),h=a(128,256,"mobilenetv1/conv_4"),p=a(256,256,"mobilenetv1/conv_5"),f=a(256,512,"mobilenetv1/conv_6"),m=a(512,512,"mobilenetv1/conv_7"),g=a(512,512,"mobilenetv1/conv_8"),y=a(512,512,"mobilenetv1/conv_9"),b=a(512,512,"mobilenetv1/conv_10"),x=a(512,512,"mobilenetv1/conv_11"),v=a(512,1024,"mobilenetv1/conv_12"),w=a(1024,1024,"mobilenetv1/conv_13");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:m,conv_8:g,conv_9:y,conv_10:b,conv_11:x,conv_12:v,conv_13:w}}function o(){let l=s(1024,256,1,"prediction_layer/conv_0"),u=s(256,512,3,"prediction_layer/conv_1"),c=s(512,128,1,"prediction_layer/conv_2"),d=s(128,256,3,"prediction_layer/conv_3"),h=s(256,128,1,"prediction_layer/conv_4"),p=s(128,256,3,"prediction_layer/conv_5"),f=s(256,64,1,"prediction_layer/conv_6"),m=s(64,128,3,"prediction_layer/conv_7"),g=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),y=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),b=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),x=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),v=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),w=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),k=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),S=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),I=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),$=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),C=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),T=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor");return{conv_0:l,conv_1:u,conv_2:c,conv_3:d,conv_4:h,conv_5:p,conv_6:f,conv_7:m,box_predictor_0:{box_encoding_predictor:g,class_predictor:y},box_predictor_1:{box_encoding_predictor:b,class_predictor:x},box_predictor_2:{box_encoding_predictor:v,class_predictor:w},box_predictor_3:{box_encoding_predictor:k,class_predictor:S},box_predictor_4:{box_encoding_predictor:I,class_predictor:$},box_predictor_5:{box_encoding_predictor:C,class_predictor:T}}}return{extractMobilenetV1Params:i,extractPredictionLayerParams:o}}function sEt(e){let t=[],{extractWeights:n,getRemainingWeights:r}=Ed(e),{extractMobilenetV1Params:s,extractPredictionLayerParams:a}=rEt(n,t),i=s(),o=a(),l={extra_dim:$T(n(5118*4),[1,5118,4])};if(t.push({paramPath:"output_layer/extra_dim"}),r().length!==0)throw new Error(`weights remaing after extract: ${r().length}`);return{params:{mobilenetv1:i,prediction_layer:o,output_layer:l},paramMappings:t}}function aEt(e,t){let n=sm(e,t);function r(u,c,d){let h=n(`${u}/Conv2d_${c}_pointwise/weights`,4,`${d}/filters`),p=n(`${u}/Conv2d_${c}_pointwise/convolution_bn_offset`,1,`${d}/batch_norm_offset`);return{filters:h,batch_norm_offset:p}}function s(u){let c=`mobilenetv1/conv_${u}`,d=`MobilenetV1/Conv2d_${u}_depthwise`,h=`${c}/depthwise_conv`,p=`${c}/pointwise_conv`,f=n(`${d}/depthwise_weights`,4,`${h}/filters`),m=n(`${d}/BatchNorm/gamma`,1,`${h}/batch_norm_scale`),g=n(`${d}/BatchNorm/beta`,1,`${h}/batch_norm_offset`),y=n(`${d}/BatchNorm/moving_mean`,1,`${h}/batch_norm_mean`),b=n(`${d}/BatchNorm/moving_variance`,1,`${h}/batch_norm_variance`);return{depthwise_conv:{filters:f,batch_norm_scale:m,batch_norm_offset:g,batch_norm_mean:y,batch_norm_variance:b},pointwise_conv:r("MobilenetV1",u,p)}}function a(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:s(1),conv_2:s(2),conv_3:s(3),conv_4:s(4),conv_5:s(5),conv_6:s(6),conv_7:s(7),conv_8:s(8),conv_9:s(9),conv_10:s(10),conv_11:s(11),conv_12:s(12),conv_13:s(13)}}function i(u,c){let d=n(`${u}/weights`,4,`${c}/filters`),h=n(`${u}/biases`,1,`${c}/bias`);return{filters:d,bias:h}}function o(u){let c=i(`Prediction/BoxPredictor_${u}/BoxEncodingPredictor`,`prediction_layer/box_predictor_${u}/box_encoding_predictor`),d=i(`Prediction/BoxPredictor_${u}/ClassPredictor`,`prediction_layer/box_predictor_${u}/class_predictor`);return{box_encoding_predictor:c,class_predictor:d}}function l(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:o(0),box_predictor_1:o(1),box_predictor_2:o(2),box_predictor_3:o(3),box_predictor_4:o(4),box_predictor_5:o(5)}}return{extractMobilenetV1Params:a,extractPredictionLayerParams:l}}function iEt(e){let t=[],{extractMobilenetV1Params:n,extractPredictionLayerParams:r}=aEt(e,t),s=e["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!Hw(s))throw new Error(`expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have ${s}`);let a={mobilenetv1:n(),prediction_layer:r(),output_layer:{extra_dim:s}};return $d(e,t),{params:a,paramMappings:t}}function sl(e,t,n){return ue(()=>{let r=ta(e,t.filters,n,"same");return r=De(r,t.batch_norm_offset),Fs(r,0,6)})}var oEt=.0010000000474974513;function lEt(e,t,n){return ue(()=>{let r=Kf(e,t.filters,n,"same");return r=qf(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,oEt),Fs(r,0,6)})}function uEt(e){return[2,4,6,12].some(t=>t===e)?[2,2]:[1,1]}function cEt(e,t){return ue(()=>{let n,r=sl(e,t.conv_0,[2,2]);if([t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13].forEach((s,a)=>{let i=a+1,o=uEt(i);r=lEt(r,s.depthwise_conv,o),r=sl(r,s.pointwise_conv,[1,1]),i===11&&(n=r)}),n===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:n}})}function dEt(e,t,n){let r=e.arraySync(),s=Math.min(r[t][0],r[t][2]),a=Math.min(r[t][1],r[t][3]),i=Math.max(r[t][0],r[t][2]),o=Math.max(r[t][1],r[t][3]),l=Math.min(r[n][0],r[n][2]),u=Math.min(r[n][1],r[n][3]),c=Math.max(r[n][0],r[n][2]),d=Math.max(r[n][1],r[n][3]),h=(i-s)*(o-a),p=(c-l)*(d-u);if(h<=0||p<=0)return 0;let f=Math.max(s,l),m=Math.max(a,u),g=Math.min(i,c),y=Math.min(o,d),b=Math.max(g-f,0)*Math.max(y-m,0);return b/(h+p-b)}function hEt(e,t,n,r,s){let a=e.shape[0],i=Math.min(n,a),o=t.map((c,d)=>({score:c,boxIndex:d})).filter(c=>c.score>s).sort((c,d)=>d.score-c.score),l=c=>c<=r?1:0,u=[];return o.forEach(c=>{if(u.length>=i)return;let d=c.score;for(let h=u.length-1;h>=0;--h){let p=dEt(e,c.boxIndex,u[h]);if(p!==0&&(c.score*=l(p),c.score<=s))break}d===c.score&&u.push(c.boxIndex)}),u}function pEt(e){let t=hr(Lt(e,[1,0])),n=[nt(t[2],t[0]),nt(t[3],t[1])],r=[De(t[0],ot(n[0],2)),De(t[1],ot(n[1],2))];return{sizes:n,centers:r}}function fEt(e,t){let{sizes:n,centers:r}=pEt(e),s=hr(Lt(t,[1,0])),a=ot(oe(Ms(ot(s[2],5)),n[0]),2),i=De(oe(ot(s[0],10),n[0]),r[0]),o=ot(oe(Ms(ot(s[3],5)),n[1]),2),l=De(oe(ot(s[1],10),n[1]),r[1]);return Lt(_r([nt(i,a),nt(l,o),De(i,a),De(l,o)]),[1,0])}function mEt(e,t,n){return ue(()=>{let r=e.shape[0],s=fEt(le(ja(n.extra_dim,[r,1,1]),[-1,4]),le(e,[-1,4]));s=le(s,[r,s.shape[0]/r,4]);let a=qi(Kt(t,[0,0,1],[-1,-1,-1])),i=Kt(a,[0,0,0],[-1,-1,1]);i=le(i,[r,i.shape[1]]);let o=hr(s),l=hr(i);return{boxes:o,scores:l}})}function ym(e,t){return ue(()=>{let n=e.shape[0],r=le(h1(e,t.box_encoding_predictor),[n,-1,1,4]),s=le(h1(e,t.class_predictor),[n,-1,3]);return{boxPredictionEncoding:r,classPrediction:s}})}function gEt(e,t,n){return ue(()=>{let r=sl(e,n.conv_0,[1,1]),s=sl(r,n.conv_1,[2,2]),a=sl(s,n.conv_2,[1,1]),i=sl(a,n.conv_3,[2,2]),o=sl(i,n.conv_4,[1,1]),l=sl(o,n.conv_5,[2,2]),u=sl(l,n.conv_6,[1,1]),c=sl(u,n.conv_7,[2,2]),d=ym(t,n.box_predictor_0),h=ym(e,n.box_predictor_1),p=ym(s,n.box_predictor_2),f=ym(i,n.box_predictor_3),m=ym(l,n.box_predictor_4),g=ym(c,n.box_predictor_5),y=In([d.boxPredictionEncoding,h.boxPredictionEncoding,p.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,g.boxPredictionEncoding],1),b=In([d.classPrediction,h.classPrediction,p.classPrediction,f.classPrediction,m.classPrediction,g.classPrediction],1);return{boxPredictions:y,classPredictions:b}})}var m$=class{constructor({minConfidence:e,maxResults:t}={}){if(this._name="SsdMobilenetv1Options",this._minConfidence=e||.5,this._maxResults=t||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(`${this._name} - expected minConfidence to be a number between 0 and 1`);if(typeof this._maxResults!="number")throw new Error(`${this._name} - expected maxResults to be a number`)}get minConfidence(){return this._minConfidence}get maxResults(){return this._maxResults}},yEt=class extends Td{constructor(){super("SsdMobilenetv1")}forwardInput(e){let{params:t}=this;if(!t)throw new Error("SsdMobilenetv1 - load model before inference");return ue(()=>{let n=je(e.toBatchTensor(512,!1),"float32"),r=nt(ot(n,127.5),1),s=cEt(r,t.mobilenetv1),{boxPredictions:a,classPredictions:i}=gEt(s.out,s.conv11,t.prediction_layer);return mEt(a,i,t.output_layer)})}async forward(e){return this.forwardInput(await ra(e))}async locateFaces(e,t={}){let{maxResults:n,minConfidence:r}=new m$(t),s=await ra(e),{boxes:a,scores:i}=this.forwardInput(s),o=a[0],l=i[0];for(let y=1;y<a.length;y++)a[y].dispose(),i[y].dispose();let u=Array.from(l.dataSync()),c=hEt(o,u,n,.5,r),d=s.getReshapedInputDimensions(0),h=s.inputSize,p=h/d.width,f=h/d.height,m=o.arraySync(),g=c.map(y=>{let[b,x]=[Math.max(0,m[y][0]),Math.min(1,m[y][2])].map(k=>k*f),[v,w]=[Math.max(0,m[y][1]),Math.min(1,m[y][3])].map(k=>k*p);return new to(u[y],new doe(v,b,w-v,x-b),{height:s.getInputHeight(0),width:s.getInputWidth(0)})});return o.dispose(),l.dispose(),g}getDefaultModelName(){return"ssd_mobilenetv1_model"}extractParamsFromWeightMap(e){return iEt(e)}extractParams(e){return sEt(e)}},bEt=.4,vEt=[new xn(.738768,.874946),new xn(2.42204,2.65704),new xn(4.30971,7.04493),new xn(10.246,4.59428),new xn(12.6868,11.8741)],xEt=[new xn(1.603231,2.094468),new xn(6.041143,7.080126),new xn(2.882459,3.518061),new xn(4.266906,5.178857),new xn(9.041765,10.66308)],wEt=[117.001,114.697,97.404],kEt="tiny_yolov2_model",SEt="tiny_yolov2_separable_conv_model",e2=e=>typeof e=="number";function IEt(e){if(!e)throw new Error(`invalid config: ${e}`);if(typeof e.withSeparableConvs!="boolean")throw new Error(`config.withSeparableConvs has to be a boolean, have: ${e.withSeparableConvs}`);if(!e2(e.iouThreshold)||e.iouThreshold<0||e.iouThreshold>1)throw new Error(`config.iouThreshold has to be a number between [0, 1], have: ${e.iouThreshold}`);if(!Array.isArray(e.classes)||!e.classes.length||!e.classes.every(t=>typeof t=="string"))throw new Error(`config.classes has to be an array class names: string[], have: ${JSON.stringify(e.classes)}`);if(!Array.isArray(e.anchors)||!e.anchors.length||!e.anchors.map(t=>t||{}).every(t=>e2(t.x)&&e2(t.y)))throw new Error(`config.anchors has to be an array of { x: number, y: number }, have: ${JSON.stringify(e.anchors)}`);if(e.meanRgb&&(!Array.isArray(e.meanRgb)||e.meanRgb.length!==3||!e.meanRgb.every(e2)))throw new Error(`config.meanRgb has to be an array of shape [number, number, number], have: ${JSON.stringify(e.meanRgb)}`)}function Rz(e){return ue(()=>{let t=oe(e,bt(.10000000149011612));return De(gn(nt(e,t)),t)})}function zu(e,t){return ue(()=>{let n=Ho(e,[[0,0],[1,1],[1,1],[0,0]]);return n=ta(n,t.conv.filters,[1,1],"valid"),n=nt(n,t.bn.sub),n=oe(n,t.bn.truediv),n=De(n,t.conv.bias),Rz(n)})}function Bu(e,t){return ue(()=>{let n=Ho(e,[[0,0],[1,1],[1,1],[0,0]]);return n=Vb(n,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),n=De(n,t.bias),Rz(n)})}function CEt(e,t){let n=Nz(e,t);function r(i,o){let l=dn(e(i)),u=dn(e(i));return t.push({paramPath:`${o}/sub`},{paramPath:`${o}/truediv`}),{sub:l,truediv:u}}function s(i,o,l){let u=n(i,o,3,`${l}/conv`),c=r(o,`${l}/bn`);return{conv:u,bn:c}}let a=Tz(e,t);return{extractConvParams:n,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}}function NEt(e,t,n,r){let{extractWeights:s,getRemainingWeights:a}=Ed(e),i=[],{extractConvParams:o,extractConvWithBatchNormParams:l,extractSeparableConvParams:u}=CEt(s,i),c;if(t.withSeparableConvs){let[d,h,p,f,m,g,y,b,x]=r,v=t.isFirstLayerConv2d?o(d,h,3,"conv0"):u(d,h,"conv0"),w=u(h,p,"conv1"),k=u(p,f,"conv2"),S=u(f,m,"conv3"),I=u(m,g,"conv4"),$=u(g,y,"conv5"),C=b?u(y,b,"conv6"):void 0,T=x?u(b,x,"conv7"):void 0,N=o(x||b||y,5*n,1,"conv8");c={conv0:v,conv1:w,conv2:k,conv3:S,conv4:I,conv5:$,conv6:C,conv7:T,conv8:N}}else{let[d,h,p,f,m,g,y,b,x]=r,v=l(d,h,"conv0"),w=l(h,p,"conv1"),k=l(p,f,"conv2"),S=l(f,m,"conv3"),I=l(m,g,"conv4"),$=l(g,y,"conv5"),C=l(y,b,"conv6"),T=l(b,x,"conv7"),N=o(x,5*n,1,"conv8");c={conv0:v,conv1:w,conv2:k,conv3:S,conv4:I,conv5:$,conv6:C,conv7:T,conv8:N}}if(a().length!==0)throw new Error(`weights remaing after extract: ${a().length}`);return{params:c,paramMappings:i}}function TEt(e,t){let n=sm(e,t);function r(o){let l=n(`${o}/sub`,1),u=n(`${o}/truediv`,1);return{sub:l,truediv:u}}function s(o){let l=n(`${o}/filters`,4),u=n(`${o}/bias`,1);return{filters:l,bias:u}}function a(o){let l=s(`${o}/conv`),u=r(`${o}/bn`);return{conv:l,bn:u}}let i=$z(n);return{extractConvParams:s,extractConvWithBatchNormParams:a,extractSeparableConvParams:i}}function $Et(e,t){let n=[],{extractConvParams:r,extractConvWithBatchNormParams:s,extractSeparableConvParams:a}=TEt(e,n),i;if(t.withSeparableConvs){let o=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?r("conv0"):a("conv0"),conv1:a("conv1"),conv2:a("conv2"),conv3:a("conv3"),conv4:a("conv4"),conv5:a("conv5"),conv6:o>7?a("conv6"):void 0,conv7:o>8?a("conv7"):void 0,conv8:r("conv8")}}else i={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:r("conv8")};return $d(e,n),{params:i,paramMappings:n}}var Dz=class{constructor({inputSize:e,scoreThreshold:t}={}){if(this._name="TinyYolov2Options",this._inputSize=e||416,this._scoreThreshold=t||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(`${this._name} - expected inputSize to be a number divisible by 32`);if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(`${this._name} - expected scoreThreshold to be a number between 0 and 1`)}get inputSize(){return this._inputSize}get scoreThreshold(){return this._scoreThreshold}},Woe=class Voe extends Td{constructor(t){super("TinyYolov2"),IEt(t),this._config=t}get config(){return this._config}get withClassScores(){return this.config.withClassScores||this.config.classes.length>1}get boxEncodingSize(){return 5+(this.withClassScores?this.config.classes.length:0)}runTinyYolov2(t,n){let r=zu(t,n.conv0);return r=Qr(r,[2,2],[2,2],"same"),r=zu(r,n.conv1),r=Qr(r,[2,2],[2,2],"same"),r=zu(r,n.conv2),r=Qr(r,[2,2],[2,2],"same"),r=zu(r,n.conv3),r=Qr(r,[2,2],[2,2],"same"),r=zu(r,n.conv4),r=Qr(r,[2,2],[2,2],"same"),r=zu(r,n.conv5),r=Qr(r,[2,2],[1,1],"same"),r=zu(r,n.conv6),r=zu(r,n.conv7),h1(r,n.conv8,"valid",!1)}runMobilenet(t,n){let r=this.config.isFirstLayerConv2d?Rz(h1(t,n.conv0,"valid",!1)):Bu(t,n.conv0);return r=Qr(r,[2,2],[2,2],"same"),r=Bu(r,n.conv1),r=Qr(r,[2,2],[2,2],"same"),r=Bu(r,n.conv2),r=Qr(r,[2,2],[2,2],"same"),r=Bu(r,n.conv3),r=Qr(r,[2,2],[2,2],"same"),r=Bu(r,n.conv4),r=Qr(r,[2,2],[2,2],"same"),r=Bu(r,n.conv5),r=Qr(r,[2,2],[1,1],"same"),r=n.conv6?Bu(r,n.conv6):r,r=n.conv7?Bu(r,n.conv7):r,h1(r,n.conv8,"valid",!1)}forwardInput(t,n){let{params:r}=this;if(!r)throw new Error("TinyYolov2 - load model before inference");return ue(()=>{let s=je(t.toBatchTensor(n,!1),"float32");return s=this.config.meanRgb?qw(s,this.config.meanRgb):s,s=s.div(255),this.config.withSeparableConvs?this.runMobilenet(s,r):this.runTinyYolov2(s,r)})}async forward(t,n){return this.forwardInput(await ra(t),n)}async detect(t,n={}){let{inputSize:r,scoreThreshold:s}=new Dz(n),a=await ra(t),i=await this.forwardInput(a,r),o=ue(()=>hr(i)[0].expandDims()),l={width:a.getInputWidth(0),height:a.getInputHeight(0)},u=await this.extractBoxes(o,a.getReshapedInputDimensions(0),s);i.dispose(),o.dispose();let c=u.map(f=>f.box),d=u.map(f=>f.score),h=u.map(f=>f.classScore),p=u.map(f=>this.config.classes[f.label]);return l$t(c.map(f=>f.rescale(r)),d,this.config.iouThreshold,!0).map(f=>new loe(d[f],h[f],p[f],c[f],l))}getDefaultModelName(){return""}extractParamsFromWeightMap(t){return $Et(t,this.config)}extractParams(t){let n=this.config.filterSizes||Voe.DEFAULT_FILTER_SIZES,r=n?n.length:void 0;if(r!==7&&r!==8&&r!==9)throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${r} filterSizes in config`);return NEt(t,this.config,this.boxEncodingSize,n)}async extractBoxes(t,n,r){let{width:s,height:a}=n,i=Math.max(s,a),o=i/s,l=i/a,u=t.shape[1],c=this.config.anchors.length,[d,h,p]=ue(()=>{let y=t.reshape([u,u,c,this.boxEncodingSize]),b=y.slice([0,0,0,0],[u,u,c,4]),x=y.slice([0,0,0,4],[u,u,c,1]),v=this.withClassScores?wd(y.slice([0,0,0,5],[u,u,c,this.config.classes.length]),3):bt(0);return[b,x,v]}),f=[],m=await h.array(),g=await d.array();for(let y=0;y<u;y++)for(let b=0;b<u;b++)for(let x=0;x<c;x++){let v=qE(m[y][b][x][0]);if(!r||v>r){let w=(b+qE(g[y][b][x][0]))/u*o,k=(y+qE(g[y][b][x][1]))/u*l,S=Math.exp(g[y][b][x][2])*this.config.anchors[x].x/u*o,I=Math.exp(g[y][b][x][3])*this.config.anchors[x].y/u*l,$=w-S/2,C=k-I/2,T={row:y,col:b,anchor:x},{classScore:N,label:E}=this.withClassScores?await this.extractPredictedClass(p,T):{classScore:1,label:0};f.push({box:new ooe($,C,$+S,C+I),score:v,classScore:v*N,label:E,...T})}}return d.dispose(),h.dispose(),p.dispose(),f}async extractPredictedClass(t,n){let{row:r,col:s,anchor:a}=n,i=await t.array();return Array(this.config.classes.length).fill(0).map((o,l)=>i[r][s][a][l]).map((o,l)=>({classScore:o,label:l})).reduce((o,l)=>o.classScore>l.classScore?o:l)}};Woe.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024];var Uoe=Woe,EEt=class extends Uoe{constructor(e=!0){let t={withSeparableConvs:e,iouThreshold:bEt,classes:["face"],...e?{anchors:xEt,meanRgb:wEt}:{anchors:vEt,withClassScores:!0}};super(t)}get withSeparableConvs(){return this.config.withSeparableConvs}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new to(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return this.withSeparableConvs?SEt:kEt}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},Oz=class extends Dz{constructor(){super(...arguments),this._name="TinyFaceDetectorOptions"}},Kw=class{async then(e){return e(await this.run())}async run(){throw new Error("ComposableTask - run is not implemented")}};async function Fz(e,t,n,r,s=({alignedRect:a})=>a){let a=e.map(l=>_z(l)?s(l):l.detection),i=r||(t instanceof Bt?await Soe(t,a):await koe(t,a)),o=await n(i);return i.forEach(l=>l instanceof Bt&&l.dispose()),o}var _Et=.4,AEt=[new xn(1.603231,2.094468),new xn(6.041143,7.080126),new xn(2.882459,3.518061),new xn(4.266906,5.178857),new xn(9.041765,10.66308)],REt=[117.001,114.697,97.404],DEt=class extends Uoe{constructor(){let e={withSeparableConvs:!0,iouThreshold:_Et,classes:["face"],anchors:AEt,meanRgb:REt,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};super(e)}get anchors(){return this.config.anchors}async locateFaces(e,t){return(await this.detect(e,t)).map(n=>new to(n.score,n.relativeBox,{width:n.imageWidth,height:n.imageHeight}))}getDefaultModelName(){return"tiny_face_detector_model"}extractParamsFromWeightMap(e){return super.extractParamsFromWeightMap(e)}},El={ssdMobilenetv1:new yEt,tinyFaceDetector:new DEt,tinyYolov2:new EEt,faceLandmark68Net:new V$t,faceLandmark68TinyNet:new H$t,faceRecognitionNet:new Q$t,faceExpressionNet:new N$t,ageGenderNet:new W$t},OEt=class extends Kw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Mz=class extends OEt{async run(){let e=await this.parentTask,t=await Fz(e,this.input,async n=>Promise.all(n.map(r=>El.faceExpressionNet.predictExpressions(r))),this.extractedFaces);return e.map((n,r)=>$$t(n,t[r]))}withAgeAndGender(){return new Lz(this,this.input)}},Pz=class extends Mz{withAgeAndGender(){return new zz(this,this.input)}withFaceDescriptors(){return new Bz(this,this.input)}},FEt=class extends Kw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.extractedFaces=n}},Lz=class extends FEt{async run(){let e=await this.parentTask,t=await Fz(e,this.input,async n=>Promise.all(n.map(r=>El.ageGenderNet.predictAgeAndGender(r))),this.extractedFaces);return e.map((n,r)=>{let{age:s,gender:a,genderProbability:i}=t[r];return tEt(nEt(n,a,i),s)})}withFaceExpressions(){return new Mz(this,this.input)}},zz=class extends Lz{withFaceExpressions(){return new Pz(this,this.input)}withFaceDescriptors(){return new Bz(this,this.input)}},MEt=class extends Kw{constructor(e,t){super(),this.parentTask=e,this.input=t}},Bz=class extends MEt{async run(){let e=await this.parentTask;return(await Fz(e,this.input,t=>Promise.all(t.map(n=>El.faceRecognitionNet.computeFaceDescriptor(n))),null,t=>t.landmarks.align(null,{useDlibAlignment:!0}))).map((t,n)=>eEt(e[n],t))}withFaceExpressions(){return new Pz(this,this.input)}withAgeAndGender(){return new zz(this,this.input)}},PEt=class extends Kw{constructor(e,t,n){super(),this.parentTask=e,this.input=t,this.useTinyLandmarkNet=n}get landmarkNet(){return this.useTinyLandmarkNet?El.faceLandmark68TinyNet:El.faceLandmark68Net}},LEt=class extends PEt{async run(){let e=await this.parentTask,t=e.map(s=>s.detection),n=this.input instanceof Bt?await Soe(this.input,t):await koe(this.input,t),r=await Promise.all(n.map(s=>this.landmarkNet.detectLandmarks(s)));return n.forEach(s=>s instanceof Bt&&s.dispose()),e.filter((s,a)=>r[a]).map((s,a)=>Ooe(s,r[a]))}withFaceExpressions(){return new Pz(this,this.input)}withAgeAndGender(){return new zz(this,this.input)}withFaceDescriptors(){return new Bz(this,this.input)}},zEt=class extends Kw{constructor(e,t=new m$){super(),this.input=e,this.options=t}},BEt=class extends zEt{async run(){let{input:e,options:t}=this,n;if(t instanceof Oz)n=El.tinyFaceDetector.locateFaces(e,t);else if(t instanceof m$)n=El.ssdMobilenetv1.locateFaces(e,t);else if(t instanceof Dz)n=El.tinyYolov2.locateFaces(e,t);else throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | TinyYolov2Options");return n}runAndExtendWithFaceDetections(){return new Promise((e,t)=>{this.run().then(n=>e(n.map(r=>rD({},r)))).catch(n=>t(n))})}withFaceLandmarks(e=!1){return new LEt(this.runAndExtendWithFaceDetections(),this.input,e)}withFaceExpressions(){return new Mz(this.runAndExtendWithFaceDetections(),this.input)}withAgeAndGender(){return new Lz(this.runAndExtendWithFaceDetections(),this.input)}};function joe(e,t=new m$){return new BEt(e,t)}function Wz(e,t){let{width:n,height:r}=new vh(t.width,t.height);if(n<=0||r<=0)throw new Error(`resizeResults - invalid dimensions: ${JSON.stringify({width:n,height:r})}`);if(Array.isArray(e))return e.map(s=>Wz(s,{width:n,height:r}));if(_z(e)){let s=e.detection.forSize(n,r),a=e.unshiftedLandmarks.forSize(s.box.width,s.box.height);return Ooe(rD(e,s),a)}return f0(e)?rD(e,e.detection.forSize(n,r)):e instanceof p0||e instanceof to?e.forSize(n,r):e}function h6(e){console.log("imageProcessing called");const t=tf.browser.fromPixels(e),n=tf.image.resizeBilinear(t,[48,48]),r=tf.image.rgbToGrayscale(n),a=r.toFloat().div(tf.scalar(255)).expandDims(0);return t.dispose(),n.dispose(),r.dispose(),a}const WEt=()=>{const[e,t]=Z.useState(""),[n,r]=Z.useState([]),[s,a]=Z.useState([]),[i,o]=Z.useState([]),[l,u]=Z.useState(""),[c,d]=Z.useState(0),[h,p]=Z.useState(!1),[f,m]=Z.useState(!1),[g,y]=Z.useState(!1),[b,x]=Z.useState(!1),[v,w]=Z.useState(!1),[k,S]=Z.useState(),[I,$]=Z.useState(),[C,T]=Z.useState(""),[N,E]=Z.useState(""),[_,R]=Z.useState(bi().toISOString().slice(0,19)),[z,W]=Z.useState(!0),[F,L]=Z.useState(!1),[O,D]=Z.useState(!1),[B,V]=Z.useState(!1),[K,G]=Z.useState(""),[U,q]=Z.useState(!1),[Q,ee]=Z.useState(""),[ae,ye]=Z.useState("confirmation"),j=Z.useRef(null),ce=Z.useRef(null),be=Z.useRef(null),ke=Z.useRef(null),Ae=Z.useRef(null);Z.useEffect(()=>{Pe()},[]),Z.useEffect(()=>{d(n.length+1)},[n]),Z.useEffect(()=>{let Ke=0;return z==!0?Ke=setInterval(()=>{R(bi().toISOString().slice(0,19))},1e3):clearInterval(Ke),()=>clearInterval(Ke)},[z]),Z.useEffect(()=>{(async()=>{await RJ,console.log(fF());const Ue=await _S("https://tpd20seu.projects.cmp.uea.ac.uk/selfie/models/tfjsCNNV3-OS-Epoch-100/model.json");$(Ue),console.log("Fetch CNN Selfie Model completed :)")})()},[]),Z.useEffect(()=>{b==!0?(async()=>{try{await Promise.all([El.tinyFaceDetector.loadFromUri("./face-api-models")]),console.log("Face-Api.js models loaded successfully from ./face-api-models"),w(!0)}catch(Ue){console.error(Ue)}})():w(!1)},[b]),Z.useEffect(()=>{(e!=""||F===!0)&&w(!1)},[e]),Z.useEffect(()=>{if(O){let Ke=[];for(const Ue of n)Ue.createdAt!=null&&_.slice(0,10)===Ue.createdAt.toString().slice(0,10)&&Ke.push(Ue.createdAt.toString().slice(0,19));o(Ke)}},[_]),Z.useEffect(()=>{let Ke=0;return v&&(Ke=setInterval(async()=>{if(ce.current&&j.current){const Ue=await joe(j.current,new Oz);Ue!=null&&S(Ue[0]._box);const Xe=f$(j.current);ce.current.innerHTML="",ce.current.appendChild(Xe),Coe(ce.current,{width:1280,height:720});const ut=Wz(Ue,{width:1280,height:720});yz.drawDetections(ce.current,ut)}},100)),()=>clearInterval(Ke)},[v]),Z.useEffect(()=>{if(!O){const Ke=setTimeout(()=>{e!==""&&pe()},100);return()=>clearTimeout(Ke)}},[e]);async function Pe(){V(!0);const Ue=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/selfie",{method:"Get",credentials:"include"})).json();if(Array.isArray(Ue)&&Ue.length!=0){let Xe=1;for(let ut of Ue){ut.selfieNumber=Xe;const vt=ut.selfieImagePath.split("/")[2];ut.selfieImagePath=encodeURIComponent(vt),Xe+=1}Array.isArray(Ue)&&Ue[0].hasOwnProperty("selfieNumber")&&(r(Ue),a(Ue))}else r([]),a([]);V(!1)}async function ie(){await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/${l}`,{method:"DELETE",headers:{"Content-Type":"application/json"},credentials:"include"}),console.log(`DELETE request with selfie #'${c}' was sent successfully to the server!`),ee(`Selfie #${c} has been deleted!`),ye("understand"),q(!0)}async function Te(Ke){if(Ke.preventDefault(),f&&O){await ie();return}const Ue=new FormData;let Xe=C,ut=N,vt="false";if(g){let Un=await pe();Un!=null&&(Xe=Un[0],ut=Un[1])}ae==="manualPrediction"&&(C==="Stressed"?Xe="Not Stressed":Xe="Stressed",ut="100%",vt="true");const Rt=await(await fetch(e,{credentials:"include"})).blob(),Bs=bi().toISOString();if(Ue.append("stressStatus",Xe),Ue.append("stressProb",ut),Ue.append("manualPrediction",vt),!f&&!O){const Un=`${Bs} ${Xe}.jpg`;Ue.append("selfieImageName",Un),Ue.append("selfieImage",Rt,Un),Ue.append("createdAt",Bs),await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/selfie",{method:"POST",body:Ue,credentials:"include"}),vt==="true"&&await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/selfie/retraining",{method:"POST",body:Ue,credentials:"include"}),console.log(`POST request with selfie '${c}' was sent successfully to the server!`),ee(`Selfie #${c} was successfully submitted!

Our model has marked the selfie as ${Xe} with a probability of ${ut}`)}else if(!f&&O){let Un;for(const pr of n)if(pr._id===l){Un=pr;break}const si=`${Un==null?void 0:Un.createdAt} ${Xe}.jpg`;Ue.append("selfieImageName",si),Ue.append("selfieImage",Rt,`${Un==null?void 0:Un.createdAt} ${Xe}.jpg`);const _a={};Ue.forEach((pr,Aa)=>{typeof pr=="string"&&(_a[Aa]=pr)}),vt==="true"&&await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/retraining/${l}`,{method:"PATCH",body:Ue,credentials:"include"}),await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/${l}`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify(_a),credentials:"include"}),console.log(`PATCH request with selfie #${c} was sent successfully to the server!`),ee(`Selfie #${c}' has been edited successfully!

Our model has marked the entry as ${Xe} with a probability of ${ut}`)}ye("understand"),q(!0)}function Le(){if(ce.current){const Ke=ce.current.children[0];if(Ke instanceof HTMLCanvasElement){const Ue=Ke.getContext("2d"),Xe=k;if(Ue&&Xe!=null){const ut=document.createElement("canvas");ut.width=Xe._width,ut.height=Xe._height;const vt=ut.getContext("2d");if(vt){vt.drawImage(Ke,Xe._x+30,Xe._y+30,Xe._width-50,Xe._height-50,0,0,Xe._width,Xe._height);const An=ut.toDataURL("image/png");t(An)}}}}}async function $e(){const Ue=await(await fetch(e,{credentials:"include"})).blob(),Xe=URL.createObjectURL(Ue),ut=new Image;return ut.src=Xe,new Promise((vt,An)=>{ut.onload=()=>{vt(ut)},ut.onerror=Rt=>{An(Rt)}})}function ge(){const Ke=new Image;return Ke.src=e,Ke}function ve(Ke){return Ke[0]>Ke[1]?0:1}async function pe(){try{let Ke;if(!O)Ke=h6(ge());else{const Rt=await $e();Ke=h6(Rt)}const Ue=I.predict(Ke);console.log("prediction = "),console.log(Ue);const Xe=Ue.arraySync()[0];console.log("scores ="),console.log(Xe);const ut=ve(Xe);let vt="",An="";if(ut===1){console.log(`Stressed: ${Xe[1]}`),T("Stressed");const Rt=Xe[1].toString();E(`${(Rt*100).toFixed(2)}%`),vt="Stressed",An=`${(Rt*100).toFixed(2)}%`}else{console.log(`Not Stressed: ${Xe[0]}`),T("Not Stressed");const Rt=Xe[0].toString();E(`${(Rt*100).toFixed(2)}%`),vt="Not Stressed",An=`${(Rt*100).toFixed(2)}%`}if(g)return[vt,An];console.log("Predicted Class:",ut)}catch(Ke){console.log("error occurred"),console.error("Error:",Ke)}}function Ie(Ke){const Ue=Ke.target.value.trim();if(Ue==="")a([]),a(n);else{a([]);const Xe=n.filter(ut=>{var vt;return(vt=ut.selfieNumber)==null?void 0:vt.toString().includes(Ue.toLowerCase())});a(Xe)}}function ze(Ke){for(const Ue of n)if(Ue._id===Ke.currentTarget.id&&Ue.selfieNumber){u(Ke.currentTarget.id),d(Ue.selfieNumber),T(Ue.stressStatus),E(Ue.stressProb),t(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/selfieImages/${Ue.selfieImagePath}`),W(!1),Ue.createdAt!=null&&R(Ue.createdAt.toString().slice(0,19)),D(!0),G(""),p(!0),L(!1);break}}function Ye(Ke){if(!ke.current||!Ae.current)return;let Ue=0;for(const ut of n)if(ut._id===l){Ue=n.indexOf(ut);break}let Xe;Ke==="prev"?n[Ue-1]===void 0?(G("No more previous selfies exist!"),ke.current.disabled=!0):(Xe=n[Ue-1],ke.current.disabled=!1,Ae.current.disabled=!1):Ke==="next"&&(n[Ue+1]===void 0?(G("No more following selfies exist!"),Ae.current.disabled=!0):(Xe=n[Ue+1],Ae.current.disabled=!1,ke.current.disabled=!1)),Xe&&Xe.selfieNumber&&Xe._id&&(G(""),d(Xe.selfieNumber),u(Xe._id),t(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/selfieImages/${Xe.selfieImagePath}`),T(Xe.stressStatus),E(Xe.stressProb),Xe.createdAt!=null&&R(Xe.createdAt.toString().slice(0,19)))}function Je(){d(n.length+1),T(""),E(""),t(""),m(!1),y(!1),ye("confirmation"),W(!0),D(!1),p(!1),L(!1)}return A.jsxs(A.Fragment,{children:[B&&A.jsxs("div",{id:"loadingSpinnerContainer",children:[A.jsx(ly,{visible:!0,height:"80",width:"80",color:"#FED362",ariaLabel:"tail-spin-loading",radius:"1",wrapperStyle:{},wrapperClass:""}),A.jsx("h2",{children:"Processing Request...."})]}),!B&&A.jsxs(A.Fragment,{children:[A.jsx("h1",{children:"Mood Selfie"}),A.jsx("p",{className:"infoP",children:"Snap a selfie of your face to determine your current mood!"}),A.jsx("p",{className:"infoP",children:"The selfie model will make stress predictions in the browser on your device."}),A.jsx("p",{className:"infoP",id:"lookIntoCameraP",children:A.jsx("b",{children:"*Please look into the camera and make try to use good lighting when taking a selfie for best results :)"})}),A.jsx("hr",{}),!F&&A.jsxs("form",{id:"selfieForm",onSubmit:Te,children:[A.jsx(nr,{id:"connectCameraTooltip",place:"top",content:"Please connect your device's camera"}),A.jsx(nr,{id:"takeSelfieTooltip",place:"top",content:"You must take a selfie first"}),A.jsx(nr,{id:"resetSelfieTooltip",place:"top",content:"Please click 'Reset' to take another selfie"}),A.jsx(nr,{id:"selfieNotSubmitted",place:"top",content:"This selfie has not been submitted yet"}),A.jsx(nr,{id:"manualPredictionTooltip",place:"top",content:"Click here if the stress prediction of this selfie is incorrect"}),A.jsx(x0,{header:Q,dialogShow:U,dialogConfirmation:ae,onConfirm:()=>{q(!1)},onCancel:()=>{q(!1)},onUnderstand:()=>{Je(),Pe(),q(!1)},onManualPrediction:()=>{q(!1)}}),A.jsxs("div",{id:"selfieModeContainer",children:[O?A.jsx("h2",{children:"View, Edit, or Delete Old Selfie"}):A.jsx("h2",{children:"Take New Selfie"}),C!==""&&N!==""&&A.jsxs("div",{id:"manualPredictionContainer","data-tooltip-id":"manualPredictionTooltip",onClick:()=>{ee(`If you believe that our model has made an incorrect prediction on your selfie, please click the confirm button.

Your selfie will be marked with the correct stress status and this selfie will be used to help train our model in the future.`),ye("manualPrediction"),q(!0)},children:[A.jsx("p",{id:"manualPredictionP",children:"Wrong?"}),A.jsx(PN,{})]})]}),A.jsxs("div",{id:"selfieTopTitleContainer",children:[A.jsxs("label",{id:"selfieNumberLbl",htmlFor:"Title",children:[h&&A.jsxs("h3",{id:"selfieSubmittedH3",children:["Selfie Number: ",c]}),!h&&A.jsxs("h3",{id:"selfieNotSubmittedH3","data-tooltip-id":"selfieNotSubmitted",children:["Selfie Number: ",c,"*"]})]}),A.jsx("div",{id:"dateLbl",children:_.replace("T",`
`)}),A.jsx("label",{id:"stressLbl",children:C===""||N===""?A.jsx("h3",{children:"Stress Status Unknown"}):A.jsx("h3",{id:C==="Stressed"?"stressed":"notStressed",children:`${C} - ${N}`})})]}),A.jsxs("div",{id:"selfieTopControlsContainer",children:[!O&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"resetSelfieBtn",className:"selfieTopControlBtn",onClick:()=>{t(""),T(""),E("")},disabled:e==="","data-tooltip-id":b===!1?"connectCameraTooltip":e===""?"takeSelfieTooltip":"",children:["Reset",A.jsx(Ux,{id:"selfieResetBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"takeSelfieBtn",className:"selfieTopControlBtn",onClick:()=>{Le()},disabled:b===!1||e!="","data-tooltip-id":b===!1?"connectCameraTooltip":e!=""?"resetSelfieTooltip":"",children:["Take Selfie",A.jsx(ac,{id:"takeSelfieBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"submitSelfieBtn",className:"selfieTopControlBtn",onClick:Ke=>{Ke.preventDefault(),ee("Are you sure you want to submit this selfie?"),m(!1),q(!0)},disabled:e==="","data-tooltip-id":b===!1?"connectCameraTooltip":e===""?"takeSelfieTooltip":"",children:["Submit Selfie",A.jsx(ml,{id:"selfieSubmitBtnIcon",className:"selfieControlBtnIcon"})]})]}),O&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"predictSelfieStressBtn",className:"selfieTopControlBtn",onClick:Ke=>{Ke.preventDefault(),ee("Are you sure you want to re-predict and submit this selfie?"),m(!1),y(!0),q(!0)},children:["Re-Predict Stress",A.jsx(ac,{id:"takeSelfieBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"deleteSelfieBtn",className:"selfieTopControlBtn",onClick:Ke=>{Ke.preventDefault(),ee("Are you sure you want to delete this selfie?"),m(!0),q(!0)},children:["Delete Selfie ",A.jsx(BN,{id:"deleteSelfieBtnIcon",className:"selfieControlBtnIcon"})]})]})]}),A.jsx("div",{id:"videoCanvasContainer",children:e===""?A.jsxs("div",{id:"videoContainer",children:[A.jsx(r8,{id:"video",videoRef:j,videoHeight:720,videoWidth:1280,videoConnected:b,videoChange:()=>{x(Ke=>!Ke)}}),b&&A.jsx(s8,{id:"canvas",canvasRef:ce,canvasHeight:720,canvasWidth:1280})]}):A.jsx("img",{id:"selfie",src:e,alt:"Take Selfie"})}),A.jsxs("div",{id:"selfieBottomContainer",children:[O&&A.jsxs("h3",{id:"selfieNumberLbl",children:["Selfies taken this day: ",i.indexOf(_)+1,"/",i.length]}),A.jsxs("div",{id:"selfieBottomControlsContainer",children:[O&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"takeNewSelfieBtn",className:"selfieBottomControlBtn",onClick:()=>{Je()},children:["Take New Selfie",A.jsx(ac,{id:"takeNewSelfieBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"selfiePrevEntryBtn",ref:ke,className:"selfieBottomControlBtn",onClick:()=>{Ye("prev")},children:[A.jsx(zN,{id:"selfiePrevBtnIcon",className:"selfieControlBtnIcon"}),"Prev Selfie"]}),A.jsxs("button",{type:"button",id:"selfieNextEntryBtn",ref:Ae,className:"selfieBottomControlBtn",onClick:()=>{Ye("next")},children:["Next Selfie",A.jsx(LN,{id:"selfieNextBtnIcon",className:"selfieControlBtnIcon"})]})]}),A.jsxs("button",{type:"button",id:"showOldSelfiesBtn",className:"selfieBottomControlBtn",onClick:()=>{D(!1),W(!1),L(!0)},children:["View Old Selfies",A.jsx(nS,{id:"showOldSelfiesIcon",className:"selfieControlBtnIcon"})]})]}),O&&A.jsx("p",{id:"prevNextErrorMessageP",children:K})]})]}),F&&A.jsxs("div",{id:"showOldSelfiesContainer",children:[A.jsxs("table",{id:"showOldSelfiesTable",ref:be,children:[A.jsx("caption",{children:A.jsxs("div",{id:"showOldSelfiesTitleContainer",children:[A.jsxs("h2",{id:"showOldSelfiesTitleH2",children:["Your Old Selfies ",A.jsx(nS,{})]}),A.jsx(iy,{placeholder:"Search table by selfie number...",onChange:Ke=>{Ie(Ke)}})]})}),A.jsx("thead",{children:A.jsxs("tr",{children:[A.jsx("th",{children:"Selfie Number"}),A.jsx("th",{children:"Selfie Image"}),A.jsx("th",{children:"Date - Time"}),A.jsx("th",{children:"Stress"})]})}),A.jsx("tbody",{children:n.length!==0&&A.jsxs(A.Fragment,{children:[s.map((Ke,Ue)=>{var Xe,ut;return A.jsxs("tr",{id:`${Ke._id}`,className:"selfieTableRow",onClick:vt=>{ze(vt)},children:[A.jsx("td",{"data-cell":"Selfie Number",className:"selfieNumberCell",children:Ke.selfieNumber}),A.jsx("td",{"data-cell":"Selfie Image",children:A.jsx("img",{className:"selfieImg",loading:"lazy",src:`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/selfieImages/${Ke.selfieImagePath}`,alt:"Image"})}),A.jsx("td",{"data-cell":"Selfie Datetime",children:`${(Xe=Ke.createdAt)==null?void 0:Xe.toString().slice(0,10)} - ${(ut=Ke.createdAt)==null?void 0:ut.toString().slice(11,19)}`}),A.jsx("td",{"data-cell":"Selfie Stress",className:Ke.stressStatus==="Stressed"?"stressedCell":"notStressedCell",children:`${Ke.stressStatus} - ${Ke.stressProb}`})]},Ue)}),s.length===0&&A.jsx("tr",{children:A.jsx("td",{id:"noMatchingSearchTermTR",colSpan:4,children:"No selfie numbers matching the searched term were found :/"})})]})})]}),n.length===0&&A.jsx("h3",{id:"noExistingSelfiesH3",children:"There are no existing selfies in our database :/"}),A.jsx("div",{id:"showOldSelfiesBottomContainer",children:A.jsxs("button",{type:"button",id:"takeNewSelfieBtn",className:"selfieBottomControlBtn",onClick:()=>{Je()},children:["Take New Selfie",A.jsx(ac,{id:"takeNewSelfieBtnIcon"})]})})]})]})]})},VEt=()=>{const[e,t]=Z.useState(""),[n,r]=Z.useState([]),[s,a]=Z.useState([]),[i,o]=Z.useState([]),[l,u]=Z.useState(""),[c,d]=Z.useState(0),[h,p]=Z.useState(!1),[f,m]=Z.useState(!1),[g,y]=Z.useState(!1),[b,x]=Z.useState(!1),[v,w]=Z.useState(!1),[k,S]=Z.useState(),[I,$]=Z.useState(""),[C,T]=Z.useState(""),[N,E]=Z.useState(bi().toISOString().slice(0,19)),[_,R]=Z.useState(!0),[z,W]=Z.useState(!1),[F,L]=Z.useState(!1),[O,D]=Z.useState(!1),[B,V]=Z.useState(""),[K,G]=Z.useState(!1),[U,q]=Z.useState(""),[Q,ee]=Z.useState("confirmation"),ae=Z.useRef(null),ye=Z.useRef(null),j=Z.useRef(null),ce=Z.useRef(null),be=Z.useRef(null);Z.useEffect(()=>{ke()},[]),Z.useEffect(()=>{d(n.length+1)},[n]),Z.useEffect(()=>{let pe=0;return _==!0?pe=setInterval(()=>{E(bi().toISOString().slice(0,19))},1e3):clearInterval(pe),()=>clearInterval(pe)},[_]),Z.useEffect(()=>{b==!0?(async()=>{try{await Promise.all([El.tinyFaceDetector.loadFromUri("./face-api-models")]),console.log("Face-Api.js models loaded successfully from ./face-api-models"),w(!0)}catch(Ie){console.error(Ie)}})():w(!1)},[b]),Z.useEffect(()=>{(e!=""||z===!0)&&w(!1)},[e]),Z.useEffect(()=>{if(F){let pe=[];for(const Ie of n)Ie.createdAt!=null&&N.slice(0,10)===Ie.createdAt.toString().slice(0,10)&&pe.push(Ie.createdAt.toString().slice(0,19));o(pe)}},[N]),Z.useEffect(()=>{let pe=0;return v&&(pe=setInterval(async()=>{if(ye.current&&ae.current){const Ie=await joe(ae.current,new Oz);Ie!=null&&S(Ie[0]._box);const ze=f$(ae.current);ye.current.innerHTML="",ye.current.appendChild(ze),Coe(ye.current,{width:1280,height:720});const Ye=Wz(Ie,{width:1280,height:720});yz.drawDetections(ye.current,Ye)}},100)),()=>clearInterval(pe)},[v]),Z.useEffect(()=>{if(!F){const pe=setTimeout(()=>{e!==""&&Te()},100);return()=>clearTimeout(pe)}},[e]);async function ke(){D(!0);const Ie=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/selfie",{method:"Get",credentials:"include"})).json();if(Array.isArray(Ie)&&Ie.length!=0){let ze=1;for(let Ye of Ie){Ye.selfieNumber=ze;const Je=Ye.selfieImagePath.split("/")[2];Ye.selfieImagePath=encodeURIComponent(Je),ze+=1}Array.isArray(Ie)&&Ie[0].hasOwnProperty("selfieNumber")&&(r(Ie),a(Ie))}else r([]),a([]);D(!1)}async function Ae(){await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/${l}`,{method:"DELETE",headers:{"Content-Type":"application/json"},credentials:"include"}),console.log(`DELETE request with selfie #'${c}' was sent successfully to the server!`),q(`Selfie #${c} has been deleted!`),ee("understand"),G(!0)}async function Pe(pe){if(pe.preventDefault(),f&&F){await Ae();return}const Ie=new FormData;let ze=I,Ye=C,Je="false";if(g){let ut=await Te();ut!=null&&(ze=ut[0],Ye=ut[1])}Q==="manualPrediction"&&(I==="Stressed"?ze="Not Stressed":ze="Stressed",Ye="100%",Je="true");const Ue=await(await fetch(e,{credentials:"include"})).blob(),Xe=bi().toISOString();if(Ie.append("stressStatus",ze),Ie.append("stressProb",Ye),Ie.append("manualPrediction",Je),!f&&!F){const ut=`${Xe} ${ze}.jpg`;Ie.append("selfieImageName",ut),Ie.append("selfieImage",Ue,ut),Ie.append("createdAt",Xe),await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/selfie",{method:"POST",body:Ie,credentials:"include"}),Je==="true"&&await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/selfie/retraining",{method:"POST",body:Ie,credentials:"include"}),console.log(`POST request with selfie '${c}' was sent successfully to the server!`),q(`Selfie #${c} was successfully submitted!

Our model has marked the selfie as ${ze} with a probability of ${Ye}`)}else if(!f&&F){let ut;for(const Rt of n)if(Rt._id===l){ut=Rt;break}const vt=`${ut==null?void 0:ut.createdAt} ${ze}.jpg`;Ie.append("selfieImageName",vt),Ie.append("selfieImage",Ue,`${ut==null?void 0:ut.createdAt} ${ze}.jpg`);const An={};Ie.forEach((Rt,Bs)=>{typeof Rt=="string"&&(An[Bs]=Rt)}),Je==="true"&&await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/retraining/${l}`,{method:"PATCH",body:Ie,credentials:"include"}),await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/${l}`,{method:"PATCH",headers:{"Content-Type":"application/json"},body:JSON.stringify(An),credentials:"include"}),console.log(`PATCH request with selfie #${c} was sent successfully to the server!`),q(`Selfie #${c}' has been edited successfully!

Our model has marked the entry as ${ze} with a probability of ${Ye}`)}ee("understand"),G(!0)}function ie(){if(ye.current){const pe=ye.current.children[0];if(pe instanceof HTMLCanvasElement){const Ie=pe.getContext("2d"),ze=k;if(Ie&&ze!=null){const Ye=document.createElement("canvas");Ye.width=ze._width,Ye.height=ze._height;const Je=Ye.getContext("2d");if(Je){Je.drawImage(pe,ze._x+30,ze._y+30,ze._width-50,ze._height-50,0,0,ze._width,ze._height);const Ke=Ye.toDataURL("image/png");t(Ke)}}}}}async function Te(){try{D(!0);const pe=new FormData,ze=await(await fetch(e,{credentials:"include"})).blob();console.log(ze),pe.append("selfieImageName","tempSelfie.jpg"),pe.append("selfieImage",ze,"tempSelfie.jpg");const Je=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/selfie/selfiePrediction",{method:"POST",body:pe,credentials:"include"})).json();if($(Je.predictedSelfie.stressState),T(Je.predictedSelfie.stressProb),D(!1),g)return[Je.predictedSelfie.stressState,Je.predictedSelfie.stressProb]}catch(pe){console.log("error occurred"),console.error("Error:",pe)}}function Le(pe){const Ie=pe.target.value.trim();if(Ie==="")a([]),a(n);else{a([]);const ze=n.filter(Ye=>{var Je;return(Je=Ye.selfieNumber)==null?void 0:Je.toString().includes(Ie.toLowerCase())});a(ze)}}function $e(pe){for(const Ie of n)if(Ie._id===pe.currentTarget.id&&Ie.selfieNumber){u(pe.currentTarget.id),d(Ie.selfieNumber),$(Ie.stressStatus),T(Ie.stressProb),t(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/selfieImages/${Ie.selfieImagePath}`),R(!1),Ie.createdAt!=null&&E(Ie.createdAt.toString().slice(0,19)),L(!0),V(""),p(!0),W(!1);break}}function ge(pe){if(!ce.current||!be.current)return;let Ie=0;for(const Ye of n)if(Ye._id===l){Ie=n.indexOf(Ye);break}let ze;pe==="prev"?n[Ie-1]===void 0?(V("No more previous selfies exist!"),ce.current.disabled=!0):(ze=n[Ie-1],ce.current.disabled=!1,be.current.disabled=!1):pe==="next"&&(n[Ie+1]===void 0?(V("No more following selfies exist!"),be.current.disabled=!0):(ze=n[Ie+1],be.current.disabled=!1,ce.current.disabled=!1)),ze&&ze.selfieNumber&&ze._id&&(V(""),d(ze.selfieNumber),u(ze._id),t(`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/selfieImages/${ze.selfieImagePath}`),$(ze.stressStatus),T(ze.stressProb),ze.createdAt!=null&&E(ze.createdAt.toString().slice(0,19)))}function ve(){d(n.length+1),$(""),T(""),t(""),m(!1),y(!1),ee("confirmation"),R(!0),L(!1),p(!1),W(!1)}return A.jsxs(A.Fragment,{children:[O&&A.jsxs("div",{id:"loadingSpinnerContainer",children:[A.jsx(ly,{visible:!0,height:"80",width:"80",color:"#FED362",ariaLabel:"tail-spin-loading",radius:"1",wrapperStyle:{},wrapperClass:""}),A.jsx("h2",{children:"Processing Request...."})]}),!O&&A.jsxs(A.Fragment,{children:[A.jsx("h1",{children:"Mood Selfie"}),A.jsx("p",{className:"infoP",children:"Snap a selfie of your face to determine your current mood!"}),A.jsx("p",{className:"infoP",children:"The selfie model will make stress predictions in the backend on our server as your device does not support frontend predictions"}),A.jsx("p",{className:"infoP",id:"lookIntoCameraP",children:A.jsx("b",{children:"*Please look into the camera and make try to use good lighting when taking a selfie for best results :)"})}),A.jsx("hr",{}),!z&&A.jsxs("form",{id:"selfieForm",onSubmit:Pe,children:[A.jsx(nr,{id:"connectCameraTooltip",place:"top",content:"Please connect your device's camera"}),A.jsx(nr,{id:"takeSelfieTooltip",place:"top",content:"You must take a selfie first"}),A.jsx(nr,{id:"resetSelfieTooltip",place:"top",content:"Please click 'Reset' to take another selfie"}),A.jsx(nr,{id:"selfieNotSubmitted",place:"top",content:"This selfie has not been submitted yet"}),A.jsx(nr,{id:"manualPredictionTooltip",place:"top",content:"Click here if the stress prediction of this selfie is incorrect"}),A.jsx(x0,{header:U,dialogShow:K,dialogConfirmation:Q,onConfirm:()=>{G(!1)},onCancel:()=>{G(!1)},onUnderstand:()=>{ve(),ke(),G(!1)},onManualPrediction:()=>{G(!1)}}),A.jsxs("div",{id:"selfieModeContainer",children:[F?A.jsx("h2",{children:"View, Edit, or Delete Old Selfie"}):A.jsx("h2",{children:"Take New Selfie"}),I!==""&&C!==""&&A.jsxs("div",{id:"manualPredictionContainer","data-tooltip-id":"manualPredictionTooltip",onClick:()=>{q(`If you believe that our model has made an incorrect prediction on your selfie, please click the confirm button.

Your selfie will be marked with the correct stress status and this selfie will be used to help train our model in the future.`),ee("manualPrediction"),G(!0)},children:[A.jsx("p",{id:"manualPredictionP",children:"Wrong?"}),A.jsx(PN,{})]})]}),A.jsxs("div",{id:"selfieTopTitleContainer",children:[A.jsxs("label",{id:"selfieNumberLbl",htmlFor:"Title",children:[h&&A.jsxs("h3",{id:"selfieSubmittedH3",children:["Selfie Number: ",c]}),!h&&A.jsxs("h3",{id:"selfieNotSubmittedH3","data-tooltip-id":"selfieNotSubmitted",children:["Selfie Number: ",c,"*"]})]}),A.jsx("div",{id:"dateLbl",children:N.replace("T",`
`)}),A.jsx("label",{id:"stressLbl",children:I===""||C===""?A.jsx("h3",{children:"Stress Status Unknown"}):A.jsx("h3",{id:I==="Stressed"?"stressed":"notStressed",children:`${I} - ${C}`})})]}),A.jsxs("div",{id:"selfieTopControlsContainer",children:[!F&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"resetSelfieBtn",className:"selfieTopControlBtn",onClick:()=>{t(""),$(""),T("")},disabled:e==="","data-tooltip-id":b===!1?"connectCameraTooltip":e===""?"takeSelfieTooltip":"",children:["Reset",A.jsx(Ux,{id:"selfieResetBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"takeSelfieBtn",className:"selfieTopControlBtn",onClick:()=>{ie()},disabled:b===!1||e!="","data-tooltip-id":b===!1?"connectCameraTooltip":e!=""?"resetSelfieTooltip":"",children:["Take Selfie",A.jsx(ac,{id:"takeSelfieBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"submitSelfieBtn",className:"selfieTopControlBtn",onClick:pe=>{pe.preventDefault(),q("Are you sure you want to submit this selfie?"),m(!1),G(!0)},disabled:e==="","data-tooltip-id":b===!1?"connectCameraTooltip":e===""?"takeSelfieTooltip":"",children:["Submit Selfie",A.jsx(ml,{id:"selfieSubmitBtnIcon",className:"selfieControlBtnIcon"})]})]}),F&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"predictSelfieStressBtn",className:"selfieTopControlBtn",onClick:pe=>{pe.preventDefault(),q("Are you sure you want to re-predict and submit this selfie?"),m(!1),y(!0),G(!0)},children:["Re-Predict Stress",A.jsx(ac,{id:"takeSelfieBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"deleteSelfieBtn",className:"selfieTopControlBtn",onClick:pe=>{pe.preventDefault(),q("Are you sure you want to delete this selfie?"),m(!0),G(!0)},children:["Delete Selfie ",A.jsx(BN,{id:"deleteSelfieBtnIcon",className:"selfieControlBtnIcon"})]})]})]}),A.jsx("div",{id:"videoCanvasContainer",children:e===""?A.jsxs("div",{id:"videoContainer",children:[A.jsx(r8,{id:"video",videoRef:ae,videoHeight:720,videoWidth:1280,videoConnected:b,videoChange:()=>{x(pe=>!pe)}}),b&&A.jsx(s8,{id:"canvas",canvasRef:ye,canvasHeight:720,canvasWidth:1280})]}):A.jsx("img",{id:"selfie",src:e,alt:"Take Selfie"})}),A.jsxs("div",{id:"selfieBottomContainer",children:[F&&A.jsxs("h3",{id:"selfieNumberLbl",children:["Selfies taken this day: ",i.indexOf(N)+1,"/",i.length]}),A.jsxs("div",{id:"selfieBottomControlsContainer",children:[F&&A.jsxs(A.Fragment,{children:[A.jsxs("button",{type:"button",id:"takeNewSelfieBtn",className:"selfieBottomControlBtn",onClick:()=>{ve()},children:["Take New Selfie",A.jsx(ac,{id:"takeNewSelfieBtnIcon",className:"selfieControlBtnIcon"})]}),A.jsxs("button",{type:"button",id:"selfiePrevEntryBtn",ref:ce,className:"selfieBottomControlBtn",onClick:()=>{ge("prev")},children:[A.jsx(zN,{id:"selfiePrevBtnIcon",className:"selfieControlBtnIcon"}),"Prev Selfie"]}),A.jsxs("button",{type:"button",id:"selfieNextEntryBtn",ref:be,className:"selfieBottomControlBtn",onClick:()=>{ge("next")},children:["Next Selfie",A.jsx(LN,{id:"selfieNextBtnIcon",className:"selfieControlBtnIcon"})]})]}),A.jsxs("button",{type:"button",id:"showOldSelfiesBtn",className:"selfieBottomControlBtn",onClick:()=>{L(!1),R(!1),W(!0)},children:["View Old Selfies",A.jsx(nS,{id:"showOldSelfiesIcon",className:"selfieControlBtnIcon"})]})]}),F&&A.jsx("p",{id:"prevNextErrorMessageP",children:B})]})]}),z&&A.jsxs("div",{id:"showOldSelfiesContainer",children:[A.jsxs("table",{id:"showOldSelfiesTable",ref:j,children:[A.jsx("caption",{children:A.jsxs("div",{id:"showOldSelfiesTitleContainer",children:[A.jsxs("h2",{id:"showOldSelfiesTitleH2",children:["Your Old Selfies ",A.jsx(nS,{})]}),A.jsx(iy,{placeholder:"Search table by selfie number...",onChange:pe=>{Le(pe)}})]})}),A.jsx("thead",{children:A.jsxs("tr",{children:[A.jsx("th",{children:"Selfie Number"}),A.jsx("th",{children:"Selfie Image"}),A.jsx("th",{children:"Date - Time"}),A.jsx("th",{children:"Stress"})]})}),A.jsx("tbody",{children:n.length!==0&&A.jsxs(A.Fragment,{children:[s.map((pe,Ie)=>{var ze,Ye;return A.jsxs("tr",{id:`${pe._id}`,className:"selfieTableRow",onClick:Je=>{$e(Je)},children:[A.jsx("td",{"data-cell":"Selfie Number",className:"selfieNumberCell",children:pe.selfieNumber}),A.jsx("td",{"data-cell":"Selfie Image",children:A.jsx("img",{className:"selfieImg",loading:"lazy",src:`https://tpd20seu.projects.cmp.uea.ac.uk/selfie/selfieImages/${pe.selfieImagePath}`,alt:"Image"})}),A.jsx("td",{"data-cell":"Selfie Datetime",children:`${(ze=pe.createdAt)==null?void 0:ze.toString().slice(0,10)} - ${(Ye=pe.createdAt)==null?void 0:Ye.toString().slice(11,19)}`}),A.jsx("td",{"data-cell":"Selfie Stress",className:pe.stressStatus==="Stressed"?"stressedCell":"notStressedCell",children:`${pe.stressStatus} - ${pe.stressProb}`})]},Ie)}),s.length===0&&A.jsx("tr",{children:A.jsx("td",{id:"noMatchingSearchTermTR",colSpan:4,children:"No selfie numbers matching the searched term were found :/"})})]})})]}),n.length===0&&A.jsx("h3",{id:"noExistingSelfiesH3",children:"There are no existing selfies in our database :/"}),A.jsx("div",{id:"showOldSelfiesBottomContainer",children:A.jsxs("button",{type:"button",id:"takeNewSelfieBtn",className:"selfieBottomControlBtn",onClick:()=>{ve()},children:["Take New Selfie",A.jsx(ac,{id:"takeNewSelfieBtnIcon"})]})})]})]})]})};function p6(e){return Dr({tag:"svg",attr:{viewBox:"0 0 24 24",fill:"none"},child:[{tag:"path",attr:{d:"M9 11C9.55228 11 10 10.5523 10 10C10 9.44772 9.55228 9 9 9C8.44772 9 8 9.44772 8 10C8 10.5523 8.44772 11 9 11Z",fill:"currentColor"}},{tag:"path",attr:{d:"M9 15C8.44772 15 8 15.4477 8 16C8 16.5523 8.44772 17 9 17H15C15.5523 17 16 16.5523 16 16C16 15.4477 15.5523 15 15 15H9Z",fill:"currentColor"}},{tag:"path",attr:{d:"M16 10C16 10.5523 15.5523 11 15 11C14.4477 11 14 10.5523 14 10C14 9.44772 14.4477 9 15 9C15.5523 9 16 9.44772 16 10Z",fill:"currentColor"}},{tag:"path",attr:{fillRule:"evenodd",clipRule:"evenodd",d:"M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12ZM20 12C20 16.4183 16.4183 20 12 20C7.58172 20 4 16.4183 4 12C4 7.58172 7.58172 4 12 4C16.4183 4 20 7.58172 20 12Z",fill:"currentColor"}}]})(e)}const UEt=()=>{const[e,t]=Z.useState(!1),[n,r]=Z.useState(bi().toISOString().slice(0,19)),[s,a]=Z.useState(!0),[i,o]=Z.useState(!1),[l,u]=Z.useState([]),[c,d]=Z.useState([]),[h,p]=Z.useState(""),[f,m]=Z.useState(""),[g,y]=Z.useState(!1),[b,x]=Z.useState(""),[v,w]=Z.useState(!1),[k,S]=Z.useState(""),[I,$]=Z.useState("No Action"),[C,T]=Z.useState("confirmation"),N=Z.useRef(null);Z.useEffect(()=>{a(!0),E()},[]),Z.useEffect(()=>{let F=0;return s==!0?F=setInterval(()=>{r(bi().toISOString().slice(0,19))},1e3):clearInterval(F),()=>clearInterval(F)},[s]);async function E(){var O;const L=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/rating",{method:"Get",credentials:"include"})).json();if(Array.isArray(L)&&L.length>0){let D=1;for(let B of L)B.ratingNumber=D,D+=1,n.slice(0,10)===((O=B.createdAt)==null?void 0:O.toString().slice(0,10))&&(y(!0),B._id!=null&&B.message!=""&&(x(B._id),m(B.message)));u(L),d(L)}else u([]),d([]),y(!1)}async function _(F){if(F.preventDefault(),o(!0),I==="Delete")await fetch(`https://tpd20seu.projects.cmp.uea.ac.uk/rating/${b}`,{method:"DELETE",headers:{"Content-Type":"application/json"},credentials:"include"}),console.log("DELETE request with rating was sent successfully to the server!"),m(""),S("Rating has been deleted! You can now make a new mood rating :)");else{const L={moodRating:h,message:f.trim(),createdAt:bi()};await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/rating",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(L),credentials:"include"}),console.log(`POST request with rating '${L.moodRating}' was sent successfully to the server!`),S(`New rating '${L.moodRating}' has been created successfully!`)}E(),o(!1),$("No Action"),T("understand"),w(!0)}function R(F){const L=F.target;L.className==="iconBtn"?L.className="iconBtnSelected":L.className==="iconBtnSelected"&&(L.className="iconBtn");const O=L.id;let D="",B="";O==="veryStressedBtn"?(p("Very Stressed"),B="Very Stressed"):O==="mildlyStressedBtn"?(p("Mildly Stressed"),B="Mildly Stressed"):O==="neutralBtn"?(p("Neutral"),B="Neutral"):O==="mildlyPositiveBtn"?(p("Mildly Positive"),B="Mildly Positive"):O==="veryPositiveBtn"&&(p("Very Positive"),B="Mildly Positive"),f===""?D=`You have selected "${B}" as your mood for today. Do you want to submit your rating?

Remember that you can add an optional message! (Click cancel to do so)`:f!=""&&(D=`You have selected "${B}" as your mood for today. Do you want to submit your rating?`),S(D),w(!0)}function z(){const F=document.querySelector(".iconBtnSelected");F!==null&&(F.className="iconBtn")}function W(F){const L=F.target.value.trim();if(L==="")d([]),d(l);else{d([]);const O=l.filter(D=>{var B;return(B=D.ratingNumber)==null?void 0:B.toString().includes(L.toLowerCase())});d(O)}}return A.jsxs(A.Fragment,{children:[i&&A.jsxs("div",{id:"loadingSpinnerContainer",children:[A.jsx(ly,{visible:!0,height:"80",width:"80",color:"#FED362",ariaLabel:"tail-spin-loading",radius:"1",wrapperStyle:{},wrapperClass:""}),A.jsx("h2",{children:"Processing Request...."})]}),!i&&A.jsxs(A.Fragment,{children:[A.jsx(nr,{id:"manualPredictionTooltip",place:"top",content:"Click here if the stress prediction of this selfie is incorrect"}),A.jsx("h1",{children:"Rate Mood"}),A.jsx("h2",{children:"Select the icon that best represents your current mood!"}),A.jsx("p",{id:"infoP",children:"*You can only rate your mood once per day! However, you can undo your rating on the day if your mood changes."}),A.jsx("hr",{}),A.jsxs("form",{id:"rateMoodForm",onSubmit:_,children:[A.jsx(x0,{header:k,dialogShow:v,dialogConfirmation:C,onConfirm:()=>{w(!1)},onCancel:()=>{z(),w(!1)},onUnderstand:()=>{z(),w(!1),T("confirmation")},onManualPrediction:()=>{w(!1)}}),!e&&A.jsxs(A.Fragment,{children:[A.jsxs("div",{id:"headerContainer",children:[A.jsx("h2",{children:"Select your current mood!"}),g&&A.jsx("p",{id:"ratingSubmittedToday",children:"A rating has already been submitted today"})]}),A.jsx("div",{id:"dateTimeContainer",children:A.jsx("p",{id:"dateTimeP",children:n.replace("T"," ")})}),A.jsxs("div",{id:"iconContainer",children:[A.jsxs("button",{type:"button",id:"veryStressedBtn",className:"iconBtn",onClick:F=>{R(F)},disabled:g,children:[A.jsx(SW,{className:"ratingIcon"}),"Very Stressed"]}),A.jsxs("button",{type:"button",id:"mildlyStressedBtn",className:"iconBtn",onClick:F=>{R(F)},disabled:g,children:[A.jsx(Sj,{className:"ratingIcon"}),"Mildly Stressed"]}),A.jsxs("button",{type:"button",id:"neutralBtn",className:"iconBtn",onClick:F=>{R(F)},disabled:g,children:[A.jsx(p6,{className:"ratingIcon"}),"Neutral"]}),A.jsxs("button",{type:"button",id:"mildlyPositiveBtn",className:"iconBtn",onClick:F=>{R(F)},disabled:g,children:[A.jsx(Ij,{className:"ratingIcon"}),"Mildly Positive"]}),A.jsxs("button",{type:"button",id:"veryPositiveBtn",className:"iconBtn",onClick:F=>{R(F)},disabled:g,children:[A.jsx(_E,{className:"ratingIcon"}),"Very Positive"]})]}),A.jsx("div",{id:"optionalMessageContainer",children:A.jsx("textarea",{id:"optionalMessageTxt",rows:2,maxLength:125,placeholder:"Optional: Write a short message describing why you feel this way.",value:f,onChange:F=>{m(F.target.value)},disabled:g})}),A.jsxs("div",{id:"viewOldRatingsContainer",children:[A.jsxs("button",{type:"button",id:"viewOldRatingsBtn",className:"ratingsBtn",onClick:()=>{t(F=>!F)},children:[A.jsx(Fg,{className:"ratingsBtnIcon"}),"View Old Ratings"]}),A.jsxs("button",{type:"button",id:"undoRatingBtn",className:"ratingsBtn",onClick:()=>{$("Delete"),S("Warning: Today's mood rating will be deleted allowing you to make a new one."),w(!0)},children:["Undo Today's Rating",A.jsx(Ux,{className:"ratingsBtnIcon"})]})]})]})]}),e&&A.jsx(A.Fragment,{children:A.jsxs("div",{id:"oldRatingsContainer",children:[A.jsxs("table",{id:"oldRatingsTable",ref:N,children:[A.jsx("caption",{children:A.jsxs("div",{id:"oldRatingsTitleContainer",children:[A.jsxs("h2",{id:"oldRatingsTitleH2",children:["Your Old Ratings ",A.jsx(Fg,{id:"ratingsBtnIcon"})]}),A.jsx(iy,{placeholder:"Search table by ratings number...",onChange:F=>{W(F)}}),c.length===0&&A.jsx("p",{children:"No entry titles matching the searched term were found :/"})]})}),A.jsx("thead",{children:A.jsxs("tr",{children:[A.jsx("th",{children:"Rating Number"}),A.jsx("th",{children:"Date Time"}),A.jsx("th",{children:"Mood Rating"}),A.jsx("th",{children:"Message"})]})}),A.jsx("tbody",{children:l.length!==0&&A.jsxs(A.Fragment,{children:[c.map((F,L)=>{var O,D;return A.jsxs("tr",{id:`${F._id}`,className:"ratingTableRow",children:[A.jsx("td",{"data-cell":"Rating Number",className:"ratingNumberCell",children:F.ratingNumber}),A.jsx("td",{"data-cell":"Rating Datetime",children:`${(O=F.createdAt)==null?void 0:O.toString().slice(0,10)} - ${(D=F.createdAt)==null?void 0:D.toString().slice(11,19)}`}),A.jsx("td",{"data-cell":"Mood Rating",children:F.moodRating&&A.jsxs("div",{className:"moodRatingTD",id:`${F.moodRating}TD`,children:[F.moodRating==="Very Stressed"&&A.jsx(SW,{className:"ratingIcon"}),F.moodRating==="Mildly Stressed"&&A.jsx(Sj,{className:"ratingIcon"}),F.moodRating==="Neutral"&&A.jsx(p6,{className:"ratingIcon"}),F.moodRating==="Mildly Positive"&&A.jsx(Ij,{className:"ratingIcon"}),F.moodRating==="Very Positive"&&A.jsx(_E,{className:"ratingIcon"}),A.jsx("p",{children:F.moodRating})]})}),A.jsxs("td",{"data-cell":"Optional Message",children:[F.message!=""&&A.jsx("p",{children:F.message}),F.message===""&&A.jsx("p",{children:"N/A"})]})]},L)}),c.length===0&&A.jsx("tr",{children:A.jsx("td",{id:"noMatchingSearchTermTR",colSpan:4,children:"No rating numbers matching the searched term were found :/"})})]})})]}),l.length===0&&A.jsx("h3",{id:"noExistingRatingsH3",children:"There are no existing ratings in our database :/"}),A.jsx("div",{id:"oldRatingsBottomContainer",children:A.jsxs("button",{type:"button",id:"viewOldRatingsBtn",className:"ratingsBtn",onClick:()=>{t(F=>!F)},children:[A.jsx(_E,{className:"ratingsBtnIcon"}),"View Old Ratings"]})})]})})]})]})},jEt=()=>A.jsxs(A.Fragment,{children:[A.jsx("h1",{children:"Recommendations"}),A.jsx("h2",{children:"Apologies, this feature has not been implemented yet."})]}),GEt=()=>A.jsxs(A.Fragment,{children:[A.jsx("h1",{children:"Mood Statistics and Trends"}),A.jsx("h2",{children:"Apologies, this feature has not been implemented yet."})]}),HEt=()=>A.jsx(A.Fragment,{});function qEt(){const t=hp().pathname==="/login",n=WI(),[r,s]=Z.useState();Z.useEffect(()=>{async function i(){try{(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/authenticationCheck",{method:"GET",credentials:"include"})).status===401?n("/loginPage",{replace:!0}):a()}catch(o){console.error("Error fetching data:",o)}}i()},[]);async function a(){console.log("fetching user's tfjs compatibility");const o=await(await fetch("https://tpd20seu.projects.cmp.uea.ac.uk/user/",{method:"GET",credentials:"include"})).json();s(o.tfjsCompatible),console.log(r)}return A.jsxs(A.Fragment,{children:[A.jsx(gW,{children:A.jsx(mo,{path:"/loginPage",element:A.jsx(I4e,{})})}),!t&&A.jsxs("div",{className:"appContainer",children:[A.jsxs("div",{className:"leftContainer",children:[A.jsx(Qde,{}),A.jsx(Mde,{})]}),A.jsxs("div",{className:"rightContainer",children:[A.jsx("div",{className:"mainContentContainer",children:A.jsxs(gW,{children:[A.jsx(mo,{path:"/homePage",element:A.jsx(C4e,{})}),A.jsx(mo,{path:"/",element:A.jsx(Sde,{to:"/loginPage"})}),A.jsx(mo,{path:"/dashboardPage",element:A.jsx(rhe,{})}),A.jsx(mo,{path:"/ratingPage",element:A.jsx(UEt,{})}),A.jsx(mo,{path:"/journalPage",element:r==="true"?A.jsx(XGe,{}):A.jsx(YGe,{})}),A.jsx(mo,{path:"/selfiePage",element:r==="true"?A.jsx(WEt,{}):A.jsx(VEt,{})}),A.jsx(mo,{path:"/recommendationsPage",element:A.jsx(jEt,{})}),A.jsx(mo,{path:"/statsPage",element:A.jsx(GEt,{})}),A.jsx(mo,{path:"/aboutMePage",element:A.jsx(HEt,{})})]})}),A.jsx(Pde,{})]})]})]})}YE.createRoot(document.getElementById("root")).render(A.jsx(wn.StrictMode,{children:A.jsx(Ade,{children:A.jsx(qEt,{})})}));
